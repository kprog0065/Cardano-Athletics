/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./contracts/nft.hl":
/*!**************************!*\
  !*** ./contracts/nft.hl ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Program; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n\n//wraps helios.Program\nclass Program {\n    #program\n\n    constructor(parameters = {}) {\n        // load all the dependencies\n        const allDeps = []\n\n        const depSrcs = new Map()\n\n        function addDepSrcs(dep) {\n            depSrcs.set(dep.name, dep.src)\n\n            for (let d of Object.keys(dep.dependencies)) {\n                addDepSrcs(d)\n            }\n        }\n\n        for (let d of allDeps) {\n            addDepSrcs(d)\n        }\n\n        this.#program = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__.Program[\"new\"](`minting nft\r\n\r\nenum Redeemer { \r\n    Init \r\n}\r\n\r\nconst TX_ID: ByteArray = #abc123\r\nconst txId: TxId = TxId::new(TX_ID)\r\nconst TX_IDX: Int = 0\r\nconst outputId: TxOutputId = TxOutputId::new(txId, TX_IDX)\r\nconst TN: String = \"\"\r\n\r\nfunc main(_, ctx: ScriptContext) -> Bool {\r\n    tx: Tx = ctx.tx;\r\n    mph: MintingPolicyHash = ctx.get_current_minting_policy_hash();\r\n\r\n    tt_assetclass: AssetClass = AssetClass::new(\r\n        mph, \r\n        TN.encode_utf8()\r\n    );\r\n\r\n    value_minted: Value = tx.minted;\r\n    (value_minted == Value::new(tt_assetclass, 1)).trace(\"NFT1: \") &&\r\n    tx.inputs.any((input: TxInput) -> Bool {\r\n                        (input.output_id == outputId).trace(\"NFT2: \")\r\n                        }\r\n    )\r\n}`, Array.from(depSrcs.values()))\n\n        if (Object.keys(parameters).length > 0) {\n            this.#program.parameters = parameters\n        }\n    }\n\n    get name() {\n        return this.#program.name\n    }\n\n    get paramTypes() {\n        return this.#program.paramTypes\n    }\n\n    get parameters() {\n        return this.#program.parameters\n    }\n\n    get types() {\n        return this.#program.types\n    }\n\n    set parameters(params) {\n        this.#program.parameters = params\n    }\n\n    compile(optimize = false) {\n        return this.#program.compile(optimize)\n    }\n\n    evalParam(paramName) {\n        return this.#program.evalParam(paramName)\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250cmFjdHMvbmZ0LmhsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ2U7QUFDZjs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsOERBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRyYWN0cy9uZnQuaGw/Nzg5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBoZWxpb3MgZnJvbSBcIkBoeXBlcmlvbmJ0L2hlbGlvc1wiXG4vL3dyYXBzIGhlbGlvcy5Qcm9ncmFtXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmFtIHtcbiAgICAjcHJvZ3JhbVxuXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIC8vIGxvYWQgYWxsIHRoZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgY29uc3QgYWxsRGVwcyA9IFtdXG5cbiAgICAgICAgY29uc3QgZGVwU3JjcyA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZERlcFNyY3MoZGVwKSB7XG4gICAgICAgICAgICBkZXBTcmNzLnNldChkZXAubmFtZSwgZGVwLnNyYylcblxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBPYmplY3Qua2V5cyhkZXAuZGVwZW5kZW5jaWVzKSkge1xuICAgICAgICAgICAgICAgIGFkZERlcFNyY3MoZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGQgb2YgYWxsRGVwcykge1xuICAgICAgICAgICAgYWRkRGVwU3JjcyhkKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jcHJvZ3JhbSA9IGhlbGlvcy5Qcm9ncmFtLm5ldyhgbWludGluZyBuZnRcclxuXHJcbmVudW0gUmVkZWVtZXIgeyBcclxuICAgIEluaXQgXHJcbn1cclxuXHJcbmNvbnN0IFRYX0lEOiBCeXRlQXJyYXkgPSAjYWJjMTIzXHJcbmNvbnN0IHR4SWQ6IFR4SWQgPSBUeElkOjpuZXcoVFhfSUQpXHJcbmNvbnN0IFRYX0lEWDogSW50ID0gMFxyXG5jb25zdCBvdXRwdXRJZDogVHhPdXRwdXRJZCA9IFR4T3V0cHV0SWQ6Om5ldyh0eElkLCBUWF9JRFgpXHJcbmNvbnN0IFROOiBTdHJpbmcgPSBcIlwiXHJcblxyXG5mdW5jIG1haW4oXywgY3R4OiBTY3JpcHRDb250ZXh0KSAtPiBCb29sIHtcclxuICAgIHR4OiBUeCA9IGN0eC50eDtcclxuICAgIG1waDogTWludGluZ1BvbGljeUhhc2ggPSBjdHguZ2V0X2N1cnJlbnRfbWludGluZ19wb2xpY3lfaGFzaCgpO1xyXG5cclxuICAgIHR0X2Fzc2V0Y2xhc3M6IEFzc2V0Q2xhc3MgPSBBc3NldENsYXNzOjpuZXcoXHJcbiAgICAgICAgbXBoLCBcclxuICAgICAgICBUTi5lbmNvZGVfdXRmOCgpXHJcbiAgICApO1xyXG5cclxuICAgIHZhbHVlX21pbnRlZDogVmFsdWUgPSB0eC5taW50ZWQ7XHJcbiAgICAodmFsdWVfbWludGVkID09IFZhbHVlOjpuZXcodHRfYXNzZXRjbGFzcywgMSkpLnRyYWNlKFwiTkZUMTogXCIpICYmXHJcbiAgICB0eC5pbnB1dHMuYW55KChpbnB1dDogVHhJbnB1dCkgLT4gQm9vbCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dC5vdXRwdXRfaWQgPT0gb3V0cHV0SWQpLnRyYWNlKFwiTkZUMjogXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgIClcclxufWAsIEFycmF5LmZyb20oZGVwU3Jjcy52YWx1ZXMoKSkpXG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb2dyYW0ucGFyYW1ldGVycyA9IHBhcmFtZXRlcnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IHBhcmFtVHlwZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLnBhcmFtVHlwZXNcbiAgICB9XG5cbiAgICBnZXQgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0ucGFyYW1ldGVyc1xuICAgIH1cblxuICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0udHlwZXNcbiAgICB9XG5cbiAgICBzZXQgcGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgdGhpcy4jcHJvZ3JhbS5wYXJhbWV0ZXJzID0gcGFyYW1zXG4gICAgfVxuXG4gICAgY29tcGlsZShvcHRpbWl6ZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLmNvbXBpbGUob3B0aW1pemUpXG4gICAgfVxuXG4gICAgZXZhbFBhcmFtKHBhcmFtTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS5ldmFsUGFyYW0ocGFyYW1OYW1lKVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contracts/nft.hl\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_container__bCOhY {\\r\\n  padding: 0 1rem;\\r\\n}\\r\\n\\r\\n.Home_main__nLjiQ {\\r\\n  min-height: 100vh;\\r\\n  padding: 0.3rem 0;\\r\\n  flex: 1 1;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: top;\\r\\n  align-items: left;\\r\\n}\\r\\n\\r\\n.Home_footer____T7K {\\r\\n  display: flex;\\r\\n  flex: 1 1;\\r\\n  padding: 2rem 0;\\r\\n  border-top: 1px solid #eaeaea;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.Home_footer____T7K a {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  flex-grow: 1;\\r\\n}\\r\\n\\r\\n.Home_title__T09hD a {\\r\\n  color: #0070f3;\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.Home_title__T09hD a:hover,\\r\\n.Home_title__T09hD a:focus,\\r\\n.Home_title__T09hD a:active {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.Home_title__T09hD {\\r\\n  margin: 0;\\r\\n  line-height: 1.15;\\r\\n  font-size: 2rem;\\r\\n}\\r\\n\\r\\n.Home_title__T09hD,\\r\\n.Home_description__41Owk {\\r\\n  text-align: left;\\r\\n}\\r\\n\\r\\n.Home_description__41Owk {\\r\\n  margin: 4rem 0;\\r\\n  line-height: 1.5;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.Home_code__suPER {\\r\\n  background: #fafafa;\\r\\n  border-radius: 5px;\\r\\n  padding: 0.75rem;\\r\\n  font-size: 1.1rem;\\r\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,\\r\\n    Bitstream Vera Sans Mono, Courier New, monospace;\\r\\n}\\r\\n\\r\\n.Home_grid__GxQ85 {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  flex-wrap: wrap;\\r\\n  max-width: 800px;\\r\\n}\\r\\n\\r\\n.Home_border__siNOS {\\r\\n  margin: 1rem;\\r\\n  padding: 0.3rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 560px;\\r\\n  min-width: 560px;\\r\\n}\\r\\n\\r\\n\\r\\n.Home_borderwallet__0hazi {\\r\\n  margin: 1rem;\\r\\n  padding: 0.3rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 300px;\\r\\n}\\r\\n\\r\\n.Home_card___LpL1 {\\r\\n  margin: 1rem;\\r\\n  padding: 1.5rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 300px;\\r\\n}\\r\\n\\r\\n.Home_card___LpL1:hover,\\r\\n.Home_card___LpL1:focus,\\r\\n.Home_card___LpL1:active {\\r\\n  color: #0070f3;\\r\\n  border-color: #0070f3;\\r\\n}\\r\\n\\r\\n.Home_card___LpL1 h2 {\\r\\n  margin: 0 0 1rem 0;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.Home_card___LpL1 p {\\r\\n  margin: 0;\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.Home_logo__27_tb {\\r\\n  height: 1em;\\r\\n  margin-left: 0.5rem;\\r\\n}\\r\\n\\r\\n@media (max-width: 600px) {\\r\\n  .Home_grid__GxQ85 {\\r\\n    width: 100%;\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  .Home_card___LpL1,\\r\\n  .Home_footer____T7K {\\r\\n    border-color: #222;\\r\\n  }\\r\\n  .Home_code__suPER {\\r\\n    background: #111;\\r\\n  }\\r\\n  .Home_logo__27_tb img {\\r\\n    filter: invert(1);\\r\\n  }\\r\\n}\\r\\n.Home_container__bCOhY {\\r\\n  min-height: 100vh;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 0 2rem;\\r\\n  background-color: #020230; /* Match background color */\\r\\n}\\r\\n\\r\\n.Home_main__nLjiQ {\\r\\n  padding: 2rem;\\r\\n  background: #1a1a2e; /* Darker background for contrast */\\r\\n  border-radius: 8px;\\r\\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); /* Slightly darker shadow */\\r\\n  width: 100%;\\r\\n  max-width: 800px;\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.Home_title__T09hD {\\r\\n  font-size: 2rem;\\r\\n  margin-bottom: 1rem;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n.Home_borderwallet__0hazi, .Home_border__siNOS {\\r\\n  border: 1px solid #fffefe; \\r\\n  padding: 1rem;\\r\\n  border-radius: 8px;\\r\\n  margin: 1rem 0;\\r\\n  background-color: #1a1a2e; \\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.Home_backButton__p7X_l {\\r\\n  display: inline-block;\\r\\n  margin-top: 2rem;\\r\\n  padding: 0.5rem 1rem;\\r\\n  background-color: #f8636b; \\r\\n  color: white;\\r\\n  border-radius: 5px;\\r\\n  text-decoration: none;\\r\\n  font-weight: bold;\\r\\n}\\r\\n\\r\\n.Home_backButton__p7X_l:hover {\\r\\n  background-color: #e53e3e; \\r\\n}\\r\\n\\r\\n.Home_footer____T7K {\\r\\n  padding: 1rem;\\r\\n  text-align: center;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n/* Form styles */\\r\\n.Home_sub-form-main__mS0im {\\r\\n  margin-top: 1.5rem;\\r\\n  color: #fff;\\r\\n  font-size: 1.25rem;\\r\\n  background-color: #020230; \\r\\n  padding: 20px;\\r\\n  border-radius: 8px;\\r\\n}\\r\\n\\r\\n.Home_input__ZarWZ[type=\\\"radio\\\"] {\\r\\n  margin-right: 0.5rem;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.Home_label__UYtOa {\\r\\n  margin-right: 1rem;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n.Home_MuiInputLabel-root__5U_WZ {\\r\\n  color: #fff !important; \\r\\n}\\r\\n\\r\\n.Home_MuiInputBase-input__bXu_R {\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.Home_MuiButton-outlined__2K5Kv {\\r\\n  margin-top: 1rem;\\r\\n  margin-bottom: 1rem;\\r\\n  width: 100px;\\r\\n  color: #f8636b; /* Match button text color */\\r\\n  border-color: #f8636b; /* Match button border color */\\r\\n  background-color: transparent;\\r\\n}\\r\\n\\r\\n.Home_MuiButton-outlined__2K5Kv:hover {\\r\\n  border-color: #e53e3e; /* Darker shade for hover */\\r\\n  color: #e53e3e; /* Darker shade for hover */\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/Home.module.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\".container {\\r\\n  padding: 0 1rem;\\r\\n}\\r\\n\\r\\n.main {\\r\\n  min-height: 100vh;\\r\\n  padding: 0.3rem 0;\\r\\n  flex: 1;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: top;\\r\\n  align-items: left;\\r\\n}\\r\\n\\r\\n.footer {\\r\\n  display: flex;\\r\\n  flex: 1;\\r\\n  padding: 2rem 0;\\r\\n  border-top: 1px solid #eaeaea;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.footer a {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  flex-grow: 1;\\r\\n}\\r\\n\\r\\n.title a {\\r\\n  color: #0070f3;\\r\\n  text-decoration: none;\\r\\n}\\r\\n\\r\\n.title a:hover,\\r\\n.title a:focus,\\r\\n.title a:active {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.title {\\r\\n  margin: 0;\\r\\n  line-height: 1.15;\\r\\n  font-size: 2rem;\\r\\n}\\r\\n\\r\\n.title,\\r\\n.description {\\r\\n  text-align: left;\\r\\n}\\r\\n\\r\\n.description {\\r\\n  margin: 4rem 0;\\r\\n  line-height: 1.5;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.code {\\r\\n  background: #fafafa;\\r\\n  border-radius: 5px;\\r\\n  padding: 0.75rem;\\r\\n  font-size: 1.1rem;\\r\\n  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,\\r\\n    Bitstream Vera Sans Mono, Courier New, monospace;\\r\\n}\\r\\n\\r\\n.grid {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  flex-wrap: wrap;\\r\\n  max-width: 800px;\\r\\n}\\r\\n\\r\\n.border {\\r\\n  margin: 1rem;\\r\\n  padding: 0.3rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 560px;\\r\\n  min-width: 560px;\\r\\n}\\r\\n\\r\\n\\r\\n.borderwallet {\\r\\n  margin: 1rem;\\r\\n  padding: 0.3rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 300px;\\r\\n}\\r\\n\\r\\n.card {\\r\\n  margin: 1rem;\\r\\n  padding: 1.5rem;\\r\\n  text-align: left;\\r\\n  color: inherit;\\r\\n  text-decoration: none;\\r\\n  border: 1px solid #eaeaea;\\r\\n  border-radius: 10px;\\r\\n  transition: color 0.15s ease, border-color 0.15s ease;\\r\\n  max-width: 300px;\\r\\n}\\r\\n\\r\\n.card:hover,\\r\\n.card:focus,\\r\\n.card:active {\\r\\n  color: #0070f3;\\r\\n  border-color: #0070f3;\\r\\n}\\r\\n\\r\\n.card h2 {\\r\\n  margin: 0 0 1rem 0;\\r\\n  font-size: 1.5rem;\\r\\n}\\r\\n\\r\\n.card p {\\r\\n  margin: 0;\\r\\n  font-size: 1.25rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.logo {\\r\\n  height: 1em;\\r\\n  margin-left: 0.5rem;\\r\\n}\\r\\n\\r\\n@media (max-width: 600px) {\\r\\n  .grid {\\r\\n    width: 100%;\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n@media (prefers-color-scheme: dark) {\\r\\n  .card,\\r\\n  .footer {\\r\\n    border-color: #222;\\r\\n  }\\r\\n  .code {\\r\\n    background: #111;\\r\\n  }\\r\\n  .logo img {\\r\\n    filter: invert(1);\\r\\n  }\\r\\n}\\r\\n.container {\\r\\n  min-height: 100vh;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 0 2rem;\\r\\n  background-color: #020230; /* Match background color */\\r\\n}\\r\\n\\r\\n.main {\\r\\n  padding: 2rem;\\r\\n  background: #1a1a2e; /* Darker background for contrast */\\r\\n  border-radius: 8px;\\r\\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); /* Slightly darker shadow */\\r\\n  width: 100%;\\r\\n  max-width: 800px;\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.title {\\r\\n  font-size: 2rem;\\r\\n  margin-bottom: 1rem;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n.borderwallet, .border {\\r\\n  border: 1px solid #fffefe; \\r\\n  padding: 1rem;\\r\\n  border-radius: 8px;\\r\\n  margin: 1rem 0;\\r\\n  background-color: #1a1a2e; \\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.backButton {\\r\\n  display: inline-block;\\r\\n  margin-top: 2rem;\\r\\n  padding: 0.5rem 1rem;\\r\\n  background-color: #f8636b; \\r\\n  color: white;\\r\\n  border-radius: 5px;\\r\\n  text-decoration: none;\\r\\n  font-weight: bold;\\r\\n}\\r\\n\\r\\n.backButton:hover {\\r\\n  background-color: #e53e3e; \\r\\n}\\r\\n\\r\\n.footer {\\r\\n  padding: 1rem;\\r\\n  text-align: center;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n/* Form styles */\\r\\n.sub-form-main {\\r\\n  margin-top: 1.5rem;\\r\\n  color: #fff;\\r\\n  font-size: 1.25rem;\\r\\n  background-color: #020230; \\r\\n  padding: 20px;\\r\\n  border-radius: 8px;\\r\\n}\\r\\n\\r\\n.input[type=\\\"radio\\\"] {\\r\\n  margin-right: 0.5rem;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.label {\\r\\n  margin-right: 1rem;\\r\\n  color: #fff; \\r\\n}\\r\\n\\r\\n.MuiInputLabel-root {\\r\\n  color: #fff !important; \\r\\n}\\r\\n\\r\\n.MuiInputBase-input {\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.MuiButton-outlined {\\r\\n  margin-top: 1rem;\\r\\n  margin-bottom: 1rem;\\r\\n  width: 100px;\\r\\n  color: #f8636b; /* Match button text color */\\r\\n  border-color: #f8636b; /* Match button border color */\\r\\n  background-color: transparent;\\r\\n}\\r\\n\\r\\n.MuiButton-outlined:hover {\\r\\n  border-color: #e53e3e; /* Darker shade for hover */\\r\\n  color: #e53e3e; /* Darker shade for hover */\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"container\": \"Home_container__bCOhY\",\n\t\"main\": \"Home_main__nLjiQ\",\n\t\"footer\": \"Home_footer____T7K\",\n\t\"title\": \"Home_title__T09hD\",\n\t\"description\": \"Home_description__41Owk\",\n\t\"code\": \"Home_code__suPER\",\n\t\"grid\": \"Home_grid__GxQ85\",\n\t\"border\": \"Home_border__siNOS\",\n\t\"borderwallet\": \"Home_borderwallet__0hazi\",\n\t\"card\": \"Home_card___LpL1\",\n\t\"logo\": \"Home_logo__27_tb\",\n\t\"backButton\": \"Home_backButton__p7X_l\",\n\t\"sub-form-main\": \"Home_sub-form-main__mS0im\",\n\t\"input\": \"Home_input__ZarWZ\",\n\t\"label\": \"Home_label__UYtOa\",\n\t\"MuiInputLabel-root\": \"Home_MuiInputLabel-root__5U_WZ\",\n\t\"MuiInputBase-input\": \"Home_MuiInputBase-input__bXu_R\",\n\t\"MuiButton-outlined\": \"Home_MuiButton-outlined__2K5Kv\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzJdIS4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0Esa0VBQWtFLHNCQUFzQixLQUFLLDJCQUEyQix3QkFBd0Isd0JBQXdCLGdCQUFnQixvQkFBb0IsNkJBQTZCLDJCQUEyQix3QkFBd0IsS0FBSyw2QkFBNkIsb0JBQW9CLGdCQUFnQixzQkFBc0Isb0NBQW9DLDhCQUE4QiwwQkFBMEIsS0FBSywrQkFBK0Isb0JBQW9CLDhCQUE4QiwwQkFBMEIsbUJBQW1CLEtBQUssOEJBQThCLHFCQUFxQiw0QkFBNEIsS0FBSyxtR0FBbUcsaUNBQWlDLEtBQUssNEJBQTRCLGdCQUFnQix3QkFBd0Isc0JBQXNCLEtBQUsseURBQXlELHVCQUF1QixLQUFLLGtDQUFrQyxxQkFBcUIsdUJBQXVCLHdCQUF3QixLQUFLLDJCQUEyQiwwQkFBMEIseUJBQXlCLHVCQUF1Qix3QkFBd0IsNklBQTZJLEtBQUssMkJBQTJCLG9CQUFvQiwwQkFBMEIsOEJBQThCLHNCQUFzQix1QkFBdUIsS0FBSyw2QkFBNkIsbUJBQW1CLHNCQUFzQix1QkFBdUIscUJBQXFCLDRCQUE0QixnQ0FBZ0MsMEJBQTBCLDREQUE0RCx1QkFBdUIsdUJBQXVCLEtBQUssdUNBQXVDLG1CQUFtQixzQkFBc0IsdUJBQXVCLHFCQUFxQiw0QkFBNEIsZ0NBQWdDLDBCQUEwQiw0REFBNEQsdUJBQXVCLEtBQUssMkJBQTJCLG1CQUFtQixzQkFBc0IsdUJBQXVCLHFCQUFxQiw0QkFBNEIsZ0NBQWdDLDBCQUEwQiw0REFBNEQsdUJBQXVCLEtBQUssMEZBQTBGLHFCQUFxQiw0QkFBNEIsS0FBSyw4QkFBOEIseUJBQXlCLHdCQUF3QixLQUFLLDZCQUE2QixnQkFBZ0IseUJBQXlCLHVCQUF1QixLQUFLLDJCQUEyQixrQkFBa0IsMEJBQTBCLEtBQUssbUNBQW1DLHlCQUF5QixvQkFBb0IsK0JBQStCLE9BQU8sS0FBSyw2Q0FBNkMsbURBQW1ELDJCQUEyQixPQUFPLHlCQUF5Qix5QkFBeUIsT0FBTyw2QkFBNkIsMEJBQTBCLE9BQU8sS0FBSyw0QkFBNEIsd0JBQXdCLG9CQUFvQiw2QkFBNkIsMEJBQTBCLDhCQUE4QixzQkFBc0IsaUNBQWlDLGlDQUFpQywyQkFBMkIsb0JBQW9CLDJCQUEyQiw2REFBNkQsK0NBQStDLDhDQUE4Qyx1QkFBdUIseUJBQXlCLEtBQUssNEJBQTRCLHNCQUFzQiwwQkFBMEIsbUJBQW1CLEtBQUssd0RBQXdELGlDQUFpQyxvQkFBb0IseUJBQXlCLHFCQUFxQixpQ0FBaUMsa0JBQWtCLEtBQUssaUNBQWlDLDRCQUE0Qix1QkFBdUIsMkJBQTJCLGlDQUFpQyxtQkFBbUIseUJBQXlCLDRCQUE0Qix3QkFBd0IsS0FBSyx1Q0FBdUMsaUNBQWlDLEtBQUssNkJBQTZCLG9CQUFvQix5QkFBeUIsbUJBQW1CLEtBQUsseURBQXlELHlCQUF5QixrQkFBa0IseUJBQXlCLGlDQUFpQyxvQkFBb0IseUJBQXlCLEtBQUssNENBQTRDLDJCQUEyQixrQkFBa0IsS0FBSyw0QkFBNEIseUJBQXlCLG1CQUFtQixLQUFLLHlDQUF5Qyw4QkFBOEIsS0FBSyx5Q0FBeUMsa0JBQWtCLEtBQUsseUNBQXlDLHVCQUF1QiwwQkFBMEIsbUJBQW1CLHNCQUFzQiwwREFBMEQsbUVBQW1FLEtBQUssK0NBQStDLDZCQUE2QixrREFBa0QsaUNBQWlDLE9BQU8sdUZBQXVGLFVBQVUsT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLE1BQU0sS0FBSyxVQUFVLFlBQVksT0FBTyxPQUFPLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLE9BQU8sTUFBTSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE9BQU8sT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxRQUFRLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLE9BQU8sT0FBTyxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssS0FBSyxVQUFVLFlBQVksTUFBTSxNQUFNLEtBQUssTUFBTSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxXQUFXLHdCQUF3QixPQUFPLEtBQUssVUFBVSx3QkFBd0IsYUFBYSx5QkFBeUIsV0FBVyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLE1BQU0sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLFlBQVksTUFBTSxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLE1BQU0sS0FBSyxZQUFZLFdBQVcsTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFlBQVksYUFBYSxXQUFXLHNCQUFzQix5QkFBeUIsYUFBYSxPQUFPLEtBQUssd0JBQXdCLHVCQUF1QixzQ0FBc0Msc0JBQXNCLEtBQUssZUFBZSx3QkFBd0Isd0JBQXdCLGNBQWMsb0JBQW9CLDZCQUE2QiwyQkFBMkIsd0JBQXdCLEtBQUssaUJBQWlCLG9CQUFvQixjQUFjLHNCQUFzQixvQ0FBb0MsOEJBQThCLDBCQUEwQixLQUFLLG1CQUFtQixvQkFBb0IsOEJBQThCLDBCQUEwQixtQkFBbUIsS0FBSyxrQkFBa0IscUJBQXFCLDRCQUE0QixLQUFLLCtEQUErRCxpQ0FBaUMsS0FBSyxnQkFBZ0IsZ0JBQWdCLHdCQUF3QixzQkFBc0IsS0FBSyxpQ0FBaUMsdUJBQXVCLEtBQUssc0JBQXNCLHFCQUFxQix1QkFBdUIsd0JBQXdCLEtBQUssZUFBZSwwQkFBMEIseUJBQXlCLHVCQUF1Qix3QkFBd0IsNklBQTZJLEtBQUssZUFBZSxvQkFBb0IsMEJBQTBCLDhCQUE4QixzQkFBc0IsdUJBQXVCLEtBQUssaUJBQWlCLG1CQUFtQixzQkFBc0IsdUJBQXVCLHFCQUFxQiw0QkFBNEIsZ0NBQWdDLDBCQUEwQiw0REFBNEQsdUJBQXVCLHVCQUF1QixLQUFLLDJCQUEyQixtQkFBbUIsc0JBQXNCLHVCQUF1QixxQkFBcUIsNEJBQTRCLGdDQUFnQywwQkFBMEIsNERBQTRELHVCQUF1QixLQUFLLGVBQWUsbUJBQW1CLHNCQUFzQix1QkFBdUIscUJBQXFCLDRCQUE0QixnQ0FBZ0MsMEJBQTBCLDREQUE0RCx1QkFBdUIsS0FBSyxzREFBc0QscUJBQXFCLDRCQUE0QixLQUFLLGtCQUFrQix5QkFBeUIsd0JBQXdCLEtBQUssaUJBQWlCLGdCQUFnQix5QkFBeUIsdUJBQXVCLEtBQUssZUFBZSxrQkFBa0IsMEJBQTBCLEtBQUssbUNBQW1DLGFBQWEsb0JBQW9CLCtCQUErQixPQUFPLEtBQUssNkNBQTZDLDJCQUEyQiwyQkFBMkIsT0FBTyxhQUFhLHlCQUF5QixPQUFPLGlCQUFpQiwwQkFBMEIsT0FBTyxLQUFLLGdCQUFnQix3QkFBd0Isb0JBQW9CLDZCQUE2QiwwQkFBMEIsOEJBQThCLHNCQUFzQixpQ0FBaUMsaUNBQWlDLGVBQWUsb0JBQW9CLDJCQUEyQiw2REFBNkQsK0NBQStDLDhDQUE4Qyx1QkFBdUIseUJBQXlCLEtBQUssZ0JBQWdCLHNCQUFzQiwwQkFBMEIsbUJBQW1CLEtBQUssZ0NBQWdDLGlDQUFpQyxvQkFBb0IseUJBQXlCLHFCQUFxQixpQ0FBaUMsa0JBQWtCLEtBQUsscUJBQXFCLDRCQUE0Qix1QkFBdUIsMkJBQTJCLGlDQUFpQyxtQkFBbUIseUJBQXlCLDRCQUE0Qix3QkFBd0IsS0FBSywyQkFBMkIsaUNBQWlDLEtBQUssaUJBQWlCLG9CQUFvQix5QkFBeUIsbUJBQW1CLEtBQUssNkNBQTZDLHlCQUF5QixrQkFBa0IseUJBQXlCLGlDQUFpQyxvQkFBb0IseUJBQXlCLEtBQUssZ0NBQWdDLDJCQUEyQixrQkFBa0IsS0FBSyxnQkFBZ0IseUJBQXlCLG1CQUFtQixLQUFLLDZCQUE2Qiw4QkFBOEIsS0FBSyw2QkFBNkIsa0JBQWtCLEtBQUssNkJBQTZCLHVCQUF1QiwwQkFBMEIsbUJBQW1CLHNCQUFzQiwwREFBMEQsbUVBQW1FLEtBQUssbUNBQW1DLDZCQUE2QixrREFBa0QsaUNBQWlDLG1CQUFtQjtBQUNodVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL0hvbWUubW9kdWxlLmNzcz80MjBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuSG9tZV9jb250YWluZXJfX2JDT2hZIHtcXHJcXG4gIHBhZGRpbmc6IDAgMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfbWFpbl9fbkxqaVEge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBwYWRkaW5nOiAwLjNyZW0gMDtcXHJcXG4gIGZsZXg6IDEgMTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAganVzdGlmeS1jb250ZW50OiB0b3A7XFxyXFxuICBhbGlnbi1pdGVtczogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfZm9vdGVyX19fX1Q3SyB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleDogMSAxO1xcclxcbiAgcGFkZGluZzogMnJlbSAwO1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX2Zvb3Rlcl9fX19UN0sgYSB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZmxleC1ncm93OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV90aXRsZV9fVDA5aEQgYSB7XFxyXFxuICBjb2xvcjogIzAwNzBmMztcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6aG92ZXIsXFxyXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6Zm9jdXMsXFxyXFxuLkhvbWVfdGl0bGVfX1QwOWhEIGE6YWN0aXZlIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV90aXRsZV9fVDA5aEQge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxufVxcclxcblxcclxcbi5Ib21lX3RpdGxlX19UMDloRCxcXHJcXG4uSG9tZV9kZXNjcmlwdGlvbl9fNDFPd2sge1xcclxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfZGVzY3JpcHRpb25fXzQxT3drIHtcXHJcXG4gIG1hcmdpbjogNHJlbSAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jb2RlX19zdVBFUiB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZmFmYWZhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcclxcbiAgcGFkZGluZzogMC43NXJlbTtcXHJcXG4gIGZvbnQtc2l6ZTogMS4xcmVtO1xcclxcbiAgZm9udC1mYW1pbHk6IE1lbmxvLCBNb25hY28sIEx1Y2lkYSBDb25zb2xlLCBMaWJlcmF0aW9uIE1vbm8sIERlamFWdSBTYW5zIE1vbm8sXFxyXFxuICAgIEJpdHN0cmVhbSBWZXJhIFNhbnMgTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfZ3JpZF9fR3hRODUge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX2JvcmRlcl9fc2lOT1Mge1xcclxcbiAgbWFyZ2luOiAxcmVtO1xcclxcbiAgcGFkZGluZzogMC4zcmVtO1xcclxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG4gIGNvbG9yOiBpbmhlcml0O1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2VhZWFlYTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjE1cyBlYXNlLCBib3JkZXItY29sb3IgMC4xNXMgZWFzZTtcXHJcXG4gIG1heC13aWR0aDogNTYwcHg7XFxyXFxuICBtaW4td2lkdGg6IDU2MHB4O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4uSG9tZV9ib3JkZXJ3YWxsZXRfXzBoYXppIHtcXHJcXG4gIG1hcmdpbjogMXJlbTtcXHJcXG4gIHBhZGRpbmc6IDAuM3JlbTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4xNXMgZWFzZSwgYm9yZGVyLWNvbG9yIDAuMTVzIGVhc2U7XFxyXFxuICBtYXgtd2lkdGg6IDMwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jYXJkX19fTHBMMSB7XFxyXFxuICBtYXJnaW46IDFyZW07XFxyXFxuICBwYWRkaW5nOiAxLjVyZW07XFxyXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcclxcbiAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMTVzIGVhc2UsIGJvcmRlci1jb2xvciAwLjE1cyBlYXNlO1xcclxcbiAgbWF4LXdpZHRoOiAzMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfY2FyZF9fX0xwTDE6aG92ZXIsXFxyXFxuLkhvbWVfY2FyZF9fX0xwTDE6Zm9jdXMsXFxyXFxuLkhvbWVfY2FyZF9fX0xwTDE6YWN0aXZlIHtcXHJcXG4gIGNvbG9yOiAjMDA3MGYzO1xcclxcbiAgYm9yZGVyLWNvbG9yOiAjMDA3MGYzO1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9jYXJkX19fTHBMMSBoMiB7XFxyXFxuICBtYXJnaW46IDAgMCAxcmVtIDA7XFxyXFxuICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfY2FyZF9fX0xwTDEgcCB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBmb250LXNpemU6IDEuMjVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS41O1xcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9sb2dvX18yN190YiB7XFxyXFxuICBoZWlnaHQ6IDFlbTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkge1xcclxcbiAgLkhvbWVfZ3JpZF9fR3hRODUge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcclxcbiAgLkhvbWVfY2FyZF9fX0xwTDEsXFxyXFxuICAuSG9tZV9mb290ZXJfX19fVDdLIHtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiAjMjIyO1xcclxcbiAgfVxcclxcbiAgLkhvbWVfY29kZV9fc3VQRVIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjMTExO1xcclxcbiAgfVxcclxcbiAgLkhvbWVfbG9nb19fMjdfdGIgaW1nIHtcXHJcXG4gICAgZmlsdGVyOiBpbnZlcnQoMSk7XFxyXFxuICB9XFxyXFxufVxcclxcbi5Ib21lX2NvbnRhaW5lcl9fYkNPaFkge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDAgMnJlbTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7IC8qIE1hdGNoIGJhY2tncm91bmQgY29sb3IgKi9cXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfbWFpbl9fbkxqaVEge1xcclxcbiAgcGFkZGluZzogMnJlbTtcXHJcXG4gIGJhY2tncm91bmQ6ICMxYTFhMmU7IC8qIERhcmtlciBiYWNrZ3JvdW5kIGZvciBjb250cmFzdCAqL1xcclxcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpOyAvKiBTbGlnaHRseSBkYXJrZXIgc2hhZG93ICovXFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5Ib21lX3RpdGxlX19UMDloRCB7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcclxcbiAgY29sb3I6ICNmZmY7IFxcclxcbn1cXHJcXG5cXHJcXG4uSG9tZV9ib3JkZXJ3YWxsZXRfXzBoYXppLCAuSG9tZV9ib3JkZXJfX3NpTk9TIHtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmZlZmU7IFxcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG4gIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFhMWEyZTsgXFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfYmFja0J1dHRvbl9fcDdYX2wge1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgbWFyZ2luLXRvcDogMnJlbTtcXHJcXG4gIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y4NjM2YjsgXFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfYmFja0J1dHRvbl9fcDdYX2w6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U1M2UzZTsgXFxyXFxufVxcclxcblxcclxcbi5Ib21lX2Zvb3Rlcl9fX19UN0sge1xcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGNvbG9yOiAjZmZmOyBcXHJcXG59XFxyXFxuXFxyXFxuLyogRm9ybSBzdHlsZXMgKi9cXHJcXG4uSG9tZV9zdWItZm9ybS1tYWluX19tUzBpbSB7XFxyXFxuICBtYXJnaW4tdG9wOiAxLjVyZW07XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7IFxcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfaW5wdXRfX1phcldaW3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfbGFiZWxfX1VZdE9hIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogMXJlbTtcXHJcXG4gIGNvbG9yOiAjZmZmOyBcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfTXVpSW5wdXRMYWJlbC1yb290X181VV9XWiB7XFxyXFxuICBjb2xvcjogI2ZmZiAhaW1wb3J0YW50OyBcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfTXVpSW5wdXRCYXNlLWlucHV0X19iWHVfUiB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfTXVpQnV0dG9uLW91dGxpbmVkX18ySzVLdiB7XFxyXFxuICBtYXJnaW4tdG9wOiAxcmVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG4gIHdpZHRoOiAxMDBweDtcXHJcXG4gIGNvbG9yOiAjZjg2MzZiOyAvKiBNYXRjaCBidXR0b24gdGV4dCBjb2xvciAqL1xcclxcbiAgYm9yZGVyLWNvbG9yOiAjZjg2MzZiOyAvKiBNYXRjaCBidXR0b24gYm9yZGVyIGNvbG9yICovXFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuXFxyXFxuLkhvbWVfTXVpQnV0dG9uLW91dGxpbmVkX18ySzVLdjpob3ZlciB7XFxyXFxuICBib3JkZXItY29sb3I6ICNlNTNlM2U7IC8qIERhcmtlciBzaGFkZSBmb3IgaG92ZXIgKi9cXHJcXG4gIGNvbG9yOiAjZTUzZTNlOyAvKiBEYXJrZXIgc2hhZGUgZm9yIGhvdmVyICovXFxyXFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixpQkFBaUI7RUFDakIsU0FBTztFQUNQLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsb0JBQW9CO0VBQ3BCLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLGFBQWE7RUFDYixTQUFPO0VBQ1AsZUFBZTtFQUNmLDZCQUE2QjtF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OztBQUVBO0VBQ0UsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixZQUFZO0VBQ1osY0FBYyxFQUFFLDRCQUE0QjtFQUM1QyxxQkFBcUIsRUFBRSw4QkFBOEI7RUFDckQsNkJBQTZCO0FBQy9COztBQUVBO0VBQ0UscUJBQXFCLEVBQUUsMkJBQTJCO0VBQ2xELGNBQWMsRUFBRSwyQkFBMkI7QUFDN0NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmNvbnRhaW5lciB7XFxyXFxuICBwYWRkaW5nOiAwIDFyZW07XFxyXFxufVxcclxcblxcclxcbi5tYWluIHtcXHJcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcbiAgcGFkZGluZzogMC4zcmVtIDA7XFxyXFxuICBmbGV4OiAxO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHRvcDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBsZWZ0O1xcclxcbn1cXHJcXG5cXHJcXG4uZm9vdGVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4OiAxO1xcclxcbiAgcGFkZGluZzogMnJlbSAwO1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5mb290ZXIgYSB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZmxleC1ncm93OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUgYSB7XFxyXFxuICBjb2xvcjogIzAwNzBmMztcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLnRpdGxlIGE6aG92ZXIsXFxyXFxuLnRpdGxlIGE6Zm9jdXMsXFxyXFxuLnRpdGxlIGE6YWN0aXZlIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4udGl0bGUge1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMTU7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxufVxcclxcblxcclxcbi50aXRsZSxcXHJcXG4uZGVzY3JpcHRpb24ge1xcclxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG59XFxyXFxuXFxyXFxuLmRlc2NyaXB0aW9uIHtcXHJcXG4gIG1hcmdpbjogNHJlbSAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY29kZSB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZmFmYWZhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcclxcbiAgcGFkZGluZzogMC43NXJlbTtcXHJcXG4gIGZvbnQtc2l6ZTogMS4xcmVtO1xcclxcbiAgZm9udC1mYW1pbHk6IE1lbmxvLCBNb25hY28sIEx1Y2lkYSBDb25zb2xlLCBMaWJlcmF0aW9uIE1vbm8sIERlamFWdSBTYW5zIE1vbm8sXFxyXFxuICAgIEJpdHN0cmVhbSBWZXJhIFNhbnMgTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXHJcXG59XFxyXFxuXFxyXFxuLmdyaWQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxufVxcclxcblxcclxcbi5ib3JkZXIge1xcclxcbiAgbWFyZ2luOiAxcmVtO1xcclxcbiAgcGFkZGluZzogMC4zcmVtO1xcclxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG4gIGNvbG9yOiBpbmhlcml0O1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2VhZWFlYTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICB0cmFuc2l0aW9uOiBjb2xvciAwLjE1cyBlYXNlLCBib3JkZXItY29sb3IgMC4xNXMgZWFzZTtcXHJcXG4gIG1heC13aWR0aDogNTYwcHg7XFxyXFxuICBtaW4td2lkdGg6IDU2MHB4O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4uYm9yZGVyd2FsbGV0IHtcXHJcXG4gIG1hcmdpbjogMXJlbTtcXHJcXG4gIHBhZGRpbmc6IDAuM3JlbTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlYWVhZWE7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4xNXMgZWFzZSwgYm9yZGVyLWNvbG9yIDAuMTVzIGVhc2U7XFxyXFxuICBtYXgtd2lkdGg6IDMwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZCB7XFxyXFxuICBtYXJnaW46IDFyZW07XFxyXFxuICBwYWRkaW5nOiAxLjVyZW07XFxyXFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcclxcbiAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMTVzIGVhc2UsIGJvcmRlci1jb2xvciAwLjE1cyBlYXNlO1xcclxcbiAgbWF4LXdpZHRoOiAzMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQ6aG92ZXIsXFxyXFxuLmNhcmQ6Zm9jdXMsXFxyXFxuLmNhcmQ6YWN0aXZlIHtcXHJcXG4gIGNvbG9yOiAjMDA3MGYzO1xcclxcbiAgYm9yZGVyLWNvbG9yOiAjMDA3MGYzO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZCBoMiB7XFxyXFxuICBtYXJnaW46IDAgMCAxcmVtIDA7XFxyXFxuICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQgcCB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBmb250LXNpemU6IDEuMjVyZW07XFxyXFxuICBsaW5lLWhlaWdodDogMS41O1xcclxcbn1cXHJcXG5cXHJcXG4ubG9nbyB7XFxyXFxuICBoZWlnaHQ6IDFlbTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkge1xcclxcbiAgLmdyaWQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcclxcbiAgLmNhcmQsXFxyXFxuICAuZm9vdGVyIHtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiAjMjIyO1xcclxcbiAgfVxcclxcbiAgLmNvZGUge1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjMTExO1xcclxcbiAgfVxcclxcbiAgLmxvZ28gaW1nIHtcXHJcXG4gICAgZmlsdGVyOiBpbnZlcnQoMSk7XFxyXFxuICB9XFxyXFxufVxcclxcbi5jb250YWluZXIge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDAgMnJlbTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7IC8qIE1hdGNoIGJhY2tncm91bmQgY29sb3IgKi9cXHJcXG59XFxyXFxuXFxyXFxuLm1haW4ge1xcclxcbiAgcGFkZGluZzogMnJlbTtcXHJcXG4gIGJhY2tncm91bmQ6ICMxYTFhMmU7IC8qIERhcmtlciBiYWNrZ3JvdW5kIGZvciBjb250cmFzdCAqL1xcclxcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpOyAvKiBTbGlnaHRseSBkYXJrZXIgc2hhZG93ICovXFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG1heC13aWR0aDogODAwcHg7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi50aXRsZSB7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcclxcbiAgY29sb3I6ICNmZmY7IFxcclxcbn1cXHJcXG5cXHJcXG4uYm9yZGVyd2FsbGV0LCAuYm9yZGVyIHtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmZlZmU7IFxcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG4gIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFhMWEyZTsgXFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLmJhY2tCdXR0b24ge1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgbWFyZ2luLXRvcDogMnJlbTtcXHJcXG4gIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y4NjM2YjsgXFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG59XFxyXFxuXFxyXFxuLmJhY2tCdXR0b246aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U1M2UzZTsgXFxyXFxufVxcclxcblxcclxcbi5mb290ZXIge1xcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGNvbG9yOiAjZmZmOyBcXHJcXG59XFxyXFxuXFxyXFxuLyogRm9ybSBzdHlsZXMgKi9cXHJcXG4uc3ViLWZvcm0tbWFpbiB7XFxyXFxuICBtYXJnaW4tdG9wOiAxLjVyZW07XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7IFxcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG59XFxyXFxuXFxyXFxuLmlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLmxhYmVsIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogMXJlbTtcXHJcXG4gIGNvbG9yOiAjZmZmOyBcXHJcXG59XFxyXFxuXFxyXFxuLk11aUlucHV0TGFiZWwtcm9vdCB7XFxyXFxuICBjb2xvcjogI2ZmZiAhaW1wb3J0YW50OyBcXHJcXG59XFxyXFxuXFxyXFxuLk11aUlucHV0QmFzZS1pbnB1dCB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLk11aUJ1dHRvbi1vdXRsaW5lZCB7XFxyXFxuICBtYXJnaW4tdG9wOiAxcmVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG4gIHdpZHRoOiAxMDBweDtcXHJcXG4gIGNvbG9yOiAjZjg2MzZiOyAvKiBNYXRjaCBidXR0b24gdGV4dCBjb2xvciAqL1xcclxcbiAgYm9yZGVyLWNvbG9yOiAjZjg2MzZiOyAvKiBNYXRjaCBidXR0b24gYm9yZGVyIGNvbG9yICovXFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG59XFxyXFxuXFxyXFxuLk11aUJ1dHRvbi1vdXRsaW5lZDpob3ZlciB7XFxyXFxuICBib3JkZXItY29sb3I6ICNlNTNlM2U7IC8qIERhcmtlciBzaGFkZSBmb3IgaG92ZXIgKi9cXHJcXG4gIGNvbG9yOiAjZTUzZTNlOyAvKiBEYXJrZXIgc2hhZGUgZm9yIGhvdmVyICovXFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNvbnRhaW5lclwiOiBcIkhvbWVfY29udGFpbmVyX19iQ09oWVwiLFxuXHRcIm1haW5cIjogXCJIb21lX21haW5fX25MamlRXCIsXG5cdFwiZm9vdGVyXCI6IFwiSG9tZV9mb290ZXJfX19fVDdLXCIsXG5cdFwidGl0bGVcIjogXCJIb21lX3RpdGxlX19UMDloRFwiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiSG9tZV9kZXNjcmlwdGlvbl9fNDFPd2tcIixcblx0XCJjb2RlXCI6IFwiSG9tZV9jb2RlX19zdVBFUlwiLFxuXHRcImdyaWRcIjogXCJIb21lX2dyaWRfX0d4UTg1XCIsXG5cdFwiYm9yZGVyXCI6IFwiSG9tZV9ib3JkZXJfX3NpTk9TXCIsXG5cdFwiYm9yZGVyd2FsbGV0XCI6IFwiSG9tZV9ib3JkZXJ3YWxsZXRfXzBoYXppXCIsXG5cdFwiY2FyZFwiOiBcIkhvbWVfY2FyZF9fX0xwTDFcIixcblx0XCJsb2dvXCI6IFwiSG9tZV9sb2dvX18yN190YlwiLFxuXHRcImJhY2tCdXR0b25cIjogXCJIb21lX2JhY2tCdXR0b25fX3A3WF9sXCIsXG5cdFwic3ViLWZvcm0tbWFpblwiOiBcIkhvbWVfc3ViLWZvcm0tbWFpbl9fbVMwaW1cIixcblx0XCJpbnB1dFwiOiBcIkhvbWVfaW5wdXRfX1phcldaXCIsXG5cdFwibGFiZWxcIjogXCJIb21lX2xhYmVsX19VWXRPYVwiLFxuXHRcIk11aUlucHV0TGFiZWwtcm9vdFwiOiBcIkhvbWVfTXVpSW5wdXRMYWJlbC1yb290X181VV9XWlwiLFxuXHRcIk11aUlucHV0QmFzZS1pbnB1dFwiOiBcIkhvbWVfTXVpSW5wdXRCYXNlLWlucHV0X19iWHVfUlwiLFxuXHRcIk11aUJ1dHRvbi1vdXRsaW5lZFwiOiBcIkhvbWVfTXVpQnV0dG9uLW91dGxpbmVkX18ySzVLdlwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css":
/*!***************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css ***!
  \***************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* MintNFT.module.css */\\r\\n\\r\\n.MintNFT_formContainer__Al_mi {\\r\\n    background-color: #020230;\\r\\n    color: white;\\r\\n    padding: 20px;\\r\\n    border-radius: 8px;\\r\\n    max-width: 500px;\\r\\n    margin: auto;\\r\\n  }\\r\\n  \\r\\n  .MintNFT_formContainer__Al_mi div {\\r\\n    margin-bottom: 15px;\\r\\n  }\\r\\n  \\r\\n  .MintNFT_formContainer__Al_mi b {\\r\\n    display: block;\\r\\n    margin-bottom: 5px;\\r\\n  }\\r\\n  \\r\\n  .MintNFT_formContainer__Al_mi input[type='text'] {\\r\\n    width: 100%;\\r\\n    padding: 10px;\\r\\n    border: 1px solid #ffffff;\\r\\n    border-radius: 4px;\\r\\n    background-color: #020230;\\r\\n    color: white;\\r\\n  }\\r\\n  \\r\\n  .MintNFT_formContainer__Al_mi input[type='submit'] {\\r\\n    background-color: #f8636b;\\r\\n    color: white;\\r\\n    border: none;\\r\\n    padding: 15px 20px;\\r\\n    border-radius: 4px;\\r\\n    cursor: pointer;\\r\\n  }\\r\\n  \\r\\n  .MintNFT_formContainer__Al_mi input[type='submit']:hover {\\r\\n    background-color: #e53e3e;\\r\\n  }\\r\\n  \", \"\",{\"version\":3,\"sources\":[\"webpack://styles/MintNFT.module.css\"],\"names\":[],\"mappings\":\"AAAA,uBAAuB;;AAEvB;IACI,yBAAyB;IACzB,YAAY;IACZ,aAAa;IACb,kBAAkB;IAClB,gBAAgB;IAChB,YAAY;EACd;;EAEA;IACE,mBAAmB;EACrB;;EAEA;IACE,cAAc;IACd,kBAAkB;EACpB;;EAEA;IACE,WAAW;IACX,aAAa;IACb,yBAAyB;IACzB,kBAAkB;IAClB,yBAAyB;IACzB,YAAY;EACd;;EAEA;IACE,yBAAyB;IACzB,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,kBAAkB;IAClB,eAAe;EACjB;;EAEA;IACE,yBAAyB;EAC3B\",\"sourcesContent\":[\"/* MintNFT.module.css */\\r\\n\\r\\n.formContainer {\\r\\n    background-color: #020230;\\r\\n    color: white;\\r\\n    padding: 20px;\\r\\n    border-radius: 8px;\\r\\n    max-width: 500px;\\r\\n    margin: auto;\\r\\n  }\\r\\n  \\r\\n  .formContainer div {\\r\\n    margin-bottom: 15px;\\r\\n  }\\r\\n  \\r\\n  .formContainer b {\\r\\n    display: block;\\r\\n    margin-bottom: 5px;\\r\\n  }\\r\\n  \\r\\n  .formContainer input[type='text'] {\\r\\n    width: 100%;\\r\\n    padding: 10px;\\r\\n    border: 1px solid #ffffff;\\r\\n    border-radius: 4px;\\r\\n    background-color: #020230;\\r\\n    color: white;\\r\\n  }\\r\\n  \\r\\n  .formContainer input[type='submit'] {\\r\\n    background-color: #f8636b;\\r\\n    color: white;\\r\\n    border: none;\\r\\n    padding: 15px 20px;\\r\\n    border-radius: 4px;\\r\\n    cursor: pointer;\\r\\n  }\\r\\n  \\r\\n  .formContainer input[type='submit']:hover {\\r\\n    background-color: #e53e3e;\\r\\n  }\\r\\n  \"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"formContainer\": \"MintNFT_formContainer__Al_mi\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzJdIS4vc3R5bGVzL01pbnRORlQubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLG1LQUErRTtBQUN6SDtBQUNBO0FBQ0EseUdBQXlHLGtDQUFrQyxxQkFBcUIsc0JBQXNCLDJCQUEyQix5QkFBeUIscUJBQXFCLE9BQU8sK0NBQStDLDRCQUE0QixPQUFPLDZDQUE2Qyx1QkFBdUIsMkJBQTJCLE9BQU8sOERBQThELG9CQUFvQixzQkFBc0Isa0NBQWtDLDJCQUEyQixrQ0FBa0MscUJBQXFCLE9BQU8sZ0VBQWdFLGtDQUFrQyxxQkFBcUIscUJBQXFCLDJCQUEyQiwyQkFBMkIsd0JBQXdCLE9BQU8sc0VBQXNFLGtDQUFrQyxPQUFPLGFBQWEsa0dBQWtHLE1BQU0sWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksV0FBVyxVQUFVLFlBQVksYUFBYSxXQUFXLE9BQU8sS0FBSyxZQUFZLDBFQUEwRSxrQ0FBa0MscUJBQXFCLHNCQUFzQiwyQkFBMkIseUJBQXlCLHFCQUFxQixPQUFPLGdDQUFnQyw0QkFBNEIsT0FBTyw4QkFBOEIsdUJBQXVCLDJCQUEyQixPQUFPLCtDQUErQyxvQkFBb0Isc0JBQXNCLGtDQUFrQywyQkFBMkIsa0NBQWtDLHFCQUFxQixPQUFPLGlEQUFpRCxrQ0FBa0MscUJBQXFCLHFCQUFxQiwyQkFBMkIsMkJBQTJCLHdCQUF3QixPQUFPLHVEQUF1RCxrQ0FBa0MsT0FBTyx5QkFBeUI7QUFDN3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL01pbnRORlQubW9kdWxlLmNzcz9lZWEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBNaW50TkZULm1vZHVsZS5jc3MgKi9cXHJcXG5cXHJcXG4uTWludE5GVF9mb3JtQ29udGFpbmVyX19BbF9taSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcGFkZGluZzogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgICBtYXgtd2lkdGg6IDUwMHB4O1xcclxcbiAgICBtYXJnaW46IGF1dG87XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5NaW50TkZUX2Zvcm1Db250YWluZXJfX0FsX21pIGRpdiB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDE1cHg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5NaW50TkZUX2Zvcm1Db250YWluZXJfX0FsX21pIGIge1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuTWludE5GVF9mb3JtQ29udGFpbmVyX19BbF9taSBpbnB1dFt0eXBlPSd0ZXh0J10ge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDIwMjMwO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5NaW50TkZUX2Zvcm1Db250YWluZXJfX0FsX21pIGlucHV0W3R5cGU9J3N1Ym1pdCddIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4NjM2YjtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBib3JkZXI6IG5vbmU7XFxyXFxuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5NaW50TkZUX2Zvcm1Db250YWluZXJfX0FsX21pIGlucHV0W3R5cGU9J3N1Ym1pdCddOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U1M2UzZTtcXHJcXG4gIH1cXHJcXG4gIFwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvTWludE5GVC5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHVCQUF1Qjs7QUFFdkI7SUFDSSx5QkFBeUI7SUFDekIsWUFBWTtJQUNaLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsZ0JBQWdCO0lBQ2hCLFlBQVk7RUFDZDs7RUFFQTtJQUNFLG1CQUFtQjtFQUNyQjs7RUFFQTtJQUNFLGNBQWM7SUFDZCxrQkFBa0I7RUFDcEI7O0VBRUE7SUFDRSxXQUFXO0lBQ1gsYUFBYTtJQUNiLHlCQUF5QjtJQUN6QixrQkFBa0I7SUFDbEIseUJBQXlCO0lBQ3pCLFlBQVk7RUFDZDs7RUFFQTtJQUNFLHlCQUF5QjtJQUN6QixZQUFZO0lBQ1osWUFBWTtJQUNaLGtCQUFrQjtJQUNsQixrQkFBa0I7SUFDbEIsZUFBZTtFQUNqQjs7RUFFQTtJQUNFLHlCQUF5QjtFQUMzQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBNaW50TkZULm1vZHVsZS5jc3MgKi9cXHJcXG5cXHJcXG4uZm9ybUNvbnRhaW5lciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwMjAyMzA7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgcGFkZGluZzogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgICBtYXgtd2lkdGg6IDUwMHB4O1xcclxcbiAgICBtYXJnaW46IGF1dG87XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5mb3JtQ29udGFpbmVyIGRpdiB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDE1cHg7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5mb3JtQ29udGFpbmVyIGIge1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuZm9ybUNvbnRhaW5lciBpbnB1dFt0eXBlPSd0ZXh0J10ge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgcGFkZGluZzogMTBweDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDIwMjMwO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5mb3JtQ29udGFpbmVyIGlucHV0W3R5cGU9J3N1Ym1pdCddIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4NjM2YjtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBib3JkZXI6IG5vbmU7XFxyXFxuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5mb3JtQ29udGFpbmVyIGlucHV0W3R5cGU9J3N1Ym1pdCddOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U1M2UzZTtcXHJcXG4gIH1cXHJcXG4gIFwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImZvcm1Db250YWluZXJcIjogXCJNaW50TkZUX2Zvcm1Db250YWluZXJfX0FsX21pXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fapp%2Fpages%2Findex.tsx&page=%2F!":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fapp%2Fpages%2Findex.tsx&page=%2F! ***!
  \****************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZhcHAlMkZwYWdlcyUyRmluZGV4LnRzeCZwYWdlPSUyRiEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0Q0FBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzRiMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fapp%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./styles/Home.module.css":
/*!********************************!*\
  !*** ./styles/Home.module.css ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/Home.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMsK2VBQW1QOztBQUVyUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sK2VBQW1QO0FBQ3pQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsK2VBQW1QOztBQUU3UTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzPzNjYmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzZdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzJdIS4vSG9tZS5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzZdLnVzZVsyXSEuL0hvbWUubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMl0hLi9Ib21lLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/Home.module.css\n"));

/***/ }),

/***/ "./styles/MintNFT.module.css":
/*!***********************************!*\
  !*** ./styles/MintNFT.module.css ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./MintNFT.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./MintNFT.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./MintNFT.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./styles/MintNFT.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvTWludE5GVC5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxvTkFBd0c7QUFDMUgsMEJBQTBCLG1CQUFPLENBQUMscWZBQXNQOztBQUV4Ujs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0scWZBQXNQO0FBQzVQO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscWZBQXNQOztBQUVoUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvTWludE5GVC5tb2R1bGUuY3NzPzY1YzEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzZdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzJdIS4vTWludE5GVC5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzZdLnVzZVsyXSEuL01pbnRORlQubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbNl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls2XS51c2VbMl0hLi9NaW50TkZULm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/MintNFT.module.css\n"));

/***/ }),

/***/ "./components/MintNFT.tsx":
/*!********************************!*\
  !*** ./components/MintNFT.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_MintNFT_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/MintNFT.module.css */ \"./styles/MintNFT.module.css\");\n/* harmony import */ var _styles_MintNFT_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_MintNFT_module_css__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nconst mintNFT = (param)=>{\n    let { onMintNFT  } = param;\n    _s();\n    const [address, setAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [name, setName] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [description, setDescription] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [img, setImg] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const onSubmit = (e)=>{\n        e.preventDefault() // prevent full page refresh\n        ;\n        onMintNFT([\n            address,\n            name,\n            description,\n            img\n        ]);\n    };\n    return(// <form onSubmit={onSubmit}>\n    //     <div>\n    //         <b>Destination Wallet Address</b> \n    //         <br></br>\n    //         <input name='address' type='text' id='address' placeholder='Enter Destination Wallet Address' \n    //         value={address}\n    //         onChange={(e) => setAddress(e.target.value)}\n    //         />\n    //         <p></p>                 \n    //     </div>\n    //     <div>\n    //         <b>NFT Token Name</b> \n    //         <br></br>\n    //         <input name='name' type='text' id='name' placeholder='Enter NFT Token Name' \n    //         value={name}\n    //         onChange={(e) => setName(e.target.value)}\n    //         />\n    //         <p></p>\n    //     </div>\n    //     <div>\n    //         <b>NFT Description</b> \n    //         <br></br>\n    //         <input name='description' type='text' id='description' placeholder='Enter NFT Description' \n    //         value={description}\n    //         onChange={(e) => setDescription(e.target.value)}\n    //         />\n    //         <p></p>\n    //     </div>\n    //     <div>\n    //         <b>NFT Image</b> \n    //         <br></br>\n    //         <input name='img' type='text' id='img' placeholder='Enter NFT Image CID' \n    //         value={img}\n    //         onChange={(e) => setImg(e.target.value)}\n    //         />\n    //         <p></p>\n    //     </div>\n    //     <br></br>                   \n    //     <input type='submit' value='Mint NFT'/>\n    // </form>\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n        onSubmit: onSubmit,\n        className: (_styles_MintNFT_module_css__WEBPACK_IMPORTED_MODULE_2___default().formContainer),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"Destination Wallet Address\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        name: \"address\",\n                        type: \"text\",\n                        id: \"address\",\n                        placeholder: \"Enter Destination Wallet Address\",\n                        value: address,\n                        onChange: (e)=>setAddress(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/MintNFT.tsx\",\n                lineNumber: 59,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"NFT Token Name\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        name: \"name\",\n                        type: \"text\",\n                        id: \"name\",\n                        placeholder: \"Enter NFT Token Name\",\n                        value: name,\n                        onChange: (e)=>setName(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 72,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/MintNFT.tsx\",\n                lineNumber: 70,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"NFT Description\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 82,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        name: \"description\",\n                        type: \"text\",\n                        id: \"description\",\n                        placeholder: \"Enter NFT Description\",\n                        value: description,\n                        onChange: (e)=>setDescription(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 83,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/MintNFT.tsx\",\n                lineNumber: 81,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                        children: \"NFT Image\"\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        name: \"img\",\n                        type: \"text\",\n                        id: \"img\",\n                        placeholder: \"Enter NFT Image CID\",\n                        value: img,\n                        onChange: (e)=>setImg(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/app/components/MintNFT.tsx\",\n                        lineNumber: 94,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/MintNFT.tsx\",\n                lineNumber: 92,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"submit\",\n                value: \"Mint NFT\"\n            }, void 0, false, {\n                fileName: \"/app/components/MintNFT.tsx\",\n                lineNumber: 103,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/components/MintNFT.tsx\",\n        lineNumber: 58,\n        columnNumber: 9\n    }, undefined));\n};\n_s(mintNFT, \"s0YEXwx+BOu/MiU5f4Qf7hZGa2U=\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (mintNFT);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LnRzeD8zY2U4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL01pbnRORlQubW9kdWxlLmNzcyc7XHJcbmNvbnN0IG1pbnRORlQgPSAoeyBvbk1pbnRORlQgfSA6IGFueSkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFthZGRyZXNzLCBzZXRBZGRyZXNzXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFtuYW1lLCBzZXROYW1lXSA9IHVzZVN0YXRlKCcnKTtcclxuICAgIGNvbnN0IFtkZXNjcmlwdGlvbiwgc2V0RGVzY3JpcHRpb25dID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2ltZywgc2V0SW1nXSA9IHVzZVN0YXRlKCcnKTtcclxuXHJcbiAgICBjb25zdCBvblN1Ym1pdCA9IChlIDogYW55KSA9PiB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpIC8vIHByZXZlbnQgZnVsbCBwYWdlIHJlZnJlc2hcclxuICAgICAgICBvbk1pbnRORlQoW2FkZHJlc3MsIG5hbWUsIGRlc2NyaXB0aW9uLCBpbWddKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcblxyXG4gICAgICAgIC8vIDxmb3JtIG9uU3VibWl0PXtvblN1Ym1pdH0+XHJcbiAgICAgICAgLy8gICAgIDxkaXY+XHJcbiAgICAgICAgLy8gICAgICAgICA8Yj5EZXN0aW5hdGlvbiBXYWxsZXQgQWRkcmVzczwvYj4gXHJcbiAgICAgICAgLy8gICAgICAgICA8YnI+PC9icj5cclxuICAgICAgICAvLyAgICAgICAgIDxpbnB1dCBuYW1lPSdhZGRyZXNzJyB0eXBlPSd0ZXh0JyBpZD0nYWRkcmVzcycgcGxhY2Vob2xkZXI9J0VudGVyIERlc3RpbmF0aW9uIFdhbGxldCBBZGRyZXNzJyBcclxuICAgICAgICAvLyAgICAgICAgIHZhbHVlPXthZGRyZXNzfVxyXG4gICAgICAgIC8vICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRBZGRyZXNzKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAvLyAgICAgICAgIC8+XHJcbiAgICAgICAgLy8gICAgICAgICA8cD48L3A+ICAgICAgICAgICAgICAgICBcclxuICAgICAgICAvLyAgICAgPC9kaXY+XHJcbiAgICAgICAgLy8gICAgIDxkaXY+XHJcbiAgICAgICAgLy8gICAgICAgICA8Yj5ORlQgVG9rZW4gTmFtZTwvYj4gXHJcbiAgICAgICAgLy8gICAgICAgICA8YnI+PC9icj5cclxuICAgICAgICAvLyAgICAgICAgIDxpbnB1dCBuYW1lPSduYW1lJyB0eXBlPSd0ZXh0JyBpZD0nbmFtZScgcGxhY2Vob2xkZXI9J0VudGVyIE5GVCBUb2tlbiBOYW1lJyBcclxuICAgICAgICAvLyAgICAgICAgIHZhbHVlPXtuYW1lfVxyXG4gICAgICAgIC8vICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROYW1lKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAvLyAgICAgICAgIC8+XHJcbiAgICAgICAgLy8gICAgICAgICA8cD48L3A+XHJcbiAgICAgICAgLy8gICAgIDwvZGl2PlxyXG4gICAgICAgIC8vICAgICA8ZGl2PlxyXG4gICAgICAgIC8vICAgICAgICAgPGI+TkZUIERlc2NyaXB0aW9uPC9iPiBcclxuICAgICAgICAvLyAgICAgICAgIDxicj48L2JyPlxyXG4gICAgICAgIC8vICAgICAgICAgPGlucHV0IG5hbWU9J2Rlc2NyaXB0aW9uJyB0eXBlPSd0ZXh0JyBpZD0nZGVzY3JpcHRpb24nIHBsYWNlaG9sZGVyPSdFbnRlciBORlQgRGVzY3JpcHRpb24nIFxyXG4gICAgICAgIC8vICAgICAgICAgdmFsdWU9e2Rlc2NyaXB0aW9ufVxyXG4gICAgICAgIC8vICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREZXNjcmlwdGlvbihlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgLy8gICAgICAgICAvPlxyXG4gICAgICAgIC8vICAgICAgICAgPHA+PC9wPlxyXG4gICAgICAgIC8vICAgICA8L2Rpdj5cclxuICAgICAgICAvLyAgICAgPGRpdj5cclxuICAgICAgICAvLyAgICAgICAgIDxiPk5GVCBJbWFnZTwvYj4gXHJcbiAgICAgICAgLy8gICAgICAgICA8YnI+PC9icj5cclxuICAgICAgICAvLyAgICAgICAgIDxpbnB1dCBuYW1lPSdpbWcnIHR5cGU9J3RleHQnIGlkPSdpbWcnIHBsYWNlaG9sZGVyPSdFbnRlciBORlQgSW1hZ2UgQ0lEJyBcclxuICAgICAgICAvLyAgICAgICAgIHZhbHVlPXtpbWd9XHJcbiAgICAgICAgLy8gICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEltZyhlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgLy8gICAgICAgICAvPlxyXG4gICAgICAgIC8vICAgICAgICAgPHA+PC9wPlxyXG4gICAgICAgIC8vICAgICA8L2Rpdj5cclxuICAgICAgICAvLyAgICAgPGJyPjwvYnI+ICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIC8vICAgICA8aW5wdXQgdHlwZT0nc3VibWl0JyB2YWx1ZT0nTWludCBORlQnLz5cclxuICAgICAgICAvLyA8L2Zvcm0+XHJcbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e29uU3VibWl0fSBjbGFzc05hbWU9e3N0eWxlcy5mb3JtQ29udGFpbmVyfT5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxiPkRlc3RpbmF0aW9uIFdhbGxldCBBZGRyZXNzPC9iPiBcclxuICAgICAgICAgICAgICAgIDxpbnB1dCBcclxuICAgICAgICAgICAgICAgICAgICBuYW1lPSdhZGRyZXNzJyBcclxuICAgICAgICAgICAgICAgICAgICB0eXBlPSd0ZXh0JyBcclxuICAgICAgICAgICAgICAgICAgICBpZD0nYWRkcmVzcycgXHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9J0VudGVyIERlc3RpbmF0aW9uIFdhbGxldCBBZGRyZXNzJyBcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17YWRkcmVzc31cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEFkZHJlc3MoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8Yj5ORlQgVG9rZW4gTmFtZTwvYj4gXHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT0nbmFtZScgXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT0ndGV4dCcgXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ9J25hbWUnIFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPSdFbnRlciBORlQgVG9rZW4gTmFtZScgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e25hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROYW1lKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGI+TkZUIERlc2NyaXB0aW9uPC9iPiBcclxuICAgICAgICAgICAgICAgIDxpbnB1dCBcclxuICAgICAgICAgICAgICAgICAgICBuYW1lPSdkZXNjcmlwdGlvbicgXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT0ndGV4dCcgXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ9J2Rlc2NyaXB0aW9uJyBcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0nRW50ZXIgTkZUIERlc2NyaXB0aW9uJyBcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZGVzY3JpcHRpb259XHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREZXNjcmlwdGlvbihlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxiPk5GVCBJbWFnZTwvYj4gXHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT0naW1nJyBcclxuICAgICAgICAgICAgICAgICAgICB0eXBlPSd0ZXh0JyBcclxuICAgICAgICAgICAgICAgICAgICBpZD0naW1nJyBcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0nRW50ZXIgTkZUIEltYWdlIENJRCcgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ltZ31cclxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEltZyhlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9J3N1Ym1pdCcgdmFsdWU9J01pbnQgTkZUJy8+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtaW50TkZUIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwic3R5bGVzIiwibWludE5GVCIsIm9uTWludE5GVCIsImFkZHJlc3MiLCJzZXRBZGRyZXNzIiwibmFtZSIsInNldE5hbWUiLCJkZXNjcmlwdGlvbiIsInNldERlc2NyaXB0aW9uIiwiaW1nIiwic2V0SW1nIiwib25TdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJmb3JtIiwiY2xhc3NOYW1lIiwiZm9ybUNvbnRhaW5lciIsImRpdiIsImIiLCJpbnB1dCIsInR5cGUiLCJpZCIsInBsYWNlaG9sZGVyIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/MintNFT.tsx\n"));

/***/ }),

/***/ "./components/WalletInfo.tsx":
/*!***********************************!*\
  !*** ./components/WalletInfo.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nconst WalletInfo = (param)=>{\n    let { walletInfo  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            color: \"white\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                children: \"Wallet Balance In Lovelace\"\n            }, void 0, false, {\n                fileName: \"/app/components/WalletInfo.tsx\",\n                lineNumber: 4,\n                columnNumber: 41\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                children: [\n                    \"\\xa0\\xa0\\xa0\\xa0\",\n                    walletInfo.balance\n                ]\n            }, void 0, true, {\n                fileName: \"/app/components/WalletInfo.tsx\",\n                lineNumber: 5,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/components/WalletInfo.tsx\",\n        lineNumber: 4,\n        columnNumber: 9\n    }, undefined);\n};\n_c = WalletInfo;\n/* harmony default export */ __webpack_exports__[\"default\"] = (WalletInfo);\nvar _c;\n$RefreshReg$(_c, \"WalletInfo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1dhbGxldEluZm8udHN4LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQUEsTUFBTUEsYUFBYSxTQUF5QjtRQUF4QixFQUFFQyxXQUFVLEVBQU87SUFFbkMscUJBQ0ksOERBQUNDO1FBQUlDLE9BQU87WUFBRUMsT0FBTztRQUFROzswQkFBRyw4REFBQ0M7MEJBQUU7Ozs7OzswQkFDL0IsOERBQUNDOztvQkFBRTtvQkFBeUJMLFdBQVdNLE9BQU87Ozs7Ozs7Ozs7Ozs7QUFHMUQ7S0FQTVA7QUFTTiwrREFBZUEsVUFBVUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1dhbGxldEluZm8udHN4P2E3NjkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgV2FsbGV0SW5mbyA9ICh7IHdhbGxldEluZm8gfTogYW55KSA9PiB7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiBcIndoaXRlXCIgfX0+PGI+V2FsbGV0IEJhbGFuY2UgSW4gTG92ZWxhY2U8L2I+XHJcbiAgICAgICAgICAgIDxpPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t3YWxsZXRJbmZvLmJhbGFuY2V9PC9pPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXYWxsZXRJbmZvXHJcbiJdLCJuYW1lcyI6WyJXYWxsZXRJbmZvIiwid2FsbGV0SW5mbyIsImRpdiIsInN0eWxlIiwiY29sb3IiLCJiIiwiaSIsImJhbGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/WalletInfo.tsx\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_MintNFT__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/MintNFT */ \"./components/MintNFT.tsx\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styles/Home.module.css */ \"./styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_WalletInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/WalletInfo */ \"./components/WalletInfo.tsx\");\n/* harmony import */ var _contracts_nft_hl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../contracts/nft.hl */ \"./contracts/nft.hl\");\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst Home = ()=>{\n    _s();\n    const optimize = false;\n    const networkParamsUrl = \"https://d1t0d7c2nekuk0.cloudfront.net/preprod.json\";\n    // const networkParamsUrl = \"https://d1t0d7c2nekuk0.cloudfront.net/preview.json\";\n    // const networkParamsUrl = \"https://book.world.dev.cardano.org/environments/preview/shelley-genesis.json\";\n    // const networkParamsUrl = \"https://raw.githubusercontent.com/apatel2582/preview_network_cardano_json/main/preview.json\";\n    const [walletInfo, setWalletInfo] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        balance: \"\"\n    });\n    const [walletIsEnabled, setWalletIsEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [whichWalletSelected, setWhichWalletSelected] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const [walletAPI, setWalletAPI] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const [walletHelper, setWalletHelper] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(undefined);\n    const [tx, setTx] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        txId: \"\"\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const checkWallet = async ()=>{\n            setWalletIsEnabled(await checkIfWalletFound());\n        };\n        checkWallet();\n    }, [\n        whichWalletSelected\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const enableSelectedWallet = async ()=>{\n            if (walletIsEnabled) {\n                await enableWallet();\n            }\n        };\n        enableSelectedWallet();\n    }, [\n        walletIsEnabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const updateWalletInfo = async ()=>{\n            if (walletIsEnabled) {\n                const _balance = await getBalance();\n                setWalletInfo({\n                    ...walletInfo,\n                    balance: _balance\n                });\n            }\n        };\n        updateWalletInfo();\n    }, [\n        walletAPI\n    ]);\n    // user selects what wallet to connect to\n    const handleWalletSelect = (obj)=>{\n        const whichWalletSelected = obj.target.value;\n        setWhichWalletSelected(whichWalletSelected);\n    };\n    const checkIfWalletFound = async ()=>{\n        let walletFound = false;\n        const walletChoice = whichWalletSelected;\n        if (walletChoice === \"nami\") {\n            var _window_cardano;\n            walletFound = !!(window === null || window === void 0 ? void 0 : (_window_cardano = window.cardano) === null || _window_cardano === void 0 ? void 0 : _window_cardano.nami);\n        } else if (walletChoice === \"eternl\") {\n            var _window_cardano1;\n            walletFound = !!(window === null || window === void 0 ? void 0 : (_window_cardano1 = window.cardano) === null || _window_cardano1 === void 0 ? void 0 : _window_cardano1.eternl);\n        }\n        return walletFound;\n    };\n    const enableWallet = async ()=>{\n        try {\n            const walletChoice = whichWalletSelected;\n            if (walletChoice === \"nami\") {\n                const handle = await window.cardano.nami.enable();\n                const walletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Cip30Wallet(handle);\n                const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.WalletHelper(walletAPI);\n                setWalletHelper(walletHelper);\n                setWalletAPI(walletAPI);\n            } else if (walletChoice === \"eternl\") {\n                const handle1 = await window.cardano.eternl.enable();\n                const walletAPI1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Cip30Wallet(handle1);\n                const walletHelper1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.WalletHelper(walletAPI1);\n                setWalletHelper(walletHelper1);\n                setWalletAPI(walletAPI1);\n            }\n        } catch (err) {\n            console.log(\"enableWallet error\", err);\n        }\n    };\n    const getBalance = async ()=>{\n        try {\n            const balanceAmountValue = await walletHelper.calcBalance();\n            const balanceAmount = balanceAmountValue.lovelace;\n            const walletBalance = BigInt(balanceAmount);\n            return walletBalance.toLocaleString();\n        } catch (err) {\n            console.log(\"getBalance error: \", err);\n        }\n    };\n    const mintNFT = async (params)=>{\n        // Re-enable wallet API since wallet account may have been changed\n        await enableWallet();\n        const address = params[0];\n        const name = params[1];\n        const description = params[2];\n        const img = params[3];\n        const minAda = 2000000; // minimum lovelace needed to send an NFT\n        const maxTxFee = 500000; // maximum estimated transaction fee\n        const minChangeAmt = 1000000; // minimum lovelace needed to be sent back as change\n        const minAdaVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Value(BigInt(minAda));\n        const minUTXOVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Value(BigInt(minAda + maxTxFee + minChangeAmt));\n        // Get wallet UTXOs\n        const utxos = await walletHelper.pickUtxos(minUTXOVal);\n        // Get change address\n        const changeAddr = await walletHelper.changeAddress;\n        // Start building the transaction\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Tx();\n        // Add the UTXO as inputs\n        tx.addInputs(utxos[0]);\n        const nftProgram = new _contracts_nft_hl__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        nftProgram.parameters = {\n            [\"TX_ID\"]: utxos[0][0].txId.hex\n        };\n        nftProgram.parameters = {\n            [\"TX_IDX\"]: utxos[0][0].utxoIdx\n        };\n        nftProgram.parameters = {\n            [\"TN\"]: name\n        };\n        // Compile the helios minting script\n        const nftCompiledProgram = nftProgram.compile(optimize);\n        // Add the script as a witness to the transaction\n        tx.attachScript(nftCompiledProgram);\n        // Construct the NFT that we will want to send as an output\n        const nftTokenName = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.ByteArrayData.fromString(name).toHex();\n        const tokens = [\n            [\n                (0,_hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(nftTokenName),\n                BigInt(1)\n            ]\n        ];\n        // Create an empty Redeemer because we must always send a Redeemer with\n        // a plutus script transaction even if we don't actually use it.\n        const mintRedeemer = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.ConstrData(0, []);\n        // Indicate the minting we want to include as part of this transaction\n        tx.mintTokens(nftCompiledProgram.mintingPolicyHash, tokens, mintRedeemer);\n        // Construct the output and include both the minimum Ada as well as the minted NFT\n        tx.addOutput(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.TxOutput(_hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Address.fromBech32(address), new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Value(minAdaVal.lovelace, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.Assets([\n            [\n                nftCompiledProgram.mintingPolicyHash,\n                tokens\n            ]\n        ]))));\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_6__.NetworkParams(await fetch(networkParamsUrl).then((response)=>response.json()));\n        // Attached the metadata for the minting transaction\n        tx.addMetadata(721, {\n            map: [\n                [\n                    nftCompiledProgram.mintingPolicyHash.hex,\n                    {\n                        map: [\n                            [\n                                name,\n                                {\n                                    map: [\n                                        [\n                                            \"name\",\n                                            name\n                                        ],\n                                        [\n                                            \"description\",\n                                            description\n                                        ],\n                                        [\n                                            \"image\",\n                                            img\n                                        ]\n                                    ]\n                                }\n                            ]\n                        ]\n                    }\n                ]\n            ]\n        });\n        console.log(\"tx before final\", tx.dump());\n        // Send any change back to the buyer\n        await tx.finalize(networkParams, changeAddr, utxos[1]);\n        console.log(\"Verifying signature...\");\n        const signatures = await walletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"tx after final\", tx.dump());\n        console.log(\"Submitting transaction...\");\n        const txHash = await walletAPI.submitTx(tx);\n        console.log(\"txHash\", txHash.hex);\n        setTx({\n            txId: txHash.hex\n        });\n    };\n    return(// <div className={styles.container}>\n    //   <Head>\n    //     <title>Cardano Athletics NFT Creator</title>\n    //     <meta name=\"description\" content=\"Cardano Athletics NFT Creator\" />\n    //     <link rel=\"icon\" href=\"/favicon.ico\" />\n    //   </Head>\n    //   <main className={styles.main}>\n    //     <h3 className={styles.title}>Cardano Athletics NFT Creator</h3>\n    //     <div className={styles.borderwallet}>\n    //       <p>Connect to your wallet</p>\n    //       <p className={styles.borderwallet}>\n    //         <input\n    //           type=\"radio\"\n    //           id=\"nami\"\n    //           name=\"wallet\"\n    //           value=\"nami\"\n    //           onChange={handleWalletSelect}\n    //         />\n    //         <label>Nami</label>\n    //       </p>\n    //       <p className={styles.borderwallet}>\n    //         <input\n    //           type=\"radio\"\n    //           id=\"eternl\"\n    //           name=\"wallet\"\n    //           value=\"eternl\"\n    //           onChange={handleWalletSelect}\n    //         />\n    //         <label>Eternl</label>\n    //       </p>\n    //     </div>\n    //     {!tx.txId && walletIsEnabled && (\n    //       <div className={styles.border}>\n    //         <WalletInfo walletInfo={walletInfo} />\n    //       </div>\n    //     )}\n    //     {tx.txId && (\n    //       <div className={styles.border}>\n    //         <b>Transaction Success!!!</b>\n    //         <p>\n    //           TxId &nbsp;&nbsp;\n    //           <a\n    //             href={\"https://preview.cexplorer.io/tx/\" + tx.txId}\n    //             target=\"_blank\"\n    //             rel=\"noopener noreferrer\"\n    //           >\n    //             {tx.txId}\n    //           </a>\n    //         </p>\n    //         <p>\n    //           Please wait until the transaction is confirmed on the blockchain\n    //           and reload this page before doing another transaction\n    //         </p>\n    //       </div>\n    //     )}\n    //     {walletIsEnabled && !tx.txId && (\n    //       <div className={styles.border}>\n    //         <MintNFT onMintNFT={mintNFT} />\n    //       </div>\n    //     )}\n    //     {/* Your permanent back button */}\n    //     <a href=\"http://localhost:3000\" className={styles.backButton}>\n    //       Go Back\n    //     </a>\n    //   </main>\n    //   <footer className={styles.footer}></footer>\n    // </div>\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Cardano Athletics NFT Creator\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 300,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Cardano Athletics NFT Creator\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 301,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 302,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/index.tsx\",\n                lineNumber: 299,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().main),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().title),\n                        children: \"Cardano Athletics NFT Creator\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 306,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().borderwallet),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"Connect to your wallet\"\n                            }, void 0, false, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 309,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().borderwallet),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"radio\",\n                                        id: \"nami\",\n                                        name: \"wallet\",\n                                        value: \"nami\",\n                                        onChange: handleWalletSelect\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/index.tsx\",\n                                        lineNumber: 311,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        children: \"Nami\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/index.tsx\",\n                                        lineNumber: 318,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 310,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().borderwallet),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"radio\",\n                                        id: \"eternl\",\n                                        name: \"wallet\",\n                                        value: \"eternl\",\n                                        onChange: handleWalletSelect\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/index.tsx\",\n                                        lineNumber: 321,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        children: \"Eternl\"\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/index.tsx\",\n                                        lineNumber: 328,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 320,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 308,\n                        columnNumber: 9\n                    }, undefined),\n                    !tx.txId && walletIsEnabled && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().border),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_WalletInfo__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            walletInfo: walletInfo\n                        }, void 0, false, {\n                            fileName: \"/app/pages/index.tsx\",\n                            lineNumber: 333,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 332,\n                        columnNumber: 11\n                    }, undefined),\n                    tx.txId && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().border),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                children: \"Transaction Success!!!\"\n                            }, void 0, false, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 338,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: [\n                                    \"TxId \\xa0\\xa0\",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"https://preprod.cardanoscan.io/transaction/\" + tx.txId,\n                                        target: \"_blank\",\n                                        rel: \"noopener noreferrer\",\n                                        children: tx.txId\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/index.tsx\",\n                                        lineNumber: 341,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 339,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: \"Please wait until the transaction is confirmed on the blockchain and reload this page before doing another transaction\"\n                            }, void 0, false, {\n                                fileName: \"/app/pages/index.tsx\",\n                                lineNumber: 349,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 337,\n                        columnNumber: 11\n                    }, undefined),\n                    walletIsEnabled && !tx.txId && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().border),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MintNFT__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            onMintNFT: mintNFT\n                        }, void 0, false, {\n                            fileName: \"/app/pages/index.tsx\",\n                            lineNumber: 357,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 356,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                        href: \"http://localhost:3000\",\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().backButton),\n                        children: \"Go Back\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/index.tsx\",\n                        lineNumber: 361,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/index.tsx\",\n                lineNumber: 305,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"footer\", {\n                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_7___default().footer)\n            }, void 0, false, {\n                fileName: \"/app/pages/index.tsx\",\n                lineNumber: 366,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/index.tsx\",\n        lineNumber: 298,\n        columnNumber: 5\n    }, undefined));\n};\n_s(Home, \"zvrImYPuy1fzEaT8BIwHpY6zDxg=\");\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Ozs7OzBCQUtoRSw4REFBQ29JO2dCQUFPdEIsV0FBVzlHLHVFQUFhOzs7Ozs7Ozs7Ozs7QUFHdEM7R0FwVk1nQjtLQUFBQTtBQXNWTiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC50c3g/MDdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcbmltcG9ydCBNaW50TkZUIGZyb20gXCIuLi9jb21wb25lbnRzL01pbnRORlRcIjtcclxuaW1wb3J0IHR5cGUgeyBOZXh0UGFnZSB9IGZyb20gXCJuZXh0XCI7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4uL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3NcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgV2FsbGV0SW5mbyBmcm9tIFwiLi4vY29tcG9uZW50cy9XYWxsZXRJbmZvXCI7XHJcbmltcG9ydCBQcm9ncmFtIGZyb20gXCIuLi9jb250cmFjdHMvbmZ0LmhsXCI7XHJcbmltcG9ydCB7XHJcbiAgQXNzZXRzLFxyXG4gIEFkZHJlc3MsXHJcbiAgQnl0ZUFycmF5RGF0YSxcclxuICBDaXAzMEhhbmRsZSxcclxuICBDaXAzMFdhbGxldCxcclxuICBDb25zdHJEYXRhLFxyXG4gIGhleFRvQnl0ZXMsXHJcbiAgTmV0d29ya1BhcmFtcyxcclxuICBWYWx1ZSxcclxuICBUeE91dHB1dCxcclxuICBUeCxcclxuICBXYWxsZXRIZWxwZXIsXHJcbn0gZnJvbSBcIkBoeXBlcmlvbmJ0L2hlbGlvc1wiO1xyXG5cclxuZGVjbGFyZSBnbG9iYWwge1xyXG4gIGludGVyZmFjZSBXaW5kb3cge1xyXG4gICAgY2FyZGFubzogYW55O1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgSG9tZTogTmV4dFBhZ2UgPSAoKSA9PiB7XHJcbiAgY29uc3Qgb3B0aW1pemUgPSBmYWxzZTtcclxuICBjb25zdCBuZXR3b3JrUGFyYW1zVXJsID0gXCJodHRwczovL2QxdDBkN2MybmVrdWswLmNsb3VkZnJvbnQubmV0L3ByZXByb2QuanNvblwiO1xyXG4gIC8vIGNvbnN0IG5ldHdvcmtQYXJhbXNVcmwgPSBcImh0dHBzOi8vZDF0MGQ3YzJuZWt1azAuY2xvdWRmcm9udC5uZXQvcHJldmlldy5qc29uXCI7XHJcbiAgLy8gY29uc3QgbmV0d29ya1BhcmFtc1VybCA9IFwiaHR0cHM6Ly9ib29rLndvcmxkLmRldi5jYXJkYW5vLm9yZy9lbnZpcm9ubWVudHMvcHJldmlldy9zaGVsbGV5LWdlbmVzaXMuanNvblwiO1xyXG4gIC8vIGNvbnN0IG5ldHdvcmtQYXJhbXNVcmwgPSBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hcGF0ZWwyNTgyL3ByZXZpZXdfbmV0d29ya19jYXJkYW5vX2pzb24vbWFpbi9wcmV2aWV3Lmpzb25cIjtcclxuICBjb25zdCBbd2FsbGV0SW5mbywgc2V0V2FsbGV0SW5mb10gPSB1c2VTdGF0ZSh7IGJhbGFuY2U6IFwiXCIgfSk7XHJcbiAgY29uc3QgW3dhbGxldElzRW5hYmxlZCwgc2V0V2FsbGV0SXNFbmFibGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbd2hpY2hXYWxsZXRTZWxlY3RlZCwgc2V0V2hpY2hXYWxsZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xyXG4gIGNvbnN0IFt3YWxsZXRBUEksIHNldFdhbGxldEFQSV0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBhbnk+KHVuZGVmaW5lZCk7XHJcbiAgY29uc3QgW3dhbGxldEhlbHBlciwgc2V0V2FsbGV0SGVscGVyXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IGFueT4odW5kZWZpbmVkKTtcclxuXHJcbiAgY29uc3QgW3R4LCBzZXRUeF0gPSB1c2VTdGF0ZSh7IHR4SWQ6IFwiXCIgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjaGVja1dhbGxldCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgc2V0V2FsbGV0SXNFbmFibGVkKGF3YWl0IGNoZWNrSWZXYWxsZXRGb3VuZCgpKTtcclxuICAgIH07XHJcbiAgICBjaGVja1dhbGxldCgpO1xyXG4gIH0sIFt3aGljaFdhbGxldFNlbGVjdGVkXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBlbmFibGVTZWxlY3RlZFdhbGxldCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKHdhbGxldElzRW5hYmxlZCkge1xyXG4gICAgICAgIGF3YWl0IGVuYWJsZVdhbGxldCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgZW5hYmxlU2VsZWN0ZWRXYWxsZXQoKTtcclxuICB9LCBbd2FsbGV0SXNFbmFibGVkXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVXYWxsZXRJbmZvID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAod2FsbGV0SXNFbmFibGVkKSB7XHJcbiAgICAgICAgY29uc3QgX2JhbGFuY2UgPSAoYXdhaXQgZ2V0QmFsYW5jZSgpKSBhcyBzdHJpbmc7XHJcbiAgICAgICAgc2V0V2FsbGV0SW5mbyh7XHJcbiAgICAgICAgICAuLi53YWxsZXRJbmZvLFxyXG4gICAgICAgICAgYmFsYW5jZTogX2JhbGFuY2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB1cGRhdGVXYWxsZXRJbmZvKCk7XHJcbiAgfSwgW3dhbGxldEFQSV0pO1xyXG5cclxuICAvLyB1c2VyIHNlbGVjdHMgd2hhdCB3YWxsZXQgdG8gY29ubmVjdCB0b1xyXG4gIGNvbnN0IGhhbmRsZVdhbGxldFNlbGVjdCA9IChvYmo6IGFueSkgPT4ge1xyXG4gICAgY29uc3Qgd2hpY2hXYWxsZXRTZWxlY3RlZCA9IG9iai50YXJnZXQudmFsdWU7XHJcbiAgICBzZXRXaGljaFdhbGxldFNlbGVjdGVkKHdoaWNoV2FsbGV0U2VsZWN0ZWQpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNoZWNrSWZXYWxsZXRGb3VuZCA9IGFzeW5jICgpID0+IHtcclxuICAgIGxldCB3YWxsZXRGb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IHdhbGxldENob2ljZSA9IHdoaWNoV2FsbGV0U2VsZWN0ZWQ7XHJcbiAgICBpZiAod2FsbGV0Q2hvaWNlID09PSBcIm5hbWlcIikge1xyXG4gICAgICB3YWxsZXRGb3VuZCA9ICEhd2luZG93Py5jYXJkYW5vPy5uYW1pO1xyXG4gICAgfSBlbHNlIGlmICh3YWxsZXRDaG9pY2UgPT09IFwiZXRlcm5sXCIpIHtcclxuICAgICAgd2FsbGV0Rm91bmQgPSAhIXdpbmRvdz8uY2FyZGFubz8uZXRlcm5sO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdhbGxldEZvdW5kO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGVuYWJsZVdhbGxldCA9IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHdhbGxldENob2ljZSA9IHdoaWNoV2FsbGV0U2VsZWN0ZWQ7XHJcbiAgICAgIGlmICh3YWxsZXRDaG9pY2UgPT09IFwibmFtaVwiKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlOiBDaXAzMEhhbmRsZSA9IGF3YWl0IHdpbmRvdy5jYXJkYW5vLm5hbWkuZW5hYmxlKCk7XHJcbiAgICAgICAgY29uc3Qgd2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KGhhbmRsZSk7XHJcbiAgICAgICAgY29uc3Qgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih3YWxsZXRBUEkpO1xyXG4gICAgICAgIHNldFdhbGxldEhlbHBlcih3YWxsZXRIZWxwZXIpO1xyXG4gICAgICAgIHNldFdhbGxldEFQSSh3YWxsZXRBUEkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHdhbGxldENob2ljZSA9PT0gXCJldGVybmxcIikge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZTogQ2lwMzBIYW5kbGUgPSBhd2FpdCB3aW5kb3cuY2FyZGFuby5ldGVybmwuZW5hYmxlKCk7XHJcbiAgICAgICAgY29uc3Qgd2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KGhhbmRsZSk7XHJcbiAgICAgICAgY29uc3Qgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih3YWxsZXRBUEkpO1xyXG4gICAgICAgIHNldFdhbGxldEhlbHBlcih3YWxsZXRIZWxwZXIpO1xyXG4gICAgICAgIHNldFdhbGxldEFQSSh3YWxsZXRBUEkpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJlbmFibGVXYWxsZXQgZXJyb3JcIiwgZXJyKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRCYWxhbmNlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYmFsYW5jZUFtb3VudFZhbHVlID0gYXdhaXQgd2FsbGV0SGVscGVyLmNhbGNCYWxhbmNlKCk7XHJcbiAgICAgIGNvbnN0IGJhbGFuY2VBbW91bnQgPSBiYWxhbmNlQW1vdW50VmFsdWUubG92ZWxhY2U7XHJcbiAgICAgIGNvbnN0IHdhbGxldEJhbGFuY2U6IEJpZ0ludCA9IEJpZ0ludChiYWxhbmNlQW1vdW50KTtcclxuICAgICAgcmV0dXJuIHdhbGxldEJhbGFuY2UudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcImdldEJhbGFuY2UgZXJyb3I6IFwiLCBlcnIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IG1pbnRORlQgPSBhc3luYyAocGFyYW1zOiBhbnkpID0+IHtcclxuICAgIC8vIFJlLWVuYWJsZSB3YWxsZXQgQVBJIHNpbmNlIHdhbGxldCBhY2NvdW50IG1heSBoYXZlIGJlZW4gY2hhbmdlZFxyXG4gICAgYXdhaXQgZW5hYmxlV2FsbGV0KCk7XHJcblxyXG4gICAgY29uc3QgYWRkcmVzcyA9IHBhcmFtc1swXTtcclxuICAgIGNvbnN0IG5hbWUgPSBwYXJhbXNbMV07XHJcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHBhcmFtc1syXTtcclxuICAgIGNvbnN0IGltZyA9IHBhcmFtc1szXTtcclxuICAgIGNvbnN0IG1pbkFkYTogbnVtYmVyID0gMjAwMDAwMDsgLy8gbWluaW11bSBsb3ZlbGFjZSBuZWVkZWQgdG8gc2VuZCBhbiBORlRcclxuICAgIGNvbnN0IG1heFR4RmVlOiBudW1iZXIgPSA1MDAwMDA7IC8vIG1heGltdW0gZXN0aW1hdGVkIHRyYW5zYWN0aW9uIGZlZVxyXG4gICAgY29uc3QgbWluQ2hhbmdlQW10OiBudW1iZXIgPSAxMDAwMDAwOyAvLyBtaW5pbXVtIGxvdmVsYWNlIG5lZWRlZCB0byBiZSBzZW50IGJhY2sgYXMgY2hhbmdlXHJcbiAgICBjb25zdCBtaW5BZGFWYWwgPSBuZXcgVmFsdWUoQmlnSW50KG1pbkFkYSkpO1xyXG4gICAgY29uc3QgbWluVVRYT1ZhbCA9IG5ldyBWYWx1ZShCaWdJbnQobWluQWRhICsgbWF4VHhGZWUgKyBtaW5DaGFuZ2VBbXQpKTtcclxuXHJcbiAgICAvLyBHZXQgd2FsbGV0IFVUWE9zXHJcbiAgICBjb25zdCB1dHhvcyA9IGF3YWl0IHdhbGxldEhlbHBlci5waWNrVXR4b3MobWluVVRYT1ZhbCk7XHJcblxyXG4gICAgLy8gR2V0IGNoYW5nZSBhZGRyZXNzXHJcbiAgICBjb25zdCBjaGFuZ2VBZGRyID0gYXdhaXQgd2FsbGV0SGVscGVyLmNoYW5nZUFkZHJlc3M7XHJcblxyXG4gICAgLy8gU3RhcnQgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICBjb25zdCB0eCA9IG5ldyBUeCgpO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgVVRYTyBhcyBpbnB1dHNcclxuICAgIHR4LmFkZElucHV0cyh1dHhvc1swXSk7XHJcblxyXG4gICAgY29uc3QgbmZ0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKCk7XHJcbiAgICBuZnRQcm9ncmFtLnBhcmFtZXRlcnMgPSB7IFtcIlRYX0lEXCJdOiB1dHhvc1swXVswXS50eElkLmhleCB9O1xyXG4gICAgbmZ0UHJvZ3JhbS5wYXJhbWV0ZXJzID0geyBbXCJUWF9JRFhcIl06IHV0eG9zWzBdWzBdLnV0eG9JZHggfTtcclxuICAgIG5mdFByb2dyYW0ucGFyYW1ldGVycyA9IHsgW1wiVE5cIl06IG5hbWUgfTtcclxuXHJcbiAgICAvLyBDb21waWxlIHRoZSBoZWxpb3MgbWludGluZyBzY3JpcHRcclxuICAgIGNvbnN0IG5mdENvbXBpbGVkUHJvZ3JhbSA9IG5mdFByb2dyYW0uY29tcGlsZShvcHRpbWl6ZSk7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBzY3JpcHQgYXMgYSB3aXRuZXNzIHRvIHRoZSB0cmFuc2FjdGlvblxyXG4gICAgdHguYXR0YWNoU2NyaXB0KG5mdENvbXBpbGVkUHJvZ3JhbSk7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSBORlQgdGhhdCB3ZSB3aWxsIHdhbnQgdG8gc2VuZCBhcyBhbiBvdXRwdXRcclxuICAgIGNvbnN0IG5mdFRva2VuTmFtZSA9IEJ5dGVBcnJheURhdGEuZnJvbVN0cmluZyhuYW1lKS50b0hleCgpO1xyXG4gICAgY29uc3QgdG9rZW5zOiBbbnVtYmVyW10sIGJpZ2ludF1bXSA9IFtcclxuICAgICAgW2hleFRvQnl0ZXMobmZ0VG9rZW5OYW1lKSwgQmlnSW50KDEpXSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGFuIGVtcHR5IFJlZGVlbWVyIGJlY2F1c2Ugd2UgbXVzdCBhbHdheXMgc2VuZCBhIFJlZGVlbWVyIHdpdGhcclxuICAgIC8vIGEgcGx1dHVzIHNjcmlwdCB0cmFuc2FjdGlvbiBldmVuIGlmIHdlIGRvbid0IGFjdHVhbGx5IHVzZSBpdC5cclxuICAgIGNvbnN0IG1pbnRSZWRlZW1lciA9IG5ldyBDb25zdHJEYXRhKDAsIFtdKTtcclxuXHJcbiAgICAvLyBJbmRpY2F0ZSB0aGUgbWludGluZyB3ZSB3YW50IHRvIGluY2x1ZGUgYXMgcGFydCBvZiB0aGlzIHRyYW5zYWN0aW9uXHJcbiAgICB0eC5taW50VG9rZW5zKG5mdENvbXBpbGVkUHJvZ3JhbS5taW50aW5nUG9saWN5SGFzaCwgdG9rZW5zLCBtaW50UmVkZWVtZXIpO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdCB0aGUgb3V0cHV0IGFuZCBpbmNsdWRlIGJvdGggdGhlIG1pbmltdW0gQWRhIGFzIHdlbGwgYXMgdGhlIG1pbnRlZCBORlRcclxuICAgIHR4LmFkZE91dHB1dChcclxuICAgICAgbmV3IFR4T3V0cHV0KFxyXG4gICAgICAgIEFkZHJlc3MuZnJvbUJlY2gzMihhZGRyZXNzKSxcclxuICAgICAgICBuZXcgVmFsdWUoXHJcbiAgICAgICAgICBtaW5BZGFWYWwubG92ZWxhY2UsXHJcbiAgICAgICAgICBuZXcgQXNzZXRzKFtbbmZ0Q29tcGlsZWRQcm9ncmFtLm1pbnRpbmdQb2xpY3lIYXNoLCB0b2tlbnNdXSlcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbmV0d29ya1BhcmFtcyA9IG5ldyBOZXR3b3JrUGFyYW1zKFxyXG4gICAgICBhd2FpdCBmZXRjaChuZXR3b3JrUGFyYW1zVXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBdHRhY2hlZCB0aGUgbWV0YWRhdGEgZm9yIHRoZSBtaW50aW5nIHRyYW5zYWN0aW9uXHJcbiAgICB0eC5hZGRNZXRhZGF0YSg3MjEsIHtcclxuICAgICAgbWFwOiBbXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgbmZ0Q29tcGlsZWRQcm9ncmFtLm1pbnRpbmdQb2xpY3lIYXNoLmhleCxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbWFwOiBbXHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgbWFwOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgW1wibmFtZVwiLCBuYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICBbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wiaW1hZ2VcIiwgaW1nXSxcclxuICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgXSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwidHggYmVmb3JlIGZpbmFsXCIsIHR4LmR1bXAoKSk7XHJcblxyXG4gICAgLy8gU2VuZCBhbnkgY2hhbmdlIGJhY2sgdG8gdGhlIGJ1eWVyXHJcbiAgICBhd2FpdCB0eC5maW5hbGl6ZShuZXR3b3JrUGFyYW1zLCBjaGFuZ2VBZGRyLCB1dHhvc1sxXSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJWZXJpZnlpbmcgc2lnbmF0dXJlLi4uXCIpO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IGF3YWl0IHdhbGxldEFQSS5zaWduVHgodHgpO1xyXG4gICAgdHguYWRkU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcInR4IGFmdGVyIGZpbmFsXCIsIHR4LmR1bXAoKSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRpbmcgdHJhbnNhY3Rpb24uLi5cIik7XHJcbiAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXRBUEkuc3VibWl0VHgodHgpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwidHhIYXNoXCIsIHR4SGFzaC5oZXgpO1xyXG4gICAgc2V0VHgoeyB0eElkOiB0eEhhc2guaGV4IH0pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICAvLyA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XHJcbiAgICAvLyAgIDxIZWFkPlxyXG4gICAgLy8gICAgIDx0aXRsZT5DYXJkYW5vIEF0aGxldGljcyBORlQgQ3JlYXRvcjwvdGl0bGU+XHJcbiAgICAvLyAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD1cIkNhcmRhbm8gQXRobGV0aWNzIE5GVCBDcmVhdG9yXCIgLz5cclxuICAgIC8vICAgICA8bGluayByZWw9XCJpY29uXCIgaHJlZj1cIi9mYXZpY29uLmljb1wiIC8+XHJcbiAgICAvLyAgIDwvSGVhZD5cclxuXHJcbiAgICAvLyAgIDxtYWluIGNsYXNzTmFtZT17c3R5bGVzLm1haW59PlxyXG4gICAgLy8gICAgIDxoMyBjbGFzc05hbWU9e3N0eWxlcy50aXRsZX0+Q2FyZGFubyBBdGhsZXRpY3MgTkZUIENyZWF0b3I8L2gzPlxyXG5cclxuICAgIC8vICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvcmRlcndhbGxldH0+XHJcbiAgICAvLyAgICAgICA8cD5Db25uZWN0IHRvIHlvdXIgd2FsbGV0PC9wPlxyXG4gICAgLy8gICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuYm9yZGVyd2FsbGV0fT5cclxuICAgIC8vICAgICAgICAgPGlucHV0XHJcbiAgICAvLyAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcclxuICAgIC8vICAgICAgICAgICBpZD1cIm5hbWlcIlxyXG4gICAgLy8gICAgICAgICAgIG5hbWU9XCJ3YWxsZXRcIlxyXG4gICAgLy8gICAgICAgICAgIHZhbHVlPVwibmFtaVwiXHJcbiAgICAvLyAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVdhbGxldFNlbGVjdH1cclxuICAgIC8vICAgICAgICAgLz5cclxuICAgIC8vICAgICAgICAgPGxhYmVsPk5hbWk8L2xhYmVsPlxyXG4gICAgLy8gICAgICAgPC9wPlxyXG4gICAgLy8gICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuYm9yZGVyd2FsbGV0fT5cclxuICAgIC8vICAgICAgICAgPGlucHV0XHJcbiAgICAvLyAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcclxuICAgIC8vICAgICAgICAgICBpZD1cImV0ZXJubFwiXHJcbiAgICAvLyAgICAgICAgICAgbmFtZT1cIndhbGxldFwiXHJcbiAgICAvLyAgICAgICAgICAgdmFsdWU9XCJldGVybmxcIlxyXG4gICAgLy8gICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVXYWxsZXRTZWxlY3R9XHJcbiAgICAvLyAgICAgICAgIC8+XHJcbiAgICAvLyAgICAgICAgIDxsYWJlbD5FdGVybmw8L2xhYmVsPlxyXG4gICAgLy8gICAgICAgPC9wPlxyXG4gICAgLy8gICAgIDwvZGl2PlxyXG4gICAgLy8gICAgIHshdHgudHhJZCAmJiB3YWxsZXRJc0VuYWJsZWQgJiYgKFxyXG4gICAgLy8gICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3JkZXJ9PlxyXG4gICAgLy8gICAgICAgICA8V2FsbGV0SW5mbyB3YWxsZXRJbmZvPXt3YWxsZXRJbmZvfSAvPlxyXG4gICAgLy8gICAgICAgPC9kaXY+XHJcbiAgICAvLyAgICAgKX1cclxuICAgIC8vICAgICB7dHgudHhJZCAmJiAoXHJcbiAgICAvLyAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvcmRlcn0+XHJcbiAgICAvLyAgICAgICAgIDxiPlRyYW5zYWN0aW9uIFN1Y2Nlc3MhISE8L2I+XHJcbiAgICAvLyAgICAgICAgIDxwPlxyXG4gICAgLy8gICAgICAgICAgIFR4SWQgJm5ic3A7Jm5ic3A7XHJcbiAgICAvLyAgICAgICAgICAgPGFcclxuICAgIC8vICAgICAgICAgICAgIGhyZWY9e1wiaHR0cHM6Ly9wcmV2aWV3LmNleHBsb3Jlci5pby90eC9cIiArIHR4LnR4SWR9XHJcbiAgICAvLyAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxyXG4gICAgLy8gICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXHJcbiAgICAvLyAgICAgICAgICAgPlxyXG4gICAgLy8gICAgICAgICAgICAge3R4LnR4SWR9XHJcbiAgICAvLyAgICAgICAgICAgPC9hPlxyXG4gICAgLy8gICAgICAgICA8L3A+XHJcbiAgICAvLyAgICAgICAgIDxwPlxyXG4gICAgLy8gICAgICAgICAgIFBsZWFzZSB3YWl0IHVudGlsIHRoZSB0cmFuc2FjdGlvbiBpcyBjb25maXJtZWQgb24gdGhlIGJsb2NrY2hhaW5cclxuICAgIC8vICAgICAgICAgICBhbmQgcmVsb2FkIHRoaXMgcGFnZSBiZWZvcmUgZG9pbmcgYW5vdGhlciB0cmFuc2FjdGlvblxyXG4gICAgLy8gICAgICAgICA8L3A+XHJcbiAgICAvLyAgICAgICA8L2Rpdj5cclxuICAgIC8vICAgICApfVxyXG4gICAgLy8gICAgIHt3YWxsZXRJc0VuYWJsZWQgJiYgIXR4LnR4SWQgJiYgKFxyXG4gICAgLy8gICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5ib3JkZXJ9PlxyXG4gICAgLy8gICAgICAgICA8TWludE5GVCBvbk1pbnRORlQ9e21pbnRORlR9IC8+XHJcbiAgICAvLyAgICAgICA8L2Rpdj5cclxuICAgIC8vICAgICApfVxyXG4gICAgLy8gICAgIHsvKiBZb3VyIHBlcm1hbmVudCBiYWNrIGJ1dHRvbiAqL31cclxuICAgIC8vICAgICA8YSBocmVmPVwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIgY2xhc3NOYW1lPXtzdHlsZXMuYmFja0J1dHRvbn0+XHJcbiAgICAvLyAgICAgICBHbyBCYWNrXHJcbiAgICAvLyAgICAgPC9hPlxyXG4gICAgLy8gICA8L21haW4+XHJcblxyXG4gICAgLy8gICA8Zm9vdGVyIGNsYXNzTmFtZT17c3R5bGVzLmZvb3Rlcn0+PC9mb290ZXI+XHJcbiAgICAvLyA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPHRpdGxlPkNhcmRhbm8gQXRobGV0aWNzIE5GVCBDcmVhdG9yPC90aXRsZT5cclxuICAgICAgICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PVwiQ2FyZGFubyBBdGhsZXRpY3MgTkZUIENyZWF0b3JcIiAvPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cclxuICAgICAgPC9IZWFkPlxyXG5cclxuICAgICAgPG1haW4gY2xhc3NOYW1lPXtzdHlsZXMubWFpbn0+XHJcbiAgICAgICAgPGgzIGNsYXNzTmFtZT17c3R5bGVzLnRpdGxlfT5DYXJkYW5vIEF0aGxldGljcyBORlQgQ3JlYXRvcjwvaDM+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9yZGVyd2FsbGV0fT5cclxuICAgICAgICAgIDxwPkNvbm5lY3QgdG8geW91ciB3YWxsZXQ8L3A+XHJcbiAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5ib3JkZXJ3YWxsZXR9PlxyXG4gICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxyXG4gICAgICAgICAgICAgIGlkPVwibmFtaVwiXHJcbiAgICAgICAgICAgICAgbmFtZT1cIndhbGxldFwiXHJcbiAgICAgICAgICAgICAgdmFsdWU9XCJuYW1pXCJcclxuICAgICAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlV2FsbGV0U2VsZWN0fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+TmFtaTwvbGFiZWw+XHJcbiAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5ib3JkZXJ3YWxsZXR9PlxyXG4gICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxyXG4gICAgICAgICAgICAgIGlkPVwiZXRlcm5sXCJcclxuICAgICAgICAgICAgICBuYW1lPVwid2FsbGV0XCJcclxuICAgICAgICAgICAgICB2YWx1ZT1cImV0ZXJubFwiXHJcbiAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZVdhbGxldFNlbGVjdH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPGxhYmVsPkV0ZXJubDwvbGFiZWw+XHJcbiAgICAgICAgICA8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgeyF0eC50eElkICYmIHdhbGxldElzRW5hYmxlZCAmJiAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJvcmRlcn0+XHJcbiAgICAgICAgICAgIDxXYWxsZXRJbmZvIHdhbGxldEluZm89e3dhbGxldEluZm99IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG4gICAgICAgIHt0eC50eElkICYmIChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9yZGVyfT5cclxuICAgICAgICAgICAgPGI+VHJhbnNhY3Rpb24gU3VjY2VzcyEhITwvYj5cclxuICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgVHhJZCAmbmJzcDsmbmJzcDtcclxuICAgICAgICAgICAgICA8YVxyXG4gICAgICAgICAgICAgICAgaHJlZj17XCJodHRwczovL3ByZXByb2QuY2FyZGFub3NjYW4uaW8vdHJhbnNhY3Rpb24vXCIgKyB0eC50eElkfVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcclxuICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIHt0eC50eElkfVxyXG4gICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICBQbGVhc2Ugd2FpdCB1bnRpbCB0aGUgdHJhbnNhY3Rpb24gaXMgY29uZmlybWVkIG9uIHRoZSBibG9ja2NoYWluXHJcbiAgICAgICAgICAgICAgYW5kIHJlbG9hZCB0aGlzIHBhZ2UgYmVmb3JlIGRvaW5nIGFub3RoZXIgdHJhbnNhY3Rpb25cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7d2FsbGV0SXNFbmFibGVkICYmICF0eC50eElkICYmIChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuYm9yZGVyfT5cclxuICAgICAgICAgICAgPE1pbnRORlQgb25NaW50TkZUPXttaW50TkZUfSAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKX1cclxuICAgICAgICB7LyogWW91ciBwZXJtYW5lbnQgYmFjayBidXR0b24gKi99XHJcbiAgICAgICAgPGEgaHJlZj1cImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiIGNsYXNzTmFtZT17c3R5bGVzLmJhY2tCdXR0b259PlxyXG4gICAgICAgICAgR28gQmFja1xyXG4gICAgICAgIDwvYT5cclxuICAgICAgPC9tYWluPlxyXG5cclxuICAgICAgPGZvb3RlciBjbGFzc05hbWU9e3N0eWxlcy5mb290ZXJ9PjwvZm9vdGVyPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvbWU7XHJcbiJdLCJuYW1lcyI6WyJIZWFkIiwiTWludE5GVCIsInN0eWxlcyIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiV2FsbGV0SW5mbyIsIlByb2dyYW0iLCJBc3NldHMiLCJBZGRyZXNzIiwiQnl0ZUFycmF5RGF0YSIsIkNpcDMwV2FsbGV0IiwiQ29uc3RyRGF0YSIsImhleFRvQnl0ZXMiLCJOZXR3b3JrUGFyYW1zIiwiVmFsdWUiLCJUeE91dHB1dCIsIlR4IiwiV2FsbGV0SGVscGVyIiwiSG9tZSIsIm9wdGltaXplIiwibmV0d29ya1BhcmFtc1VybCIsIndhbGxldEluZm8iLCJzZXRXYWxsZXRJbmZvIiwiYmFsYW5jZSIsIndhbGxldElzRW5hYmxlZCIsInNldFdhbGxldElzRW5hYmxlZCIsIndoaWNoV2FsbGV0U2VsZWN0ZWQiLCJzZXRXaGljaFdhbGxldFNlbGVjdGVkIiwidW5kZWZpbmVkIiwid2FsbGV0QVBJIiwic2V0V2FsbGV0QVBJIiwid2FsbGV0SGVscGVyIiwic2V0V2FsbGV0SGVscGVyIiwidHgiLCJzZXRUeCIsInR4SWQiLCJjaGVja1dhbGxldCIsImNoZWNrSWZXYWxsZXRGb3VuZCIsImVuYWJsZVNlbGVjdGVkV2FsbGV0IiwiZW5hYmxlV2FsbGV0IiwidXBkYXRlV2FsbGV0SW5mbyIsIl9iYWxhbmNlIiwiZ2V0QmFsYW5jZSIsImhhbmRsZVdhbGxldFNlbGVjdCIsIm9iaiIsInRhcmdldCIsInZhbHVlIiwid2FsbGV0Rm91bmQiLCJ3YWxsZXRDaG9pY2UiLCJ3aW5kb3ciLCJjYXJkYW5vIiwibmFtaSIsImV0ZXJubCIsImhhbmRsZSIsImVuYWJsZSIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJiYWxhbmNlQW1vdW50VmFsdWUiLCJjYWxjQmFsYW5jZSIsImJhbGFuY2VBbW91bnQiLCJsb3ZlbGFjZSIsIndhbGxldEJhbGFuY2UiLCJCaWdJbnQiLCJ0b0xvY2FsZVN0cmluZyIsIm1pbnRORlQiLCJwYXJhbXMiLCJhZGRyZXNzIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiaW1nIiwibWluQWRhIiwibWF4VHhGZWUiLCJtaW5DaGFuZ2VBbXQiLCJtaW5BZGFWYWwiLCJtaW5VVFhPVmFsIiwidXR4b3MiLCJwaWNrVXR4b3MiLCJjaGFuZ2VBZGRyIiwiY2hhbmdlQWRkcmVzcyIsImFkZElucHV0cyIsIm5mdFByb2dyYW0iLCJwYXJhbWV0ZXJzIiwiaGV4IiwidXR4b0lkeCIsIm5mdENvbXBpbGVkUHJvZ3JhbSIsImNvbXBpbGUiLCJhdHRhY2hTY3JpcHQiLCJuZnRUb2tlbk5hbWUiLCJmcm9tU3RyaW5nIiwidG9IZXgiLCJ0b2tlbnMiLCJtaW50UmVkZWVtZXIiLCJtaW50VG9rZW5zIiwibWludGluZ1BvbGljeUhhc2giLCJhZGRPdXRwdXQiLCJmcm9tQmVjaDMyIiwibmV0d29ya1BhcmFtcyIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImFkZE1ldGFkYXRhIiwibWFwIiwiZHVtcCIsImZpbmFsaXplIiwic2lnbmF0dXJlcyIsInNpZ25UeCIsImFkZFNpZ25hdHVyZXMiLCJ0eEhhc2giLCJzdWJtaXRUeCIsImRpdiIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsInRpdGxlIiwibWV0YSIsImNvbnRlbnQiLCJsaW5rIiwicmVsIiwiaHJlZiIsIm1haW4iLCJoMyIsImJvcmRlcndhbGxldCIsInAiLCJpbnB1dCIsInR5cGUiLCJpZCIsIm9uQ2hhbmdlIiwibGFiZWwiLCJib3JkZXIiLCJiIiwiYSIsIm9uTWludE5GVCIsImJhY2tCdXR0b24iLCJmb290ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/@hyperionbt/helios/helios.js":
/*!***************************************************!*\
  !*** ./node_modules/@hyperionbt/helios/helios.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Address\": function() { return /* binding */ Address; },\n/* harmony export */   \"AssetClass\": function() { return /* binding */ AssetClass; },\n/* harmony export */   \"Assets\": function() { return /* binding */ Assets; },\n/* harmony export */   \"BlockfrostV0\": function() { return /* binding */ BlockfrostV0; },\n/* harmony export */   \"Bool\": function() { return /* binding */ Bool; },\n/* harmony export */   \"ByteArray\": function() { return /* binding */ ByteArray; },\n/* harmony export */   \"ByteArrayData\": function() { return /* binding */ ByteArrayData; },\n/* harmony export */   \"CborData\": function() { return /* binding */ CborData; },\n/* harmony export */   \"Cip30Wallet\": function() { return /* binding */ Cip30Wallet; },\n/* harmony export */   \"CoinSelection\": function() { return /* binding */ CoinSelection; },\n/* harmony export */   \"ConstrData\": function() { return /* binding */ ConstrData; },\n/* harmony export */   \"Crypto\": function() { return /* binding */ Crypto; },\n/* harmony export */   \"DEFAULT_UPLC_RTE_CALLBACKS\": function() { return /* binding */ DEFAULT_UPLC_RTE_CALLBACKS; },\n/* harmony export */   \"Datum\": function() { return /* binding */ Datum; },\n/* harmony export */   \"DatumHash\": function() { return /* binding */ DatumHash; },\n/* harmony export */   \"Duration\": function() { return /* binding */ Duration; },\n/* harmony export */   \"FuzzyTest\": function() { return /* binding */ FuzzyTest; },\n/* harmony export */   \"HInt\": function() { return /* binding */ HInt; },\n/* harmony export */   \"HList\": function() { return /* binding */ HList; },\n/* harmony export */   \"HMap\": function() { return /* binding */ HMap; },\n/* harmony export */   \"HString\": function() { return /* binding */ HString; },\n/* harmony export */   \"HashedDatum\": function() { return /* binding */ HashedDatum; },\n/* harmony export */   \"HeliosData\": function() { return /* binding */ HeliosData; },\n/* harmony export */   \"IRAnonCallExpr\": function() { return /* binding */ IRAnonCallExpr; },\n/* harmony export */   \"IRExprRegistry\": function() { return /* binding */ IRExprRegistry; },\n/* harmony export */   \"IRFuncDefExpr\": function() { return /* binding */ IRFuncDefExpr; },\n/* harmony export */   \"IRNameExprRegistry\": function() { return /* binding */ IRNameExprRegistry; },\n/* harmony export */   \"IRNestedAnonCallExpr\": function() { return /* binding */ IRNestedAnonCallExpr; },\n/* harmony export */   \"IRParametricProgram\": function() { return /* binding */ IRParametricProgram; },\n/* harmony export */   \"IntData\": function() { return /* binding */ IntData; },\n/* harmony export */   \"ListData\": function() { return /* binding */ ListData; },\n/* harmony export */   \"MapData\": function() { return /* binding */ MapData; },\n/* harmony export */   \"MintingPolicyHash\": function() { return /* binding */ MintingPolicyHash; },\n/* harmony export */   \"NetworkEmulator\": function() { return /* binding */ NetworkEmulator; },\n/* harmony export */   \"NetworkParams\": function() { return /* binding */ NetworkParams; },\n/* harmony export */   \"Option\": function() { return /* binding */ Option; },\n/* harmony export */   \"Program\": function() { return /* binding */ Program; },\n/* harmony export */   \"PubKeyHash\": function() { return /* binding */ PubKeyHash; },\n/* harmony export */   \"ScriptHash\": function() { return /* binding */ ScriptHash; },\n/* harmony export */   \"Signature\": function() { return /* binding */ Signature; },\n/* harmony export */   \"Source\": function() { return /* binding */ Source; },\n/* harmony export */   \"StakeAddress\": function() { return /* binding */ StakeAddress; },\n/* harmony export */   \"StakeKeyHash\": function() { return /* binding */ StakeKeyHash; },\n/* harmony export */   \"StakingValidatorHash\": function() { return /* binding */ StakingValidatorHash; },\n/* harmony export */   \"Time\": function() { return /* binding */ Time; },\n/* harmony export */   \"TimeType\": function() { return /* binding */ TimeType; },\n/* harmony export */   \"Token\": function() { return /* binding */ Token; },\n/* harmony export */   \"Tokenizer\": function() { return /* binding */ Tokenizer; },\n/* harmony export */   \"Tx\": function() { return /* binding */ Tx; },\n/* harmony export */   \"TxId\": function() { return /* binding */ TxId; },\n/* harmony export */   \"TxOutput\": function() { return /* binding */ TxOutput; },\n/* harmony export */   \"TxOutputId\": function() { return /* binding */ TxOutputId; },\n/* harmony export */   \"TxRefInput\": function() { return /* binding */ TxRefInput; },\n/* harmony export */   \"TxWitnesses\": function() { return /* binding */ TxWitnesses; },\n/* harmony export */   \"UTxO\": function() { return /* binding */ UTxO; },\n/* harmony export */   \"UplcBool\": function() { return /* binding */ UplcBool; },\n/* harmony export */   \"UplcByteArray\": function() { return /* binding */ UplcByteArray; },\n/* harmony export */   \"UplcData\": function() { return /* binding */ UplcData; },\n/* harmony export */   \"UplcDataValue\": function() { return /* binding */ UplcDataValue; },\n/* harmony export */   \"UplcInt\": function() { return /* binding */ UplcInt; },\n/* harmony export */   \"UplcList\": function() { return /* binding */ UplcList; },\n/* harmony export */   \"UplcPair\": function() { return /* binding */ UplcPair; },\n/* harmony export */   \"UplcProgram\": function() { return /* binding */ UplcProgram; },\n/* harmony export */   \"UplcString\": function() { return /* binding */ UplcString; },\n/* harmony export */   \"UplcType\": function() { return /* binding */ UplcType; },\n/* harmony export */   \"UplcUnit\": function() { return /* binding */ UplcUnit; },\n/* harmony export */   \"UplcValue\": function() { return /* binding */ UplcValue; },\n/* harmony export */   \"UserError\": function() { return /* binding */ UserError; },\n/* harmony export */   \"VERSION\": function() { return /* binding */ VERSION; },\n/* harmony export */   \"ValidatorHash\": function() { return /* binding */ ValidatorHash; },\n/* harmony export */   \"Value\": function() { return /* binding */ Value; },\n/* harmony export */   \"WalletEmulator\": function() { return /* binding */ WalletEmulator; },\n/* harmony export */   \"WalletHelper\": function() { return /* binding */ WalletHelper; },\n/* harmony export */   \"buildScript\": function() { return /* binding */ buildScript; },\n/* harmony export */   \"bytesToHex\": function() { return /* binding */ bytesToHex; },\n/* harmony export */   \"bytesToText\": function() { return /* binding */ bytesToText; },\n/* harmony export */   \"config\": function() { return /* binding */ config; },\n/* harmony export */   \"deserializeUplc\": function() { return /* binding */ deserializeUplc; },\n/* harmony export */   \"deserializeUplcBytes\": function() { return /* binding */ deserializeUplcBytes; },\n/* harmony export */   \"exportedForTesting\": function() { return /* binding */ exportedForTesting; },\n/* harmony export */   \"extractScriptPurposeAndName\": function() { return /* binding */ extractScriptPurposeAndName; },\n/* harmony export */   \"findUplcBuiltin\": function() { return /* binding */ findUplcBuiltin; },\n/* harmony export */   \"hexToBytes\": function() { return /* binding */ hexToBytes; },\n/* harmony export */   \"highlight\": function() { return /* binding */ highlight; },\n/* harmony export */   \"hl\": function() { return /* binding */ hl; },\n/* harmony export */   \"isUplcBuiltin\": function() { return /* binding */ isUplcBuiltin; },\n/* harmony export */   \"reduceNullPairs\": function() { return /* binding */ reduceNullPairs; },\n/* harmony export */   \"setImportPathTranslator\": function() { return /* binding */ setImportPathTranslator; },\n/* harmony export */   \"textToBytes\": function() { return /* binding */ textToBytes; },\n/* harmony export */   \"tokenize\": function() { return /* binding */ tokenize; }\n/* harmony export */ });\n//@ts-check\n//////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////      Helios      /////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// Author:        Christian Schmitz\n// Email:         cschmitz398@gmail.com\n// Website:       https://www.hyperion-bt.org\n// Repository:    https://github.com/hyperion-bt/helios\n// Version:       0.13.28\n// Last update:   April 2023\n// License type:  BSD-3-Clause\n//\n//\n// About: Helios is a smart contract DSL for Cardano.\n//     This Javascript library contains functions to compile Helios sources into Plutus-core.\n//     Transactions can also be built using Helios.\n//\n//\n// Dependencies: none\n//\n//\n// Disclaimer: I made Helios available as FOSS so that the Cardano community can test it \n//     extensively. I don't guarantee the library is bug-free, nor do I guarantee\n//     backward compatibility with future versions.\n//\n//\n// Example usage:\n//     > import * as helios from \"helios.js\";\n//     > console.log(helios.Program.new(\"spending my_validator ...\").compile().serialize());\n//     \n//\n// Documentation: https://www.hyperion-bt.org/helios-book\n//\n//\n// Note: I recommend keeping the Helios library as a single unminified file for optimal \n//     auditability.\n//\n// \n// License text:\n//     Copyright 2023 Christian Schmitz\n//     \n//     Redistribution and use in source and binary forms, with or without \n//     modification, are permitted provided that the following conditions are met:\n//     \n//     1. Redistributions of source code must retain the above copyright notice, this \n//     list of conditions and the following disclaimer.\n//     \n//     2. Redistributions in binary form must reproduce the above copyright notice, \n//     this list of conditions and the following disclaimer in the documentation \n//     and/or other materials provided with the distribution.\n//     \n//     3. Neither the name of the copyright holder nor the names of its contributors \n//     may be used to endorse or promote products derived from this software without \n//     specific prior written permission.\n//     \n//     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” \n//     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n//     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n//     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE \n//     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \n//     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n//     SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \n//     CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, \n//     OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n//     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//     \n//\n//\n// Overview of internals:\n//     Section 1: Config                     VERSION, TAB, config\n//\n//     Section 2: Utilities                  assert, assertDefined, assertClass, assertNumber, \n//                                           reduceNull, reduceNullPairs, eq, assertEq, idiv, \n//                                           ipow2, imask, imod8, bigIntToBytes, bytesToBigInt, \n//                                           padZeroes, byteToBitString, hexToBytes, bytesToHex, \n//                                           textToBytes, bytesToText, replaceTabs, BitReader, \n//                                           BitWriter, Source, hl, deprecationWarning\n//\n//     Section 3: Tokens                     Site, RuntimeError, Token, assertToken, Word, \n//                                           SymbolToken, Group, PrimitiveLiteral, IntLiteral, \n//                                           BoolLiteral, ByteArrayLiteral, StringLiteral\n//\n//     Section 4: Cryptography functions     BLAKE2B_DIGEST_SIZE, setBlake2bDigestSize, imod32, \n//                                           irotr, posMod, UInt64, Crypto\n//\n//     Section 5: Cbor encoder/decoder       CborData\n//\n//     Section 6: Uplc data types            UPLC_DATA_NODE_MEM_SIZE, UplcData, IntData, \n//                                           ByteArrayData, ListData, MapData, ConstrData\n//\n//     Section 7: Helios data objects        HeliosData, HInt, Time, Duration, Bool, HString, \n//                                           ByteArray, HList, HMap, Option, Hash, DatumHash, \n//                                           PubKeyHash, ScriptHash, MintingPolicyHash, \n//                                           StakeKeyHash, StakingValidatorHash, ValidatorHash, \n//                                           TxId, TxOutputId, Address, AssetClass, Assets, Value\n//\n//     Section 8: Uplc cost-models           NetworkParams, CostModel, ConstCost, LinearCost, \n//                                           ArgSizeCost, Arg0SizeCost, Arg1SizeCost, \n//                                           Arg2SizeCost, MinArgSizeCost, MaxArgSizeCost, \n//                                           SumArgSizesCost, ArgSizeDiffCost, ArgSizeProdCost, \n//                                           ArgSizeDiagCost\n//\n//     Section 9: Uplc built-in functions    UPLC_BUILTINS, dumpCostModels, findUplcBuiltin, \n//                                           isUplcBuiltin\n//\n//     Section 10: Uplc AST                  ScriptPurpose, getPurposeName, UplcValue, UplcType, \n//                                           DEFAULT_UPLC_RTE_CALLBACKS, UplcRte, UplcStack, \n//                                           UplcAnon, UplcDelayedValue, UplcInt, UplcByteArray, \n//                                           UplcString, UplcUnit, UplcBool, UplcPair, UplcList, \n//                                           UplcDataValue, UplcTerm, UplcVariable, UplcDelay, \n//                                           UplcLambda, UplcCall, UplcConst, UplcForce, \n//                                           UplcError, UplcBuiltin\n//\n//     Section 11: Uplc program              UPLC_VERSION_COMPONENTS, UPLC_VERSION, \n//                                           PLUTUS_SCRIPT_VERSION, deserializeUplcBytes, \n//                                           deserializeUplc\n//\n//     Section 12: Tokenization              Tokenizer, tokenize, tokenizeIR\n//\n//     Section 13: Helios eval entities      EvalEntity, Type, AnyType, DataType, AnyDataType, \n//                                           BuiltinType, BuiltinEnumMember, StatementType, \n//                                           StructStatementType, EnumStatementType, \n//                                           EnumMemberStatementType, ArgType, FuncType, NotType, \n//                                           Instance, DataInstance, ConstStatementInstance, \n//                                           FuncInstance, FuncStatementInstance, MultiInstance, \n//                                           VoidInstance, ErrorInstance, BuiltinFuncInstance, \n//                                           PrintFunc, VoidType, ErrorType, IntType, BoolType, \n//                                           StringType, ByteArrayType, ParamType, ParamFuncValue, \n//                                           ListType, MapType, OptionType, OptionSomeType, \n//                                           OptionNoneType, HashType, PubKeyHashType, \n//                                           StakeKeyHashType, PubKeyType, ScriptHashType, \n//                                           ValidatorHashType, MintingPolicyHashType, \n//                                           StakingValidatorHashType, DatumHashType, \n//                                           ScriptContextType, ScriptPurposeType, \n//                                           MintingScriptPurposeType, SpendingScriptPurposeType, \n//                                           RewardingScriptPurposeType, \n//                                           CertifyingScriptPurposeType, StakingPurposeType, \n//                                           StakingRewardingPurposeType, \n//                                           StakingCertifyingPurposeType, DCertType, \n//                                           RegisterDCertType, DeregisterDCertType, \n//                                           DelegateDCertType, RegisterPoolDCertType, \n//                                           RetirePoolDCertType, TxType, TxIdType, TxInputType, \n//                                           TxOutputType, OutputDatumType, NoOutputDatumType, \n//                                           HashedOutputDatumType, InlineOutputDatumType, \n//                                           RawDataType, TxOutputIdType, AddressType, \n//                                           CredentialType, CredentialPubKeyType, \n//                                           CredentialValidatorType, StakingHashType, \n//                                           StakingHashStakeKeyType, StakingHashValidatorType, \n//                                           StakingCredentialType, StakingHashCredentialType, \n//                                           StakingPtrCredentialType, TimeType, DurationType, \n//                                           TimeRangeType, AssetClassType, ValueType\n//\n//     Section 14: Scopes                    GlobalScope, Scope, TopScope, ModuleScope, \n//                                           FuncStatementScope\n//\n//     Section 15: Helios AST expressions    Expr, TypeExpr, TypeRefExpr, TypePathExpr, \n//                                           ListTypeExpr, MapTypeExpr, OptionTypeExpr, \n//                                           VoidTypeExpr, FuncArgTypeExpr, FuncTypeExpr, \n//                                           ValueExpr, AssignExpr, PrintExpr, VoidExpr, \n//                                           ChainExpr, PrimitiveLiteralExpr, LiteralDataExpr, \n//                                           StructLiteralField, StructLiteralExpr, \n//                                           ListLiteralExpr, MapLiteralExpr, NameTypePair, \n//                                           FuncArg, FuncLiteralExpr, ValueRefExpr, \n//                                           ValuePathExpr, UnaryExpr, BinaryExpr, ParensExpr, \n//                                           CallArgExpr, CallExpr, MemberExpr, IfElseExpr, \n//                                           DestructExpr, SwitchCase, UnconstrDataSwitchCase, \n//                                           SwitchDefault, SwitchExpr, EnumSwitchExpr, \n//                                           DataSwitchExpr\n//\n//     Section 16: Literal functions         buildLiteralExprFromJson, buildLiteralExprFromValue\n//\n//     Section 17: Helios AST statements     Statement, ImportStatement, ConstStatement, \n//                                           DataField, DataDefinition, StructStatement, \n//                                           FuncStatement, EnumMember, EnumStatement, \n//                                           ImplDefinition\n//\n//     Section 18: Helios AST building       AUTOMATIC_METHODS, importPathTranslator, \n//                                           setImportPathTranslator, buildProgramStatements, \n//                                           buildScriptPurpose, buildScript, \n//                                           extractScriptPurposeAndName, buildConstStatement, \n//                                           splitDataImpl, buildStructStatement, buildDataFields, \n//                                           buildFuncStatement, buildFuncLiteralExpr, \n//                                           buildFuncArgs, buildEnumStatement, \n//                                           buildImportStatements, buildEnumMember, \n//                                           buildImplDefinition, buildImplMembers, buildTypeExpr, \n//                                           buildListTypeExpr, buildMapTypeExpr, \n//                                           buildOptionTypeExpr, buildFuncTypeExpr, \n//                                           buildFuncArgTypeExpr, buildFuncRetTypeExprs, \n//                                           buildTypePathExpr, buildTypeRefExpr, buildValueExpr, \n//                                           buildMaybeAssignOrPrintExpr, buildDestructExpr, \n//                                           buildDestructExprs, buildAssignLhs, \n//                                           makeBinaryExprBuilder, makeUnaryExprBuilder, \n//                                           buildChainedValueExpr, buildCallExpr, \n//                                           buildChainStartValueExpr, buildParensExpr, \n//                                           buildCallArgs, buildCallArgExpr, buildIfElseExpr, \n//                                           buildSwitchExpr, buildSwitchCaseName, \n//                                           buildSwitchCase, buildSwitchCaseNameType, \n//                                           buildMultiArgSwitchCase, buildSingleArgSwitchCase, \n//                                           buildSwitchCaseBody, buildSwitchDefault, \n//                                           buildListLiteralExpr, buildMapLiteralExpr, \n//                                           buildStructLiteralExpr, buildStructLiteralField, \n//                                           buildStructLiteralNamedField, \n//                                           buildStructLiteralUnnamedField, buildValuePathExpr\n//\n//     Section 19: IR definitions            onNotifyRawUsage, setRawUsageNotifier, RawFunc, \n//                                           makeRawFunctions, wrapWithRawFunctions\n//\n//     Section 20: IR Context objects        IRScope, IRVariable, IRValue, IRFuncValue, \n//                                           IRLiteralValue, IRDeferredValue, IRCallStack\n//\n//     Section 21: IR AST objects            IRNameExprRegistry, IRExprRegistry, IRExpr, \n//                                           IRNameExpr, IRLiteralExpr, IRConstExpr, IRFuncExpr, \n//                                           IRCallExpr, IRCoreCallExpr, IRUserCallExpr, \n//                                           IRAnonCallExpr, IRNestedAnonCallExpr, IRFuncDefExpr, \n//                                           IRErrorCallExpr\n//\n//     Section 22: IR AST build functions    buildIRExpr, buildIRFuncExpr\n//\n//     Section 23: IR Program                IRProgram, IRParametricProgram\n//\n//     Section 24: Helios program            Module, MainModule, RedeemerProgram, \n//                                           DatumRedeemerProgram, TestingProgram, \n//                                           SpendingProgram, MintingProgram, StakingProgram\n//\n//     Section 25: Tx types                  Tx, TxBody, TxWitnesses, TxInput, UTxO, TxRefInput, \n//                                           TxOutput, DCert, StakeAddress, Signature, Redeemer, \n//                                           SpendingRedeemer, MintingRedeemer, Datum, \n//                                           HashedDatum, InlineDatum, encodeMetadata, \n//                                           decodeMetadata, TxMetadata\n//\n//     Section 26: Highlighting function     SyntaxCategory, highlight\n//\n//     Section 27: Fuzzy testing framework   FuzzyTest\n//\n//     Section 28: CoinSelection             CoinSelection\n//\n//     Section 29: Wallets                   Cip30Wallet, WalletHelper\n//\n//     Section 30: Network                   BlockfrostV0\n//\n//     Section 31: Emulator                  WalletEmulator, GenesisTx, RegularTx, NetworkEmulator\n//\n///////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////\n// Section 1: Config\n////////////////////\n\n/**\n * Version of the Helios library.\n */\nconst VERSION = \"0.13.28\";\n\n/**\n * A tab used for indenting of the IR.\n * 2 spaces.\n * @package\n * @type {string}\n */\nconst TAB = \"  \";\n\n/**\n * Modifiable config vars\n * @type {{\n *   DEBUG: boolean,\n *   STRICT_BABBAGE: boolean,\n *   IS_TESTNET: boolean,\n *   N_DUMMY_INPUTS: number\n * }}\n */\nconst config = {\n    /**\n     * Global debug flag. Not currently used for anything though.\n     */\n    DEBUG: false,\n\n    /**\n     * Set this to true if you want to experiment with transactions serialized using the strict babbage cddl format\n     */\n    STRICT_BABBAGE: false,\n\n    /**\n     * Set to false if using the library for mainnet (impacts Addresses)\n     */\n    IS_TESTNET: true,\n\n    /**\n     * Calculating the execution budget during tx building requires knowing all the inputs beforehand,\n     *   which is very difficult because balancing is done after the budget is calculated.\n     * Instead we use at least 1 dummy input, which should act as a representative balancing input.\n     * For increased robustness we use 2 dummy inputs, one with Txid 0 and other with TxId ffff...,\n     *   because eg. there are case where the TxId is being printed, and a Txid of ffff... would overestimate the fee\n     * This value must be '1' or '2'\n     */\n    N_DUMMY_INPUTS: 2\n}\n\n\n\n///////////////////////\n// Section 2: Utilities\n///////////////////////\n\n\n/**\n * Throws an error if 'cond' is false.\n * @package\n * @param {boolean} cond \n * @param {string} msg \n */\nfunction assert(cond, msg = \"unexpected\") {\n\tif (!cond) {\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * Throws an error if 'obj' is undefined. Returns 'obj' itself (for chained application).\n * @package\n * @template T\n * @param {T | undefined | null} obj \n * @param {string} msg \n * @returns {T}\n */\nfunction assertDefined(obj, msg = \"unexpected undefined value\") {\n\tif (obj === undefined || obj === null ) {\n\t\tthrow new Error(msg);\n\t}\n\n\treturn obj;\n}\n\n/**\n * @package\n * @template Tin, Tout\n * @param {Tin} obj\n * @param {{new(...any): Tout}} C\n * @returns {Tout}\n */\nfunction assertClass(obj, C, msg = \"unexpected class\") {\n\tif (obj instanceof C) {\n\t\treturn obj;\n\t} else {\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * @package\n * @param {any} obj \n * @param {string} msg \n * @returns {number}\n */\nfunction assertNumber(obj, msg = \"expected a number\") {\n\tif (obj === undefined || obj === null) {\n\t\tthrow new Error(msg);\n\t} else if (typeof obj == \"number\") {\n\t\treturn obj;\n\t} else {\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * @package\n * @template T\n * @param {(T | null)[]} lst\n * @returns {null | (T[])}\n */\nfunction reduceNull(lst) {\n\t/**\n\t * @type {T[]}\n\t */\n\tconst nonNullLst = [];\n\n\tlet someNull = false;\n\n\tlst.forEach(item => {\n\t\tif (item !== null && !someNull) {\n\t\t\tnonNullLst.push(item);\n\t\t} else {\n\t\t\tsomeNull = true;\n\t\t}\n\t});\n\n\tif (someNull) {\n\t\treturn null;\n\t} else {\n\t\treturn nonNullLst;\n\t}\n}\n\n/**\n * @template Ta\n * @template Tb\n * @param {[Ta | null, Tb | null][]} pairs\n * @returns {null | [Ta, Tb][]}\n */\nfunction reduceNullPairs(pairs) {\n\t/**\n\t * @type {[Ta, Tb][]}\n\t */\n\tconst nonNullPairs = [];\n\n\tlet someNull = false;\n\n\tpairs.forEach(([a, b]) => {\n\t\tif (a === null || b === null) {\n\t\t\tsomeNull = true;\n\t\t} else if (!someNull) {\n\t\t\tnonNullPairs.push([a, b]);\n\t\t}\n\t});\n\n\tif (someNull) {\n\t\treturn null;\n\t} else {\n\t\treturn nonNullPairs;\n\t}\n}\n\n/**\n * Compares two objects (deep recursive comparison)\n * @package\n * @template T\n * @param {T} a \n * @param {T} b \n * @returns {boolean}\n */\nfunction eq(a, b) {\n\tif (a === undefined || b === undefined) {\n\t\tthrow new Error(\"one of the args is undefined\");\n\t} else if (typeof a == \"string\") {\n\t\treturn a === b;\n\t} else if (typeof a == \"number\") {\n\t\treturn a === b;\n\t} else if (typeof a == \"boolean\") {\n\t\treturn a === b;\n\t} else if (typeof a == \"bigint\") {\n\t\treturn a === b;\n\t} else if (a instanceof Array && b instanceof Array) {\n\t\tif (a.length != b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (!eq(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t} else {\n\t\tthrow new Error(\"eq not yet implemented for these types\");\n\t}\n}\n\n/**\n * Throws an error if two object aren't equal (deep comparison).\n * Used by unit tests that are autogenerated from JSDoc inline examples.\n * @package\n * @template T\n * @param {T} a\n * @param {T} b\n * @param {string} msg\n */\nfunction assertEq(a, b, msg) {\n\tif (!eq(a, b)) {\n\t\tconsole.log(a);\n\t\tconsole.log(b);\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * Divides two integers. Assumes a and b are whole numbers. Rounds down the result.\n * @example\n * idiv(355, 113) => 3\n * @package\n * @param {number} a\n * @param {number} b \n */\nfunction idiv(a, b) {\n\treturn Math.floor(a / b);\n\t// alternatively: (a - a%b)/b\n}\n\n/**\n * 2 to the power 'p' for bigint.\n * @package\n * @param {bigint} p\n * @returns {bigint}\n */\nfunction ipow2(p) {\n\treturn (p <= 0n) ? 1n : 2n << (p - 1n);\n}\n\n/**\n * Masks bits of 'b' by setting bits outside the range ['i0', 'i1') to 0. \n * 'b' is an 8 bit integer (i.e. number between 0 and 255).\n * The return value is also an 8 bit integer, shift right by 'i1'.\n \n * @example\n * imask(0b11111111, 1, 4) => 0b0111 // (i.e. 7)\n * @package\n * @param {number} b \n * @param {number} i0 \n * @param {number} i1 \n * @returns {number}\n */\nfunction imask(b, i0, i1) {\n\tassert(i0 < i1);\n\n\tconst mask_bits = [\n\t\t0b11111111,\n\t\t0b01111111,\n\t\t0b00111111,\n\t\t0b00011111,\n\t\t0b00001111,\n\t\t0b00000111,\n\t\t0b00000011,\n\t\t0b00000001,\n\t];\n\n\treturn (b & mask_bits[i0]) >> (8 - i1);\n}\n\n/**\n * Make sure resulting number fits in uint8\n * @package\n * @param {number} x\n */\nfunction imod8(x) {\n\treturn x & 0xff;\n}\n\n/**\n * Converts an unbounded integer into a list of uint8 numbers (big endian)\n * Used by the CBOR encoding of data structures, and by Ed25519\n * @package\n * @param {bigint} x\n * @returns {number[]}\n */\nfunction bigIntToBytes(x) {\n\tif (x == 0n) {\n\t\treturn [0];\n\t} else {\n\t\t/**\n\t\t * @type {number[]}\n\t\t */\n\t\tconst res = [];\n\n\t\twhile (x > 0n) {\n\t\t\tres.unshift(Number(x%256n));\n\n\t\t\tx = x/256n;\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\n/**\n * Converts a list of uint8 numbers into an unbounded int (big endian)\n * Used by the CBOR decoding of data structures.\n * @package\n * @param {number[]} b\n * @return {bigint}\n */\nfunction bytesToBigInt(b) {\n\tlet s = 1n;\n\tlet total = 0n;\n\n\twhile (b.length > 0) {\n\t\ttotal += BigInt(assertDefined(b.pop()))*s;\n\n\t\ts *= 256n;\n\t}\n\n\treturn total;\n}\n\n/**\n * Prepends zeroes to a bit-string so that 'result.length == n'.\n * @example\n * padZeroes(\"1111\", 8) => \"00001111\"\n * @package\n * @param {string} bits\n * @param {number} n \n * @returns {string}\n */\nfunction padZeroes(bits, n) {\n\t// padded to multiple of n\n\tif (bits.length % n != 0) {\n\t\tconst nPad = n - bits.length % n;\n\n\t\tbits = (new Array(nPad)).fill('0').join('') + bits;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Converts a 8 bit integer number into a bit string with an optional \"0b\" prefix.\n * The result is padded with leading zeroes to become 'n' chars long ('2 + n' chars long if you count the \"0b\" prefix). \n * @example\n * byteToBitString(7) => \"0b00000111\"\n * @package\n * @param {number} b \n * @param {number} n\n * @param {boolean} prefix\n * @returns {string}\n */\nfunction byteToBitString(b, n = 8, prefix = true) {\n\tconst s = padZeroes(b.toString(2), n);\n\n\tif (prefix) {\n\t\treturn \"0b\" + s;\n\t} else {\n\t\treturn s;\n\t}\n}\n\n/**\n * Converts a hexadecimal representation of bytes into an actual list of uint8 bytes.\n * @example\n * hexToBytes(\"00ff34\") => [0, 255, 52] \n * @param {string} hex \n * @returns {number[]}\n */\nfunction hexToBytes(hex) {\n\thex = hex.trim();\n\t\n\tconst bytes = [];\n\n\tfor (let i = 0; i < hex.length; i += 2) {\n\t\tbytes.push(parseInt(hex.slice(i, i + 2), 16));\n\t}\n\n\treturn bytes;\n}\n\n/**\n * Converts a list of uint8 bytes into its hexadecimal string representation.\n * @example\n * bytesToHex([0, 255, 52]) => \"00ff34\"\n * @param {number[]} bytes\n * @returns {string}\n */\nfunction bytesToHex(bytes) {\n\tconst parts = [];\n\n\tfor (let b of bytes) {\n\t\tparts.push(padZeroes(b.toString(16), 2));\n\t}\n\n\treturn parts.join('');\n}\n\n/**\n * Encodes a string into a list of uint8 bytes using UTF-8 encoding.\n * @example\n * textToBytes(\"hello world\") => [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]\n * @param {string} str \n * @returns {number[]}\n */\nfunction textToBytes(str) {\n\treturn Array.from((new TextEncoder()).encode(str));\n}\n\n/**\n * Decodes a list of uint8 bytes into a string using UTF-8 encoding.\n * @example\n * bytesToText([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]) => \"hello world\"\n * @param {number[]} bytes \n * @returns {string}\n */\nfunction bytesToText(bytes) {\n\treturn (new TextDecoder(\"utf-8\", {fatal: true})).decode((new Uint8Array(bytes)).buffer);\n}\n\n/**\n * Replaces the tab characters of a string with spaces.\n * This is used to create a prettier IR (which is built-up from many template js strings in this file, which might contain tabs depending on the editor used)\n * @example\n * replaceTabs(\"\\t\\t\\t\") => [TAB, TAB, TAB].join(\"\")\n * @package\n * @param {string} str \n * @returns {string}\n */\nfunction replaceTabs(str) {\n\treturn str.replace(new RegExp(\"\\t\", \"g\"), TAB);\n}\n\n/**\n * Read non-byte aligned numbers\n * @package\n */\nclass BitReader {\n    /**\n     * @type {Uint8Array}\n     */\n\t#view;\n\n    /**\n     * @type {number}\n     */\n\t#pos;\n\n    /**\n     * @type {boolean}\n     */\n\t#truncate;\n\n\t/**\n\t * @param {number[]} bytes\n\t * @param {boolean} truncate - if true then read last bits as low part of number, if false pad with zero bits\n\t */\n\tconstructor(bytes, truncate = true) {\n\t\tthis.#view = new Uint8Array(bytes);\n\t\tthis.#pos = 0; // bit position, not byte position\n\t\tthis.#truncate = truncate;\n\t}\n\n\t/**\n     * @package\n\t * @returns {boolean}\n\t */\n\teof() {\n\t\treturn idiv(this.#pos, 8) >= this.#view.length;\n\t}\n\n\t/**\n\t * Reads a number of bits (<= 8) and returns the result as an unsigned number\n     * @package\n\t * @param {number} n - number of bits to read\n\t * @returns {number}\n\t */\n\treadBits(n) {\n\t\tassert(n <= 8, \"reading more than 1 byte\");\n\n\t\tlet leftShift = 0;\n\t\tif (this.#pos + n > this.#view.length * 8) {\n\t\t\tconst newN = (this.#view.length*8 - this.#pos);\n\n\t\t\tif (!this.#truncate) {\n\t\t\t\tleftShift = n - newN;\n\t\t\t}\n\n\t\t\tn = newN;\n\t\t}\n\n\t\tassert(n > 0, \"eof\");\n\n\t\t// it is assumed we don't need to be at the byte boundary\n\n\t\tlet res = 0;\n\t\tlet i0 = this.#pos;\n\n\t\tfor (let i = this.#pos + 1; i <= this.#pos + n; i++) {\n\t\t\tif (i % 8 == 0) {\n\t\t\t\tconst nPart = i - i0;\n\n\t\t\t\tres += imask(this.#view[idiv(i, 8) - 1], i0 % 8, 8) << (n - nPart);\n\n\t\t\t\ti0 = i;\n\t\t\t} else if (i == this.#pos + n) {\n\t\t\t\tres += imask(this.#view[idiv(i, 8)], i0 % 8, i % 8);\n\t\t\t}\n\t\t}\n\n\t\tthis.#pos += n;\n\t\treturn res << leftShift;\n\t}\n\n\t/**\n\t * Moves position to next byte boundary\n     * @package\n\t * @param {boolean} force - if true then move to next byte boundary if already at byte boundary\n\t */\n\tmoveToByteBoundary(force = false) {\n\t\tif (this.#pos % 8 != 0) {\n\t\t\tlet n = 8 - this.#pos % 8;\n\n\t\t\tvoid this.readBits(n);\n\t\t} else if (force) {\n\t\t\tthis.readBits(8);\n\t\t}\n\t}\n\n\t/**\n\t * Reads 8 bits\n     * @package\n\t * @returns {number}\n\t */\n\treadByte() {\n\t\treturn this.readBits(8);\n\t}\n\n\t/**\n\t * Dumps remaining bits we #pos isn't yet at end.\n\t * This is intended for debugging use.\n     * @package\n\t */\n\tdumpRemainingBits() {\n\t\tif (!this.eof()) {\n\t\t\tconsole.log(\"remaining bytes:\");\n\t\t\tfor (let first = true, i = idiv(this.#pos, 8); i < this.#view.length; first = false, i++) {\n\t\t\t\tif (first && this.#pos % 8 != 0) {\n\t\t\t\t\tconsole.log(byteToBitString(imask(this.#view[i], this.#pos % 8, 8) << 8 - this.#pos % 7));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(byteToBitString(this.#view[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"eof\");\n\t\t}\n\t}\n}\n\n/**\n * BitWriter turns a string of '0's and '1's into a list of bytes.\n * Finalization pads the bits using '0*1' if not yet aligned with the byte boundary.\n * @package\n */\nclass BitWriter {\n\t/**\n\t * Concatenated and padded upon finalization\n\t * @type {string[]}\n\t */\n\t#parts;\n\n\t/**\n\t * Number of bits written so far\n\t * @type {number}\n\t */\n\t#n;\n\n\tconstructor() {\n\t\tthis.#parts = [];\n\t\tthis.#n = 0;\n\t}\n\n\t/**\n     * @package\n\t * @type {number}\n\t */\n\tget length() {\n\t\treturn this.#n;\n\t}\n\n\t/**\n\t * Write a string of '0's and '1's to the BitWriter.\n     * @package\n\t * @param {string} bitChars\n\t */\n\twrite(bitChars) {\n\t\tfor (let c of bitChars) {\n\t\t\tif (c != '0' && c != '1') {\n\t\t\t\tthrow new Error(\"bad bit char\");\n\t\t\t}\n\t\t}\n\n\t\tthis.#parts.push(bitChars);\n\t\tthis.#n += bitChars.length;\n\t}\n\n\t/**\n     * @package\n\t * @param {number} byte\n\t */\n\twriteByte(byte) {\n\t\tthis.write(padZeroes(byte.toString(2), 8));\n\t}\n\n\t/**\n\t * Add padding to the BitWriter in order to align with the byte boundary.\n\t * If 'force == true' then 8 bits are added if the BitWriter is already aligned.\n     * @package\n\t * @param {boolean} force \n\t */\n\tpadToByteBoundary(force = false) {\n\t\tlet nPad = 0;\n\t\tif (this.#n % 8 != 0) {\n\t\t\tnPad = 8 - this.#n % 8;\n\t\t} else if (force) {\n\t\t\tnPad = 8;\n\t\t}\n\n\t\tif (nPad != 0) {\n\t\t\tlet padding = (new Array(nPad)).fill('0');\n\t\t\tpadding[nPad - 1] = '1';\n\n\t\t\tthis.#parts.push(padding.join(''));\n\n\t\t\tthis.#n += nPad;\n\t\t}\n\t}\n\n\t/**\n\t * Pads the BitWriter to align with the byte boundary and returns the resulting bytes.\n     * @package\n\t * @param {boolean} force - force padding (will add one byte if already aligned)\n\t * @returns {number[]}\n\t */\n\tfinalize(force = true) {\n\t\tthis.padToByteBoundary(force);\n\n\t\tlet chars = this.#parts.join('');\n\n\t\tlet bytes = [];\n\n\t\tfor (let i = 0; i < chars.length; i += 8) {\n\t\t\tlet byteChars = chars.slice(i, i + 8);\n\t\t\tlet byte = parseInt(byteChars, 2);\n\n\t\t\tbytes.push(byte);\n\t\t}\n\n\t\treturn bytes;\n\t}\n}\n\n/**\n * Function that generates a random number between 0 and 1\n * @typedef {() => number} NumberGenerator\n */\n\n/**\n * A Source instance wraps a string so we can use it cheaply as a reference inside a Site.\n * Also used by VSCode plugin\n */\nclass Source {\n\t#raw;\n\t#fileIndex;\n\t#errors; // errors are collected into this object\n\n\t/**\n\t * @param {string} raw \n\t * @param {?number} fileIndex\n\t */\n\tconstructor(raw, fileIndex = null) {\n\t\tthis.#raw = assertDefined(raw);\n\t\tthis.#fileIndex = fileIndex;\n\t\tthis.#errors = [];\n\t}\n\n    /**\n     * @package\n     * @type {string}\n     */\n\tget raw() {\n\t\treturn this.#raw;\n\t}\n\n    /**\n     * @package\n     * @type {?number}\n     */\n\tget fileIndex() {\n\t\treturn this.#fileIndex;\n\t}\n\n\t/**\n\t * @type {Error[]}\n\t */\n\tget errors() {\n\t\treturn this.#errors;\n\t}\n\n\tthrowErrors() {\n\t\tif (this.#errors.length > 0) {\n\t\t\tthrow this.#errors[0];\n\t\t}\n\t}\n\n\t/**\n\t * Get char from the underlying string.\n\t * Should work fine utf-8 runes.\n     * @package\n\t * @param {number} pos\n\t * @returns {string}\n\t */\n\tgetChar(pos) {\n\t\treturn this.#raw[pos];\n\t}\n\t\n\t/**\n\t * Returns word under pos\n     * @package\n\t * @param {number} pos \n\t * @returns {?string}\n\t */\n\tgetWord(pos) {\n\t\t/** @type {string[]} */\n\t\tconst chars = [];\n\n\t\t/**\n\t\t * @param {string | undefined} c \n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction isWordChar(c) {\n\t\t\tif (c === undefined) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn (c == '_' || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n\t\t\t}\n\t\t}\n\n\t\tlet c = this.#raw[pos];\n\t\twhile (isWordChar(c)) {\n\t\t\tchars.push(c);\n\t\t\tpos += 1;\n\t\t\tc = this.#raw[pos];\n\t\t}\n\n\t\tif (chars.length == 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn chars.join(\"\");\n\t\t}\n\t}\n\n    /**\n     * @package\n     * @type {number}\n     */\n\tget length() {\n\t\treturn this.#raw.length;\n\t}\n\n\t/**\n\t * Calculates the line number of the line where the given character is located (0-based).\n     * @package\n\t * @param {number} pos \n\t * @returns {number}\n\t */\n\tposToLine(pos) {\n\t\tlet line = 0;\n\t\tfor (let i = 0; i < pos; i++) {\n\t\t\tif (this.#raw[i] == '\\n') {\n\t\t\t\tline += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn line;\n\t}\n\n\t/**\n\t * Calculates the column and line number where the given character is located (0-based).\n     * @package\n\t * @param {number} pos\n\t * @returns {[number, number]}\n\t */\n\t// returns [col, line]\n\tposToLineAndCol(pos) {\n\t\tlet col = 0;\n\t\tlet line = 0;\n\t\tfor (let i = 0; i < pos; i++) {\n\t\t\tif (this.#raw[i] == '\\n') {\n\t\t\t\tcol = 0;\n\t\t\t\tline += 1;\n\t\t\t} else {\n\t\t\t\tcol += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn [line, col];\n\t}\n\n\t/**\n\t * Creates a more human-readable version of the source by prepending the line-numbers to each line.\n\t * The line-numbers are at least two digits.\n\t * @example\n\t * (new Source(\"hello\\nworld\")).pretty() => \"01  hello\\n02  world\"\n     * @package\n\t * @returns {string}\n\t */\n\tpretty() {\n\t\tconst lines = this.#raw.split(\"\\n\");\n\n\t\tconst nLines = lines.length;\n\t\tconst nDigits = Math.max(Math.ceil(Math.log10(nLines)), 2); // line-number is at least two digits\n\n\t\tfor (let i = 0; i < nLines; i++) {\n\t\t\tlines[i] = String(i + 1).padStart(nDigits, '0') + \"  \" + lines[i];\n\t\t}\n\n\t\treturn lines.join(\"\\n\");\n\t}\n}\n\n/**\n * A tag function for a helios source.\n * Is just a marker so IDE support can work on literal helios sources inside javascript/typescript files.\n * @example\n * hl`hello ${\"world\"}!` => \"hello world!\"\n * @param {string[]} a \n * @param  {...any} b \n * @returns {string}\n */\nfunction hl(a, ...b) {\n\treturn a.map((part, i) => {\n\t\tif (i < b.length) {\n\t\t\treturn part + b[i].toString();\n\t\t} else {\n\t\t\treturn part;\n\t\t}\n\t}).join(\"\");\n}\n\n/**\n * Display a warning message that a certain feature will be deprecated at some point in the future.\n * @package\n * @param {string} feature\n * @param {string} futureVersion\n * @param {string} alternative\n * @param {string} docUrl\n */\nfunction deprecationWarning(feature, futureVersion, alternative, docUrl = \"\") {\n\tlet msg = `${feature} is DEPRECATED, and will be removed from version ${futureVersion} onwards!\n${alternative}`;\n\n\tif (docUrl != \"\") {\n\t\tmsg += `\\n(for more information: ${docUrl})`;\n\t}\n\n\tconsole.warn(msg);\n}\n\n\n\n////////////////////\n// Section 3: Tokens\n////////////////////\n\n/**\n * Each Token/Expression/Statement has a Site, which encapsulates a position in a Source\n * @package\n */\nclass Site {\n\t#src;\n\t#startPos;\n\t#endPos;\n\n\t/** @type {?Site} - end of token, exclusive, TODO: replace with endPos */\n\t#endSite;\n\n\t/**@type {?Site} */\n\t#codeMapSite;\n\n\t/**\n\t * @param {Source} src \n\t * @param {number} startPos\n\t * @param {number} endPos \n\t */\n\tconstructor(src, startPos, endPos = startPos + 1) {\n\t\tthis.#src = src;\n\t\tthis.#startPos = startPos;\n\t\tthis.#endPos = endPos;\n\t\tthis.#endSite = null;\n\t\tthis.#codeMapSite = null;\n\t}\n\n\tstatic dummy() {\n\t\treturn new Site(new Source(\"\"), 0);\n\t}\n\n\tget src() {\n\t\treturn this.#src;\n\t}\n\n\tget startPos() {\n\t\treturn this.#startPos;\n\t}\n\n\tget endPos() {\n\t\treturn this.#endPos;\n\t}\n\t\n\tget endSite() {\n\t\treturn this.#endSite;\n\t}\n\n\t/**\n\t * @param {Site} other \n\t * @returns {Site}\n\t */\n\tmerge(other) {\n\t\treturn new Site(this.#src, this.#startPos, other.#endPos);\n\t}\n\n\t/**\n\t * @param {?Site} site\n\t */\n\tsetEndSite(site) {\n\t\tthis.#endSite = site;\n\t}\n\n\t/**\n\t * @type {?Site} \n\t */\n\tget codeMapSite() {\n\t\treturn this.#codeMapSite;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t */\n\tsetCodeMapSite(site) {\n\t\tthis.#codeMapSite = site;\n\t}\n\n\t/**\n\t * Returns a SyntaxError\n\t * @param {string} info \n\t * @returns {UserError}\n\t */\n\tsyntaxError(info = \"\") {\n\t\treturn UserError.syntaxError(this.#src, this.#startPos, this.#endPos, info);\n\t}\n\n\t/**\n\t * Returns a TypeError\n\t * @param {string} info\n\t * @returns {UserError}\n\t */\n\ttypeError(info = \"\") {\n\t\treturn UserError.typeError(this.#src, this.#startPos, this.#endPos, info);\n\t}\n\n\t/**\n\t * Returns a ReferenceError\n\t * @param {string} info \n\t * @returns {UserError}\n\t */\n\treferenceError(info = \"\") {\n\t\treturn UserError.referenceError(this.#src, this.#startPos, this.#endPos, info);\n\t}\n\n\t/**\n\t * Returns a RuntimeError\n\t * @param {string} info\n\t * @returns {UserError}\n\t */\n\truntimeError(info = \"\") {\n\t\tif (this.#codeMapSite !== null) {\n\t\t\tlet site = this.#codeMapSite;\n\t\t\treturn RuntimeError.newRuntimeError(site.#src, site.#startPos, false, info);\n\t\t} else {\n\t\t\treturn RuntimeError.newRuntimeError(this.#src, this.#startPos, true, info);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the column,line position in 'this.#src'\n\t * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]\n\t */\n\tgetFilePos() {\n\t\tconst [startLine, startCol] = this.#src.posToLineAndCol(this.#startPos);\n\n\t\tconst [endLine, endCol] = this.#src.posToLineAndCol(this.#endPos);\n\n\t\treturn [startLine, startCol, endLine, endCol];\n\t}\n}\n\n\n/**\n * UserErrors are generated when the user of Helios makes a mistake (eg. a syntax error),\n * or when the user of Helios throws an explicit error inside a script (eg. division by zero).\n */\n class UserError extends Error {\n\t#src;\n\t#startPos;\n\t#endPos;\n\n\t/**\n\t * @param {string} msg\n\t * @param {Source} src \n\t * @param {number} startPos \n\t * @param {number} endPos\n\t */\n\tconstructor(msg, src, startPos, endPos = startPos + 1) {\n\t\tsuper(msg);\n\t\tthis.#src = src;\n\t\tthis.#startPos = startPos;\n\t\tthis.#endPos = endPos;\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {Source} src \n\t * @param {number} startPos \n\t * @param {number} endPos\n\t * @param {string} info \n\t */\n\tstatic new(type, src, startPos, endPos, info = \"\") {\n\t\tlet line = src.posToLine(startPos);\n\n\t\tlet msg = `${type} on line ${line + 1}`;\n\t\tif (info != \"\") {\n\t\t\tmsg += `: ${info}`;\n\t\t}\n\n\t\treturn new UserError(msg, src, startPos, endPos);\n\t}\n\n\t/**\n\t * @type {Source}\n\t */\n\tget src() {\n\t\treturn this.#src;\n\t}\n\n\t/**\n\t * Constructs a SyntaxError\n\t * @param {Source} src \n\t * @param {number} startPos \n\t * @param {number} endPos\n\t * @param {string} info \n\t * @returns {UserError}\n\t */\n\tstatic syntaxError(src, startPos, endPos, info = \"\") {\n\t\tconst error = UserError.new(\"SyntaxError\", src, startPos, endPos, info);\n\n\t\tsrc.errors.push(error);\n\n\t\treturn error;\n\t}\n\n\t/**\n\t * Constructs a TypeError\n\t * @param {Source} src \n\t * @param {number} startPos \n\t * @param {number} endPos\n\t * @param {string} info \n\t * @returns {UserError}\n\t */\n\tstatic typeError(src, startPos, endPos, info = \"\") {\n\t\tconst error = UserError.new(\"TypeError\", src, startPos, endPos, info);\n\n\t\tsrc.errors.push(error);\n\n\t\treturn error;\n\t}\n\n\t/**\n\t * @param {Error} e \n\t * @returns {boolean}\n\t */\n\tstatic isTypeError(e) {\n\t\treturn (e instanceof UserError) && e.message.startsWith(\"TypeError\");\n\t}\n\n\t/**\n\t * Constructs a ReferenceError (i.e. name undefined, or name unused)\n\t * @param {Source} src \n\t * @param {number} startPos \n\t * @param {number} endPos\n\t * @param {string} info \n\t * @returns {UserError}\n\t */\n\tstatic referenceError(src, startPos, endPos, info = \"\") {\n\t\tconst error = UserError.new(\"ReferenceError\", src, startPos, endPos, info);\n\n\t\tsrc.errors.push(error);\n\n\t\treturn error;\n\t}\n\n\t/**\n\t * @param {Error} e \n\t * @returns {boolean}\n\t */\n\tstatic isReferenceError(e) {\n\t\treturn (e instanceof UserError) && e.message.startsWith(\"ReferenceError\");\n\t}\n\n\tget data() {\n\t\tthrow new Error(\"is error\");\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget startPos() {\n\t\treturn this.#startPos;\n\t}\n\n\t/**\n\t * Calculates column/line position in 'this.src'.\n\t * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]\n\t */\n\tgetFilePos() {\n\t\tconst [startLine, startCol] = this.#src.posToLineAndCol(this.#startPos);\n\t\tconst [endLine, endCol] = this.#src.posToLineAndCol(this.#endPos);\n\n\t\treturn [startLine, startCol, endLine, endCol];\n\t}\n\n\t/**\n\t * Dumps the error without throwing.\n\t * If 'verbose == true' the Source is also pretty printed with line-numbers.\n\t * @param {boolean} verbose \n\t */\n\tdump(verbose = false) {\n\t\tif (verbose) {\n\t\t\tconsole.error(this.#src.pretty());\n\t\t}\n\n\t\tconsole.error(\"\\n\" + this.message);\n\t}\n\n\t/**\n\t * Returns the error message (alternative to e.message)\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.message;\n\t}\n\n\t/**\n\t * Catches any UserErrors thrown inside 'fn()`.\n\t * Dumps the error\n\t * @template T\n\t * @param {() => T} fn \n\t * @param {boolean} verbose \n\t * @returns {T | undefined}\t\n\t */\n\tstatic catch(fn, verbose = false) {\n\t\ttry {\n\t\t\treturn fn();\n\t\t} catch (error) {\n\t\t\tif (error instanceof UserError) {\n\t\t\t\terror.dump(verbose);\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @typedef {(error: UserError) => void} Throw\n */\n\n/**\n * @package\n */\nclass RuntimeError extends UserError {\n\t#isIR; // last trace added\n\n\t/**\n\t * @param {string} msg \n\t * @param {Source} src \n\t * @param {number} pos \n\t * @param {boolean} isIR \n\t */\n\tconstructor(msg, src, pos, isIR) {\n\t\tsuper(msg, src, pos);\n\t\tthis.#isIR = isIR;\n\t}\n\n\t/**\n\t * @param {Source} src \n\t * @param {number} pos \n\t * @param {boolean} isIR\n\t * @param {string} info\n\t * @returns {RuntimeError}\n\t */\n\tstatic newRuntimeError(src, pos, isIR, info = \"\") {\n\t\tlet line = src.posToLine(pos);\n\n\t\tlet msg = `RuntimeError on line ${line + 1}${isIR ? \" of IR\" : \"\"}`;\n\t\tif (info != \"\") {\n\t\t\tmsg += `: ${info}`;\n\t\t}\n\n\t\treturn new RuntimeError(msg, src, pos, isIR);\n\t}\n\n\t/**\n\t * @param {Source} src \n\t * @param {number} pos \n\t * @param {boolean} isIR \n\t * @param {string} info \n\t * @returns {RuntimeError}\n\t */\n\taddTrace(src, pos, isIR, info = \"\") {\n\t\tif (isIR && !this.#isIR) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet line = src.posToLine(pos);\n\n\t\tlet msg = `Trace${info == \"\" ? \":\" : \",\"} line ${line + 1}`;\n\t\tif (isIR) {\n\t\t\tmsg += \" of IR\";\n\t\t} \n\n\t\tlet word = src.getWord(pos);\n\t\tif (word !== null && word !== \"print\") {\n\t\t\tmsg += ` in '${word}'`;\n\t\t}\n\n\t\tif (info != \"\") {\n\t\t\tmsg += `: ${info}`;\n\t\t}\n\n\t\t\n\t\tmsg += \"\\n\" + this.message;\n\n\t\treturn new RuntimeError(msg, this.src, this.startPos, isIR);\n\t}\n\t\n\t/**\n\t * @param {Site} site \n\t * @param {string} info \n\t * @returns {RuntimeError}\n\t */\n\taddTraceSite(site, info = \"\") {\n\t\tif (site.codeMapSite === null) {\n\t\t\treturn this.addTrace(site.src, site.startPos, true, info);\n\t\t} else {\n\t\t\treturn this.addTrace(site.codeMapSite.src, site.codeMapSite.startPos, false, info);\n\t\t}\n\t}\n}\n\n/**\n * Token is the base class of all Expressions and Statements\n */\nclass Token {\n\t#site;\n\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tthis.#site = assertDefined(site); // position in source of start of token\n\t}\n\n\tget site() {\n\t\treturn this.#site;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is a literal primitive, a literal struct constructor, or a literal function expression.\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is a Word token.\n\t * @param {?(string | string[])} value\n\t * @returns {boolean}\n\t */\n\tisWord(value = null) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisKeyword() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is a Symbol token (eg. '+', '(' etc.)\n\t * @param {?(string | string[])} value\n\t * @returns {boolean}\n\t */\n\tisSymbol(value = null) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is a group (eg. '(...)').\n\t * @param {?string} value\n\t * @param {number | null} nFields\n\t * @returns {boolean}\n\t */\n\tisGroup(value, nFields = null) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a SyntaxError at the current Site.\n\t * @param {string} msg \n\t * @returns {UserError}\n\t */\n\tsyntaxError(msg) {\n\t\treturn this.#site.syntaxError(msg);\n\t}\n\n\t/**\n\t * Returns a TypeError at the current Site.\n\t * @param {string} msg\n\t * @returns {UserError}\n\t */\n\ttypeError(msg) {\n\t\treturn this.#site.typeError(msg);\n\t}\n\n\t/**\n\t * Returns a ReferenceError at the current Site.\n\t * @param {string} msg\n\t * @returns {UserError}\n\t */\n\treferenceError(msg) {\n\t\treturn this.#site.referenceError(msg);\n\t}\n\n\t/**\n\t * Throws a SyntaxError if 'this' isn't a Word.\n\t * @param {?(string | string[])} value \n\t * @returns {Word | null}\n\t */\n\tassertWord(value = null) {\n\t\tif (value !== null) {\n\t\t\tthis.syntaxError(`expected \\'${value}\\', got \\'${this.toString()}\\'`);\n\t\t} else {\n\t\t\tthis.syntaxError(`expected word, got ${this.toString()}`);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Throws a SyntaxError if 'this' isn't a Symbol.\n\t * @param {?(string | string[])} value \n\t * @returns {SymbolToken | null}\n\t */\n\tassertSymbol(value = null) {\n\t\tif (value !== null) {\n\t\t\tthis.syntaxError(`expected '${value}', got '${this.toString()}'`);\n\t\t} else {\n\t\t\tthis.syntaxError(`expected symbol, got '${this.toString()}'`);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Throws a SyntaxError if 'this' isn't a Group.\n\t * @param {?string} type \n\t * @param {?number} nFields\n\t * @returns {Group | null}\n\t */\n\tassertGroup(type = null, nFields = null) {\n\t\tif (type !== null) {\n\t\t\tthis.syntaxError(`invalid syntax: expected '${type}...${Group.matchSymbol(type)}'`);\n\t\t} else {\n\t\t\tthis.syntaxError(`invalid syntax: expected group`);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n/**\n * @package\n * @param {undefined | null | Token} t\n * @param {Site} site\n * @param {string} msg\n * @returns {null | Token}\n */\nfunction assertToken(t, site, msg = \"expected token\") {\n\tif (!t) {\n\t\tsite.syntaxError(msg);\n\t\treturn null;\n\t} else {\n\t\treturn t;\n\t}\n}\n\n/**\n * A Word token represents a token that matches /[A-Za-z_][A-Za-z_0-9]/\n * @package\n */\nclass Word extends Token {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * @param {string} value \n\t * @returns {Word}\n\t */\n\tstatic new(value) {\n\t\treturn new Word(Site.dummy(), value);\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @param {?(string | string[])} value \n\t * @returns {boolean}\n\t */\n\tisWord(value = null) {\n\t\tif (value !== null) {\n\t\t\tif (value instanceof Array) {\n\t\t\t\treturn value.lastIndexOf(this.#value) != -1;\n\t\t\t} else {\n\t\t\t\treturn value == this.#value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {?(string | string[])} value \n\t * @returns {Word}\n\t */\n\tassertWord(value = null) {\n\t\tif (!this.isWord(value)) {\n\t\t\tsuper.assertWord(value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {Word}\n\t */\n\tassertNotInternal() {\n\t\tif (this.#value == \"_\") {\n\t\t\tthrow this.syntaxError(\"_ is reserved\");\n\t\t} else if (this.#value.startsWith(\"__\")) {\n\t\t\tthrow this.syntaxError(\"__ prefix is reserved\");\n\t\t} else if (this.#value.endsWith(\"__\")) {\n\t\t\tthrow this.syntaxError(\"__ suffix is reserved\");\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisKeyword() {\n\t\tswitch (this.#value) {\n\t\t\tcase \"const\":\n\t\t\tcase \"func\":\n\t\t\tcase \"struct\":\n\t\t\tcase \"enum\":\n\t\t\tcase \"import\":\n\t\t\tcase \"if\":\n\t\t\tcase \"else\":\n\t\t\tcase \"switch\":\n\t\t\tcase \"self\":\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Word | null}\n\t */\n\tassertNotKeyword() {\n\t\tthis.assertNotInternal();\n\n\t\tif (this.isKeyword()) {\n\t\t\tthis.syntaxError(`'${this.#value}' is a reserved word`);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * Finds the index of the first Word(value) in a list of tokens\n\t * Returns -1 if none found\n\t * @param {Token[]} ts \n\t * @param {string | string[]} value \n\t * @returns {number}\n\t */\n\tstatic find(ts, value) {\n\t\treturn ts.findIndex(item => item.isWord(value));\n\t}\n}\n\n/**\n * Symbol token represent anything non alphanumeric\n * @package\n */\nclass SymbolToken extends Token {\n\t#value;\n\n\t/**\n\t * @param {Site} site\n\t * @param {string} value\n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @param {?(string | string[])} value \n\t * @returns {boolean}\n\t */\n\tisSymbol(value = null) {\n\t\tif (value !== null) {\n\t\t\tif (value instanceof Array) {\n\t\t\t\treturn value.lastIndexOf(this.#value) != -1;\n\t\t\t} else {\n\t\t\t\treturn value == this.#value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {?(string | string[])} value \n\t * @returns {SymbolToken}\n\t */\n\tassertSymbol(value) {\n\t\tif (!this.isSymbol(value)) {\n\t\t\tsuper.assertSymbol(value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * Finds the index of the first Symbol(value) in a list of tokens.\n\t * Returns -1 if none found.\n\t * @param {Token[]} ts\n\t * @param {string | string[]} value\n\t * @returns {number}\n\t */\n\tstatic find(ts, value) {\n\t\treturn ts.findIndex(item => item.isSymbol(value));\n\t}\n\n\t/**\n\t * Finds the index of the last Symbol(value) in a list of tokens.\n\t * Returns -1 if none found.\n\t * @param {Token[]} ts \n\t * @param {string | string[]} value \n\t * @returns {number}\n\t */\n\tstatic findLast(ts, value) {\n\t\tfor (let i = ts.length - 1; i >= 0; i--) {\n\t\t\tif (ts[i].isSymbol(value)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\n/**\n * Group token can '(...)', '[...]' or '{...}' and can contain comma separated fields.\n * @package\n */\nclass Group extends Token {\n\t#type;\n\t#fields;\n\t#firstComma;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} type - \"(\", \"[\" or \"{\"\n\t * @param {Token[][]} fields \n\t * @param {?SymbolToken} firstComma\n\t */\n\tconstructor(site, type, fields, firstComma = null) {\n\t\tsuper(site);\n\t\tthis.#type = type;\n\t\tthis.#fields = fields; // list of lists of tokens\n\t\tthis.#firstComma = firstComma;\n\n\t\tassert(fields.length < 2 || firstComma !== null);\n\t}\n\n\tget fields() {\n\t\treturn this.#fields.slice(); // copy, so fields_ doesn't get mutated\n\t}\n\n\t/**\n\t * @param {?string} type \n\t * @param {number | null} nFields\n\t * @returns {boolean}\n\t */\n\tisGroup(type = null, nFields = null) {\n\t\tconst nFieldsOk = (nFields === null) || (nFields == this.#fields.length);\n\n\t\tif (type !== null) {\n\t\t\treturn this.#type == type && nFieldsOk;\n\t\t} else {\n\t\t\treturn nFieldsOk;\n\t\t}\n\t}\n\n\t/**\n\t * @param {?string} type \n\t * @param {?number} nFields \n\t * @returns {Group | null}\n\t */\n\tassertGroup(type = null, nFields = null) {\n\t\tif (type !== null && this.#type != type) {\n\t\t\tthis.syntaxError(`invalid syntax: expected '${type}...${Group.matchSymbol(type)}', got '${this.#type}...${Group.matchSymbol(this.#type)}'`);\n\n\t\t\treturn null;\n\t\t} else if (type !== null && nFields !== null && nFields != this.#fields.length) {\n\t\t\tif (this.#fields.length > 1 && nFields <= 1 && this.#firstComma !== null) {\n\t\t\t\tthis.#firstComma.syntaxError(`invalid syntax, unexpected ','`);\n\t\t\t} else {\n\t\t\t\tthis.syntaxError(`invalid syntax: expected '${type}...${Group.matchSymbol(type)}' with ${nFields} field(s), got '${type}...${Group.matchSymbol(type)}' with ${this.#fields.length} fields`);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tlet s = this.#type;\n\n\t\tlet parts = [];\n\t\tfor (let f of this.#fields) {\n\t\t\tparts.push(f.map(t => t.toString()).join(\" \"));\n\t\t}\n\n\t\ts += parts.join(\", \") + Group.matchSymbol(this.#type);\n\n\t\treturn s;\n\t}\n\n\t/**\n\t * @param {Token} t \n\t * @returns {boolean}\n\t */\n\tstatic isOpenSymbol(t) {\n\t\treturn t.isSymbol(\"{\") || t.isSymbol(\"[\") || t.isSymbol(\"(\");\n\t}\n\n\t/**\n\t * @param {Token} t \n\t * @returns {boolean}\n\t */\n\tstatic isCloseSymbol(t) {\n\t\treturn t.isSymbol(\"}\") || t.isSymbol(\"]\") || t.isSymbol(\")\");\n\t}\n\n\t/**\n\t * Returns the corresponding closing bracket, parenthesis or brace.\n\t * Throws an error if not a group symbol.\n\t * @example\n\t * Group.matchSymbol(\"(\") => \")\"\n\t * @param {string | SymbolToken} t\n\t * @returns {string}\n\t */\n\tstatic matchSymbol(t) {\n\t\tif (t instanceof SymbolToken) {\n\t\t\tt = t.value;\n\t\t}\n\n\t\tif (t == \"{\") {\n\t\t\treturn \"}\";\n\t\t} else if (t == \"[\") {\n\t\t\treturn \"]\";\n\t\t} else if (t == \"(\") {\n\t\t\treturn \")\";\n\t\t} else if (t == \"}\") {\n\t\t\treturn \"{\";\n\t\t} else if (t == \"]\") {\n\t\t\treturn \"[\";\n\t\t} else if (t == \")\") {\n\t\t\treturn \"(\";\n\t\t} else {\n\t\t\tthrow new Error(\"not a group symbol\");\n\t\t}\n\t}\n\n\t/**\n\t * Finds the index of first Group(type) in list of tokens\n\t * Returns -1 if none found.\n\t * @param {Token[]} ts \n\t * @param {string} type \n\t * @returns {number}\n\t */\n\tstatic find(ts, type) {\n\t\treturn ts.findIndex(item => item.isGroup(type));\n\t}\n}\n\n/**\n * Base class of literal tokens\n * @package\n */\nclass PrimitiveLiteral extends Token {\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\treturn true;\n\t}\n}\n\n/**\n * Signed int literal token\n * @package\n */\nclass IntLiteral extends PrimitiveLiteral {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {bigint} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value.toString();\n\t}\n}\n\n/**\n * Bool literal token\n * @package\n */\nclass BoolLiteral extends PrimitiveLiteral {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {boolean} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value ? \"true\" : \"false\";\n\t}\n}\n\n/**\n * ByteArray literal token\n * @package\n */\nclass ByteArrayLiteral extends PrimitiveLiteral {\n\t#bytes;\n\n\t/**\n\t * @param {Site} site \n\t * @param {number[]} bytes \n\t */\n\tconstructor(site, bytes) {\n\t\tsuper(site);\n\t\tthis.#bytes = bytes;\n\t}\n\n\tget bytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoString() {\n\t\treturn `#${bytesToHex(this.#bytes)}`;\n\t}\n}\n\n/**\n * String literal token (utf8)\n * @package\n */\nclass StringLiteral extends PrimitiveLiteral {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\ttoString() {\n\t\treturn `\"${this.#value.toString()}\"`;\n\t}\n}\n\n/**\n * @package\n * @typedef {[number, Site][]} CodeMap\n */\n\n/**\n * @package\n * @typedef {Map<string, IR>} IRDefinitions\n */\n\n/**\n * The IR class combines a string of intermediate representation sourcecode with an optional site.\n * The site is used for mapping IR code to the original source code.\n * @package\n */\n class IR {\n\t#content;\n\t#site;\n\n\t/**\n\t * @param {string | IR[]} content \n\t * @param {?Site} site \n\t */\n\tconstructor(content, site = null) {\n\t\tassert(!(Array.isArray(content) && content.some(item => item == undefined)), \"some items undefined\");\n\t\tthis.#content = content;\n\t\tthis.#site = site;\n\t}\n\n    /**\n     * @package\n     * @type {string | IR[]}\n     */\n\tget content() {\n\t\treturn this.#content;\n\t}\n\n    /**\n     * @package\n     * @type {?Site}\n     */\n\tget site() {\n\t\treturn this.#site;\n\t}\n\n\t/**\n\t * Returns a list containing IR instances that themselves only contain strings\n     * @package\n\t * @returns {IR[]}\n\t */\n\tflatten() {\n\t\tif (typeof this.#content == \"string\") {\n\t\t\treturn [this];\n\t\t} else {\n\t\t\t/**\n\t\t\t * @type {IR[]}\n\t\t\t */\n\t\t\tlet result = [];\n\n\t\t\tfor (let item of this.#content) {\n\t\t\t\tresult = result.concat(item.flatten());\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Intersperse nested IR content with a separator\n     * @package\n\t * @param {string} sep\n\t * @returns {IR}\n\t */\n\tjoin(sep) {\n\t\tif (typeof this.#content == \"string\") {\n\t\t\treturn this;\n\t\t} else {\n\t\t\t/** @type {IR[]} */\n\t\t\tconst result = [];\n\n\t\t\tfor (let i = 0; i < this.#content.length; i++) {\n\t\t\t\tresult.push(this.#content[i]);\n\n\t\t\t\tif (i < this.#content.length - 1) {\n\t\t\t\t\tresult.push(new IR(sep))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new IR(result);\n\t\t}\n\t}\n\n    /**\n     * @package\n\t * @returns {[string, CodeMap]}\n\t */\n\tgenerateSource() {\n\t\tconst parts = this.flatten();\n\n\t\t/** @type {string[]} */\n\t\tconst partSrcs = [];\n\n\t\t/** @type {CodeMap} */\n\t\tconst codeMap = [];\n\n\t\tlet pos = 0;\n\t\tfor (let part of parts) {\n\t\t\tconst rawPartSrc = part.content;\n\n\t\t\tif (typeof rawPartSrc == \"string\") {\n\t\t\t\tconst origSite = part.site;\n\t\t\t\tif (origSite !== null) {\n\t\t\t\t\t/** @type {[number, Site]} */\n\t\t\t\t\tconst pair = [pos, origSite];\n\n\t\t\t\t\tcodeMap.push(pair);\n\t\t\t\t}\n\n\t\t\t\tconst partSrc = replaceTabs(rawPartSrc);\n\n\t\t\t\tpos += partSrc.length;\n\t\t\t\tpartSrcs.push(partSrc);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"expected IR to contain only strings after flatten\");\n\t\t\t}\n\t\t}\n\n\t\treturn [partSrcs.join(\"\"), codeMap];\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tpretty() {\n\t\tconst [src, _] = this.generateSource();\n\n\t\treturn (new Source(src)).pretty();\n\t}\n\n\t/**\n\t * Wraps 'inner' IR source with some definitions (used for top-level statements and for builtins)\n     * @package\n\t * @param {IR} inner \n\t * @param {IRDefinitions} definitions - name -> definition\n\t * @returns {IR}\n\t */\n\tstatic wrapWithDefinitions(inner, definitions) {\n\t\tconst keys = Array.from(definitions.keys()).reverse();\n\n\t\tlet res = inner;\n\t\tfor (let key of keys) {\n\t\t\tconst definition = definitions.get(key);\n\n\t\t\tif (definition === undefined) {\n\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t} else {\n\n\t\t\t\tres = new IR([new IR(\"(\"), new IR(key), new IR(\") -> {\\n\"),\n\t\t\t\t\tres, new IR(`\\n}(\\n${TAB}/*${key}*/\\n${TAB}`), definition,\n\t\t\t\tnew IR(\"\\n)\")]);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n}\n\n\n\n////////////////////////////////////\n// Section 4: Cryptography functions\n////////////////////////////////////\n/**\n * Size of default Blake2b digest\n * @package\n */\nvar BLAKE2B_DIGEST_SIZE = 32; // bytes\n\n/**\n * Changes the value of BLAKE2B_DIGEST_SIZE \n *  (because the nodejs crypto module only supports \n *   blake2b-512 and not blake2b-256, and we want to avoid non-standard dependencies in the \n *   test-suite)\n * @package\n * @param {number} s - 32 or 64\n */\nfunction setBlake2bDigestSize(s) {\n    BLAKE2B_DIGEST_SIZE = s;\n}\n \n/**\n * Make sure resulting number fits in uint32\n * @package\n * @param {number} x\n */\nfunction imod32(x) {\n\treturn x >>> 0;\n}\n\n/**\n * 32 bit number rotation\n * @package\n * @param {number} x - originally uint32\n * @param {number} n\n * @returns {number} - originally uint32\n */\nfunction irotr(x, n) {\n\treturn imod32((x >>> n) | (x << (32 - n)));\n}\n\n/**\n * @package\n * @param {bigint} x \n * @param {bigint} n \n * @returns {bigint}\n */\nfunction posMod(x, n) {\n\tconst res = x % n;\n\n\tif (res < 0n) {\n\t\treturn res + n;\n\t} else {\n\t\treturn res;\n\t}\n}\n\n/**\n * UInt64 number (represented by 2 UInt32 numbers)\n * @package\n */\nclass UInt64 {\n\t#high;\n\t#low;\n\n\t/**\n\t * @param {number} high  - uint32 number\n\t * @param {number} low - uint32 number\n\t */\n\tconstructor(high, low) {\t\t\n\t\tthis.#high = imod32(high);\n\t\tthis.#low = imod32(low);\n\t}\n\n\t/**\n     * @package\n\t * @returns {UInt64}\n\t */\n\tstatic zero() {\n\t\treturn new UInt64(0, 0);\n\t}\n\n\t/**\n     * @package\n\t * @param {number[]} bytes - 8 uint8 numbers\n\t * @param {boolean} littleEndian\n\t * @returns {UInt64}\n\t */\n\tstatic fromBytes(bytes, littleEndian = true) {\n\t\t/** @type {number} */\n\t\tlet low;\n\n\t\t/** @type {number} */\n\t\tlet high;\n\n\t\tif (littleEndian) {\n\t\t\tlow  = (bytes[0] << 0) | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);\n\t\t\thigh = (bytes[4] << 0) | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24);\n\t\t} else {\n\t\t\thigh = (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | (bytes[3] << 0);\n\t\t\tlow  = (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | (bytes[7] << 0);\n\t\t}\n\n\t\treturn new UInt64(imod32(high), imod32(low));\n\t}\n\n\t/**\n     * @package\n\t * @param {string} str \n\t * @returns {UInt64}\n\t */\n\tstatic fromString(str) {\n\t\tconst high = parseInt(str.slice(0,  8), 16);\n\t\tconst low  = parseInt(str.slice(8, 16), 16);\n\n\t\treturn new UInt64(high, low);\n\t}\n\n    /**\n     * @package\n     * @type {number}\n     */\n\tget high() {\n\t\treturn this.#high;\n\t}\n\n    /**\n     * @package\n     * @type {number}\n     */\n\tget low() {\n\t\treturn this.#low;\n\t}\n\n\t/**\n\t * Returns [low[0], low[1], low[2], low[3], high[0], high[1], high[2], high[3]] if littleEndian==true\n     * @package\n\t * @param {boolean} littleEndian\n\t * @returns {number[]}\n\t */\n\ttoBytes(littleEndian = true) {\n\t\tconst res = [\n\t\t\t(0x000000ff & this.#low),\n\t\t\t(0x0000ff00 & this.#low) >>> 8,\n\t\t\t(0x00ff0000 & this.#low) >>> 16,\n\t\t\t(0xff000000 & this.#low) >>> 24,\n\t\t\t(0x000000ff & this.#high),\n\t\t\t(0x0000ff00 & this.#high) >>> 8,\n\t\t\t(0x00ff0000 & this.#high) >>> 16,\n\t\t\t(0xff000000 & this.#high) >>> 24,\n\t\t];\n\n\t\tif (!littleEndian) {\n\t\t\tres.reverse(); \n\t\t} \n\t\t\n\t\treturn res;\n\t}\n\n\t/**\n     * @package\n\t * @param {UInt64} other \n\t * @returns {boolean}\n\t */\n\teq(other) {\n\t\treturn (this.#high == other.#high) && (this.#low == other.#low);\n\t}\n\n\t/**\n     * @package\n\t * @returns {UInt64} \n\t */\n\tnot() {\n\t\treturn new UInt64(~this.#high, ~this.#low);\n\t}\n\n\t/**\n     * @package\n\t * @param {UInt64} other\n\t * @returns {UInt64}\n\t */\n\tand(other) {\n\t\treturn new UInt64(this.#high & other.#high, this.#low & other.#low);\n\t}\n\n\t/**\n     * @package\n\t * @param {UInt64} other \n\t * @returns {UInt64}\n\t */\n\txor(other) {\n\t\treturn new UInt64(this.#high ^ other.#high, this.#low ^ other.#low);\n\t}\n\n\t/**\n     * @package\n\t * @param {UInt64} other \n\t * @returns {UInt64}\n\t */\n\tadd(other) {\n\t\tconst low = this.#low + other.#low;\n\n\t\tlet high = this.#high + other.#high;\n\n\t\tif (low >= 0x100000000) {\n\t\t\thigh += 1;\n\t\t}\n\n\t\treturn new UInt64(high, low);\n\t}\n\n\t/**\n     * @package\n\t * @param {number} n \n\t * @returns {UInt64}\n\t */\n\trotr(n) {\n\t\tif (n == 32) {\n\t\t\treturn new UInt64(this.#low, this.#high);\n\t\t} else if (n > 32) {\n\t\t\treturn (new UInt64(this.#low, this.#high)).rotr(n - 32);\n\t\t} else {\n\t\t\treturn new UInt64(\n\t\t\t\timod32((this.#high >>> n) | (this.#low  << (32 - n))), \n\t\t\t\timod32((this.#low  >>> n) | (this.#high << (32 - n)))\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n     * @package\n\t * @param {number} n\n\t * @returns {UInt64}\n\t */\n\tshiftr(n) {\n\t\tif (n >= 32) {\n\t\t\treturn new UInt64(0, this.#high >>> n - 32);\n\t\t} else {\n\t\t\treturn new UInt64(this.#high >>> n, (this.#low >>> n) | (this.#high << (32 - n)));\n\t\t}\n\t}\t\n}\n\n/**\n * A collection of cryptography primitives are included here in order to avoid external dependencies\n *     mulberry32: random number generator\n *     base32 encoding and decoding\n *     bech32 encoding, checking, and decoding\n *     sha2_256, sha2_512, sha3 and blake2b hashing\n *     ed25519 pubkey generation, signing, and signature verification (NOTE: the current implementation is simple but slow)\n */\nclass Crypto {\n\t/**\n\t * Returns a simple random number generator\n     * @package\n\t * @param {number} seed\n\t * @returns {NumberGenerator} - a random number generator\n\t */\n\tstatic mulberry32(seed) {\n\t\t/**\n\t\t * @type {NumberGenerator}\n\t\t */\n\t\treturn function() {\n\t\t\tlet t = seed += 0x6D2B79F5;\n\t\t\tt = Math.imul(t ^ t >>> 15, t | 1);\n\t\t\tt ^= t + Math.imul(t ^ t >>> 7, t | 61);\n\t\t\treturn ((t ^ t >>> 14) >>> 0) / 4294967296;\n\t\t}\n\t}\n\n\t/**\n\t * Alias for rand generator of choice\n     * @package\n\t * @param {number} seed\n\t * @returns {NumberGenerator} - the random number generator function\n\t */\n\tstatic rand(seed) {\n\t\treturn this.mulberry32(seed);\n\t}\n\n\t/**\n\t * Rfc 4648 base32 alphabet\n\t * @type {string}\n\t */\n\tstatic get DEFAULT_BASE32_ALPHABET() {\n\t\treturn \"abcdefghijklmnopqrstuvwxyz234567\";\n\t}\n\n\t/**\n\t * Bech32 base32 alphabet\n\t * @type {string}\n\t */\n\tstatic get BECH32_BASE32_ALPHABET() {\n\t\treturn \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n\t}\n\t\n\t/**\n\t * Encode bytes in special base32.\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"f\")) => \"my\"\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"fo\")) => \"mzxq\"\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"foo\")) => \"mzxw6\"\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"foob\")) => \"mzxw6yq\"\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"fooba\")) => \"mzxw6ytb\"\n\t * @example\n\t * Crypto.encodeBase32(textToBytes(\"foobar\")) => \"mzxw6ytboi\"\n     * @package\n\t * @param {number[]} bytes - uint8 numbers\n\t * @param {string} alphabet - list of chars\n\t * @return {string}\n\t */\n\tstatic encodeBase32(bytes, alphabet = Crypto.DEFAULT_BASE32_ALPHABET) {\n\t\treturn Crypto.encodeBase32Bytes(bytes).map(c => alphabet[c]).join(\"\");\n\t}\n\n\t/**\n\t * Internal method\n     * @package\n\t * @param {number[]} bytes \n\t * @returns {number[]} - list of numbers between 0 and 32\n\t */\n\tstatic encodeBase32Bytes(bytes)  {\n\t\tconst result = [];\n\n\t\tconst reader = new BitReader(bytes, false);\n\n\t\twhile (!reader.eof()) {\n\t\t\tresult.push(reader.readBits(5));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Decode base32 string into bytes.\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"my\")) => \"f\"\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"mzxq\")) => \"fo\"\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"mzxw6\")) => \"foo\"\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"mzxw6yq\")) => \"foob\"\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"mzxw6ytb\")) => \"fooba\"\n\t * @example\n\t * bytesToText(Crypto.decodeBase32(\"mzxw6ytboi\")) => \"foobar\"\n     * @package\n\t * @param {string} encoded\n\t * @param {string} alphabet\n\t * @return {number[]}\n\t */\n\tstatic decodeBase32(encoded, alphabet = Crypto.DEFAULT_BASE32_ALPHABET) {\n\t\tconst writer = new BitWriter();\n\n\t\tconst n = encoded.length;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst c = encoded[i];\n\t\t\tconst code = alphabet.indexOf(c.toLowerCase());\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t// last, make sure we align to byte\n\n\t\t\t\tconst nCut = n*5 - 8*Math.floor(n*5/8);\n\n\t\t\t\tconst bits = padZeroes(code.toString(2), 5)\n\n\t\t\t\twriter.write(bits.slice(0, 5 - nCut));\n\t\t\t} else {\n\t\t\t\tconst bits = padZeroes(code.toString(2), 5);\n\n\t\t\t\twriter.write(bits);\n\t\t\t}\n\t\t}\n\n\t\tconst result = writer.finalize(false);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum\n\t * Internal method.\n     * @package\n\t * @param {string} hrp\n\t * @returns {number[]}\n\t */\n\tstatic expandBech32HumanReadablePart(hrp) {\n\t\tconst bytes = [];\n\t\tfor (let c of hrp) {\n\t\t\tbytes.push(c.charCodeAt(0) >> 5);\n\t\t}\n\n\t\tbytes.push(0);\n\n\t\tfor (let c of hrp) {\n\t\t\tbytes.push(c.charCodeAt(0) & 31);\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\t/**\n\t * Used as part of the bech32 checksum.\n\t * Internal method.\n     * @package\n\t * @param {number[]} bytes \n\t * @returns {number}\n\t */\n\tstatic calcBech32Polymod(bytes) {\n\t\tconst GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\n\t\tlet chk = 1;\n\t\tfor (let b of bytes) {\n\t\t\tconst c = (chk >> 25);\n\t\t\tchk = (chk & 0x1fffffff) << 5 ^ b;\n\n\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\tif (((c >> i) & 1) != 0) {\n\t\t\t\t\tchk ^= GEN[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chk;\n\t}\n\n\t/**\n\t * Generate the bech32 checksum\n\t * Internal method\n     * @package\n\t * @param {string} hrp \n\t * @param {number[]} data - numbers between 0 and 32\n\t * @returns {number[]} - 6 numbers between 0 and 32\n\t */\n\tstatic calcBech32Checksum(hrp, data) {\n\t\tconst bytes = Crypto.expandBech32HumanReadablePart(hrp).concat(data);\n\n\t\tconst chk = Crypto.calcBech32Polymod(bytes.concat([0,0,0,0,0,0])) ^ 1;\n\n\t\tconst chkSum = [];\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tchkSum.push((chk >> 5 * (5 - i)) & 31);\n\t\t}\n\n\t\treturn chkSum;\n\t}\n\n\t/**\n\t * Creates a bech32 checksummed string (used to represent Cardano addresses)\n\t * @example\n\t * Crypto.encodeBech32(\"foo\", textToBytes(\"foobar\")) => \"foo1vehk7cnpwgry9h96\"\n\t * @example\n\t * Crypto.encodeBech32(\"addr_test\", hexToBytes(\"70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539\")) => \"addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld\"\n     * @package\n\t * @param {string} hrp \n\t * @param {number[]} data - uint8 0 - 256\n\t * @returns {string}\n\t */\n\tstatic encodeBech32(hrp, data) {\n\t\tassert(hrp.length > 0, \"human-readable-part must have non-zero length\");\n\n\t\tdata = Crypto.encodeBase32Bytes(data);\n\n\t\tconst chkSum = Crypto.calcBech32Checksum(hrp, data);\n\n\t\treturn hrp + \"1\" + data.concat(chkSum).map(i => Crypto.BECH32_BASE32_ALPHABET[i]).join(\"\");\n\t}\n\n\t/**\n\t * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes\n\t * Throws an error if checksum is invalid.\n\t * @example\n\t * bytesToHex(Crypto.decodeBech32(\"addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld\")[1]) => \"70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539\"\n     * @package\n\t * @param {string} addr \n\t * @returns {[string, number[]]}\n\t */\n\tstatic decodeBech32(addr) {\n\t\tassert(Crypto.verifyBech32(addr), \"invalid bech32 addr\");\n\n\t\tconst i = addr.indexOf(\"1\");\n\n\t\tassert(i != -1);\n\n\t\tconst hrp = addr.slice(0, i);\n\n\t\taddr = addr.slice(i+1);\n\n\t\tconst data = Crypto.decodeBase32(addr.slice(0, addr.length - 6), Crypto.BECH32_BASE32_ALPHABET);\n\n\t\treturn [hrp, data];\n\t}\n\n\t/**\n\t * Verify a bech32 checksum\n\t * @example\n\t * Crypto.verifyBech32(\"foo1vehk7cnpwgry9h96\") => true\n\t * @example\n\t * Crypto.verifyBech32(\"foo1vehk7cnpwgry9h97\") => false\n\t * @example\n\t * Crypto.verifyBech32(\"a12uel5l\") => true\n\t * @example\n\t * Crypto.verifyBech32(\"mm1crxm3i\") => false\n\t * @example\n\t * Crypto.verifyBech32(\"A1G7SGD8\") => false\n\t * @example\n\t * Crypto.verifyBech32(\"abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw\") => true\n\t * @example\n\t * Crypto.verifyBech32(\"?1ezyfcl\") => true\n\t * @example\n\t * Crypto.verifyBech32(\"addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld\") => true\n     * @package\n\t * @param {string} addr\n\t * @returns {boolean}\n\t */\n\tstatic verifyBech32(addr) {\n\t\tconst data =[];\n\n\t\tconst i = addr.indexOf(\"1\");\n        \n\t\tif (i == -1 || i == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hrp = addr.slice(0, i);\n\n\t\taddr = addr.slice(i + 1);\n\n\t\tfor (let c of addr) {\n\t\t\tconst j = Crypto.BECH32_BASE32_ALPHABET.indexOf(c);\n\t\t\tif (j == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tdata.push(j);\n\t\t}\n\n\t\tconst chkSumA = data.slice(data.length - 6);\n\n\t\tconst chkSumB = Crypto.calcBech32Checksum(hrp, data.slice(0, data.length - 6));\n\n\t\tfor (let j = 0; j < 6; j++) {\n\t\t\tif (chkSumA[j] != chkSumB[j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Calculates sha2-256 (32bytes) hash of a list of uint8 numbers.\n\t * Result is also a list of uint8 number.\n\t * @example \n\t * bytesToHex(Crypto.sha2_256([0x61, 0x62, 0x63])) => \"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\"\n\t * @example\n\t * Crypto.sha2_256(textToBytes(\"Hello, World!\")) => [223, 253, 96, 33, 187, 43, 213, 176, 175, 103, 98, 144, 128, 158, 195, 165, 49, 145, 221, 129, 199, 247, 10, 75, 40, 104, 138, 54, 33, 130, 152, 111]\n     * @package\n\t * @param {number[]} bytes - list of uint8 numbers\n\t * @returns {number[]} - list of uint8 numbers\n\t */\n\tstatic sha2_256(bytes) {\n\t\t/**\n\t\t * Pad a bytearray so its size is a multiple of 64 (512 bits).\n\t\t * Internal method.\n\t\t * @param {number[]} src - list of uint8 numbers\n\t\t * @returns {number[]}\n\t\t */\n\t\tfunction pad(src) {\n\t\t\tconst nBits = src.length*8;\n\n\t\t\tconst dst = src.slice();\n\n\t\t\tdst.push(0x80);\n\n\t\t\tlet nZeroes = (64 - dst.length%64) - 8;\n\t\t\tif (nZeroes < 0) {\n\t\t\t\tnZeroes += 64;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < nZeroes; i++) {\n\t\t\t\tdst.push(0);\n\t\t\t}\n\n\t\t\t// assume nBits fits in 32 bits\n\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(imod8(nBits >> 24));\n\t\t\tdst.push(imod8(nBits >> 16));\n\t\t\tdst.push(imod8(nBits >> 8));\n\t\t\tdst.push(imod8(nBits >> 0));\n\t\t\t\n\t\t\treturn dst;\n\t\t}\n\n\t\t/**\n\t\t * @type {number[]} - 64 uint32 numbers\n\t\t */\n\t\tconst k = [\n\t\t\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t\t\t0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t\t\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t\t\t0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t\t\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t\t\t0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t\t\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t\t\t0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t\t\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t\t\t0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t\t\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t\t\t0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t\t\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t\t\t0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t\t\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t\t\t0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n\t\t];\n\n\t\t/**\n\t\t * Initial hash (updated during compression phase)\n\t\t * @type {number[]} - 8 uint32 number\n\t\t */\n\t\tconst hash = [\n\t\t\t0x6a09e667, \n\t\t\t0xbb67ae85, \n\t\t\t0x3c6ef372, \n\t\t\t0xa54ff53a, \n\t\t\t0x510e527f, \n\t\t\t0x9b05688c, \n\t\t\t0x1f83d9ab, \n\t\t\t0x5be0cd19,\n\t\t];\n\t\n\t\t/**\n\t\t * @param {number} x\n\t\t * @returns {number}\n\t\t */\n\t\tfunction sigma0(x) {\n\t\t\treturn irotr(x, 7) ^ irotr(x, 18) ^ (x >>> 3);\n\t\t}\n\n\t\t/**\n\t\t * @param {number} x\n\t\t * @returns {number}\n\t\t */\n\t\tfunction sigma1(x) {\n\t\t\treturn irotr(x, 17) ^ irotr(x, 19) ^ (x >>> 10);\n\t\t}\n\n\t\tbytes = pad(bytes);\n\n\t\t// break message in successive 64 byte chunks\n\t\tfor (let chunkStart = 0; chunkStart < bytes.length; chunkStart += 64) {\n\t\t\tconst chunk = bytes.slice(chunkStart, chunkStart + 64);\n\n\t\t\tconst w = (new Array(64)).fill(0); // array of 32 bit numbers!\n\n\t\t\t// copy chunk into first 16 positions of w\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tw[i] = (chunk[i*4 + 0] << 24) |\n\t\t\t\t\t   (chunk[i*4 + 1] << 16) |\n\t\t\t\t\t   (chunk[i*4 + 2] <<  8) |\n\t\t\t\t\t   (chunk[i*4 + 3]);\n\t\t\t}\n\n\t\t\t// extends the first 16 positions into the remaining 48 positions\n\t\t\tfor (let i = 16; i < 64; i++) {\n\t\t\t\tw[i] = imod32(w[i-16] + sigma0(w[i-15]) + w[i-7] + sigma1(w[i-2]));\n\t\t\t}\n\n\t\t\t// intialize working variables to current hash value\n\t\t\tlet a = hash[0];\n\t\t\tlet b = hash[1];\n\t\t\tlet c = hash[2];\n\t\t\tlet d = hash[3];\n\t\t\tlet e = hash[4];\n\t\t\tlet f = hash[5];\n\t\t\tlet g = hash[6];\n\t\t\tlet h = hash[7];\n\n\t\t\t// compression function main loop\n\t\t\tfor (let i = 0; i < 64; i++) {\n\t\t\t\tconst S1 = irotr(e, 6) ^ irotr(e, 11) ^ irotr(e, 25);\n\t\t\t\tconst ch = (e & f) ^ ((~e) & g);\n\t\t\t\tconst temp1 = imod32(h + S1 + ch + k[i] + w[i]);\n\t\t\t\tconst S0 = irotr(a, 2) ^ irotr(a, 13) ^ irotr(a, 22);\n\t\t\t\tconst maj = (a & b) ^ (a & c) ^ (b & c);\n\t\t\t\tconst temp2 = imod32(S0 + maj);\n\n\t\t\t\th = g;\n\t\t\t\tg = f;\n\t\t\t\tf = e;\n\t\t\t\te = imod32(d + temp1);\n\t\t\t\td = c;\n\t\t\t\tc = b;\n\t\t\t\tb = a;\n\t\t\t\ta = imod32(temp1 + temp2);\n\t\t\t}\n\n\t\t\t// update the hash\n\t\t\thash[0] = imod32(hash[0] + a);\n\t\t\thash[1] = imod32(hash[1] + b);\n\t\t\thash[2] = imod32(hash[2] + c);\n\t\t\thash[3] = imod32(hash[3] + d);\n\t\t\thash[4] = imod32(hash[4] + e);\n\t\t\thash[5] = imod32(hash[5] + f);\n\t\t\thash[6] = imod32(hash[6] + g);\n\t\t\thash[7] = imod32(hash[7] + h);\n\t\t}\n\n\t\t// produce the final digest of uint8 numbers\n\t\tconst result = [];\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tconst item = hash[i];\n\n\t\t\tresult.push(imod8(item >> 24));\n\t\t\tresult.push(imod8(item >> 16));\n\t\t\tresult.push(imod8(item >>  8));\n\t\t\tresult.push(imod8(item >>  0));\n\t\t}\n\t\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calculates sha2-512 (64bytes) hash of a list of uint8 numbers.\n\t * Result is also a list of uint8 number.\n\t * @example \n\t * bytesToHex(Crypto.sha2_512([0x61, 0x62, 0x63])) => \"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\"\n\t * @example \n\t * bytesToHex(Crypto.sha2_512([])) => \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n     * @package\n\t * @param {number[]} bytes - list of uint8 numbers\n\t * @returns {number[]} - list of uint8 numbers\n\t */\n\tstatic sha2_512(bytes) {\n\t\t/**\n\t\t * Pad a bytearray so its size is a multiple of 128 (1024 bits).\n\t\t * Internal method.\n\t\t * @param {number[]} src - list of uint8 numbers\n\t\t * @returns {number[]}\n\t\t */\n\t\tfunction pad(src) {\n\t\t\tconst nBits = src.length*8;\n\n\t\t\tconst dst = src.slice();\n\n\t\t\tdst.push(0x80);\n\n\t\t\tlet nZeroes = (128 - dst.length%128) - 8;\n\t\t\tif (nZeroes < 0) {\n\t\t\t\tnZeroes += 128;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < nZeroes; i++) {\n\t\t\t\tdst.push(0);\n\t\t\t}\n\n\t\t\t// assume nBits fits in 32 bits\n\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(0);\n\t\t\tdst.push(imod8(nBits >> 24));\n\t\t\tdst.push(imod8(nBits >> 16));\n\t\t\tdst.push(imod8(nBits >> 8));\n\t\t\tdst.push(imod8(nBits >> 0));\n\t\t\t\n\t\t\treturn dst;\n\t\t}\n\n\t\t/**\n\t\t * @type {UInt64[]} - 80 uint64 numbers\n\t\t */\n\t\tconst k = [\n\t\t\tnew UInt64(0x428a2f98, 0xd728ae22), new UInt64(0x71374491, 0x23ef65cd), \n\t\t\tnew UInt64(0xb5c0fbcf, 0xec4d3b2f), new UInt64(0xe9b5dba5, 0x8189dbbc),\n\t\t\tnew UInt64(0x3956c25b, 0xf348b538), new UInt64(0x59f111f1, 0xb605d019), \n\t\t\tnew UInt64(0x923f82a4, 0xaf194f9b), new UInt64(0xab1c5ed5, 0xda6d8118),\n\t\t\tnew UInt64(0xd807aa98, 0xa3030242), new UInt64(0x12835b01, 0x45706fbe), \n\t\t\tnew UInt64(0x243185be, 0x4ee4b28c), new UInt64(0x550c7dc3, 0xd5ffb4e2),\n\t\t\tnew UInt64(0x72be5d74, 0xf27b896f), new UInt64(0x80deb1fe, 0x3b1696b1), \n\t\t\tnew UInt64(0x9bdc06a7, 0x25c71235), new UInt64(0xc19bf174, 0xcf692694),\n\t\t\tnew UInt64(0xe49b69c1, 0x9ef14ad2), new UInt64(0xefbe4786, 0x384f25e3), \n\t\t\tnew UInt64(0x0fc19dc6, 0x8b8cd5b5), new UInt64(0x240ca1cc, 0x77ac9c65),\n\t\t\tnew UInt64(0x2de92c6f, 0x592b0275), new UInt64(0x4a7484aa, 0x6ea6e483), \n\t\t\tnew UInt64(0x5cb0a9dc, 0xbd41fbd4), new UInt64(0x76f988da, 0x831153b5),\n\t\t\tnew UInt64(0x983e5152, 0xee66dfab), new UInt64(0xa831c66d, 0x2db43210), \n\t\t\tnew UInt64(0xb00327c8, 0x98fb213f), new UInt64(0xbf597fc7, 0xbeef0ee4),\n\t\t\tnew UInt64(0xc6e00bf3, 0x3da88fc2), new UInt64(0xd5a79147, 0x930aa725), \n\t\t\tnew UInt64(0x06ca6351, 0xe003826f), new UInt64(0x14292967, 0x0a0e6e70),\n\t\t\tnew UInt64(0x27b70a85, 0x46d22ffc), new UInt64(0x2e1b2138, 0x5c26c926), \n\t\t\tnew UInt64(0x4d2c6dfc, 0x5ac42aed), new UInt64(0x53380d13, 0x9d95b3df),\n\t\t\tnew UInt64(0x650a7354, 0x8baf63de), new UInt64(0x766a0abb, 0x3c77b2a8), \n\t\t\tnew UInt64(0x81c2c92e, 0x47edaee6), new UInt64(0x92722c85, 0x1482353b),\n\t\t\tnew UInt64(0xa2bfe8a1, 0x4cf10364), new UInt64(0xa81a664b, 0xbc423001), \n\t\t\tnew UInt64(0xc24b8b70, 0xd0f89791), new UInt64(0xc76c51a3, 0x0654be30),\n\t\t\tnew UInt64(0xd192e819, 0xd6ef5218), new UInt64(0xd6990624, 0x5565a910), \n\t\t\tnew UInt64(0xf40e3585, 0x5771202a), new UInt64(0x106aa070, 0x32bbd1b8),\n\t\t\tnew UInt64(0x19a4c116, 0xb8d2d0c8), new UInt64(0x1e376c08, 0x5141ab53), \n\t\t\tnew UInt64(0x2748774c, 0xdf8eeb99), new UInt64(0x34b0bcb5, 0xe19b48a8),\n\t\t\tnew UInt64(0x391c0cb3, 0xc5c95a63), new UInt64(0x4ed8aa4a, 0xe3418acb), \n\t\t\tnew UInt64(0x5b9cca4f, 0x7763e373), new UInt64(0x682e6ff3, 0xd6b2b8a3),\n\t\t\tnew UInt64(0x748f82ee, 0x5defb2fc), new UInt64(0x78a5636f, 0x43172f60), \n\t\t\tnew UInt64(0x84c87814, 0xa1f0ab72), new UInt64(0x8cc70208, 0x1a6439ec),\n\t\t\tnew UInt64(0x90befffa, 0x23631e28), new UInt64(0xa4506ceb, 0xde82bde9), \n\t\t\tnew UInt64(0xbef9a3f7, 0xb2c67915), new UInt64(0xc67178f2, 0xe372532b),\n\t\t\tnew UInt64(0xca273ece, 0xea26619c), new UInt64(0xd186b8c7, 0x21c0c207), \n\t\t\tnew UInt64(0xeada7dd6, 0xcde0eb1e), new UInt64(0xf57d4f7f, 0xee6ed178),\n\t\t\tnew UInt64(0x06f067aa, 0x72176fba), new UInt64(0x0a637dc5, 0xa2c898a6), \n\t\t\tnew UInt64(0x113f9804, 0xbef90dae), new UInt64(0x1b710b35, 0x131c471b),\n\t\t\tnew UInt64(0x28db77f5, 0x23047d84), new UInt64(0x32caab7b, 0x40c72493), \n\t\t\tnew UInt64(0x3c9ebe0a, 0x15c9bebc), new UInt64(0x431d67c4, 0x9c100d4c),\n\t\t\tnew UInt64(0x4cc5d4be, 0xcb3e42b6), new UInt64(0x597f299c, 0xfc657e2a), \n\t\t\tnew UInt64(0x5fcb6fab, 0x3ad6faec), new UInt64(0x6c44198c, 0x4a475817),\n\t\t];\n\n\t\t/**\n\t\t * Initial hash (updated during compression phase)\n\t\t * @type {UInt64[]} - 8 uint64 numbers\n\t\t */\n\t\tconst hash = [\n\t\t\tnew UInt64(0x6a09e667, 0xf3bcc908),\n\t\t\tnew UInt64(0xbb67ae85, 0x84caa73b),\n\t\t\tnew UInt64(0x3c6ef372, 0xfe94f82b),\n\t\t\tnew UInt64(0xa54ff53a, 0x5f1d36f1),\n\t\t\tnew UInt64(0x510e527f, 0xade682d1),\n\t\t\tnew UInt64(0x9b05688c, 0x2b3e6c1f),\n\t\t\tnew UInt64(0x1f83d9ab, 0xfb41bd6b),\n\t\t\tnew UInt64(0x5be0cd19, 0x137e2179),\n\t\t];\n\t\n\t\t/**\n\t\t * @param {UInt64} x\n\t\t * @returns {UInt64} \n\t\t */\n\t\tfunction sigma0(x) {\n\t\t\treturn x.rotr(1).xor(x.rotr(8)).xor(x.shiftr(7));\n\t\t}\n\n\t\t/**\n\t\t * @param {UInt64} x\n\t\t * @returns {UInt64}\n\t\t */\n\t\tfunction sigma1(x) {\n\t\t\treturn x.rotr(19).xor(x.rotr(61)).xor(x.shiftr(6));\n\t\t}\n\n\t\tbytes = pad(bytes);\n\n\t\t// break message in successive 64 byte chunks\n\t\tfor (let chunkStart = 0; chunkStart < bytes.length; chunkStart += 128) {\n\t\t\tconst chunk = bytes.slice(chunkStart, chunkStart + 128);\n\n\t\t\tconst w = (new Array(80)).fill(UInt64.zero()); // array of 32 bit numbers!\n\n\t\t\t// copy chunk into first 16 hi/lo positions of w (i.e. into first 32 uint32 positions)\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tw[i] = UInt64.fromBytes(chunk.slice(i*8, i*8 + 8), false);\n\t\t\t}\n\n\t\t\t// extends the first 16 positions into the remaining 80 positions\n\t\t\tfor (let i = 16; i < 80; i++) {\n\t\t\t\tw[i] = sigma1(w[i-2]).add(w[i-7]).add(sigma0(w[i-15])).add(w[i-16]);\n\t\t\t}\n\n\t\t\t// intialize working variables to current hash value\n\t\t\tlet a = hash[0];\n\t\t\tlet b = hash[1];\n\t\t\tlet c = hash[2];\n\t\t\tlet d = hash[3];\n\t\t\tlet e = hash[4];\n\t\t\tlet f = hash[5];\n\t\t\tlet g = hash[6];\n\t\t\tlet h = hash[7];\n\n\t\t\t// compression function main loop\n\t\t\tfor (let i = 0; i < 80; i++) {\n\t\t\t\tconst S1 = e.rotr(14).xor(e.rotr(18)).xor(e.rotr(41));\n\t\t\t\tconst ch = e.and(f).xor(e.not().and(g));\n\t\t\t\tconst temp1 = h.add(S1).add(ch).add(k[i]).add(w[i]);\n\t\t\t\tconst S0 = a.rotr(28).xor(a.rotr(34)).xor(a.rotr(39));\n\t\t\t\tconst maj = a.and(b).xor(a.and(c)).xor(b.and(c));\n\t\t\t\tconst temp2 = S0.add(maj);\n\n\t\t\t\th = g;\n\t\t\t\tg = f;\n\t\t\t\tf = e;\n\t\t\t\te = d.add(temp1);\n\t\t\t\td = c;\n\t\t\t\tc = b;\n\t\t\t\tb = a;\n\t\t\t\ta = temp1.add(temp2);\n\t\t\t}\n\n\t\t\t// update the hash\n\t\t\thash[0] = hash[0].add(a);\n\t\t\thash[1] = hash[1].add(b);\n\t\t\thash[2] = hash[2].add(c);\n\t\t\thash[3] = hash[3].add(d);\n\t\t\thash[4] = hash[4].add(e);\n\t\t\thash[5] = hash[5].add(f);\n\t\t\thash[6] = hash[6].add(g);\n\t\t\thash[7] = hash[7].add(h);\n\t\t}\n\n\t\t// produce the final digest of uint8 numbers\n\t\tlet result = [];\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tconst item = hash[i];\n\n\t\t\tresult = result.concat(item.toBytes(false));\n\t\t}\n\t\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calculates sha3-256 (32bytes) hash of a list of uint8 numbers.\n\t * Result is also a list of uint8 number.\n\t * Sha3 only bit-wise operations, so 64-bit operations can easily be replicated using 2 32-bit operations instead\n\t * @example\n\t * bytesToHex(Crypto.sha3(textToBytes(\"abc\"))) => \"3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532\"\n\t * @example\n\t * bytesToHex(Crypto.sha3((new Array(136)).fill(1))) => \"b36dc2167c4d9dda1a58b87046c8d76a6359afe3612c4de8a38857e09117b2db\"\n\t * @example\n\t * bytesToHex(Crypto.sha3((new Array(135)).fill(2))) => \"5bdf5d815d29a9d7161c66520efc17c2edd7898f2b99a029e8d2e4ff153407f4\"\n\t * @example\n\t * bytesToHex(Crypto.sha3((new Array(134)).fill(3))) => \"8e6575663dfb75a88f94a32c5b363c410278b65020734560d968aadd6896a621\"\n\t * @example\n\t * bytesToHex(Crypto.sha3((new Array(137)).fill(4))) => \"f10b39c3e455006aa42120b9751faa0f35c821211c9d086beb28bf3c4134c6c6\"\n     * @package\n\t * @param {number[]} bytes - list of uint8 numbers\n\t * @returns {number[]} - list of uint8 numbers\n\t */\n\tstatic sha3(bytes) {\n\t\t/**\n\t\t * @type {number} - state width (1600 bits, )\n\t\t */\n\t\tconst WIDTH = 200;\n\n\t\t/**\n\t\t * @type {number} - rate (1088 bits, 136 bytes)\n\t\t */\n\t\tconst RATE = 136;\n\n\t\t/**\n\t\t * @type {number} - capacity\n\t\t */\n\t\tconst CAP = WIDTH - RATE;\n\n\t\t/**\n\t\t * Apply 1000...1 padding until size is multiple of r.\n\t\t * If already multiple of r then add a whole block of padding.\n\t\t * @param {number[]} src - list of uint8 numbers\n\t\t * @returns {number[]} - list of uint8 numbers\n\t\t */\n\t\tfunction pad(src) {\n\t\t\tconst dst = src.slice();\n\n\t\t\t/** @type {number} */\n\t\t\tlet nZeroes = RATE - 2 - (dst.length%RATE);\n\t\t\tif (nZeroes < -1) {\n\t\t\t\tnZeroes += RATE - 2;\n\t\t\t}\n\n\t\t\tif (nZeroes == -1) {\n\t\t\t\tdst.push(0x86);\n\t\t\t} else {\n\t\t\t\tdst.push(0x06);\n\n\t\t\t\tfor (let i = 0; i < nZeroes; i++) {\n\t\t\t\t\tdst.push(0);\n\t\t\t\t}\n\n\t\t\t\tdst.push(0x80);\n\t\t\t}\n\n\t\t\tassert(dst.length%RATE == 0);\n\t\t\t\n\t\t\treturn dst;\n\t\t}\n\n\t\t/**\n\t\t * 24 numbers used in the sha3 permute function\n\t\t * @type {number[]}\n\t\t */\n\t\tconst OFFSETS = [6, 12, 18, 24, 3, 9, 10, 16, 22, 1, 7, 13, 19, 20, 4, 5, 11, 17, 23, 2, 8, 14, 15, 21];\n\n\t\t/**\n\t\t * 24 numbers used in the sha3 permute function\n\t\t * @type {number[]}\n\t\t */\n\t\tconst SHIFTS = [-12, -11, 21, 14, 28, 20, 3, -13, -29, 1, 6, 25, 8, 18, 27, -4, 10, 15, -24, -30, -23, -7, -9, 2];\n\n\t\t/**\n\t\t * Round constants used in the sha3 permute function\n\t\t * @type {UInt64[]} \n\t\t */\n\t\tconst RC = [\n\t\t\tnew UInt64(0x00000000, 0x00000001) , \n\t\t\tnew UInt64(0x00000000, 0x00008082) , \n\t\t\tnew UInt64(0x80000000, 0x0000808a) ,\n\t\t\tnew UInt64(0x80000000, 0x80008000) ,\n\t\t\tnew UInt64(0x00000000, 0x0000808b) ,\n\t\t\tnew UInt64(0x00000000, 0x80000001) ,\n\t\t\tnew UInt64(0x80000000, 0x80008081) ,\n\t\t\tnew UInt64(0x80000000, 0x00008009) ,\n\t\t\tnew UInt64(0x00000000, 0x0000008a) ,\n\t\t\tnew UInt64(0x00000000, 0x00000088) ,\n\t\t\tnew UInt64(0x00000000, 0x80008009) ,\n\t\t\tnew UInt64(0x00000000, 0x8000000a) ,\n\t\t\tnew UInt64(0x00000000, 0x8000808b) ,\n\t\t\tnew UInt64(0x80000000, 0x0000008b) ,\n\t\t\tnew UInt64(0x80000000, 0x00008089) ,\n\t\t\tnew UInt64(0x80000000, 0x00008003) ,\n\t\t\tnew UInt64(0x80000000, 0x00008002) ,\n\t\t\tnew UInt64(0x80000000, 0x00000080) ,\n\t\t\tnew UInt64(0x00000000, 0x0000800a) ,\n\t\t\tnew UInt64(0x80000000, 0x8000000a) ,\n\t\t\tnew UInt64(0x80000000, 0x80008081) ,\n\t\t\tnew UInt64(0x80000000, 0x00008080) ,\n\t\t\tnew UInt64(0x00000000, 0x80000001) ,\n\t\t\tnew UInt64(0x80000000, 0x80008008) ,\n\t\t];\n\t\t\n\t\t/**\n\t\t * @param {UInt64[]} s \n\t\t */\n\t\tfunction permute(s) {\t\n\t\t\t/**\n\t\t\t * @type {UInt64[]}\n\t\t\t */\t\t\n\t\t\tconst c = new Array(5);\n\n\t\t\t/**\n\t\t\t * @type {UInt64[]}\n\t\t\t */\n\t\t\tconst b = new Array(25);\n\t\t\t\n\t\t\tfor (let round = 0; round < 24; round++) {\n\t\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\t\tc[i] = s[i].xor(s[i+5]).xor(s[i+10]).xor(s[i+15]).xor(s[i+20]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\t\tconst i1 = (i+1)%5;\n\t\t\t\t\tconst i2 = (i+4)%5;\n\n\t\t\t\t\tconst tmp = c[i2].xor(c[i1].rotr(63));\n\n\t\t\t\t\tfor (let j = 0; j < 5; j++) {\n\t\t\t\t\t\ts[i+5*j] = s[i+5*j].xor(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tb[0] = s[0];\n\n\t\t\t\tfor(let i = 1; i < 25; i++) {\n\t\t\t\t\tconst offset = OFFSETS[i-1];\n\n\t\t\t\t\tconst left = Math.abs(SHIFTS[i-1]);\n\t\t\t\t\tconst right = 32 - left;\n\n\t\t\t\t\tif (SHIFTS[i-1] < 0) {\n\t\t\t\t\t\tb[i] = s[offset].rotr(right);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb[i] = s[offset].rotr(right + 32);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\t\tfor (let j = 0; j < 5; j++) {\n\t\t\t\t\t\ts[i*5+j] = b[i*5+j].xor(b[i*5 + (j+1)%5].not().and(b[i*5 + (j+2)%5]))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ts[0] = s[0].xor(RC[round]);\n\t\t\t}\n\t\t}\n\n\t\tbytes = pad(bytes);\n\n\t\t// initialize the state\n\t\t/**\n\t\t * @type {UInt64[]}\n\t\t */\n\t\tconst state = (new Array(WIDTH/8)).fill(UInt64.zero());\n\n\t\tfor (let chunkStart = 0; chunkStart < bytes.length; chunkStart += RATE) {\n\t\t\t// extend the chunk to become length WIDTH\n\t\t\tconst chunk = bytes.slice(chunkStart, chunkStart + RATE).concat((new Array(CAP)).fill(0));\n\n\t\t\t// element-wise xor with 'state'\n\t\t\tfor (let i = 0; i < WIDTH; i += 8) {\n\t\t\t\tstate[i/8] = state[i/8].xor(UInt64.fromBytes(chunk.slice(i, i+8)));\n\n\t\t\t\t// beware: a uint32 is stored as little endian, but a pair of uint32s that form a uin64 are stored in big endian format!\n\t\t\t}\n\n\t\t\t// apply block permutations\n\t\t\tpermute(state);\n\t\t}\n\n\t\t/** @type {number[]} */\n\t\tlet hash = [];\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\thash = hash.concat(state[i].toBytes());\n\t\t}\n\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Calculates blake2b hash of a list of uint8 numbers (variable digest size).\n\t * Result is also a list of uint8 number.\n\t * Blake2b is a 64bit algorithm, so we need to be careful when replicating 64-bit operations with 2 32-bit numbers (low-word overflow must spill into high-word, and shifts must go over low/high boundary)\n\t * @example                                        \n\t * bytesToHex(Crypto.blake2b([0, 1])) => \"01cf79da4945c370c68b265ef70641aaa65eaa8f5953e3900d97724c2c5aa095\"\n\t * @example\n\t * bytesToHex(Crypto.blake2b(textToBytes(\"abc\"), 64)) => \"ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d17d87c5392aab792dc252d5de4533cc9518d38aa8dbf1925ab92386edd4009923\"\n     * @package\n\t * @param {number[]} bytes \n\t * @param {number} digestSize - at most 64\n\t * @returns {number[]}\n\t */\n\tstatic blake2b(bytes, digestSize = BLAKE2B_DIGEST_SIZE) {\n\t\t/**\n\t\t * 128 bytes (16*8 byte words)\n\t\t * @type {number}\n\t\t */\n\t\tconst WIDTH = 128;\n\n\t\t/**\n\t\t * Initialization vector\n\t\t */\n\t\tconst IV = [\n\t\t\tnew UInt64(0x6a09e667, 0xf3bcc908), \n\t\t\tnew UInt64(0xbb67ae85, 0x84caa73b),\n\t\t\tnew UInt64(0x3c6ef372, 0xfe94f82b), \n\t\t\tnew UInt64(0xa54ff53a, 0x5f1d36f1),\n\t\t\tnew UInt64(0x510e527f, 0xade682d1),\n\t\t\tnew UInt64(0x9b05688c, 0x2b3e6c1f),\n\t\t\tnew UInt64(0x1f83d9ab, 0xfb41bd6b), \n\t\t\tnew UInt64(0x5be0cd19, 0x137e2179), \n\t\t];\n\n\t\tconst SIGMA = [\n\t\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n\t\t\t[14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n\t\t\t[11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n\t\t\t[7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n\t\t\t[9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n\t\t\t[2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],\n\t\t\t[12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],\n\t\t\t[13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],\n\t\t\t[6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],\n\t\t\t[10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],\n\t\t];\n\n\t\t/**\n\t\t * @param {number[]} src - list of uint8 bytes\n\t\t * @returns {number[]} - list of uint8 bytes\n\t\t */\n\t\tfunction pad(src) {\n\t\t\tconst dst = src.slice();\n\n\t\t\tconst nZeroes = dst.length == 0 ? WIDTH : (WIDTH - dst.length%WIDTH)%WIDTH;\n\n\t\t\t// just padding with zeroes, the actual message length is used during compression stage of final block in order to uniquely hash messages of different lengths\n\t\t\tfor (let i = 0; i < nZeroes; i++) {\n\t\t\t\tdst.push(0);\n\t\t\t}\n\t\t\t\n\t\t\treturn dst;\n\t\t}\n\n\t\t/**\n\t\t * @param {UInt64[]} v\n\t\t * @param {UInt64[]} chunk\n\t\t * @param {number} a - index\n\t\t * @param {number} b - index\n\t\t * @param {number} c - index\n\t\t * @param {number} d - index\n\t\t * @param {number} i - index in chunk for low word 1\n\t\t * @param {number} j - index in chunk for low word 2\n\t\t */\n\t\tfunction mix(v, chunk, a, b, c, d, i, j) {\n\t\t\tconst x = chunk[i];\n\t\t\tconst y = chunk[j];\n\n\t\t\tv[a] = v[a].add(v[b]).add(x);\n\t\t\tv[d] = v[d].xor(v[a]).rotr(32);\n\t\t\tv[c] = v[c].add(v[d]);\n\t\t\tv[b] = v[b].xor(v[c]).rotr(24);\n\t\t\tv[a] = v[a].add(v[b]).add(y);\n\t\t\tv[d] = v[d].xor(v[a]).rotr(16);\n\t\t\tv[c] = v[c].add(v[d]);\n\t\t\tv[b] = v[b].xor(v[c]).rotr(63);\n\t\t}\n\n\t\t/**\n\t\t * @param {UInt64[]} h - state vector\n\t\t * @param {UInt64[]} chunk\n\t\t * @param {number} t - chunkEnd (expected to fit in uint32)\n\t\t * @param {boolean} last\n\t\t */\n\t\tfunction compress(h, chunk, t, last) {\n\t\t\t// work vectors\n\t\t\tconst v = h.slice().concat(IV.slice());\n\n\t\t\tv[12] = v[12].xor(new UInt64(0, imod32(t))); // v[12].high unmodified\n\t\t\t// v[13] unmodified\n\n\t\t\tif (last) {\n\t\t\t\tv[14] = v[14].xor(new UInt64(0xffffffff, 0xffffffff));\n\t\t\t}\n\n\t\t\tfor (let round = 0; round < 12; round++) {\n\t\t\t\tconst s = SIGMA[round%10];\n\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tmix(v, chunk, i, i+4, i+8, i+12, s[i*2], s[i*2+1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tmix(v, chunk, i, (i+1)%4 + 4, (i+2)%4 + 8, (i+3)%4 + 12, s[8+i*2], s[8 + i*2 + 1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\th[i] = h[i].xor(v[i].xor(v[i+8]));\n\t\t\t}\t\t\n\t\t}\n \n\t\tconst nBytes = bytes.length;\n\n\t\tbytes = pad(bytes);\n\n\t\t// init hash vector\n\t\tconst h = IV.slice();\n\t\t\n\n\t\t// setup the param block\n\t\tconst paramBlock = new Uint8Array(64);\n\t\tparamBlock[0] = digestSize; // n output  bytes\n\t\tparamBlock[1] = 0; // key-length (always zero in our case) \n\t\tparamBlock[2] = 1; // fanout\n\t\tparamBlock[3] = 1; // depth\n\n\t\t//mix in the parameter block\n\t\tconst paramBlockView = new DataView(paramBlock.buffer);\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\th[i] = h[i].xor(new UInt64(\n\t\t\t\tparamBlockView.getUint32(i*8+4, true),\n\t\t\t\tparamBlockView.getUint32(i*8, true),\n\t\t\t));\n\t\t}\n\t\t\n\t\t// loop all chunks\n\t\tfor (let chunkStart = 0; chunkStart < bytes.length; chunkStart += WIDTH) {\n\t\t\tconst chunkEnd = chunkStart + WIDTH; // exclusive\n\t\t\tconst chunk = bytes.slice(chunkStart, chunkStart + WIDTH);\n\n\t\t\tconst chunk64 = new Array(WIDTH/8);\n\t\t\tfor (let i = 0; i < WIDTH; i += 8) {\n\t\t\t\tchunk64[i/8] = UInt64.fromBytes(chunk.slice(i, i+8));\n\t\t\t}\n\t\t\t\n\t\t\tif (chunkStart == bytes.length - WIDTH) {\n\t\t\t\t// last block\n\t\t\t\tcompress(h, chunk64, nBytes, true);\n\t\t\t} else {\n\t\t\t\tcompress(h, chunk64, chunkEnd, false);\n\t\t\t}\n\t\t}\n\n\t\t// extract lowest BLAKE2B_DIGEST_SIZE bytes from h\n\n\t\t/** @type {number[]} */\n\t\tlet hash = [];\n\t\tfor (let i = 0; i < digestSize/8; i++) {\n\t\t\thash = hash.concat(h[i].toBytes());\n\t\t}\n\n\t\treturn hash.slice(0, digestSize);\n\t}\n\n\t/**\n\t * Crypto.Ed25519 exports the following functions:\n\t *  * Crypto.Ed25519.derivePublicKey(privateKey)\n\t *  * Crypto.Ed25519.sign(message, privateKey)\n\t *  * Crypto.Ed25519.verify(message, signature, publicKey)\n\t * \n\t * This is implementation is slow (~0.5s per verification), but should be good enough for simple client-side usage\n\t * \n\t * Ported from: https://ed25519.cr.yp.to/python/ed25519.py\n     * @package\n\t */\n\tstatic get Ed25519() {\n\t\tconst Q = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // ipowi(255n) - 19n\n\t\tconst Q38 = 7237005577332262213973186563042994240829374041602535252466099000494570602494n; // (Q + 3n)/8n\n\t\tconst CURVE_ORDER = 7237005577332262213973186563042994240857116359379907606001950938285454250989n; // ipow2(252n) + 27742317777372353535851937790883648493n;\n\t\tconst D = -4513249062541557337682894930092624173785641285191125241628941591882900924598840740n; // -121665n * invert(121666n);\n\t\tconst I = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // expMod(2n, (Q - 1n)/4n, Q);\n\t\t\n\t\t/**\n\t\t * @type {[bigint, bigint]}\n\t\t */\n\t\tconst BASE = [\n\t\t\t15112221349535400772501151409588531511454012693041857206046113283949847762202n, // recoverX(B[1]) % Q\n\t\t\t46316835694926478169428394003475163141307993866256225615783033603165251855960n, // (4n*invert(5n)) % Q\n\t\t];\n\n\t\t/**\n\t\t * @param {bigint} b \n\t\t * @param {bigint} e \n\t\t * @param {bigint} m \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction expMod(b, e, m) {\n\t\t\tif (e == 0n) {\n\t\t\t\treturn 1n;\n\t\t\t} else {\n\t\t\t\tlet t = expMod(b, e/2n, m);\n\t\t\t\tt = (t*t) % m;\n\n\t\t\t\tif ((e % 2n) != 0n) {\n\t\t\t\t\tt = posMod(t*b, m)\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {bigint} n \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction invert(n) {\n\t\t\tlet a = posMod(n, Q);\n\t\t\tlet b = Q;\n\n\t\t\tlet x = 0n;\n\t\t\tlet y = 1n;\n\t\t\tlet u = 1n;\n\t\t\tlet v = 0n;\n\n\t\t\twhile (a !== 0n) {\n\t\t\t\tconst q = b / a;\n\t\t\t\tconst r = b % a;\n\t\t\t\tconst m = x - u*q;\n\t\t\t\tconst n = y - v*q;\n\t\t\t\tb = a;\n\t\t\t\ta = r;\n\t\t\t\tx = u;\n\t\t\t\ty = v;\n\t\t\t\tu = m;\n\t\t\t\tv = n;\n\t\t\t}\n\n\t\t\treturn posMod(x, Q)\n\t\t}\n\n\t\t/**\n\t\t * @param {bigint} y \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction recoverX(y) {\n\t\t\tconst yy = y*y;\n\t\t\tconst xx = (yy - 1n) * invert(D*yy + 1n);\n\t\t\tlet x = expMod(xx, Q38, Q);\n\n\t\t\tif (((x*x - xx) % Q) != 0n) {\n\t\t\t\tx = (x*I) % Q;\n\t\t\t}\n\n\t\t\tif ((x%2n) != 0n) {\n\t\t\t\tx = Q - x;\n\t\t\t}\n\n\t\t\treturn x;\n\t\t}\t\t\n\n\t\t/**\n\t\t * Curve point 'addition'\n\t\t * Note: this is probably the bottleneck of this Ed25519 implementation\n\t\t * @param {[bigint, bigint]} a \n\t\t * @param {[bigint, bigint]} b \n\t\t * @returns {[bigint, bigint]}\n\t\t */\n\t\tfunction edwards(a, b) {\n\t\t\tconst x1 = a[0];\n\t\t\tconst y1 = a[1];\n\t\t\tconst x2 = b[0];\n\t\t\tconst y2 = b[1];\n\t\t\tconst dxxyy = D*x1*x2*y1*y2;\n\t\t\tconst x3 = (x1*y2+x2*y1) * invert(1n+dxxyy);\n\t\t\tconst y3 = (y1*y2+x1*x2) * invert(1n-dxxyy);\n\t\t\treturn [posMod(x3, Q), posMod(y3, Q)];\n\t\t}\n\n\t\t/**\n\t\t * @param {[bigint, bigint]} point \n\t\t * @param {bigint} n \n\t\t * @returns {[bigint, bigint]}\n\t\t */\n\t\tfunction scalarMul(point, n) {\n\t\t\tif (n == 0n) {\n\t\t\t\treturn [0n, 1n];\n\t\t\t} else {\n\t\t\t\tlet sum = scalarMul(point, n/2n);\n\t\t\t\tsum = edwards(sum, sum);\n\t\t\t\tif ((n % 2n) != 0n) {\n\t\t\t\t\tsum = edwards(sum, point);\n\t\t\t\t}\n\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Curve point 'multiplication'\n\t\t * @param {bigint} y \n\t\t * @returns {number[]}\n\t\t */\n\t\tfunction encodeInt(y) {\n\t\t\tconst bytes = bigIntToBytes(y).reverse();\n\t\t\t\n\t\t\twhile (bytes.length < 32) {\n\t\t\t\tbytes.push(0);\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t}\n\n\t\t/**\n\t\t * @param {number[]} s \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction decodeInt(s) {\n\t\t\treturn bytesToBigInt(s.reverse());\n\t\t}\n\n\t\t/**\n\t\t * @param {[bigint, bigint]} point\n\t\t * @returns {number[]}\n\t\t */\n\t\tfunction encodePoint(point) {\n\t\t\tconst [x, y] = point;\n\n\t\t\tconst bytes = encodeInt(y);\n\n\t\t\t// last bit is determined by x\n\n\t\t\tbytes[31] = (bytes[31] & 0b011111111) | (Number(x & 1n) * 0b10000000);\n\n\t\t\treturn bytes;\n\t\t}\n\n\t\t/**\n\t\t * @param {number[]} bytes \n\t\t * @param {number} i - bit index\n\t\t * @returns {number} - 0 or 1\n\t\t */\n\t\tfunction getBit(bytes, i) {\n\t\t\treturn (bytes[Math.floor(i/8)] >> i%8) & 1\n\t\t}\n\n\t\t/**\n\t\t * @param {[bigint, bigint]} point\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction isOnCurve(point) {\n\t\t\tconst x = point[0];\n\t\t\tconst y = point[1];\n\t\t\tconst xx = x*x;\n\t\t\tconst yy = y*y;\n\t\t\treturn (-xx + yy - 1n - D*xx*yy) % Q == 0n;\n\t\t}\n\n\t\t/**\n\t\t * @param {number[]} s \n\t\t */\n\t\tfunction decodePoint(s) {\n\t\t\tassert(s.length == 32);\n\n\t\t\tconst bytes = s.slice();\n\t\t\tbytes[31] = bytes[31] & 0b01111111;\n\n\t\t\tconst y = decodeInt(bytes);\n\n\t\t\tlet x = recoverX(y);\n\t\t\tif (Number(x & 1n) != getBit(s, 255)) {\n\t\t\t\tx = Q - x;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {[bigint, bigint]}\n\t\t\t */\n\t\t\tconst point = [x, y];\n\n\t\t\tif (!isOnCurve(point)) {\n\t\t\t\tthrow new Error(\"point isn't on curve\");\n\t\t\t}\n\n\t\t\treturn point;\n\t\t}\n\n\t\t/**\n\t\t * Couldn't think of a proper name for this function\n\t\t * @param {number[]} h \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction calca(h) {\n\t\t\tconst a = 28948022309329048855892746252171976963317496166410141009864396001978282409984n; // ipow2(253)\n\n\t\t\tconst bytes = h.slice(0, 32);\n\t\t\tbytes[0] = bytes[0] & 0b11111000;\n\t\t\tbytes[31] = bytes[31] & 0b00111111;\n\n\t\t\tconst x = bytesToBigInt(bytes.reverse());\n\t\t\treturn a + x;\n\t\t}\n\n\t\t/**\n\t\t * @param {number[]} m \n\t\t * @returns {bigint}\n\t\t */\n\t\tfunction ihash(m) {\n\t\t\tconst h = Crypto.sha2_512(m);\n\n\t\t\treturn decodeInt(h);\n\t\t}\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * @param {number[]} privateKey \n\t\t\t * @returns {number[]}\n\t\t\t */\n\t\t\tderivePublicKey: function(privateKey) {\n\t\t\t\tconst privateKeyHash = Crypto.sha2_512(privateKey);\n\t\t\t\tconst a = calca(privateKeyHash);\n\t\t\t\tconst A = scalarMul(BASE, a);\n\n\t\t\t\treturn encodePoint(A);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {number[]} message \n\t\t\t * @param {number[]} privateKey \n\t\t\t * @returns {number[]}\n\t\t\t */\n\t\t\tsign: function(message, privateKey) {\n\t\t\t\tconst privateKeyHash = Crypto.sha2_512(privateKey);\n\t\t\t\tconst a = calca(privateKeyHash);\n\n\t\t\t\t// for convenience calculate publicKey here:\n\t\t\t\tconst publicKey = encodePoint(scalarMul(BASE, a));\n\n\t\t\t\tconst r = ihash(privateKeyHash.slice(32, 64).concat(message));\n\t\t\t\tconst R = scalarMul(BASE, r);\n\t\t\t\tconst S = posMod(r + ihash(encodePoint(R).concat(publicKey).concat(message))*a, CURVE_ORDER);\n\n\t\t\t\treturn encodePoint(R).concat(encodeInt(S));\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {number[]} signature \n\t\t\t * @param {number[]} message \n\t\t\t * @param {number[]} publicKey \n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tverify: function(signature, message, publicKey) {\n\t\t\t\tif (signature.length != 64) {\n\t\t\t\t\tthrow new Error(`unexpected signature length ${signature.length}`);\n\t\t\t\t}\n\t\n\t\t\t\tif (publicKey.length != 32) {\n\t\t\t\t\tthrow new Error(`unexpected publickey length ${publicKey.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst R = decodePoint(signature.slice(0, 32));\n\t\t\t\tconst A = decodePoint(publicKey);\n\t\t\t\tconst S = decodeInt(signature.slice(32, 64));\n\t\t\t\tconst h = ihash(signature.slice(0, 32).concat(publicKey).concat(message));\n\n\t\t\t\tconst left = scalarMul(BASE, S);\n\t\t\t\tconst right = edwards(R, scalarMul(A, h));\n\n\t\t\t\treturn (left[0] == right[0]) && (left[1] == right[1]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//////////////////////////////////\n// Section 5: Cbor encoder/decoder\n//////////////////////////////////\n\n/**\n * @typedef {(i: number, bytes: number[]) => void} Decoder\n */\n\n/**\n * Base class of any Cbor serializable data class\n * Also contains helper methods for (de)serializing data to/from Cbor\n */\nclass CborData {\n\tconstructor() {\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {number} m - major type\n\t * @param {bigint} n - size parameter\n\t * @returns {number[]} - uint8 bytes\n\t */\n\tstatic encodeHead(m, n) {\n\t\tif (n <= 23n) {\n\t\t\treturn [32*m + Number(n)];\n\t\t} else if (n >= 24n && n <= 255n) {\n\t\t\treturn [32*m + 24, Number(n)];\n\t\t} else if (n >= 256n && n <= 256n*256n - 1n) {\n\t\t\treturn [32*m + 25, Number((n/256n)%256n), Number(n%256n)];\n\t\t} else if (n >= 256n*256n && n <= 256n*256n*256n*256n - 1n) {\n\t\t\tlet e4 = bigIntToBytes(n);\n\n\t\t\twhile (e4.length < 4) {\n\t\t\t\te4.unshift(0);\n\t\t\t}\n\t\t\treturn [32*m + 26].concat(e4);\n\t\t} else if (n >= 256n*256n*256n*256n && n <= 256n*256n*256n*256n*256n*256n*256n*256n - 1n) {\n\t\t\tlet e8 = bigIntToBytes(n);\n\n\t\t\twhile(e8.length < 8) {\n\t\t\t\te8.unshift(0);\n\t\t\t}\n\t\t\treturn [32*m + 27].concat(e8);\n\t\t} else {\n\t\t\tthrow new Error(\"n out of range\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes - mutated to contain the rest\n\t * @returns {[number, bigint]} - [majorType, n]\n\t */\n\tstatic decodeHead(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor head\");\n\t\t}\n\n\t\tlet first = assertDefined(bytes.shift());\n\n\t\tif (first%32 <= 23) {\n\t\t\treturn [idiv(first, 32), BigInt(first%32)];\n\t\t} else if (first%32 == 24) {\n\t\t\treturn [idiv(first, 32), bytesToBigInt(bytes.splice(0, 1))];\n\t\t} else if (first%32 == 25) {\n\t\t\treturn [idiv(first, 32), bytesToBigInt(bytes.splice(0, 2))];\n\t\t} else if (first%32 == 26) {\n\t\t\treturn [idiv(first, 32), bytesToBigInt(bytes.splice(0, 4))];\n\t\t} else if (first%32 == 27) {\n\t\t\treturn [idiv(first, 32), bytesToBigInt(bytes.splice(0, 8))];\n\t\t} else {\n\t\t\tthrow new Error(\"bad header\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} m\n\t * @returns {number[]}\n\t */\n\tstatic encodeIndefHead(m) {\n\t\treturn [32*m + 31];\n\t}\n\n\t/**\n\t * @param {number[]} bytes - cbor bytes\n\t * @returns {number} - majorType\n\t */\n\tstatic decodeIndefHead(bytes) {\n\t\tlet first = assertDefined(bytes.shift());\n\n\t\tlet m = idiv(first - 31, 32);\n\n\t\treturn m;\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isNull(bytes) {\n\t\treturn bytes[0] == 246;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\tstatic encodeNull() {\n\t\treturn [246];\n\t}\n\n\t/**\n\t * Throws error if not null\n\t * @param {number[]} bytes\n\t */\n\tstatic decodeNull(bytes) {\n\t\tlet b = assertDefined(bytes.shift());\n\n\t\tif (b != 246) {\n\t\t\tthrow new Error(\"not null\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {boolean} b\n\t * @returns {number[]}\n\t */\n\tstatic encodeBool(b) {\n\t\tif (b) {\n\t\t\treturn [245];\n\t\t} else {\n\t\t\treturn [244];\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic decodeBool(bytes) {\n\t\tlet b = assertDefined(bytes.shift());\n\n\t\tif (b == 245) {\n\t\t\treturn true;\n\t\t} else if (b == 244) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected non-boolean cbor object\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isDefBytes(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor bytes\");\n\t\t}\n\n\t\tlet [m, _] = CborData.decodeHead(bytes.slice(0, 9));\n\n\t\treturn m == 2;\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isIndefBytes(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor bytes\");\n\t\t}\n\n\t\treturn 2*32 + 31 == bytes[0];\n\t}\n\n\t/**\n\t * @example\n\t * bytesToHex(CborData.encodeBytes(hexToBytes(\"4d01000033222220051200120011\"))) => \"4e4d01000033222220051200120011\"\n\t * @param {number[]} bytes\n\t * @param {boolean} splitInChunks\n\t * @returns {number[]} - cbor bytes\n\t */\n\tstatic encodeBytes(bytes, splitInChunks = false) {\n\t\tbytes = bytes.slice();\n\n\t\tif (bytes.length <= 64 || !splitInChunks) {\n\t\t\tlet head = CborData.encodeHead(2, BigInt(bytes.length));\n\t\t\treturn head.concat(bytes);\n\t\t} else {\n\t\t\tlet res = CborData.encodeIndefHead(2);\n\n\t\t\twhile (bytes.length > 0) {\n\t\t\t\tlet chunk = bytes.splice(0, 64);\n\n\t\t\t\tres = res.concat(CborData.encodeHead(2, BigInt(chunk.length))).concat(chunk);\n\t\t\t}\n\n\t\t\tres.push(255);\n\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * Decodes both an indef array of bytes, and a bytearray of specified length\n\t * @example\n\t * bytesToHex(CborData.decodeBytes(hexToBytes(\"4e4d01000033222220051200120011\"))) => \"4d01000033222220051200120011\"\n\t * @param {number[]} bytes - cborbytes, mutated to form remaining\n\t * @returns {number[]} - byteArray\n\t */\n\tstatic decodeBytes(bytes) {\n\t\t// check header type\n\t\tassert(bytes.length > 0);\n\n\t\tif (CborData.isIndefBytes(bytes)) {\n\t\t\t// multiple chunks\n\t\t\tvoid bytes.shift();\n\n\t\t\t/**\n\t\t\t * @type {number[]}\n\t\t\t */\n\t\t\tlet res = [];\n\n\t\t\twhile(bytes[0] != 255) {\n\t\t\t\tlet [_, n] = CborData.decodeHead(bytes);\n\t\t\t\tif (n > 64n) {\n\t\t\t\t\tthrow new Error(\"bytearray chunk too large\");\n\t\t\t\t}\n\n\t\t\t\tres = res.concat(bytes.splice(0, Number(n)));\n\t\t\t}\n\n\t\t\tassert(bytes.shift() == 255);\n\n\t\t\treturn res;\n\t\t} else {\n\t\t\tlet [_, n] = CborData.decodeHead(bytes);\n\n\t\t\treturn bytes.splice(0, Number(n));\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isUtf8(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor bytes\");\n\t\t}\n\n\t\treturn bytes[0] === 120;\n\t}\n\n\t/**\n\t * Encodes a Utf8 string into Cbor bytes.\n\t * Strings longer than 64 bytes are split into lists with 64 byte chunks\n\t * Note: string splitting isn't reversible\n\t * @param {string} str\n\t * @param {boolean} split\n\t * @returns {number[]}\n\t */\n\tstatic encodeUtf8(str, split = false) {\n\t\tconst bytes = textToBytes(str);\n\n\t\tif (split && bytes.length > 64) {\n\t\t\t/** @type {number[][]} */\n\t\t\tconst chunks = [];\n\n\t\t\tfor (let i = 0; i < bytes.length; i += 64) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 64);\n\n\t\t\t\tchunks.push([120, chunk.length].concat(chunk));\n\t\t\t}\n\n\t\t\treturn CborData.encodeDefList(chunks);\n\t\t} else {\n\t\t\treturn [120, bytes.length].concat(bytes);\n\t\t}\n\t}\n\n\t/**\n\t* @param {number[]} bytes\n\t* @returns {string}\n\t*/\n\tstatic decodeUtf8Internal(bytes) {\n\t\tassert(bytes.shift() === 120);\n\n\t\tconst length = bytes.shift();\n\n\t\treturn bytesToText(bytes.splice(0, length));\n\t}\n\n\t/**\n\t* @param {number[]} bytes\n\t* @returns {string}\n\t*/\n\tstatic decodeUtf8(bytes) {\n\t\tassert(bytes.length > 0);\n\n\t\tif (CborData.isDefList(bytes)) {\n\t\t\tlet result = \"\";\n\n\t\t\tCborData.decodeList(bytes, (_, itemBytes) => {\n\t\t\t\tresult += CborData.decodeUtf8Internal(itemBytes);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn CborData.decodeUtf8Internal(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * @param {bigint} n\n\t * @returns {number[]} - cbor bytes\n\t */\n\tstatic encodeInteger(n) {\n\t\tif (n >= 0n && n <= (2n << 63n) - 1n) {\n\t\t\treturn CborData.encodeHead(0, n);\n\t\t} else if (n >= (2n << 63n)) {\n\t\t\treturn CborData.encodeHead(6, 2n).concat(CborData.encodeBytes(bigIntToBytes(n)));\n\t\t} else if (n <= -1n && n >= -(2n << 63n)) {\n\t\t\treturn CborData.encodeHead(1, -n - 1n);\n\t\t} else {\n\t\t\treturn CborData.encodeHead(6, 3n).concat(CborData.encodeBytes(bigIntToBytes(-n - 1n)));\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {bigint}\n\t */\n\tstatic decodeInteger(bytes) {\n\t\tlet [m, n] = CborData.decodeHead(bytes);\n\n\t\tif (m == 0) {\n\t\t\treturn n;\n\t\t} else if (m == 1) {\n\t\t\treturn -n - 1n;\n\t\t} else if (m == 6) {\n\t\t\tif (n == 2n) {\n\t\t\t\tlet b = CborData.decodeBytes(bytes);\n\n\t\t\t\treturn bytesToBigInt(b);\n\t\t\t} else if (n == 3n) {\n\t\t\t\tlet b = CborData.decodeBytes(bytes);\n\n\t\t\t\treturn -bytesToBigInt(b) - 1n;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`unexpected tag n:${n}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`unexpected tag m:${m}`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isIndefList(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor bytes\");\n\t\t}\n\n\t\treturn 4*32 + 31 == bytes[0];\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\tstatic encodeIndefListStart() {\n\t\treturn CborData.encodeIndefHead(4);\n\t}\n\n\t/**\n\t * @param {CborData[] | number[][]} list\n\t * @returns {number[]}\n\t */\n\tstatic encodeListInternal(list) {\n\t\t/**\n\t\t * @type {number[]}\n\t\t */\n\t\tlet res = [];\n\t\tfor (let item of list) {\n\t\t\tif (item instanceof CborData) {\n\t\t\t\tres = res.concat(item.toCbor());\n\t\t\t} else {\n\t\t\t\tres = res.concat(item);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\tstatic encodeIndefListEnd() {\n\t\treturn [255];\n\t}\n\n\t/**\n\t * @param {CborData[] | number[][]} list\n\t * @returns {number[]}\n\t */\n\tstatic encodeList(list) {\n\t\t// This follows the serialization format that the Haskell input-output-hk/plutus UPLC evaluator\n\t\t// https://github.com/well-typed/cborg/blob/4bdc818a1f0b35f38bc118a87944630043b58384/serialise/src/Codec/Serialise/Class.hs#L181\n\t\treturn list.length ? CborData.encodeIndefList(list) : CborData.encodeDefList(list);\n\t}\n\n\t/**\n\t * @param {CborData[] | number[][]} list\n\t * @returns {number[]}\n\t */\n\tstatic encodeIndefList(list) {\n\t\treturn CborData.encodeIndefListStart().concat(CborData.encodeListInternal(list)).concat(CborData.encodeIndefListEnd());\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isDefList(bytes) {\n\t\ttry {\n\t\t\tlet [m, _] = CborData.decodeHead(bytes.slice(0, 9));\n\t\t\treturn m == 4;\n\t\t} catch (error) {\n\t\t\tif (error.message.includes(\"bad header\")) return false;\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * @param {bigint} n\n\t * @returns {number[]}\n\t */\n\tstatic encodeDefListStart(n) {\n\t\treturn CborData.encodeHead(4, n);\n\t}\n\n\t/**\n\t * @param {CborData[] | number[][]} list\n\t * @returns {number[]}\n\t */\n\tstatic encodeDefList(list) {\n\t\treturn CborData.encodeDefListStart(BigInt(list.length)).concat(CborData.encodeListInternal(list));\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isList(bytes) {\n\t\treturn CborData.isIndefList(bytes) || CborData.isDefList(bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @param {Decoder} itemDecoder\n\t */\n\tstatic decodeList(bytes, itemDecoder) {\n\t\tif (CborData.isIndefList(bytes)) {\n\t\t\tassert(CborData.decodeIndefHead(bytes) == 4);\n\n\t\t\tlet i = 0;\n\t\t\twhile(bytes[0] != 255) {\n\t\t\t\titemDecoder(i, bytes);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tassert(bytes.shift() == 255);\n\t\t} else {\n\t\t\tlet [m, n] = CborData.decodeHead(bytes);\n\n\t\t\tassert(m == 4);\n\n\t\t\tfor (let i = 0; i < Number(n); i++) {\n\t\t\t\titemDecoder(i, bytes);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isTuple(bytes) {\n\t\treturn CborData.isIndefList(bytes) || CborData.isDefList(bytes);\n\t}\n\n\t/**\n\t * @param {number[][]} tuple\n\t * @returns {number[]}\n\t */\n\tstatic encodeTuple(tuple) {\n\t\treturn CborData.encodeDefList(tuple);\n\t}\n\n\n\t/**\n\t * @param {number[]} bytes\n\t * @param {Decoder} tupleDecoder\n\t * @returns {number} - returns the size of the tuple\n\t */\n\tstatic decodeTuple(bytes, tupleDecoder) {\n\t\tlet count = 0;\n\n\t\tCborData.decodeList(bytes, (_, itemBytes) => {\n\t\t\ttupleDecoder(count, itemBytes);\n\t\t\tcount++;\n\t\t});\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isMap(bytes) {\n\t\tlet [m, _] = CborData.decodeHead(bytes.slice(0, 9));\n\n\t\treturn m == 5;\n\t}\n\n\t/**\n\t * @param {[CborData | number[], CborData | number[]][]} pairList\n\t * @returns {number[]}\n\t */\n\tstatic encodeMapInternal(pairList) {\n\t\t/**\n\t\t * @type {number[]}\n\t\t */\n\t\tlet res = [];\n\n\t\tfor (let pair of pairList) {\n\t\t\tlet key = pair[0];\n\t\t\tlet value = pair[1];\n\n\t\t\tif (key instanceof CborData) {\n\t\t\t\tres = res.concat(key.toCbor());\n\t\t\t} else {\n\t\t\t\tres = res.concat(key);\n\t\t\t}\n\n\t\t\tif (value instanceof CborData) {\n\t\t\t\tres = res.concat(value.toCbor());\n\t\t\t} else {\n\t\t\t\tres = res.concat(value);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * A decode map method doesn't exist because it specific for the requested type\n\t * @param {[CborData | number[], CborData | number[]][]} pairList\n\t * @returns {number[]}\n\t */\n\tstatic encodeMap(pairList) {\n\t\treturn CborData.encodeHead(5, BigInt(pairList.length)).concat(CborData.encodeMapInternal(pairList));\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @param {Decoder} pairDecoder\n\t */\n\tstatic decodeMap(bytes, pairDecoder) {\n\t\tlet [m, n] = CborData.decodeHead(bytes);\n\n\t\tassert(m == 5);\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tpairDecoder(i, bytes);\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isObject(bytes) {\n\t\treturn CborData.isMap(bytes);\n\t}\n\n\t/**\n\t * @param {Map<number, CborData | number[]>} object\n\t * @returns {number[]}\n\t */\n\tstatic encodeObject(object) {\n\t\treturn CborData.encodeMap(Array.from(object.entries()).map(pair => [\n\t\t\tCborData.encodeInteger(BigInt(pair[0])),\n\t\t\tpair[1]\n\t\t]));\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @param {Decoder} fieldDecoder\n\t * @returns {Set<number>}\n\t */\n\tstatic decodeObject(bytes, fieldDecoder) {\n\t\t/** @type {Set<number>} */\n\t\tlet done = new Set();\n\n\t\tCborData.decodeMap(bytes, (_, pairBytes) => {\n\t\t\tlet i = Number(CborData.decodeInteger(pairBytes));\n\n\t\t\tfieldDecoder(i, pairBytes);\n\t\t\t\n\t\t\tdone.add(i);\n\t\t});\n\n\t\treturn done;\n\t}\n\n\t/**\n\t * Unrelated to constructor\n\t * @param {bigint} tag\n\t * @returns {number[]}\n\t */\n\tstatic encodeTag(tag) {\n\t\treturn CborData.encodeHead(6, tag);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {bigint}\n\t */\n\tstatic decodeTag(bytes) {\n\t\tlet [m, n] = CborData.decodeHead(bytes);\n\n\t\tassert(m == 6);\n\n\t\treturn n;\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {boolean}\n\t */\n\tstatic isConstr(bytes) {\n\t\tif (bytes.length == 0) {\n\t\t\tthrow new Error(\"empty cbor bytes\");\n\t\t}\n\n\t\tlet [m, _] = CborData.decodeHead(bytes.slice(0, 9));\n\n\t\treturn m == 6;\n\t}\n\n\t/**\n\t * Encode a constructor tag of a ConstrData type\n\t * @param {number} tag\n\t * @returns {number[]}\n\t */\n\tstatic encodeConstrTag(tag) {\n\t\tif (tag >= 0 && tag <= 6) {\n\t\t\treturn CborData.encodeHead(6, 121n + BigInt(tag));\n\t\t} else if (tag >= 7 && tag <= 127) {\n\t\t\treturn CborData.encodeHead(6, 1280n + BigInt(tag - 7));\n\t\t} else {\n\t\t\treturn CborData.encodeHead(6, 102n).concat(CborData.encodeHead(4, 2n)).concat(CborData.encodeInteger(BigInt(tag)));\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} tag\n\t * @param {CborData[] | number[][]} fields\n\t * @returns {number[]}\n\t */\n\tstatic encodeConstr(tag, fields) {\n\t\treturn CborData.encodeConstrTag(tag).concat(CborData.encodeList(fields));\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {number}\n\t */\n\tstatic decodeConstrTag(bytes) {\n\t\t// constr\n\t\tlet [m, n] = CborData.decodeHead(bytes);\n\n\t\tassert(m == 6);\n\n\t\tif (n < 127n) {\n\t\t\treturn Number(n - 121n);\n\t\t} else if (n == 102n) {\n\t\t\tlet [mCheck, nCheck] = CborData.decodeHead(bytes);\n\t\t\tassert(mCheck == 4 && nCheck == 2n);\n\n\t\t\treturn Number(CborData.decodeInteger(bytes));\n\t\t} else {\n\t\t\treturn Number(n - 1280n + 7n);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the tag\n\t * @param {number[]} bytes\n\t * @param {Decoder} fieldDecoder\n\t * @returns {number}\n\t */\n\tstatic decodeConstr(bytes, fieldDecoder) {\n\t\tlet tag = CborData.decodeConstrTag(bytes);\n\n\t\tCborData.decodeList(bytes, fieldDecoder);\n\n\t\treturn tag;\n\t}\n}\n\n\n\n/////////////////////////////\n// Section 6: Uplc data types\n/////////////////////////////\n\n/**\n * Min memory used by a UplcData value during validation\n * @package\n * @type {number}\n */\nconst UPLC_DATA_NODE_MEM_SIZE = 4;\n\n/**\n * Base class for Plutus-core data classes (not the same as Plutus-core value classes!)\n */\nclass UplcData extends CborData {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Estimate of memory usage during validation\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Compares the schema jsons\n\t * @param {UplcData} other\n\t * @returns {boolean}\n\t */\n\tisSame(other) {\n\t\treturn this.toSchemaJson() == other.toSchemaJson();\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget bytes() {\n\t\tthrow new Error(\"not a bytearray\");\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget int() {\n\t\tthrow new Error(\"not an int\");\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget index() {\n\t\tthrow new Error(\"not a constr\");\n\t}\n\n\t/**\n\t * @type {UplcData[]}\n\t */\n\tget fields() {\n\t\tthrow new Error(\"not a constr\");\n\t}\n\n\t/**\n\t * @type {UplcData[]}\n\t */\n\tget list() {\n\t\tthrow new Error(\"not a list\");\n\t}\n\n\t/**\n\t * @type {[UplcData, UplcData][]}\n\t */\n\tget map() {\n\t\tthrow new Error(\"not a map\");\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {string | number[]} bytes\n\t * @returns {UplcData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tif (typeof bytes == \"string\") {\n\t\t\treturn UplcData.fromCbor(hexToBytes(bytes));\n\t\t} else {\n\t\t\tif (CborData.isList(bytes)) {\n\t\t\t\treturn ListData.fromCbor(bytes);\n\t\t\t} else if (CborData.isIndefBytes(bytes)) {\n\t\t\t\treturn ByteArrayData.fromCbor(bytes);\n\t\t\t} else {\n\t\t\t\tif (CborData.isDefBytes(bytes)) {\n\t\t\t\t\treturn ByteArrayData.fromCbor(bytes);\n\t\t\t\t} else if (CborData.isMap(bytes)) {\n\t\t\t\t\treturn MapData.fromCbor(bytes);\n\t\t\t\t} else if (CborData.isConstr(bytes)) {\n\t\t\t\t\treturn ConstrData.fromCbor(bytes);\n\t\t\t\t} else {\n\t\t\t\t\t// int, must come last\n\t\t\t\t\treturn IntData.fromCbor(bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Plutus-core int data class\n */\nclass IntData extends UplcData {\n\t#value;\n\n\t/**\n\t * @param {bigint} value\n\t */\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * Alias getter\n\t * @type {bigint}\n\t */\n\tget int() {\n\t\treturn this.#value;\n\t}\n\n    /**\n     * Calculate the mem size of a integer (without the DATA_NODE overhead)\n     * @param {bigint} value\n     * @returns {number}\n     */\n    static memSizeInternal(value) {\n        if (value == 0n) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tconst abs = value > 0n ? value : -value;\n\n\t\t\treturn Math.floor(Math.floor(Math.log2(Number(abs)))/64) + 1;\n\t\t}\n    }\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn UPLC_DATA_NODE_MEM_SIZE + IntData.memSizeInternal(this.#value);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value.toString();\n\t}\n\n\t/**\n\t * Returns integer literal wrapped with integer data function call.\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\treturn new IR(`__core__iData(${this.#value.toString()})`);\n\t}\n\n\t/**\n\t * Returns string, not js object, because of unbounded integers\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\treturn `{\"int\": ${this.#value.toString()}}`;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeInteger(this.#value);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {IntData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new IntData(CborData.decodeInteger(bytes));\n\t}\n}\n\n/**\n * Plutus-core bytearray data class.\n * Wraps a regular list of uint8 numbers (so not Uint8Array)\n */\nclass ByteArrayData extends UplcData {\n\t#bytes;\n\n\t/**\n\t * @param {number[]} bytes\n\t */\n\tconstructor(bytes) {\n\t\tsuper();\n\t\tthis.#bytes = bytes;\n\t}\n\n\t/**\n\t * Applies utf-8 encoding\n\t * @param {string} s\n\t * @returns {ByteArrayData}\n\t */\n\tstatic fromString(s) {\n\t\tlet bytes = textToBytes(s);\n\n\t\treturn new ByteArrayData(bytes);\n\t}\n\n\tget bytes() {\n\t\treturn this.#bytes.slice();\n\t}\n\n    /**\n     * Calculates the mem size of a byte array without the DATA_NODE overhead.\n     * @param {number[]} bytes\n     * @returns {number}\n     */\n    static memSizeInternal(bytes) {\n        let n = bytes.length;\n\t\tif (n === 0) {\n\t\t\treturn 1; // this is so annoying: haskell reference implementation says it should be 0, but current (20220925) testnet and mainnet settings say it's 1\n\t\t} else {\n\t\t\treturn Math.floor((bytes.length - 1)/8) + 1;\n\t\t}\n    }\n\n\tget memSize() {\n\t\treturn UPLC_DATA_NODE_MEM_SIZE + ByteArrayData.memSizeInternal(this.#bytes);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoHex() {\n\t\treturn bytesToHex(this.#bytes);\n\t}\n\n\ttoString() {\n\t\treturn `#${this.toHex()}`;\n\t}\n\n\t/**\n\t * Returns bytearray literal wrapped with bytearray data function as IR.\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\treturn new IR(`__core__bData(#${this.toHex()})`);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\treturn `{\"bytes\": \"${this.toHex()}\"}`;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeBytes(this.#bytes, true);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {ByteArrayData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new ByteArrayData(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * Bytearray comparison, which can be used for sorting bytearrays\n\t * @example\n\t * ByteArrayData.comp(hexToBytes(\"0101010101010101010101010101010101010101010101010101010101010101\"), hexToBytes(\"0202020202020202020202020202020202020202020202020202020202020202\")) => -1\n\t * @param {number[]} a\n\t * @param {number[]} b\n\t * @returns {number} - 0 -> equals, 1 -> gt, -1 -> lt\n\t */\n\tstatic comp(a, b) {\n\t\t/** @return {boolean} */\n\t\tfunction lessThan() {\n\t\t\tfor (let i = 0; i < Math.min(a.length, b.length); i++) {\n\t\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\treturn a[i] < b[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a.length < b.length;\n\t\t}\n\n\t\t/** @return {number} */\n\t\tfunction lessOrGreater() {\n\t\t\treturn lessThan() ? -1 : 1;\n\t\t}\n\n\t\tif (a.length != b.length) {\n\t\t\treturn lessOrGreater();\n\t\t} else {\n\t\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\treturn lessOrGreater();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/**\n * Plutus-core list data class\n */\nclass ListData extends UplcData {\n\t#items;\n\n\t/**\n\t * @param {UplcData[]} items\n\t */\n\tconstructor(items) {\n\t\tsuper();\n\t\tthis.#items = items;\n\t}\n\n\t/**\n\t * @type {UplcData[]}\n\t */\n\tget list() {\n\t\treturn this.#items.slice();\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\tlet sum = UPLC_DATA_NODE_MEM_SIZE;\n\n\t\tfor (let item of this.#items) {\n\t\t\tsum += item.memSize;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.#items.map(item => item.toString()).join(\", \")}]`;\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\tlet ir = new IR(\"__core__mkNilData(())\");\n\t\tfor (let i = this.#items.length - 1; i >= 0; i--) {\n\t\t\tir = new IR([new IR(\"__core__mkCons(\"), this.#items[i].toIR(), new IR(\", \"), ir, new IR(\")\")]);\n\t\t}\n\n\t\treturn new IR([new IR(\"__core__listData(\"), ir, new IR(\")\")]);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\treturn `{\"list\":[${this.#items.map(item => item.toSchemaJson()).join(\", \")}]}`;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeList(this.#items);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {ListData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/**\n\t\t * @type {UplcData[]}\n\t\t */\n\t\tlet list = [];\n\n\t\tCborData.decodeList(bytes, (_, itemBytes) => {\n\t\t\tlist.push(UplcData.fromCbor(itemBytes));\n\t\t});\n\n\t\treturn new ListData(list);\n\t}\n}\n\n/**\n * Plutus-core map data class\n */\nclass MapData extends UplcData {\n\t#pairs;\n\n\t/**\n\t * @param {[UplcData, UplcData][]} pairs\n\t */\n\tconstructor(pairs) {\n\t\tsuper();\n\t\tthis.#pairs = pairs;\n\t}\n\n\t/**\n\t * @type {[UplcData, UplcData][]}\n\t */\n\tget map() {\n\t\treturn this.#pairs.slice();\n\t}\n\n\tget memSize() {\n\t\tlet sum = UPLC_DATA_NODE_MEM_SIZE;\n\n\t\tfor (let [k, v] of this.#pairs) {\n\t\t\tsum += k.memSize + v.memSize;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\ttoString() {\n\t\treturn `{${this.#pairs.map(([fst, snd]) => `${fst.toString()}: ${snd.toString()}`).join(\", \")}}`;\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\tlet ir = new IR(\"__core__mkNilPairData(())\");\n\n\t\tfor (let i = this.#pairs.length - 1; i >= 0; i--) {\n\t\t\tlet a = this.#pairs[i][0].toIR();\n\t\t\tlet b = this.#pairs[i][1].toIR();\n\n\t\t\tir = new IR([new IR(\"__core__mkCons(__core__mkPairData(\"), a, new IR(\", \"), b, new IR(\", \"), new IR(\")\"), new IR(\", \"), ir, new IR(\")\")]);\n\t\t}\n\n\t\treturn new IR([new IR(\"__core__mapData(\"), ir, new IR(\")\")]);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\treturn `{\"map\": [${this.#pairs.map(pair => { return \"{\\\"k\\\": \" + pair[0].toSchemaJson() + \", \\\"v\\\": \" + pair[1].toSchemaJson() + \"}\" }).join(\", \")}]}`;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeMap(this.#pairs);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {MapData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/**\n\t\t * @type {[UplcData, UplcData][]}\n\t\t */\n\t\tlet pairs = [];\n\n\t\tCborData.decodeMap(bytes, (_, pairBytes) => {\n\t\t\tpairs.push([UplcData.fromCbor(pairBytes), UplcData.fromCbor(pairBytes)]);\n\t\t});\n\n\t\treturn new MapData(pairs);\n\t}\n}\n\n/**\n * Plutus-core constructed data class\n */\nclass ConstrData extends UplcData {\n\t#index;\n\t#fields;\n\n\t/**\n\t * @param {number} index\n\t * @param {UplcData[]} fields\n\t */\n\tconstructor(index, fields) {\n\t\tsuper();\n\t\tthis.#index = index;\n\t\tthis.#fields = fields;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget index() {\n\t\treturn this.#index;\n\t}\n\n\t/**\n\t * @type {UplcData[]}\n\t */\n\tget fields() {\n\t\treturn this.#fields.slice();\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\tlet sum = UPLC_DATA_NODE_MEM_SIZE;\n\n\t\tfor (let field of this.#fields) {\n\t\t\tsum += field.memSize;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tlet parts = this.#fields.map(field => field.toString());\n\t\treturn `${this.#index.toString()}{${parts.join(\", \")}}`;\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\tlet ir = new IR(\"__core__mkNilData(())\");\n\t\tfor (let i = this.#fields.length - 1; i >= 0; i--) {\n\t\t\tir = new IR([new IR(\"__core__mkCons(\"), this.#fields[i].toIR(), new IR(\", \"), ir, new IR(\")\")]);\n\t\t}\n\n\t\treturn new IR([new IR(\"__core__constrData(\"), new IR(this.#index.toString()), new IR(\", \"), ir, new IR(\")\")]);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoSchemaJson() {\n\t\treturn `{\"constructor\": ${this.#index.toString()}, \"fields\": [${this.#fields.map(f => f.toSchemaJson()).join(\", \")}]}`;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeConstr(this.#index, this.#fields);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {ConstrData}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/**\n\t\t * @type {UplcData[]}\n\t\t */\n\t\tlet fields = [];\n\n\t\tlet tag = CborData.decodeConstr(bytes, (_, fieldBytes) => {\n\t\t\tfields.push(UplcData.fromCbor(fieldBytes));\n\t\t});\n\n\t\treturn new ConstrData(tag, fields);\n\t}\n}\n\n\n\n/////////////////////////////////\n// Section 7: Helios data objects\n/////////////////////////////////\n\n/**\n * Base-type of all data-types that exist both on- and off-chain, and map directly to Helios instances.\n */\nclass HeliosData extends CborData {\n\tconstructor() {\n        super();\n\t}\n\n    /**\n     * Name begins with underscore so it can never conflict with structure field names.\n     * @package\n     * @returns {UplcData}\n     */\n\t_toUplcData() {\n        throw new Error(\"not yet implemented\");\n\t}\n\n    /**\n     * @returns {string}\n     */\n\ttoSchemaJson() {\n\t\treturn this._toUplcData().toSchemaJson();\n\t}\n}\n\n/**\n * @template {HeliosData} T\n * @typedef {{\n *   new(...args: any[]): T;\n *   fromUplcCbor: (bytes: (string | number[])) => T,\n *   fromUplcData: (data: UplcData) => T\n * }} HeliosDataClass\n */\n\n/**\n * Helios Int type\n */\nclass HInt extends HeliosData {\n    /** \n     * @type {bigint} \n     */\n    #value;\n\n    /**\n     * @package\n     * @param {number | bigint | string} rawValue\n     * @returns {bigint}\n     */\n    static cleanConstructorArg(rawValue) {\n        const value = BigInt(rawValue);\n\n        if (value.toString() != rawValue.toString()) {\n            throw new Error(\"not a valid integer\");\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {number | bigint | string} rawValue\n     */\n    constructor(rawValue) {\n        super();\n\n        this.#value = HInt.cleanConstructorArg(rawValue);\n    }\n\n    /**\n     * @type {bigint}\n     */\n    get value() {\n        return this.#value;\n    }\n\n    /**\n     * @package\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new IntData(this.#value);\n    }\n\n    /**\n     * @param {UplcData} data\n     * @returns {HInt}\n     */\n    static fromUplcData(data) {\n        return new HInt(data.int);\n    }\n\n    /**\n     * @param {string | number[]} bytes\n     * @returns {HInt}\n     */\n    static fromUplcCbor(bytes) {\n        return HInt.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Milliseconds since 1 jan 1970\n */\nclass Time extends HInt {\n     /**\n     * @package\n     * @param {number | bigint | string | Date} rawValue\n     * @returns {bigint}\n     */\n      static cleanConstructorArg(rawValue) {\n\n        if (rawValue instanceof Date) {\n            return BigInt(rawValue.getTime());\n        } else {\n            const value = BigInt(rawValue);\n\n            if (value.toString() != rawValue.toString()) {\n                throw new Error(\"not a valid integer\");\n            } else {\n                return value;\n            }\n        }\n    }\n\n    /**\n     * @param {number | bigint | string | Date} rawValue\n     */\n    constructor(rawValue) {\n        super(Time.cleanConstructorArg(rawValue));\n    }\n\n    /**\n     * @param {UplcData} data\n     * @returns {Time}\n     */\n    static fromUplcData(data) {\n        return new Time(data.int);\n    }\n\n    /**\n     * @param {string | number[]} bytes\n     * @returns {Time}\n     */\n    static fromUplcCbor(bytes) {\n        return Time.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Difference between two time values in milliseconds.\n */\nclass Duration extends HInt {\n    /**\n     * @param {UplcData} data\n     * @returns {Duration}\n     */\n    static fromUplcData(data) {\n        return new Duration(data.int);\n    }\n\n    /**\n     * @param {string | number[]} bytes\n     * @returns {Duration}\n     */\n    static fromUplcCbor(bytes) {\n        return Duration.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Helios Bool type\n */\nclass Bool extends HeliosData {\n    /** \n     * @type {boolean} \n     */\n    #value;\n\n    /**\n     * @package\n     * @param {boolean | string} rawValue \n     * @returns {boolean}\n     */\n    static cleanConstructorArg(rawValue) {\n        if (typeof rawValue == \"string\") {\n            if (rawValue == \"false\") {\n                return false;\n            } else if (rawValue == \"true\") {\n                return true;\n            } else {\n                throw new Error(\"not a valid string representation of a Bool\");\n            }\n        } else if (typeof rawValue == \"boolean\") {\n            return rawValue;\n        } else {\n            throw new Error(\"can't convert to boolean\");\n        }\n    }\n\n    /**\n     * @param {boolean | string} rawValue \n     */\n    constructor(rawValue) {\n        super();\n\n        this.#value = Bool.cleanConstructorArg(rawValue);\n    }\n\n    get bool() {\n        return this.#value;\n    }\n    \n    /**\n     * @package\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ConstrData(this.#value ? 1 : 0, []);\n    }\n\n    /** \n     * @param {UplcData} data\n     * @returns {Bool}\n     */\n    static fromUplcData(data) {\n        assert(data.fields.length == 0, \"bool data can't have fields\");\n\n        if (data.index == 0) {\n            return new Bool(false);\n        } else if (data.index == 1) {\n            return new Bool(true);\n        } else {\n            throw new Error(\"expected 0 or 1 for ConstrData representing Bool\");\n        }\n    }\n\n    /**\n     * @param {string | number[]} bytes \n     * @returns {Bool}\n     */\n    static fromUplcCbor(bytes) {\n        return Bool.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Helios String type.\n * Can't be named 'String' because that would interfere with the javascript 'String'-type\n */\nclass HString extends HeliosData {\n    /**\n     * @type {string}\n     */\n    #value;\n\n    /**\n     * @param {string} value \n     */\n    constructor(value) {\n        super();\n\n        this.#value = value;\n    }\n\n    get string() {\n        return this.#value;\n    }\n\n    /**\n     * @package\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ByteArrayData(textToBytes(this.#value));\n    }\n\n    /**\n     * @param {UplcData} data \n     * @returns {HString}\n     */\n    static fromUplcData(data) {\n        return new HString(bytesToText(data.bytes));\n    }\n\n    /**\n     * @param {string | number[]} bytes \n     * @returns {HString}\n     */\n    static fromUplcCbor(bytes) {\n        return HString.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Helios ByteArray type\n */\nclass ByteArray extends HeliosData {\n    /**\n     * @type {number[]}\n     */\n    #bytes;\n\n    /**\n     * @package\n     * @param {string | number[]} rawValue \n     */\n    static cleanConstructorArg(rawValue) {\n        if (Array.isArray(rawValue)) {\n            return rawValue;\n        } else if (typeof rawValue == \"string\") {\n            if (rawValue.startsWith(\"#\")) {\n                rawValue = rawValue.slice(1);\n            }\n\n            return hexToBytes(rawValue);\n        } else {\n            throw new Error(\"unexpected bytes type\");\n        }\n    }\n\n    /**\n     * @param {string | number[]} rawValue \n     */\n    constructor(rawValue) {\n        super();\n\n        this.#bytes = ByteArray.cleanConstructorArg(rawValue);\n    }\n\n    /**\n     * @type {number[]}\n     */\n    get bytes() {\n        return this.#bytes;\n    }\n\n    /**\n     * @type {string}\n     */\n    get hex() {\n        return bytesToHex(this.#bytes);\n    }\n\n    /**\n     * @package\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ByteArrayData(this.#bytes);\n    }\n\n    /**\n     * @param {UplcData} data \n     * @returns {ByteArray}\n     */\n    static fromUplcData(data) {\n        return new ByteArray(data.bytes);\n    }\n\n    /**\n     * @param {string | number[]} bytes\n     * @returns {ByteArray}\n     */\n    static fromUplcCbor(bytes) {\n        return ByteArray.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * Dynamically constructs a new List class, depending on the item type.\n * @template {HeliosData} T\n * @param {HeliosDataClass<T>} ItemClass\n * @returns {HeliosDataClass<HList_>}\n */\nfunction HList(ItemClass) {\n    assert(!new.target, \"List can't be called with new\");\n    assert(ItemClass.prototype instanceof HeliosData);\n\n    const typeName = `[]${ItemClass.name}`;\n\n    class HList_ extends HeliosData {\n        /** \n         * @type {T[]} \n         */\n        #items;\n\n        /**\n         * @param {any[]} rawList \n         */\n        constructor(rawList) {\n            super();\n\n            this.#items = rawList.map(item => {\n                if (item instanceof ItemClass) {\n                    return item;\n                } else {\n                    return new ItemClass(item);\n                }\n            });\n        }\n\n        /**\n         * @package\n         * @type {string}\n         */\n        get _listTypeName() {\n            return typeName;\n        }\n\n        /**\n         * Overload 'instanceof' operator\n         * @package\n         * @param {any} other \n         * @returns {boolean}\n         */\n        static [Symbol.hasInstance](other) {\n            return (other._listTypeName === typeName) && (other instanceof HeliosData);\n        }\n\n        /**\n         * @type {T[]}\n         */\n        get items() {\n            return this.#items;\n        }\n\n        /**\n         * @package\n         * @returns {UplcData}\n         */\n        _toUplcData() {\n            return new ListData(this.#items.map(item => item._toUplcData()))\n        }\n\n        /**\n         * @param {UplcData} data \n         * @returns {HList_}\n         */\n        static fromUplcData(data) {\n            return new HList_(data.list.map(d => ItemClass.fromUplcData(d)));\n        }\n\n        /**\n         * @param {string | number[]} bytes \n         * @returns {HList_}\n         */\n        static fromUplcCbor(bytes) {\n            return HList_.fromUplcData(UplcData.fromCbor(bytes));\n        }\n    }\n\n    Object.defineProperty(HList_, \"name\", {\n        value: typeName,\n        writable: false\n    });\n\n    return HList_;\n}\n\n/**\n * @template {HeliosData} TKey\n * @template {HeliosData} TValue\n * @param {HeliosDataClass<TKey>} KeyClass \n * @param {HeliosDataClass<TValue>} ValueClass\n * @returns {HeliosDataClass<HMap_>}\n */\nfunction HMap(KeyClass, ValueClass) {\n    assert(!new.target, \"HMap can't be called with new\");\n    assert(KeyClass.prototype instanceof HeliosData);\n    assert(ValueClass.prototype instanceof HeliosData);\n    \n    const typeName = `Map[${KeyClass.name}]${ValueClass.name}`;\n\n    class HMap_ extends HeliosData {\n        /**\n         * @type {[TKey, TValue][]}\n         */\n        #pairs;\n\n        /**\n         * @package\n         * @param {...any} args\n         * @returns {[any, any][]}\n         */\n        static cleanConstructorArgs(...args) {\n            /** @type {[any, any][]} */\n            let pairs = [];\n\n            if (args.length == 1) {\n                const arg = args[0];\n\n                if (arg instanceof Map) {\n                    return HMap_.cleanConstructorArgs(Array.from(arg.entries()));\n                } else if (!Array.isArray(arg)) {\n                    throw new Error(\"expected array or Map arg\");\n                } else {\n                    const lst = arg;\n\n                    pairs = lst.map(item => {\n                        if (!Array.isArray(item)) {\n                            throw new Error(\"expected array item (pair)\");\n                        } else if (item.length != 2) {\n                            throw new Error(\"expected array item of length 2 (pair)\");\n                        } else {\n                            return [item[0], item[1]];\n                        }\n                    });\n                }\n            } else if (args.length == 2) {\n                const [keys, values] = args;\n\n                if (!Array.isArray(keys)) {\n                    throw new Error(\"expected keys array arg\");\n                } else if (!Array.isArray(values)) {\n                    throw new Error(\"expected values array arg\");\n                } else if (keys.length != values.length) {\n                    throw new Error(\"keys and values list don't have same length\");\n                } else {\n                    pairs = keys.map((key, i) => {\n                        const value = values[i];\n\n                        return [key, value];\n                    });\n                }\n            } else {\n                throw new Error(\"unexpected number of args\");\n            }\n\n            return pairs;\n        }\n\n        /**\n         * @param  {...any} args\n         */\n        constructor(...args) {\n            const rawPairs = HMap_.cleanConstructorArgs(...args);\n\n            /**\n             * @type {[TKey, TValue][]}\n             */\n            const pairs = rawPairs.map(([rawKey, rawValue]) => {\n                const key = function() {\n                    if (rawKey instanceof KeyClass) {\n                        return rawKey;\n                    } else {\n                        return new KeyClass(rawKey);\n                    }\n                }();\n\n                const value = function() {\n                    if (rawValue instanceof ValueClass) {\n                        return rawValue;\n                    } else {\n                        return new ValueClass(rawValue);\n                    }\n                }();\n\n                return [key, value];\n            });\n\n            super();\n\n            this.#pairs = pairs;\n        }\n\n        /**\n         * @package\n         * @type {string}\n         */\n        get _mapTypeName() {\n            return typeName;\n        }\n\n        /**\n         * Overload 'instanceof' operator\n         * @package\n         * @param {any} other \n         * @returns {boolean}\n         */\n        static [Symbol.hasInstance](other) {\n            return (other._mapTypeName === typeName) && (other instanceof HeliosData);\n        }\n\n        /**\n         * @type {[TKey, TValue][]}\n         */\n        get pairs() {\n            return this.#pairs;\n        }\n\n        /**\n         * @package\n         * @returns {UplcData}\n         */\n        _toUplcData() {\n            return new MapData(this.#pairs.map(([key, value]) => [key._toUplcData(), value._toUplcData()]));\n        }\n\n        /**\n         * @param {UplcData} data \n         * @returns {HMap_}\n         */\n        static fromUplcData(data) {\n            return new HMap_(data.map.map(([kd, vd]) => [KeyClass.fromUplcData(kd), ValueClass.fromUplcData(vd)]));\n        }\n\n        /**\n         * @param {string | number[]} bytes \n         * @returns {HMap_}\n         */\n        static fromUplcCbor(bytes) {\n            return HMap_.fromUplcData(UplcData.fromCbor(bytes));\n        }\n    }\n\n    Object.defineProperty(HMap_, \"name\", {\n        value: typeName,\n        writable: false\n    });\n\n    return HMap_;\n}\n\n/**\n * @template {HeliosData} T\n * @param {HeliosDataClass<T>} SomeClass\n * @returns {HeliosDataClass<Option_>}\n */\nfunction Option(SomeClass) {\n    assert(!new.target, \"Option can't be called with new\");\n    assert(SomeClass.prototype instanceof HeliosData);\n\n    const typeName = `Option[${SomeClass.name}]`;\n\n    class Option_ extends HeliosData {\n        /**\n         * @type {?T}\n         */\n        #value;\n\n        /**\n         * @package\n         * @param {?any} rawValue \n         * @returns {?T}\n         */\n        static cleanConstructorArg(rawValue) {\n            if (rawValue == null) {\n                return null;\n            } else if (!(rawValue instanceof SomeClass)) {\n                return new SomeClass(rawValue);\n            } else {\n                return rawValue;\n            }\n        }\n\n        /** \n         * @param {?any} rawValue\n         */\n        constructor(rawValue = null) {\n            super();\n\n            this.#value = Option_.cleanConstructorArg(rawValue);\n        }\n\n        /**\n         * @package\n         * @type {string}\n         */\n        get _optionTypeName() {\n            return typeName;\n        }\n\n        /**\n         * Overload 'instanceof' operator\n         * @package\n         * @param {any} other \n         * @returns {boolean}\n         */\n        static [Symbol.hasInstance](other) {\n            return (other._optionTypeName === typeName) && (other instanceof HeliosData);\n        }\n\n        /**\n         * @type {?T}\n         */\n        get some() {\n            return this.#value;\n        }\n\n        /**\n         * @package\n         * @returns {UplcData}\n         */\n        _toUplcData() {\n            return new ConstrData(this.#value === null ? 1 : 0, this.#value === null ? [] : [this.#value._toUplcData()]);\n        }\n\n        /**\n         * @param {UplcData} data \n         * @returns {Option_}\n         */\n        static fromUplcData(data) {\n            if (data.index == 1) {\n                assert(data.fields.length == 0);\n\n                return new Option_(null);\n            } else if (data.index == 0) {\n                assert(data.fields.length == 1);\n\n                return new Option_(SomeClass.fromUplcData(data.fields[0]))\n            } else {\n                throw new Error(\"unexpected option constr index\");\n            }\n        }\n\n        /**\n         * @param {string | number[]} bytes\n         * @returns {Option_}\n         */\n        static fromUplcCbor(bytes) {\n            return Option_.fromUplcData(UplcData.fromCbor(bytes));\n        }\n    }\n\n    Object.defineProperty(HList, \"name\", {\n        value: typeName,\n        writable: false\n    });\n\n    return Option_;\n}\n\n\n/**\n * Base class of all hash-types\n * @package\n */\nclass Hash extends HeliosData {\n\t/** @type {number[]} */\n\t#bytes;\n\n\t/**\n\t * @param {string | number[]} rawValue \n\t * @returns {number[]}\n\t */\n\tstatic cleanConstructorArg(rawValue) {\n\t\tif (typeof rawValue == \"string\") {\n\t\t\treturn hexToBytes(rawValue);\n\t\t} else {\n\t\t\treturn rawValue;\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t */\n\tconstructor(bytes) {\n\t\tsuper();\n\t\tthis.#bytes = bytes;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\tget bytes() {\n\t\treturn this.#bytes;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tget hex() {\n\t\treturn bytesToHex(this.#bytes);\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeBytes(this.#bytes);\n\t}\n\n    /**\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ByteArrayData(this.#bytes);\n    }\n\n\t/**\n\t * Used internally for metadataHash and scriptDataHash\n\t * @param {number[]} bytes \n\t * @returns {Hash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new Hash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * Might be needed for internal use\n\t * @param {string} str \n\t * @returns {Hash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new Hash(hexToBytes(str));\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn bytesToHex(this.#bytes);\n\t}\n\n\t/**\n\t * @param {Hash} other\n\t */\n\teq(other) {\n\t\treturn eq(this.#bytes, other.#bytes);\n\t}\n\n\t/**\n\t * @param {Hash} a \n\t * @param {Hash} b \n\t * @returns {number}\n\t */\n\tstatic compare(a, b) {\n\t\treturn ByteArrayData.comp(a.#bytes, b.#bytes);\n\t}\n}\n\nclass DatumHash extends Hash {\n\t/**\n\t * @param {string | number[]} rawValue\n\t */\n\tconstructor(rawValue) {\n\t\tconst bytes = Hash.cleanConstructorArg(rawValue);\n\n\t\tassert(bytes.length == 32);\n\t\tsuper(bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {DatumHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new DatumHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {DatumHash}\n\t */\n\t static fromUplcData(data) {\n\t\treturn new DatumHash(data.bytes);\n\t}\n\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {DatumHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn DatumHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {DatumHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new DatumHash(hexToBytes(str));\n\t}\n}\n\nclass PubKeyHash extends Hash {\n\t\n\t/**\n\t * @param {string | number[]} rawValue \n\t */\n\tconstructor(rawValue) {\n\t\tconst bytes = Hash.cleanConstructorArg(rawValue);\n\n\t\tassert(bytes.length == 28, `expected 28 bytes for PubKeyHash, got ${bytes.length}`);\n\t\tsuper(bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {PubKeyHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new PubKeyHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {PubKeyHash}\n\t */\n\tstatic fromUplcData(data) {\n\t\treturn new PubKeyHash(data.bytes);\n\t}\n\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {PubKeyHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn PubKeyHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {PubKeyHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new PubKeyHash(hexToBytes(str));\n\t}\n}\n\nclass ScriptHash extends Hash {\n\t/**\n\t * @param {string | number[]} rawValue\n\t */\n\tconstructor(rawValue) {\n\t\tconst bytes = Hash.cleanConstructorArg(rawValue);\n\n\t\tassert(bytes.length == 28, `expected 28 bytes for ScriptHash, got ${bytes.length}`);\n\t\tsuper(bytes);\n\t}\n}\n\nclass MintingPolicyHash extends ScriptHash {\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {MintingPolicyHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new MintingPolicyHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {MintingPolicyHash}\n\t */\n\tstatic fromUplcData(data) {\n\t\treturn new MintingPolicyHash(data.bytes);\n\t}\n\t\t\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {MintingPolicyHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn MintingPolicyHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {MintingPolicyHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new MintingPolicyHash(hexToBytes(str));\n\t}\n\n\t/**\n\t * Encodes as bech32 string using 'asset' as human readable part\n\t * @returns {string}\n\t */\n\ttoBech32() {\n\t\treturn Crypto.encodeBech32(\"asset\", Crypto.blake2b(this.bytes, 20));\n\t}\n}\n\nclass StakeKeyHash extends Hash {\n\t/**\n\t * @param {number[]} rawValue\n\t */\n\tconstructor(rawValue) {\n\t\tconst bytes = Hash.cleanConstructorArg(rawValue);\n\t\t\n\t\tassert(bytes.length == 28, `expected 28 bytes for StakeKeyHash, got ${bytes.length}`);\n\t\tsuper(bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {StakeKeyHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new StakeKeyHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {StakeKeyHash}\n\t */\n\tstatic fromUplcData(data) {\n\t\treturn new StakeKeyHash(data.bytes);\n\t}\n\t\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {StakeKeyHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn StakeKeyHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {StakeKeyHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new StakeKeyHash(hexToBytes(str));\n\t}\n}\n\nclass StakingValidatorHash extends ScriptHash {\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {StakingValidatorHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new StakingValidatorHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {StakingValidatorHash}\n\t */\n\tstatic fromUplcData(data) {\n\t\treturn new StakingValidatorHash(data.bytes);\n\t}\n\t\t\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {StakingValidatorHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn StakingValidatorHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {StakingValidatorHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new StakingValidatorHash(hexToBytes(str));\n\t}\n}\n\nclass ValidatorHash extends ScriptHash {\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {ValidatorHash}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new ValidatorHash(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {ValidatorHash}\n\t */\n\tstatic fromUplcData(data) {\n\t\treturn new ValidatorHash(data.bytes);\n\t}\n\t\t\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {ValidatorHash}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn ValidatorHash.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n\n\t/**\n\t * @param {string} str \n\t * @returns {ValidatorHash}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new ValidatorHash(hexToBytes(str));\n\t}\n}\n\n/**\n * Hash of a transaction\n */\nclass TxId extends Hash {\n\t/**\n\t * @param {string | number[]} rawValue \n\t */\n\tconstructor(rawValue) {\n        const bytes = Hash.cleanConstructorArg(rawValue);\n\n\t\tassert(bytes.length == 32, `expected 32 bytes for TxId, got ${bytes.length}`);\n\t\tsuper(bytes);\n\t}\n\n    /**\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ConstrData(0, [new ByteArrayData(this.bytes)]);\n    }\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {TxId}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new TxId(CborData.decodeBytes(bytes));\n\t}\n\n    /**\n     * @param {UplcData} data\n     * @returns {TxId}\n     */\n    static fromUplcData(data) {\n        assert(data.index == 0);\n        assert(data.fields.length == 1);\n\n        return new TxId(data.fields[0].bytes);\n    }\n\n    /**\n     * @param {string | number[]} bytes \n     * @returns {TxId}\n     */\n    static fromUplcCbor(bytes) {\n        return TxId.fromUplcData(UplcData.fromCbor(bytes));\n    }\n\n\t/**\n\t * @param {string} str \n\t * @returns {TxId}\n\t */\n\tstatic fromHex(str) {\n\t\treturn new TxId(hexToBytes(str));\n\t}\n\n\t/**\n\t * Filled with 255 so that the internal show() function has max execution budget cost\n\t * @param {number} fill\n\t * @returns {TxId}\n\t */\n\tstatic dummy(fill = 255) {\n\t\treturn new TxId((new Array(32)).fill(fill));\n\t}\n}\n\n/**\n * Id of a Utxo\n */\nclass TxOutputId extends HeliosData {\n    /** @type {TxId} */\n    #txId;\n\n    /** @type {HInt} */\n    #utxoIdx;\n\n    /**\n     * @param  {...any} args\n     * @returns {[any, any]}\n     */\n    static cleanConstructorArgs(...args) {\n        if (args.length == 1) {\n            const arg = args[0];\n\n            if (typeof arg == \"string\") {\n                const parts = arg.split(\"#\");\n\n                assert(parts.length == 2);\n\n                return [parts[0], parts[1]];\n            } else {\n                throw new Error(\"unexpected single arg type\");\n            }\n        } else if (args.length == 2) {\n            return [args[0], args[1]];\n        } else {\n            throw new Error(\"unexpected number of args\");\n        }\n    }\n\n    /**\n     * @param {...any} args\n     */\n    constructor(...args) {\n        const [rawTxId, rawUtxoIdx] = TxOutputId.cleanConstructorArgs(...args);\n\n        const txId = (rawTxId instanceof TxId) ? rawTxId : new TxId(rawTxId);\n        const utxoIdx = (rawUtxoIdx instanceof HInt) ? rawUtxoIdx : new HInt(rawUtxoIdx);\n\n        super();\n\n        this.#txId = txId;\n        this.#utxoIdx = utxoIdx;\n    }\n\n    get txId() {\n        return this.#txId;\n    }\n\n    get utxoIdx() {\n        return this.#utxoIdx;\n    }\n\n    /**\n     * @returns {UplcData}\n     */\n    _toUplcData() {\n        return new ConstrData(0, [this.#txId._toUplcData(), this.#utxoIdx._toUplcData()])\n    }\n\n    /**\n     * @param {UplcData} data\n     * @returns {TxOutputId}\n     */\n    static fromUplcData(data) {\n        assert(data.index == 0);\n        assert(data.fields.length == 2);\n\n        return new TxOutputId(TxId.fromUplcData(data.fields[0]), HInt.fromUplcData(data.fields[1]));\n    }\n\n    /**\n     * @param {string | number[]} bytes \n     * @returns {TxOutputId}\n     */\n    static fromUplcCbor(bytes) {\n        return TxOutputId.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n/**\n * See CIP19 for formatting of first byte\n */\nclass Address extends HeliosData {\n\t/** @type {number[]} */\n\t#bytes;\n\n    /**\n\t * @param {number[] | string} rawValue\n\t * @returns {number[]}\n\t */\n    static cleanConstructorArg(rawValue) {\n        if (typeof rawValue == \"string\") {\n            if (rawValue.startsWith(\"addr\")) {\n                return Address.fromBech32(rawValue).bytes;\n            } else {\n                if (rawValue.startsWith(\"#\")) {\n                    rawValue = rawValue.slice(1);\n                }\n\n                return hexToBytes(rawValue);\n            }\n        } else {\n            return rawValue;\n        }\n    }\n\n\t/**\n\t * @param {string | number[]} rawValue\n\t */\n\tconstructor(rawValue) {\n\t\tsuper();\n\t\tthis.#bytes = Address.cleanConstructorArg(rawValue);\n\n        assert(this.#bytes.length == 29 || this.#bytes.length == 57, `expected 29 or 57 bytes for Address, got ${this.#bytes.length}`);\n\t}\n\n\tget bytes() {\n\t\treturn this.#bytes.slice();\n\t}\n\n\ttoCbor() {\n\t\treturn CborData.encodeBytes(this.#bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {Address}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new Address(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @param {string} str\n\t * @returns {Address}\n\t */\n\tstatic fromBech32(str) {\n\t\t// ignore the prefix (encoded in the bytes anyway)\n\t\tlet [prefix, bytes] = Crypto.decodeBech32(str);\n\n\t\tlet result = new Address(bytes);\n\n\t\tassert(prefix == (Address.isForTestnet(result) ? \"addr_test\" : \"addr\"), \"invalid Address prefix\");\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Doesn't check validity\n\t * @param {string} hex\n\t * @returns {Address}\n\t */\n\tstatic fromHex(hex) {\n\t\treturn new Address(hexToBytes(hex));\n\t}\n\n\t/**\n\t * Returns the raw Address bytes as a hex encoded string\n\t * @returns {string}\n\t */\n\ttoHex() {\n\t\treturn bytesToHex(this.#bytes);\n\t}\n\n    /**\n     * @param {PubKeyHash | ValidatorHash} hash \n     * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash \n     * @param {boolean} isTestnet\n     * @returns {Address}\n     */\n    static fromHashes(hash, stakingHash = null, isTestnet = config.IS_TESTNET) {\n        if (hash instanceof PubKeyHash) {\n            return Address.fromPubKeyHash(hash, stakingHash, isTestnet);\n        } else if (hash instanceof ValidatorHash) {\n            return Address.fromValidatorHash(hash, stakingHash, isTestnet);\n        } else {\n            throw new Error(\"unexpected\");\n        }\n    }\n\n\t/**\n\t * Simple payment address without a staking part\n\t * @param {PubKeyHash} hash\n\t * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash\n     * @param {boolean} isTestnet\n\t * @returns {Address}\n\t */\n\tstatic fromPubKeyHash(hash, stakingHash = null, isTestnet = config.IS_TESTNET) {\n\t\tif (stakingHash !== null) {\n\t\t\tif (stakingHash instanceof StakeKeyHash) {\n\t\t\t\treturn new Address(\n\t\t\t\t\t[isTestnet ? 0x00 : 0x01].concat(hash.bytes).concat(stakingHash.bytes)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tassert(stakingHash instanceof StakingValidatorHash);\n\t\t\t\treturn new Address(\n\t\t\t\t\t[isTestnet ? 0x20 : 0x21].concat(hash.bytes).concat(stakingHash.bytes)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\treturn new Address([isTestnet ? 0x60 : 0x61].concat(hash.bytes));\n\t\t}\n\t}\n\n\t/**\n\t * Simple script address without a staking part\n\t * Only relevant for validator scripts\n\t * @param {ValidatorHash} hash\n\t * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash\n     * @param {boolean} isTestnet\n\t * @returns {Address}\n\t */\n\tstatic fromValidatorHash(hash, stakingHash = null, isTestnet = config.IS_TESTNET) {\n\t\tif (stakingHash !== null) {\n\t\t\tif (stakingHash instanceof StakeKeyHash) {\n\t\t\t\treturn new Address(\n\t\t\t\t\t[isTestnet ? 0x10 : 0x11].concat(hash.bytes).concat(stakingHash.bytes)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tassert(stakingHash instanceof StakingValidatorHash);\n\t\t\t\treturn new Address(\n\t\t\t\t\t[isTestnet ? 0x30 : 0x31].concat(hash.bytes).concat(stakingHash.bytes)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\treturn new Address([isTestnet ? 0x70 : 0x71].concat(hash.bytes));\n\t\t}\n\t}\n\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoBech32() {\n\t\treturn Crypto.encodeBech32(\n\t\t\tAddress.isForTestnet(this) ? \"addr_test\" : \"addr\",\n\t\t\tthis.#bytes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\thex: bytesToHex(this.#bytes),\n\t\t\tbech32: this.toBech32(),\n\t\t};\n\t}\n\n\t/**\n\t * @param {Address} address\n\t * @returns {boolean}\n\t */\n\tstatic isForTestnet(address) {\n\t\tlet type = address.bytes[0] & 0b00001111;\n\n\t\treturn type == 0;\n\t}\n\n\t/**\n     * \n     * @private\n\t * @returns {ConstrData}\n\t */\n\ttoCredentialData() {\n\t\tlet vh = this.validatorHash;\n\n\t\tif (vh !== null) {\n\t\t\treturn new ConstrData(1, [new ByteArrayData(vh.bytes)]);\n\t\t} else {\n\t\t\tlet pkh = this.pubKeyHash;\n\n\t\t\tif (pkh === null) {\n\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t} else {\n\t\t\t\treturn new ConstrData(0, [new ByteArrayData(pkh.bytes)]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoStakingData() {\n        const type = this.#bytes[0] >> 4;\n\t\tconst sh = this.stakingHash;\n\n\t\tif (sh == null) {\n\t\t\treturn new ConstrData(1, []); // none\n\t\t} else {\n            if (type == 4 || type == 5) {\n                throw new Error(\"not yet implemented\");\n            } else if (type == 3 || type == 2) {\n                // some\n                return new ConstrData(0, [\n                    // staking credential -> 0, 1 -> pointer\n                    new ConstrData(0, [\n                        // StakingValidator credential\n                        new ConstrData(1, [new ByteArrayData(sh.bytes)]),\n                    ]),\n                ]);\n            } else if (type == 0 || type == 1) {\n                // some\n                return new ConstrData(0, [\n                    // staking credential -> 0, 1 -> pointer\n                    new ConstrData(0, [\n                        // StakeKeyHash credential\n                        new ConstrData(0, [new ByteArrayData(sh.bytes)]),\n                    ]),\n                ]);\n            } else {\n                throw new Error(\"unexpected\");\n            }\n\t\t}\n\t}\n\n\t/**\n\t * @returns {UplcData}\n\t */\n\t_toUplcData() {\n\t\treturn new ConstrData(0, [this.toCredentialData(), this.toStakingData()]);\n\t}\n\n    /**\n     * @param {UplcData} data \n     * @param {boolean} isTestnet\n     * @returns {Address}\n     */\n    static fromUplcData(data, isTestnet = config.IS_TESTNET) {\n        assert(data.index == 0);\n        assert(data.fields.length == 2);\n        \n        const credData = data.fields[0];\n        const stakData = data.fields[1];\n\n        assert(credData.fields.length == 1);\n\n        /**\n         * @type {?(StakeKeyHash | StakingValidatorHash)}\n         */\n        let sh;\n\n\t\t// for some weird reason Option::None has index 1\n        if (stakData.index == 1) {\n            sh = null;\n        } else if (stakData.index == 0) {\n            assert(stakData.fields.length == 1);\n\n            const inner = stakData.fields[0];\n            assert(inner.fields.length == 1);\n\n            if (inner.index == 0) {\n                const innerInner = inner.fields[0];\n                assert(innerInner.fields.length == 1);\n\n                if (innerInner.index == 0) {\n                    sh = new StakeKeyHash(innerInner.fields[0].bytes);\n                } else if (innerInner.index == 1) {\n                    sh = new StakingValidatorHash(innerInner.fields[0].bytes);\n                } else {\n                    throw new Error(\"unexpected\");\n                }\n            } else if (inner.index == 1) {\n                throw new Error(\"staking pointer not yet handled\");\n            } else {\n                throw new Error(\"unexpected\");\n            }\n        } else {\n            throw new Error(\"unexpected\");\n        }\n\n        if (credData.index == 0) {\n            return Address.fromPubKeyHash(new PubKeyHash(credData.fields[0].bytes), sh, isTestnet);\n        } else if (credData.index == 1) {\n            return Address.fromValidatorHash(new ValidatorHash(credData.fields[0].bytes), sh, isTestnet);\n        } else {\n            throw new Error(\"unexpected\");\n        }\n    }\n\n    /**\n     * @param {string | number[]} bytes \n     * @param {boolean} isTestnet\n     * @returns {Address}\n     */\n    static fromUplcCbor(bytes, isTestnet = config.IS_TESTNET) {\n        return Address.fromUplcData(UplcData.fromCbor(bytes), isTestnet);\n    }\n\n\t/**\n\t * @type {?PubKeyHash}\n\t */\n\tget pubKeyHash() {\n\t\tlet type = this.#bytes[0] >> 4;\n\n\t\tif (type % 2 == 0) {\n\t\t\treturn new PubKeyHash(this.#bytes.slice(1, 29));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * @type {?ValidatorHash}\n\t */\n\tget validatorHash() {\n\t\tlet type = this.#bytes[0] >> 4;\n\n\t\tif (type % 2 == 1) {\n\t\t\treturn new ValidatorHash(this.#bytes.slice(1, 29));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * @type {?(StakeKeyHash | StakingValidatorHash)}\n\t */\n\tget stakingHash() {\n\t\tlet type = this.#bytes[0] >> 4;\n\n        let bytes = this.#bytes.slice(29);\n        \n\n        if (type == 0 || type == 1) {\n            assert(bytes.length == 28);\n            return new StakeKeyHash(bytes);\n        } else if (type == 2 || type == 3) {\n            assert(bytes.length == 28);\n            return new StakingValidatorHash(bytes);\n        } else if (type == 4 || type == 5) {\n            throw new Error(\"staking pointer not yet supported\");\n        } else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Used to sort txbody withdrawals\n\t * @param {Address} a\n\t * @param {Address} b\n\t * @return {number}\n\t */\n\tstatic compStakingHashes(a, b) {\n\t\treturn Hash.compare(assertDefined(a.stakingHash), assertDefined(b.stakingHash));\n\t}\n}\n\nclass AssetClass extends HeliosData {\n\t/**\n\t * @type {MintingPolicyHash}\n\t */\n\t#mph;\n\n\t/**\n\t * @type {number[]}\n\t */\n\t#tokenName;\n\n\t/**\n\t * @param {any[]} args\n\t * @returns {[MintingPolicyHash, number[]]}\n\t */\n\tstatic cleanConstructorArgs(args) {\n\t\tif (args.length == 1) {\n\t\t\tconst arg = args[0];\t\n\n\t\t\tif (typeof arg == \"string\") {\n\t\t\t\tconst fields = arg.split(\".\")\n\n\t\t\t\tassert(fields.length == 2, \"expected '.' in hex encoded AssetClass\");\n\n\t\t\t\treturn [new MintingPolicyHash(fields[0]), hexToBytes(fields[1])];\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unexpected AssetClass arg type\");\n\t\t\t}\n\t\t} else if (args.length == 2) {\n\t\t\tconst arg0 = args[0];\n\t\t\tconst arg1 = args[1];\n\n\t\t\treturn [\n\t\t\t\targ0 instanceof MintingPolicyHash ? arg0 : new MintingPolicyHash(arg0),\n\t\t\t\tArray.isArray(arg1) ? arg1 : hexToBytes(arg1)\n\t\t\t];\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected number of AssetClass args\");\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {any[]} args \n\t */\n\tconstructor(...args) {\n\t\tsuper();\n\t\tconst [mph, tokenName] = AssetClass.cleanConstructorArgs(args);\n\n\t\tthis.#mph = mph;\n\t\tthis.#tokenName = tokenName;\n\t}\n\n\t/**\n\t * Used when generating script contexts for running programs\n\t * @returns {ConstrData}\n\t */\n\t_toUplcData() {\n\t\treturn new ConstrData(0, [\n\t\t\tthis.#mph._toUplcData(),\n\t\t\tnew ByteArrayData(this.#tokenName)\n\t\t])\n\t}\n\n\t/**\n\t * \n\t * @param {UplcData} data \n\t * @returns {AssetClass}\n\t */\n\tstatic fromUplcData(data) {\n\t\tassert(data.index == 0);\n\t\tassert(data.fields.length == 2);\n\n\t\tconst mph = MintingPolicyHash.fromUplcData(data.fields[0]);\n\t\tconst tokenName = data.fields[1].bytes;\n\n\t\treturn new AssetClass(mph, tokenName);\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeConstr(0, [\n\t\t\tthis.#mph.toCbor(),\n\t\t\tCborData.encodeBytes(this.#tokenName)\n\t\t]);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t */\n\tstatic fromCbor(bytes) {\n\t\t/**\n\t\t * @type {MintingPolicyHash | null}\n\t\t */\n\t\tlet mph = null;\n\n\t\t/**\n\t\t * @type {number[] | null}\n\t\t */\n\t\tlet tokenName = null;\n\n\t\tconst tag = CborData.decodeConstr(bytes, (i, fieldBytes) => {\n\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tmph = MintingPolicyHash.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttokenName = CborData.decodeBytes(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unexpected field\");\n\t\t\t} \n\t\t});\n\n\t\tassert(tag == 0);\n\n\t\tif (mph == null || tokenName == null) {\n\t\t\tthrow new Error(\"insufficient fields\");\n\t\t} else {\n\t\t\treturn new AssetClass(mph, tokenName);\n\t\t}\n\t}\n\n    /**\n     * @param {string | number[]} bytes\n     * @returns {AssetClass}\n     */\n    static fromUplcCbor(bytes) {\n        return AssetClass.fromUplcData(UplcData.fromCbor(bytes));\n    }\n}\n\n\n/**\n * Collection of non-lovelace assets\n */\nclass Assets extends CborData {\n\t/** @type {[MintingPolicyHash, [number[], bigint][]][]} */\n\t#assets;\n\n\t/**\n\t * @param {[MintingPolicyHash | number[] | string, [number[] | string, bigint | number][]][]} assets \n\t */\n\tconstructor(assets = []) {\n\t\tsuper();\n\t\tthis.#assets = assets.map(([rawMph, tokens]) => {\n\t\t\tconst mph = rawMph instanceof MintingPolicyHash ? rawMph : new MintingPolicyHash(rawMph);\n\n\t\t\treturn [\n\t\t\t\tmph,\n\t\t\t\ttokens.map(([rawName, amount]) => {\n\t\t\t\t\tconst name = Array.isArray(rawName) ? rawName : hexToBytes(rawName);\n\n\t\t\t\t\treturn [name, BigInt(amount)];\n\t\t\t\t})\n\t\t\t];\n\t\t});\n\t}\n\n\t/**\n\t * @type {MintingPolicyHash[]}\n\t */\n\tget mintingPolicies() {\n\t\treturn this.#assets.map(([mph, _]) => mph);\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget nTokenTypes() {\n\t\tlet count = 0;\n\t\t\n\t\tthis.#assets.forEach(([mph, tokens]) => {\n\t\t\ttokens.forEach(([tokenName, _]) => {\n\t\t\t\tcount += 1\n\t\t\t})\n\t\t})\n\n\t\treturn count;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisZero() {\n\t\treturn this.#assets.length == 0;\n\t}\n\n\t/**\n\t * @param {MintingPolicyHash} mph\n\t * @param {number[]} tokenName \n\t * @returns {boolean}\n\t */\n\thas(mph, tokenName) {\n\t\tlet inner = this.#assets.find(asset => mph.eq(asset[0]));\n\n\t\tif (inner !== undefined) {\n\t\t\treturn inner[1].findIndex(pair => eq(pair[0], tokenName)) != -1;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {MintingPolicyHash} mph\n\t * @param {number[]} tokenName \n\t * @returns {bigint}\n\t */\n\tget(mph, tokenName) {\n\t\tlet inner = this.#assets.find(asset => mph.eq(asset[0]));\n\n\t\tif (inner !== undefined) {\n\t\t\tlet token = inner[1].find(pair => eq(pair[0], tokenName));\n\n\t\t\tif (token !== undefined) {\n\t\t\t\treturn token[1];\n\t\t\t} else {\n\t\t\t\treturn 0n;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0n;\n\t\t}\n\t}\n\n\t/**\n\t * Mutates 'this'\n\t */\n\tremoveZeroes() {\n\t\tfor (let asset of this.#assets) {\n\t\t\tasset[1] = asset[1].filter(token => token[1] != 0n);\n\t\t}\n\n\t\tthis.#assets = this.#assets.filter(asset => asset[1].length != 0);\n\t}\n\n\t/**\n\t * Mutates 'this'\n\t * @param {MintingPolicyHash} mph\n\t * @param {number[]} tokenName \n\t * @param {bigint} quantity\n\t */\n\taddComponent(mph, tokenName, quantity) {\n\t\tif (quantity == 0n) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet inner = this.#assets.find(asset => mph.eq(asset[0]));\n\n\t\tif (inner === undefined) {\n\t\t\tthis.#assets.push([mph, [[tokenName, quantity]]]);\n\t\t} else {\n\t\t\tlet token = inner[1].find(pair => eq(pair[0], tokenName));\n\n\t\t\tif (token === undefined) {\n\t\t\t\tinner[1].push([tokenName, quantity]);\n\t\t\t} else {\n\t\t\t\ttoken[1] += quantity;\n\t\t\t}\n\t\t}\n\n\t\tthis.removeZeroes();\n\t}\n\n\t/**\n\t * @param {Assets} other \n\t * @param {(a: bigint, b: bigint) => bigint} op \n\t * @returns {Assets}\n\t */\n\tapplyBinOp(other, op) {\n\t\tlet res = new Assets();\n\n\t\tfor (let [mph, tokens] of this.#assets) {\n\t\t\tfor (let [tokenName, quantity] of tokens) {\n\t\t\t\tres.addComponent(mph, tokenName, op(quantity, 0n));\n\t\t\t}\n\t\t}\n\n\t\tfor (let [mph, tokens] of other.#assets) {\n\t\t\tfor (let [tokenName, quantity] of tokens) {\n\t\t\t\tres.addComponent(mph, tokenName, op(0n, quantity));\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @param {Assets} other \n\t * @returns {Assets}\n\t */\n\tadd(other) {\n\t\treturn this.applyBinOp(other, (a, b) => a + b);\n\t}\n\n\t/**\n\t * @param {Assets} other \n\t * @returns {Assets}\n\t */\n\tsub(other) {\n\t\treturn this.applyBinOp(other, (a, b) => a - b);\n\t}\n\n\t/**\n\t * Mutates 'this'\n\t * Throws error if mph is already contained in 'this'\n\t * @param {MintingPolicyHash} mph\n\t * @param {[number[], bigint][]} tokens\n\t */\n\taddTokens(mph, tokens) {\n\t\tfor (let asset of this.#assets) {\n\t\t\tif (asset[0].eq(mph)) {\n\t\t\t\tthrow new Error(`MultiAsset already contains ${bytesToHex(mph.bytes)}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.#assets.push([mph, tokens.slice()]);\n\n\t\t// sort immediately\n\t\tthis.sort();\n\t}\n\n\t/**\n\t * @param {MintingPolicyHash} mph\n\t * @returns {number[][]}\n\t */\n\tgetTokenNames(mph) {\n\t\tfor (let [otherMph, tokens] of this.#assets) {\n\t\t\tif (otherMph.eq(mph)) {\n\t\t\t\treturn tokens.map(([tokenName, _]) => tokenName);\n\t\t\t}\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t/**\n\t * @param {Assets} other \n\t * @returns {boolean}\n\t */\n\teq(other) {\n\t\tfor (let asset of this.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (token[1] != other.get(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let asset of other.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (token[1] != this.get(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Strict gt, if other contains assets this one doesn't contain => return false\n\t * @param {Assets} other \n\t * @returns {boolean}\n\t */\n\tgt(other) {\n\t\tif (this.isZero()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let asset of this.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (token[1] <= other.get(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let asset of other.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (!this.has(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Assets} other \n\t * @returns {boolean}\n\t */\n\tge(other) {\n\t\tif (this.isZero()) {\n\t\t\treturn other.isZero();\n\t\t}\n\n\t\tfor (let asset of this.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (token[1] < other.get(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let asset of other.#assets) {\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tif (!this.has(asset[0], token[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tallPositive() {\n\t\tfor (let asset of this.#assets) {\n\t\t\tfor (let pair of asset[1]) {\n\t\t\t\tif (pair[1] < 0n) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (pair[1] == 0n) {\n\t\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Throws an error if any contained quantity <= 0n\n\t */\n\tassertAllPositive() {\n\t\tassert(this.allPositive(), \"non-positive token amounts detected\");\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeMap(\n\t\t\tthis.#assets.map(\n\t\t\t\touterPair => {\n\t\t\t\t\treturn [outerPair[0].toCbor(), CborData.encodeMap(outerPair[1].map(\n\t\t\t\t\t\tinnerPair => {\n\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\tCborData.encodeBytes(innerPair[0]), CborData.encodeInteger(innerPair[1])\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t))]\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {Assets}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tlet ms = new Assets();\n\n\t\tCborData.decodeMap(bytes, (_, pairBytes) => {\n\t\t\tlet mph = MintingPolicyHash.fromCbor(pairBytes);\n\n\t\t\t/**\n\t\t\t * @type {[number[], bigint][]}\n\t\t\t */\n\t\t\tlet innerMap = [];\n\t\t\t\n\t\t\tCborData.decodeMap(pairBytes, (_, innerPairBytes) => {\n\t\t\t\tinnerMap.push([\n\t\t\t\t\tCborData.decodeBytes(innerPairBytes),\n\t\t\t\t\tCborData.decodeInteger(innerPairBytes),\n\t\t\t\t]);\n\t\t\t});\n\n\t\t\tms.#assets.push([mph, innerMap]);\n\t\t});\n\n\t\treturn ms;\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tlet obj = {};\n\n\t\tfor (let [mph, tokens] of this.#assets) {\n\t\t\tlet innerObj = {};\n\n\t\t\tfor (let [tokenName, quantity] of tokens) {\n\t\t\t\tinnerObj[bytesToHex(tokenName)] = quantity.toString();\n\t\t\t}\n\n\t\t\tobj[mph.dump()] = innerObj;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\t/**\n\t * Used when generating script contexts for running programs\n\t * @returns {MapData}\n\t */\n\t_toUplcData() {\n\t\t/** @type {[UplcData, UplcData][]} */\n\t\tlet pairs = [];\n\n\t\tfor (let asset of this.#assets) {\n\t\t\t/** @type {[UplcData, UplcData][]} */\n\t\t\tlet innerPairs = [];\n\n\t\t\tfor (let token of asset[1]) {\n\t\t\t\tinnerPairs.push([\n\t\t\t\t\tnew ByteArrayData(token[0]),\n\t\t\t\t\tnew IntData(token[1]),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tpairs.push([\n\t\t\t\tnew ByteArrayData(asset[0].bytes),\n\t\t\t\tnew MapData(innerPairs),\n\t\t\t])\n\t\t}\n\n\t\treturn new MapData(pairs);\n\t}\n\n\t/**\n\t * Makes sure minting policies are in correct order\n\t * Mutates 'this'\n\t * Order of tokens per mintingPolicyHash isn't changed\n\t */\n\tsort() {\n\t\tthis.#assets.sort((a, b) => {\n\t\t\treturn Hash.compare(a[0], b[0]);\n\t\t});\n\t}\n\n\tassertSorted() {\n\t\tthis.#assets.forEach((b, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tconst a = this.#assets[i-1];\n\n\t\t\t\tassert(Hash.compare(a[0], b[0]) == -1, \"assets not sorted\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nclass Value extends HeliosData {\n\t/** @type {bigint} */\n\t#lovelace;\n\n\t/** @type {Assets} */\n\t#assets;\n\t\n\t/**\n\t * @param {bigint} lovelace \n\t * @param {Assets} assets \n\t */\n\tconstructor(lovelace = 0n, assets = new Assets()) {\n\t\tsuper();\n\t\tthis.#lovelace = lovelace;\n\t\tthis.#assets = assets;\n\t}\n\n\t/**\n\t * @param {MintingPolicyHash} mph \n\t * @param {number[]} tokenName \n\t * @param {bigint} quantity \n\t * @returns {Value}\n\t */\n\tstatic asset(mph, tokenName, quantity) {\n\t\treturn new Value(0n, new Assets([\n\t\t\t[mph, [\n\t\t\t\t[tokenName, quantity]\n\t\t\t]]\n\t\t]));\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget lovelace() {\n\t\treturn this.#lovelace;\n\t}\n\n\t/**\n\t * Setter for lovelace\n\t * Note: mutation is handy when balancing transactions\n\t * @param {bigint} lovelace\n\t */\n\tsetLovelace(lovelace) {\n\t\tthis.#lovelace = lovelace;\n\t}\n\n\t/**\n\t * @type {Assets}\n\t */\n\tget assets() {\n\t\treturn this.#assets;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\tif (this.#assets.isZero()) {\n\t\t\treturn CborData.encodeInteger(this.#lovelace);\n\t\t} else {\n\t\t\treturn CborData.encodeTuple([\n\t\t\t\tCborData.encodeInteger(this.#lovelace),\n\t\t\t\tthis.#assets.toCbor()\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {Value}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tlet mv = new Value();\n\n\t\tif (CborData.isTuple(bytes)) {\n\t\t\tCborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\t\tswitch(i) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmv.#lovelace = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmv.#assets = Assets.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tmv.#lovelace = CborData.decodeInteger(bytes);\n\t\t}\n\n\t\treturn mv;\n\t}\n\n\t/**\n\t * @param {Value[]} values \n\t * @returns {Value}\n\t */\n\tstatic sum(values) {\n\t\tlet s = new Value(0n);\n\n\t\tvalues.forEach(v => {\n\t\t\ts = s.add(v);\n\t\t});\n\n\t\treturn s;\n\t}\n\t\n\t/**\n\t * @param {Value} other \n\t * @returns {Value}\n\t */\n\tadd(other) {\n\t\treturn new Value(this.#lovelace + other.#lovelace, this.#assets.add(other.#assets));\n\t}\n\n\t/**\n\t * @param {Value} other \n\t * @returns {Value}\n\t */\n\tsub(other) {\n\t\treturn new Value(this.#lovelace - other.#lovelace, this.#assets.sub(other.#assets));\n\t}\n\n\t/**\n\t * @param {Value} other \n\t * @returns {boolean}\n\t */\n\teq(other) {\n\t\treturn (this.#lovelace == other.#lovelace) && (this.#assets.eq(other.#assets));\n\t}\n\n\t/**\n\t * Strictly greater than. Returns false if any asset is missing \n\t * @param {Value} other \n\t * @returns {boolean}\n\t */\n\tgt(other) {\n\t\treturn (this.#lovelace > other.#lovelace) && (this.#assets.gt(other.#assets));\n\t}\n\n\t/**\n\t * Strictly >= \n\t * @param {Value} other \n\t * @returns {boolean}\n\t */\n\tge(other) {\n\t\treturn (this.#lovelace >= other.#lovelace) && (this.#assets.ge(other.#assets));\n\t}\n\n\t/**\n\t * Throws an error if any contained quantity is negative\n\t * Used when building transactions because transactions can't contain negative values\n\t * @returns {Value} - returns this\n\t */\n\tassertAllPositive() {\n\t\tassert(this.#lovelace >= 0n);\n\n\t\tthis.#assets.assertAllPositive();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tlovelace: this.#lovelace.toString(),\n\t\t\tassets: this.#assets.dump()\n\t\t};\n\t}\n\n\t/**\n\t * Used when building script context\n\t * @param {boolean} isInScriptContext\n\t * @returns {MapData}\n\t */\n\t_toUplcData(isInScriptContext = false) {\n\t\tlet map = this.#assets._toUplcData();\n\n\t\tif (this.#lovelace != 0n || isInScriptContext) {\n\t\t\tlet inner = map.map; \n\n\t\t\tinner.unshift([\n\t\t\t\tnew ByteArrayData([]),\n\t\t\t\tnew MapData([\n\t\t\t\t\t[new ByteArrayData([]), new IntData(this.#lovelace)]\n\t\t\t\t]),\n\t\t\t]);\n\n\t\t\t// 'inner' is copy, so mutating won't change the original\n\t\t\tmap = new MapData(inner);\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Useful when deserializing inline datums\n\t * @param {UplcData} data\n\t * @returns {Value}\n\t */\n\tstatic fromUplcData(data) {\n\t\tlet sum = new Value();\n\n\t\tlet outerMap = data.map;\n\n\t\tfor (let [mphData, tokensData] of outerMap) {\n\t\t\tlet mphBytes = mphData.bytes;\n\n\t\t\tlet innerMap = tokensData.map;\n\n\t\t\tif (mphBytes.length == 0) {\n\t\t\t\t//lovelace\n\t\t\t\tassert(innerMap.length == 1 && innerMap[0][0].bytes.length == 0); \n\t\t\t\tsum = sum.add(new Value(innerMap[0][1].int));\n\t\t\t} else {\n\t\t\t\t// other assets\n\t\t\t\tlet mph = new MintingPolicyHash(mphBytes);\n\n\t\t\t\tfor (let [tokenNameData, quantityData] of innerMap) {\n\t\t\t\t\tlet tokenName = tokenNameData.bytes;\n\t\t\t\t\tlet quantity = quantityData.int;\n\n\t\t\t\t\tsum = sum.add(Value.asset(mph, tokenName, quantity));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t/**\n\t * @param {string | number[]} bytes \n\t * @returns {Value}\n\t */\n\tstatic fromUplcCbor(bytes) {\n\t\treturn Value.fromUplcData(UplcData.fromCbor(bytes));\n\t}\n}\n\n\n//////////////////////////////\n// Section 8: Uplc cost-models\n//////////////////////////////\n\n/**\n * @typedef {Object} Cost\n * @property {bigint} mem\n * @property {bigint} cpu\n */\n\n/**\n * NetworkParams contains all protocol parameters. These are needed to do correct, up-to-date, cost calculations.\n */\nclass NetworkParams {\n\t#raw;\n\n\t/**\n\t * @param {Object} raw \n\t */\n\tconstructor(raw) {\n\t\tthis.#raw = raw;\n\t}\n\t\n    /**\n     * @package\n     * @type {Object}\n     */\n\tget costModel() {\n\t\treturn assertDefined(this.#raw?.latestParams?.costModels?.PlutusScriptV2, \"'obj.latestParams.costModels.PlutusScriptV2' undefined\");\n\t}\n\n\t/**\n     * @package\n\t * @param {string} key \n\t * @returns {number}\n\t */\n\tgetCostModelParameter(key) {\n\t\treturn assertNumber(this.costModel[key], `'obj.${key}' undefined`);\n\t}\n\n\t/**\n     * @package\n\t * @param {string} name \n\t * @returns {Cost}\n\t */\n\tgetTermCost(name) {\n\t\tlet memKey = `cek${name}Cost-exBudgetMemory`;\n\t\tlet cpuKey = `cek${name}Cost-exBudgetCPU`;\n\n\t\treturn {\n\t\t\tmem: BigInt(assertNumber(this.costModel[memKey], `'obj.${memKey}' undefined`)),\n\t\t\tcpu: BigInt(assertNumber(this.costModel[cpuKey], `'obj.${cpuKey}' undefined`)),\n\t\t};\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreStartupCost() {\n\t\treturn this.getTermCost(\"Startup\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreVariableCost() {\n\t\treturn this.getTermCost(\"Var\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreLambdaCost() {\n\t\treturn this.getTermCost(\"Lam\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreDelayCost() {\n\t\treturn this.getTermCost(\"Delay\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreCallCost() {\n\t\treturn this.getTermCost(\"Apply\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreConstCost() {\n\t\treturn this.getTermCost(\"Const\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreForceCost() {\n\t\treturn this.getTermCost(\"Force\");\n\t}\n\n\t/**\n     * @package\n\t * @type {Cost}\n\t */\n\tget plutusCoreBuiltinCost() {\n\t\treturn this.getTermCost(\"Builtin\");\n\t}\n\n\t/**\n     * @package\n\t * @type {[number, number]} - a + b*size\n\t */\n\tget txFeeParams() {\n\t\treturn [\n\t\t\tassertNumber(this.#raw?.latestParams?.txFeeFixed),\n\t\t\tassertNumber(this.#raw?.latestParams?.txFeePerByte),\n\t\t];\n\t}\n\n\t/**\n     * @package\n\t * @type {[number, number]} - [memFee, cpuFee]\n\t */\n\tget exFeeParams() {\n\t\treturn [\n\t\t\tassertNumber(this.#raw?.latestParams?.executionUnitPrices?.priceMemory),\n\t\t\tassertNumber(this.#raw?.latestParams?.executionUnitPrices?.priceSteps),\n\t\t];\n\t}\n\t\n\t/**\n     * @package\n\t * @type {number[]}\n\t */\n\tget sortedCostParams() {\n\t\tlet baseObj = this.#raw?.latestParams?.costModels?.PlutusScriptV2;\n\t\tlet keys = Object.keys(baseObj);\n\n\t\tkeys.sort();\n\n\t\treturn keys.map(key => assertNumber(baseObj[key]));\n\t}\n\n\t/**\n     * @package\n\t * @type {number}\n\t */\n\tget lovelacePerUTXOByte() {\n\t\treturn assertNumber(this.#raw?.latestParams?.utxoCostPerByte);\n\t}\n\n\t/**\n     * @package\n\t * @type {number}\n\t */\n\tget minCollateralPct() {\n\t\treturn assertNumber(this.#raw?.latestParams?.collateralPercentage);\n\t}\n\n\t/**\n     * @package\n\t * @type {number}\n\t */\n\tget maxCollateralInputs() {\n\t\treturn assertNumber(this.#raw?.latestParams?.maxCollateralInputs);\n\t}\n\n\t/**\n     * @package\n\t * @type {[number, number]} - [mem, cpu]\n\t */\n\tget maxTxExecutionBudget() {\n\t\treturn [\n\t\t\tassertNumber(this.#raw?.latestParams?.maxTxExecutionUnits?.memory),\n\t\t\tassertNumber(this.#raw?.latestParams?.maxTxExecutionUnits?.steps),\n\t\t];\n\t}\n\n\t/**\n     * @package\n\t * @type {number}\n\t */\n\tget maxTxSize() {\n\t\treturn assertNumber(this.#raw?.latestParams?.maxTxSize);\n\t}\n\n\t/**\n\t * @package\n\t * @type {bigint}\n\t */\n\tget maxTxFee() {\n\t\tconst [a, b] = this.txFeeParams;\n\t\tconst [feePerMem, feePerCpu] = this.exFeeParams;\n\t\tconst [maxMem, maxCpu] = this.maxTxExecutionBudget;\n\n\t\treturn BigInt(a) + BigInt(Math.ceil(b*this.maxTxSize)) + BigInt(Math.ceil(feePerMem*maxMem)) + BigInt(Math.ceil(feePerCpu*maxCpu));\n\t}\n\n\t/**\n\t * Use the latest slot in networkParameters to determine time.\n     * @package\n\t * @param {bigint} slot\n\t * @returns {bigint}\n\t */\n\tslotToTime(slot) {\n\t\tlet secondsPerSlot = assertNumber(this.#raw?.shelleyGenesis?.slotLength);\n\n\t\tlet lastSlot = BigInt(assertNumber(this.#raw?.latestTip?.slot));\n\t\tlet lastTime = BigInt(assertNumber(this.#raw?.latestTip?.time));\n\n\t\tlet slotDiff = slot - lastSlot;\n\n\t\treturn lastTime + slotDiff*BigInt(secondsPerSlot*1000);\n\t}\n\n\t/**\n\t * Use the latest slot in network parameters to determine slot.\n     * @package\n\t * @param {bigint} time - milliseconds since 1970\n\t * @returns {bigint}\n\t */\n\ttimeToSlot(time) {\n\t\tlet secondsPerSlot = assertNumber(this.#raw?.shelleyGenesis?.slotLength);\n\n\t\tlet lastSlot = BigInt(assertNumber(this.#raw?.latestTip?.slot));\n\t\tlet lastTime = BigInt(assertNumber(this.#raw?.latestTip?.time));\n\n\t\tlet timeDiff = time - lastTime;\n\n\t\treturn lastSlot + BigInt(Math.round(Number(timeDiff)/(1000*secondsPerSlot)));\n\t}\n}\n\n/**\n * Each builtin has an associated CostModel.\n * The CostModel calculates the execution cost of a builtin, depending on the byte-size of the inputs.\n * @package\n */\nclass CostModel {\n\tconstructor() {\n\t}\n\n\t/**\n\t * @param {NetworkParams} params\n\t * @param {string} baseName\n\t * @returns {CostModel}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {number[]} args \n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * A simple constant cost, independent of arg size.\n * @package\n */\nclass ConstCost extends CostModel {\n\t#constant;\n\n\t/**\n\t * @param {bigint} constant\n\t */\n\tconstructor(constant) {\n\t\tsuper();\n\t\tthis.#constant = constant;\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {ConstCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet a = params.getCostModelParameter(`${baseName}`);\n\n\t\treturn new ConstCost(BigInt(a));\n\t}\n\n\t/**\n\t * @param {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\treturn this.#constant;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn `const: ${this.#constant.toString()}`;\n\t}\n}\n\n/**\n * cost = a + b*size(arg)\n * @package\n */\nclass LinearCost extends CostModel {\n\t#a;\n\t#b;\n\n\t/**\n\t * a + b*SizeFn(x, y)\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tthis.#a = a;\n\t\tthis.#b = b;\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {[bigint, bigint]}\n\t */\n\tstatic getParams(params, baseName) {\n\t\tlet a = params.getCostModelParameter(`${baseName}-intercept`);\n\t\tlet b = params.getCostModelParameter(`${baseName}-slope`);\n\n\t\treturn [BigInt(a), BigInt(b)];\n\t}\n\n\t/**\n\t * @param  {number} size\n\t * @returns {bigint}\n\t */\n\tcalcInternal(size) {\n\t\treturn this.#a + this.#b*BigInt(size);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn `intercept: ${this.#a.toString()}, slope: ${this.#b.toString()}`;\n\t}\n}\n\n/**\n * cost = a + b*size(args[i])\n * @package\n */\nclass ArgSizeCost extends LinearCost {\n\t#i;\n\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t * @param {number} i - index of the arg\n\t */\n\tconstructor(a, b, i) {\n\t\tsuper(a, b);\n\t\tthis.#i = i;\n\t}\n\n\t/**\n\t * @param {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tassert(this.#i < args.length && this.#i >= 0);\n\n\t\treturn this.calcInternal(args[this.#i]);\n\t}\n}\n\n/**\n * cost = a + b*size(arg0)\n * @package\n */\nclass Arg0SizeCost extends ArgSizeCost {\n\t/**\n\t * @param {bigint} a \n\t * @param {bigint} b \n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b, 0);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {Arg0SizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new Arg0SizeCost(a, b);\n\t}\n}\n\n/**\n * cost = a + b*size(arg1)\n * @package\n */\nclass Arg1SizeCost extends ArgSizeCost {\n\t/**\n\t * @param {bigint} a \n\t * @param {bigint} b \n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b, 1);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {Arg1SizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new Arg1SizeCost(a, b);\n\t}\n}\n\n/**\n * cost = a + b*size(arg2)\n * @package\n */\nclass Arg2SizeCost extends ArgSizeCost {\n\t/**\n\t * @param {bigint} a \n\t * @param {bigint} b \n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b, 2);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {Arg2SizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new Arg2SizeCost(a, b);\n\t}\n}\n\n/**\n * cost = a + b*min(args)\n * @package\n */\nclass MinArgSizeCost extends LinearCost {\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b);\n\t}\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {MaxArgSizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new MinArgSizeCost(a, b);\n\t}\n\n\t/**\n\t * @param  {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\treturn this.calcInternal(Math.min(...args));\n\t}\n}\n\n/**\n * cost = a + b*max(args)\n * @package\n */\nclass MaxArgSizeCost extends LinearCost {\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {MaxArgSizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new MaxArgSizeCost(a, b);\n\t}\n\n\t/**\n\t * @param  {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\treturn this.calcInternal(Math.max(...args));\n\t}\n}\n\n/**\n * cost = a + b*sum(sizes(args))\n * @package\n */\nclass SumArgSizesCost extends LinearCost {\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t */\n\tconstructor(a, b) {\n\t\tsuper(a, b);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {MaxArgSizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\n\t\treturn new SumArgSizesCost(a, b);\n\t}\n\n\t/**\n\t * @param  {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tlet sum = 0;\n\n\t\tfor (let arg of args) {\n\t\t\tsum += arg;\n\t\t}\n\n\t\treturn this.calcInternal(sum);\n\t}\n}\n\n/**\n * cost = a + b*max(size(arg0)-size(arg1), min)\n * (only for Uplc functions with two arguments) \n * @package\n */\nclass ArgSizeDiffCost extends LinearCost {\n\t#min;\n\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t * @param {number} min\n\t */\n\tconstructor(a, b, min) {\n\t\tsuper(a, b);\n\t\tthis.#min = min\n\t}\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {ArgSizeDiffCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tlet [a, b] = LinearCost.getParams(params, baseName);\n\t\tlet min = params.getCostModelParameter(`${baseName}-minimum`);\n\n\t\treturn new ArgSizeDiffCost(a, b, min);\n\t}\n\n\t/**\n\t * @param {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tassert(args.length == 2);\n\t\tlet [x, y] = args;\n\n\t\treturn this.calcInternal(Math.max(x - y, this.#min));\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn super.dump() + `, minimum: ${this.#min.toString()}`;\n\t}\n}\n\n/**\n * cost = (size(arg0) > size(arg1)) ? constant : a + b*size(arg0)*size(arg1)\n * (only for Uplc functions with two arguments)\n * @package\n */\nclass ArgSizeProdCost extends LinearCost {\n\t#constant;\n\n\t/**\n\t * @param {bigint} a - intercept\n\t * @param {bigint} b - slope\n\t * @param {bigint} constant\n\t */\n\tconstructor(a, b, constant) {\n\t\tsuper(a, b);\n\t\tthis.#constant = constant;\n\t}\n\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {MaxArgSizeCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tconst [a, b] = LinearCost.getParams(params, `${baseName}-model-arguments`);\n\t\tconst constant = params.getCostModelParameter(`${baseName}-constant`);\n\n\t\treturn new ArgSizeProdCost(a, b, BigInt(constant));\n\t}\n\n\t/**\n\t * @param {number[]} args\n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tassert(args.length == 2);\n\t\t\n\t\tconst [x, y] = args;\n\n\t\tif (x > y) {\n\t\t\treturn this.#constant;\n\t\t} else {\n\t\t\treturn this.calcInternal(x*y);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn super.dump() + `, constant: ${this.#constant.toString()}`;\n\t}\n}\n\n/**\n * cost = (size(arg0) != size(arg1)) ? constant : a + b*size(arg0)\n * (only for Uplc functions with two arguments)\n * @package\n */\nclass ArgSizeDiagCost extends LinearCost {\n\t#constant;\n\n\t/**\n\t * @param {bigint} a\n\t * @param {bigint} b\n\t * @param {bigint} constant\n\t */\n\tconstructor(a, b, constant) {\n\t\tsuper(a, b);\n\t\tthis.#constant = constant;\n\t}\n\t/**\n\t * @param {NetworkParams} params \n\t * @param {string} baseName - eg. addInteger-cpu-arguments\n\t * @returns {ArgSizeDiagCost}\n\t */\n\tstatic fromParams(params, baseName) {\n\t\tconst [a, b] = LinearCost.getParams(params, baseName);\n\t\tconst constant = params.getCostModelParameter(`${baseName}-constant`);\n\n\t\treturn new ArgSizeDiagCost(a, b, BigInt(constant));\n\t}\n\n\t/**\n\t * @param {number[]} args \n\t * @returns {bigint}\n\t */\n\tcalc(args) {\n\t\tassert(args.length == 2);\n\n\t\tif (args[0] == args[1]) {\n\t\t\treturn this.calcInternal(args[0]);\n\t\t} else {\n\t\t\treturn this.#constant;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tdump() {\n\t\treturn super.dump() + `, constant: ${this.#constant.toString()}`;\n\t}\n}\n\n/**\n * @typedef CostModelClass\n * @property {(params: NetworkParams, baseName: string) => CostModel} fromParams\n */\n\n\n/////////////////////////////////////\n// Section 9: Uplc built-in functions\n/////////////////////////////////////\n\n/**\n * Cost-model configuration of UplcBuiltin.\n * Also specifies the number of times a builtin must be 'forced' before being callable.\n * @package\n */\n class UplcBuiltinConfig {\n\t#name;\n\t#forceCount;\n\t#memCostModelClass;\n\t#cpuCostModelClass;\n\n\t/**\n\t * @param {string} name \n\t * @param {number} forceCount - number of type parameters of a Plutus-core builtin function (0, 1 or 2)\n\t * @param {CostModelClass} memCostModelClass \n\t * @param {CostModelClass} cpuCostModelClass \n\t */\n\tconstructor(name, forceCount, memCostModelClass, cpuCostModelClass) {\n\t\tthis.#name = name;\n\t\tthis.#forceCount = forceCount;\n\t\tthis.#memCostModelClass = memCostModelClass;\n\t\tthis.#cpuCostModelClass = cpuCostModelClass;\n\t}\n\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\tget forceCount() {\n\t\treturn this.#forceCount;\n\t}\n\n\t/**\n\t * @param {NetworkParams} params\n\t * @returns {[CostModel, CostModel]}\n\t */\n\tinstantiateCostModels(params) {\n\t\tif (this.#memCostModelClass !== null && this.#cpuCostModelClass !== null) {\n\t\t\tlet memCostModel = this.#memCostModelClass.fromParams(params, `${this.#name}-memory-arguments`);\n\t\t\tlet cpuCostModel = this.#cpuCostModelClass.fromParams(params, `${this.#name}-cpu-arguments`);\n\n\t\t\treturn [memCostModel, cpuCostModel];\n\t\t} else {\n\t\t\tthrow new Error(`cost model not yet implemented for builtin ${this.#name}`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {NetworkParams} params\n\t * @param {number[]} argSizes\n\t * @returns {Cost}\n\t */\n\tcalcCost(params, argSizes) {\n\t\t// Note: instantiating everytime might be slow. Should this be cached (eg. in the params object?)?\n\t\tconst [memCostModel, cpuCostModel] = this.instantiateCostModels(params);\n\n\t\tconst memCost = memCostModel.calc(argSizes);\n\t\tconst cpuCost = cpuCostModel.calc(argSizes);\n\n\t\treturn {mem: memCost, cpu: cpuCost};\n\t}\n\n\t/**\n\t * @param {NetworkParams} params\n\t */\n\tdumpCostModel(params) {\n\t\tconst [memCostModel, cpuCostModel] = this.instantiateCostModels(params);\n\n\t\tconsole.log(`${this.name}-memory-arguments={${memCostModel.dump()},\\n${this.name}-cpu-arguments={${cpuCostModel.dump()}}`);\n\t}\n}\n\n/** \n * A list of all PlutusScript builins, with associated costmodels (actual costmodel parameters are loaded from NetworkParams during runtime)\n * @package\n * @type {UplcBuiltinConfig[]} \n */\nconst UPLC_BUILTINS = (\n\t/**\n\t * @returns {UplcBuiltinConfig[]}\n\t */\n\tfunction () {\n\t\t/**\n\t\t * Constructs a builtinInfo object\n\t\t * @param {string} name \n\t\t * @param {number} forceCount \n\t\t * @param {CostModelClass} memCostModel\n\t\t * @param {CostModelClass} cpuCostModel\n\t\t * @returns {UplcBuiltinConfig}\n\t\t */\n\t\tfunction builtinConfig(name, forceCount, memCostModel, cpuCostModel) {\n\t\t\t// builtins might need be wrapped in `force` a number of times if they are not fully typed\n\t\t\treturn new UplcBuiltinConfig(name, forceCount, memCostModel, cpuCostModel);\n\t\t}\n\n\t\treturn [\n\t\t\tbuiltinConfig(\"addInteger\",               0, MaxArgSizeCost, MaxArgSizeCost), // 0\n\t\t\tbuiltinConfig(\"subtractInteger\",          0, MaxArgSizeCost, MaxArgSizeCost),\n\t\t\tbuiltinConfig(\"multiplyInteger\",          0, SumArgSizesCost, SumArgSizesCost),\n\t\t\tbuiltinConfig(\"divideInteger\",            0, ArgSizeDiffCost, ArgSizeProdCost),\n\t\t\tbuiltinConfig(\"quotientInteger\",          0, ArgSizeDiffCost, ArgSizeProdCost), \n\t\t\tbuiltinConfig(\"remainderInteger\",         0, ArgSizeDiffCost, ArgSizeProdCost),\n\t\t\tbuiltinConfig(\"modInteger\",               0, ArgSizeDiffCost, ArgSizeProdCost),\n\t\t\tbuiltinConfig(\"equalsInteger\",            0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"lessThanInteger\",          0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"lessThanEqualsInteger\",    0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"appendByteString\",         0, SumArgSizesCost, SumArgSizesCost), // 10\n\t\t\tbuiltinConfig(\"consByteString\",           0, SumArgSizesCost, Arg1SizeCost),\n\t\t\tbuiltinConfig(\"sliceByteString\",          0, Arg2SizeCost, Arg2SizeCost),\n\t\t\tbuiltinConfig(\"lengthOfByteString\",       0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"indexByteString\",          0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"equalsByteString\",         0, ConstCost, ArgSizeDiagCost),\n\t\t\tbuiltinConfig(\"lessThanByteString\",       0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"lessThanEqualsByteString\", 0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"sha2_256\",                 0, ConstCost, Arg0SizeCost),\n\t\t\tbuiltinConfig(\"sha3_256\",                 0, ConstCost, Arg0SizeCost),\n\t\t\tbuiltinConfig(\"blake2b_256\",              0, ConstCost, Arg0SizeCost), // 20\n\t\t\tbuiltinConfig(\"verifyEd25519Signature\",   0, ConstCost, Arg2SizeCost),\n\t\t\tbuiltinConfig(\"appendString\",             0, SumArgSizesCost, SumArgSizesCost),\n\t\t\tbuiltinConfig(\"equalsString\",             0, ConstCost, ArgSizeDiagCost),\n\t\t\tbuiltinConfig(\"encodeUtf8\",               0, Arg0SizeCost, Arg0SizeCost),\n\t\t\tbuiltinConfig(\"decodeUtf8\",               0, Arg0SizeCost, Arg0SizeCost),\n\t\t\tbuiltinConfig(\"ifThenElse\",               1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"chooseUnit\",               1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"trace\",                    1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"fstPair\",                  2, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"sndPair\",                  2, ConstCost, ConstCost), // 30\n\t\t\tbuiltinConfig(\"chooseList\",               2, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"mkCons\",                   1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"headList\",                 1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"tailList\",                 1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"nullList\",                 1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"chooseData\",               1, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"constrData\",               0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"mapData\",                  0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"listData\",                 0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"iData\",                    0, ConstCost, ConstCost), // 40\n\t\t\tbuiltinConfig(\"bData\",                    0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"unConstrData\",             0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"unMapData\",                0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"unListData\",               0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"unIData\",                  0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"unBData\",                  0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"equalsData\",               0, ConstCost, MinArgSizeCost),\n\t\t\tbuiltinConfig(\"mkPairData\",               0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"mkNilData\",                0, ConstCost, ConstCost),\n\t\t\tbuiltinConfig(\"mkNilPairData\",            0, ConstCost, ConstCost), // 50\n\t\t\tbuiltinConfig(\"serialiseData\",            0, Arg0SizeCost, Arg0SizeCost),\n\t\t\tbuiltinConfig(\"verifyEcdsaSecp256k1Signature\",   0, ConstCost, ConstCost), // these parameters are from aiken, but the cardano-cli parameter file differ?\n\t\t\tbuiltinConfig(\"verifySchnorrSecp256k1Signature\", 0, ConstCost, Arg1SizeCost), // these parameters are from, but the cardano-cli parameter file differs?\n\t\t];\n\t}\n)();\n\n/**\n * Use this function to check cost-model parameters\n * @package\n * @param {NetworkParams} networkParams\n */\nfunction dumpCostModels(networkParams) {\n\tfor (let builtin of UPLC_BUILTINS) {\n\t\tbuiltin.dumpCostModel(networkParams);\n\t}\n}\n\n/**\n * Returns index of a named builtin\n * Throws an error if builtin doesn't exist\n * @param {string} name \n * @returns \n */\nfunction findUplcBuiltin(name) {\n\tlet i = UPLC_BUILTINS.findIndex(info => { return \"__core__\" + info.name == name });\n\tassert(i != -1, `${name} is not a real builtin`);\n\treturn i;\n}\n\n/**\n * Checks if a named builtin exists\n * @param {string} name \n * @param {boolean} strict - if true then throws an error if builtin doesn't exist\n * @returns {boolean}\n */\nfunction isUplcBuiltin(name, strict = false) {\n\tif (name.startsWith(\"__core\")) {\n\t\tif (strict) {\n\t\t\tvoid this.findBuiltin(name); // assert that builtin exists\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n///////////////////////\n// Section 10: Uplc AST\n///////////////////////\n\n\n/**\n * A Helios/Uplc Program can have different purposes\n * @package\n */\nconst ScriptPurpose = {\n\tTesting: -1,\n\tMinting:  0,\n\tSpending: 1,\n\tStaking:  2,\n\tModule:   3\n};\n\n/**\n * @package\n * @param {number} id\n * @returns {string}\n */\nfunction getPurposeName(id) {\n\tswitch (id) {\n\t\tcase ScriptPurpose.Testing:\n\t\t\treturn \"testing\";\n\t\tcase ScriptPurpose.Minting:\n\t\t\treturn \"minting\";\n\t\tcase ScriptPurpose.Spending:\n\t\t\treturn \"spending\";\n\t\tcase ScriptPurpose.Staking:\n\t\t\treturn \"staking\";\n\t\tcase ScriptPurpose.Module:\n\t\t\treturn \"module\";\n\t\tdefault:\n\t\t\tthrow new Error(`unhandled ScriptPurpose ${id}`);\n\t}\n}\n\n\n/** \n * a UplcValue is passed around by Plutus-core expressions.\n */\nclass UplcValue {\n\t#site;\n\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tassert(site != undefined && (site instanceof Site));\n\t\tthis.#site = site;\n\t}\n\n\t/**\n\t * Return a copy of the UplcValue at a different Site.\n     * @package\n\t * @param {Site} newSite \n\t * @returns {UplcValue}\n\t */\n\tcopy(newSite) {\n\t\tthrow new Error(\"not implemented\");\n\t}\n\n    /**\n     * @package\n     * @type {Site}\n     */\n\tget site() {\n\t\treturn this.#site;\n\t}\n\n\t/**\n\t * @package\n\t * @type {number}\n\t */\n\tget length() {\n\t\tthrow new Error(\"not a list nor a map\");\n\t}\n\n\t/**\n\t * Size in words (8 bytes, 64 bits) occupied in target node\n     * @package\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Throws an error because most values can't be called (overridden by UplcAnon)\n     * @package\n\t * @param {UplcRte | UplcStack} rte \n\t * @param {Site} site \n\t * @param {UplcValue} value\n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync call(rte, site, value) {\n\t\tthrow site.typeError(`expected a Plutus-core function, got '${this.toString()}'`);\n\t}\n\n\t/**\n     * @package\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget int() {\n\t\tthrow this.site.typeError(`expected a Plutus-core int, got '${this.toString()}'`);\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget bytes() {\n\t\tthrow this.site.typeError(`expected a Plutus-core bytearray, got '${this.toString()}'`);\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget string() {\n\t\tthrow this.site.typeError(`expected a Plutus-core string, got '${this.toString()}'`);\n\t}\n\t\n\t/**\n\t * @type {boolean}\n\t */\n\tget bool() {\n\t\tthrow this.site.typeError(`expected a Plutus-core bool, got '${this.toString()}'`);\n\t}\n\n\t/**\n\t * Distinguishes a pair from a mapItem\n\t * @returns {boolean}\n\t */\n\tisPair() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget first() {\n\t\tthrow this.site.typeError(`expected a Plutus-core pair, got '${this.toString()}'`);\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget second() {\n\t\tthrow this.site.typeError(`expected a Plutus-core pair, got '${this.toString()}'`);\n\t}\n\n\t/**\n\t * Distinguishes a list from a map\n\t * @returns {boolean}\n\t */\n\tisList() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @type {UplcType}\n\t */\n\tget itemType() {\n\t\tthrow this.site.typeError(\"not a list\");\n\t}\n\n\t/**\n\t * @type {UplcValue[]}\n\t */\n\tget list() {\n\t\tthrow this.site.typeError(`expected a Plutus-core list, got '${this.toString()}'`);\n\t}\n\n    /**\n     * @returns {boolean}\n     */\n\tisData() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\tthrow this.site.typeError(`expected Plutus-core data, got '${this.toString()}'`);\n\t}\n\n\t/**\n     * @package\n\t * @returns {Promise<UplcValue>}\n\t */\n\tforce() {\n\t\tthrow this.site.typeError(`expected delayed value, got '${this.toString()}'`);\n\t}\n\n\t/**\n     * @package\n\t * @returns {UplcUnit}\n\t */\n\tassertUnit() {\n\t\tthrow this.site.typeError(`expected Plutus-core unit, got '${this.toString}'`);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n     * @package\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Encodes value without type header\n     * @package\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Encodes value with plutus flat encoding.\n\t * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.\n     * @package\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValue(bitWriter) {\n\t\tbitWriter.write('1' + this.typeBits() + '0');\n\t\t\n\t\tthis.toFlatValueInternal(bitWriter);\n\t}\n}\n\nclass UplcType {\n\t#typeBits;\n\n\t/**\n\t * @param {string} typeBits \n\t */\n\tconstructor(typeBits) {\n\t\tthis.#typeBits = typeBits;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn this.#typeBits;\n\t}\n\n\t/**\n\t * @param {UplcValue} value \n\t * @returns {boolean}\n\t */\n\tisSameType(value) {\n\t\treturn this.#typeBits == value.typeBits();\n\t}\n\n\t/**\n\t * @returns {UplcType}\n\t */\n\tstatic newDataType() {\n\t\treturn new UplcType(\"1000\");\n\t}\n\n\t/**\n\t * @returns {UplcType}\n\t */\n\tstatic newDataPairType() {\n\t\treturn new UplcType([\"0111\", \"0111\", \"0110\", \"1000\", \"1000\"].join(\"1\"));\n\t}\n\n\t/**\n\t * @param {number[]} lst\n\t * @returns {UplcType}\n\t */\n\tstatic fromNumbers(lst) {\n\t\treturn new UplcType(lst.map(x => byteToBitString(x, 4, false)).join(\"1\"));\n\t}\n}\n\n/**\n * @package\n * @typedef {[?string, UplcValue][]} UplcRawStack\n */\n\n/**\n* @typedef {object} UplcRTECallbacks\n* @property {(msg: string) => Promise<void>} [onPrint]\n* @property {(site: Site, rawStack: UplcRawStack) => Promise<boolean>} [onStartCall]\n* @property {(site: Site, rawStack: UplcRawStack) => Promise<void>} [onEndCall]\n* @property {(name: string, isTerm: boolean, cost: Cost) => void} [onIncrCost]\n*/\n\n/**\n * @type {UplcRTECallbacks}\n */\nconst DEFAULT_UPLC_RTE_CALLBACKS = {\n\tonPrint: async function (/** @type {string} */ msg) {return},\n\tonStartCall: async function(/** @type {Site} */ site, /** @type {UplcRawStack} */ rawStack) {return false},\n\tonEndCall: async function(/** @type {Site} */ site, /** @type {UplcRawStack} */ rawStack) {return},\n\tonIncrCost: function(/** @type {string} */ name, /** @type {boolean} */ isTerm, /** @type {Cost} */ cost) {return},\n}\n\n/**\n * Plutus-core Runtime Environment is used for controlling the programming evaluation (eg. by a debugger)\n * @package\n */\nclass UplcRte {\n\t#callbacks;\n\n\t#networkParams;\n\n\t/**\n\t * this.onNotifyCalls is set to 'false' when the debugger is in step over-mode.\n\t * @type {boolean}\n\t */\n\t#notifyCalls;\n\n\t/**\n\t * this.onNotifyCalls is set back to true if the endCall is called with the same rawStack as the marker.\n\t * @type {?UplcRawStack}\n\t */\n\t#marker;\n\n\t/**\n\t * @typedef {[?string, UplcValue][]} UplcRawStack\n\t */\n\n\t/**\n\t * @param {UplcRTECallbacks} callbacks \n\t * @param {?NetworkParams} networkParams\n\t */\n\tconstructor(callbacks = DEFAULT_UPLC_RTE_CALLBACKS, networkParams = null) {\n\t\tassertDefined(callbacks);\n\t\tthis.#callbacks = callbacks;\n\t\tthis.#networkParams = networkParams;\n\t\tthis.#notifyCalls = true;\n\t\tthis.#marker = null;\n\t}\n\n\t/**\n\t * @param {string} name - for breakdown\n\t * @param {boolean} isTerm\n\t * @param {Cost} cost \n\t */\n\tincrCost(name, isTerm, cost) {\n\t\tif (cost.mem <= 0n || cost.cpu <= 0n) {\n\t\t\tthrow new Error(\"cost not increasing\");\n\t\t}\n\n\t\tif (this.#callbacks.onIncrCost !== undefined) {\n\t\t\tthis.#callbacks.onIncrCost(name, isTerm, cost);\n\t\t}\n\t}\n\n\tincrStartupCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"startup\", true, this.#networkParams.plutusCoreStartupCost);\n\t\t}\n\t}\n\n\tincrVariableCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"variable\", true, this.#networkParams.plutusCoreVariableCost);\n\t\t}\n\t}\n\n\tincrLambdaCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"lambda\", true, this.#networkParams.plutusCoreLambdaCost);\n\t\t}\n\t}\n\n\tincrDelayCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"delay\", true, this.#networkParams.plutusCoreDelayCost);\n\t\t}\n\t}\n\n\tincrCallCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"call\", true, this.#networkParams.plutusCoreCallCost);\n\t\t}\n\t}\n\n\tincrConstCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"const\", true, this.#networkParams.plutusCoreConstCost);\n\t\t}\n\t}\n\n\tincrForceCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"force\", true, this.#networkParams.plutusCoreForceCost);\n\t\t}\n\t}\n\n\tincrBuiltinCost() {\n\t\tif (this.#networkParams !== null) {\n\t\t\tthis.incrCost(\"builtin\", true, this.#networkParams.plutusCoreBuiltinCost);\n\t\t}\n\t}\n\n\t/**\n\t * @param {UplcBuiltin} fn\n\t * @param {UplcValue[]} args\n\t */\n\tcalcAndIncrCost(fn, ...args) {\n\t\tif (this.#networkParams !== null) {\n\t\t\tlet cost = fn.calcCost(this.#networkParams, ...args);\n\n\t\t\tthis.incrCost(fn.name, false, cost);\n\t\t}\n\t}\n\n\t/**\n\t * Gets variable using Debruijn index. Throws error here because UplcRTE is the stack root and doesn't contain any values.\n\t * @param {number} i \n\t * @returns {UplcValue}\n\t */\n\tget(i) {\n\t\tthrow new Error(\"variable index out of range\");\n\t}\n\n\t/**\n\t * Creates a child stack.\n\t * @param {UplcValue} value \n\t * @param {?string} valueName \n\t * @returns {UplcStack}\n\t */\n\tpush(value, valueName = null) {\n\t\treturn new UplcStack(this, value, valueName);\n\t}\n\n\t/**\n\t * Calls the print callback (or does nothing if print callback isn't defined)\n\t * @param {string} msg \n\t * @returns {Promise<void>}\n\t */\n\tasync print(msg) {\n\t\tif (this.#callbacks.onPrint != undefined) {\n\t\t\tawait this.#callbacks.onPrint(msg);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the onStartCall callback.\n\t * @param {Site} site \n\t * @param {UplcRawStack} rawStack \n\t * @returns {Promise<void>}\n\t */\n\tasync startCall(site, rawStack) {\n\t\tif (this.#notifyCalls && this.#callbacks.onStartCall != undefined) {\n\t\t\tlet stopNotifying = await this.#callbacks.onStartCall(site, rawStack);\n\t\t\tif (stopNotifying) {\n\t\t\t\tthis.#notifyCalls = false;\n\t\t\t\tthis.#marker = rawStack;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Calls the onEndCall callback if '#notifyCalls == true'.\n\t * '#notifyCalls' is set to true if 'rawStack == #marker'.\n\t * @param {Site} site \n\t * @param {UplcRawStack} rawStack \n\t * @param {UplcValue} result \n\t * @returns {Promise<void>}\n\t */\n\tasync endCall(site, rawStack, result) {\n\t\tif (!this.#notifyCalls && this.#marker == rawStack) {\n\t\t\tthis.#notifyCalls = true;\n\t\t\tthis.#marker = null;\n\t\t}\n\n\t\tif (this.#notifyCalls && this.#callbacks.onEndCall != undefined) {\n\t\t\trawStack = rawStack.slice();\n\t\t\trawStack.push([\"__result\", result]);\n\t\t\tawait this.#callbacks.onEndCall(site, rawStack);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {UplcRawStack}\n\t */\n\ttoList() {\n\t\treturn [];\n\t}\n}\n\n/**\n * UplcStack contains a value that can be retrieved using a Debruijn index.\n */\nclass UplcStack {\n\t#parent;\n\t#value;\n\t#valueName;\n\n\t/**\n\t * @param {(?UplcStack) | UplcRte} parent\n\t * @param {?UplcValue} value\n\t * @param {?string} valueName\n\t */\n\tconstructor(parent, value = null, valueName = null) {\n\t\tthis.#parent = parent;\n\t\tthis.#value = value;\n\t\tthis.#valueName = valueName;\n\t}\n\n\tincrStartupCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrStartupCost()\n\t\t}\n\t}\n\n\tincrVariableCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrVariableCost()\n\t\t}\n\t}\n\n\tincrLambdaCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrLambdaCost()\n\t\t}\n\t}\n\t\n\tincrDelayCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrDelayCost();\n\t\t}\n\t}\n\n\tincrCallCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrCallCost();\n\t\t}\n\t}\n\n\tincrConstCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrConstCost();\n\t\t}\n\t}\n\n\tincrForceCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrForceCost()\n\t\t}\n\t}\n\n\tincrBuiltinCost() {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.incrBuiltinCost()\n\t\t}\n\t}\n\n\t/**\n\t * @param {UplcBuiltin} fn\n\t * @param {UplcValue[]} args\n\t */\n\tcalcAndIncrCost(fn, ...args) {\n\t\tif (this.#parent !== null) {\n\t\t\tthis.#parent.calcAndIncrCost(fn, ...args);\n\t\t}\n\t}\n\n\t/**\n\t * Gets a value using the Debruijn index. If 'i == 1' then the current value is returned.\n\t * Otherwise 'i' is decrement and passed to the parent stack.\n\t * @param {number} i \n\t * @returns {UplcValue}\n\t */\n\tget(i) {\n\t\ti -= 1;\n\n\t\tif (i == 0) {\n\t\t\tif (this.#value === null) {\n\t\t\t\tthrow new Error(\"Plutus-core stack value not set\");\n\t\t\t} else {\n\t\t\t\treturn this.#value;\n\t\t\t}\n\t\t} else {\n\t\t\tassert(i > 0);\n\t\t\tif (this.#parent === null) {\n\t\t\t\tthrow new Error(\"variable index out of range\");\n\t\t\t} else {\n\t\t\t\treturn this.#parent.get(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Instantiates a child stack.\n\t * @param {UplcValue} value \n\t * @param {?string} valueName \n\t * @returns {UplcStack}\n\t */\n\tpush(value, valueName = null) {\n\t\treturn new UplcStack(this, value, valueName);\n\t}\n\n\t/**\n\t * Calls the onPrint callback in the RTE (root of stack).\n\t * @param {string} msg \n\t * @returns {Promise<void>}\n\t */\n\tasync print(msg) {\n\t\tif (this.#parent !== null) {\n\t\t\tawait this.#parent.print(msg);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the onStartCall callback in the RTE (root of stack).\n\t * @param {Site} site \n\t * @param {UplcRawStack} rawStack \n\t * @returns {Promise<void>}\n\t */\n\tasync startCall(site, rawStack) {\n\t\tif (this.#parent !== null) {\n\t\t\tawait this.#parent.startCall(site, rawStack);\n\t\t}\n\t}\n\n\t/** \n\t * Calls the onEndCall callback in the RTE (root of stack).\n\t * @param {Site} site\n\t * @param {UplcRawStack} rawStack\n\t * @param {UplcValue} result\n\t * @returns {Promise<void>}\n\t*/\n\tasync endCall(site, rawStack, result) {\n\t\tif (this.#parent !== null) {\n\t\t\tawait this.#parent.endCall(site, rawStack, result);\n\t\t}\n\t}\n\n\t/** \n\t * @returns {UplcRawStack}\n\t*/\n\ttoList() {\n\t\tlet lst = this.#parent !== null ? this.#parent.toList() : [];\n\t\tif (this.#value !== null) {\n\t\t\tlst.push([this.#valueName, this.#value]);\n\t\t}\n\t\treturn lst;\n\t}\n}\n\n/**\n * Anonymous Plutus-core function.\n * Returns a new UplcAnon whenever it is called/applied (args are 'accumulated'), except final application, when the function itself is evaluated.\n * @package\n */\nclass UplcAnon extends UplcValue {\n\t/**\n\t * @typedef {(callSite: Site, subStack: UplcStack, ...args: UplcValue[]) => (UplcValue | Promise<UplcValue>)} UplcAnonCallback\n\t */\n\n\t#rte;\n\t#nArgs;\n\t#argNames;\n\n\t/**\n\t * Increment every time function a new argument is applied.\n\t */\n\t#argCount;\n\n\t/**\n\t * Callback that is called when function is fully applied.\n\t * @type {UplcAnonCallback}\n\t */\n\t#fn;\n\t#callSite;\n\n\t/**\n\t * \n\t * @param {Site} site \n\t * @param {UplcRte | UplcStack} rte \n\t * @param {string[] | number} args - args can be list of argNames (for debugging), or the number of args\n\t * @param {UplcAnonCallback} fn \n\t * @param {number} argCount \n\t * @param {?Site} callSite \n\t */\n\tconstructor(site, rte, args, fn, argCount = 0, callSite = null) {\n\t\tsuper(site);\n\t\tassert(typeof argCount == \"number\");\n\n\t\tlet nArgs = 0;\n\t\t/** @type {?string[]} */\n\t\tlet argNames = null;\n\t\tif ((typeof args != 'number')) {\n\t\t\tif (args instanceof Array) {\n\t\t\t\tnArgs = args.length;\n\t\t\t\targNames = args;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"not an Array\");\n\t\t\t}\n\t\t} else {\n\t\t\tnArgs = args;\n\t\t}\n\n\t\tassert(nArgs >= 1);\n\n\t\tthis.#rte = rte;\n\t\tthis.#nArgs = nArgs;\n\t\tthis.#argNames = argNames;\n\t\tthis.#argCount = argCount;\n\t\tthis.#fn = fn;\n\t\tthis.#callSite = callSite;\n\t}\n\n\tget memSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcAnon}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcAnon(\n\t\t\tnewSite,\n\t\t\tthis.#rte,\n\t\t\tthis.#argNames !== null ? this.#argNames : this.#nArgs,\n\t\t\tthis.#fn,\n\t\t\tthis.#argCount,\n\t\t\tthis.#callSite,\n\t\t);\n\t}\n\n\t/**\n\t * @param {Site} callSite\n\t * @param {UplcStack} subStack\n\t * @param {UplcValue[]} args\n\t * @returns {UplcValue | Promise<UplcValue>}\n\t */\n\tcallSync(callSite, subStack, args) {\n\t\treturn this.#fn(callSite, subStack, ...args);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte \n\t * @param {Site} site \n\t * @param {UplcValue} value \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync call(rte, site, value) {\n\t\tassert(site != undefined && site instanceof Site);\n\n\t\tlet subStack = this.#rte.push(value, this.#argNames !== null ? this.#argNames[this.#argCount] : null); // this is the only place where the stack grows\n\t\tlet argCount = this.#argCount + 1;\n\t\tlet callSite = this.#callSite !== null ? this.#callSite : site;\n\n\t\t// function is fully applied, collect the args and call the callback\n\t\tif (argCount == this.#nArgs) {\n\t\t\t/** @type {UplcValue[]} */\n\t\t\tlet args = [];\n\n\t\t\tlet rawStack = rte.toList(); // use the RTE of the callsite\n\n\t\t\tfor (let i = this.#nArgs; i >= 1; i--) {\n\t\t\t\tlet argValue = subStack.get(i);\n\t\t\t\targs.push(argValue);\n\t\t\t\trawStack.push([`__arg${this.#nArgs - i}`, argValue]);\n\t\t\t}\n\n\t\t\t// notify the RTE of the new live stack (list of pairs instead of UplcStack), and await permission to continue\n\t\t\tawait this.#rte.startCall(callSite, rawStack);\n\n\t\t\ttry {\n\t\t\t\tlet result = this.callSync(callSite, subStack, args);\n\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tresult = await result;\n\t\t\t\t}\n\t\n\t\t\t\t// the same rawStack object can be used as a marker for 'Step-Over' in the debugger\n\t\t\t\tawait this.#rte.endCall(callSite, rawStack, result);\n\t\n\t\t\t\treturn result.copy(callSite);\n\t\t\t} catch(e) {\n\t\t\t\t// TODO: better trace\n\t\t\t\tif (e instanceof RuntimeError) {\n\t\t\t\t\te = e.addTraceSite(callSite);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t} else {\n\t\t\t// function isn't yet fully applied, return a new partially applied UplcAnon\n\t\t\tassert(this.#nArgs > 1);\n\n\t\t\treturn new UplcAnon(\n\t\t\t\tcallSite,\n\t\t\t\tsubStack,\n\t\t\t\tthis.#argNames !== null ? this.#argNames : this.#nArgs,\n\t\t\t\tthis.#fn,\n\t\t\t\targCount,\n\t\t\t\tcallSite,\n\t\t\t);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"fn\";\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\tthrow new Error(\"a UplcAnon value doesn't have a literal representation\");\n\t}\n\n\t/**\n\t * Encodes value with plutus flat encoding.\n\t * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValue(bitWriter) {\n\t\tthrow new Error(\"a UplcAnon value doesn't have a literal representation\");\n\t}\n}\n\n/**\n * @package\n */\nclass UplcDelayedValue extends UplcValue {\n\t#evaluator;\n\n\t/**\n\t * @param {Site} site\n\t * @param {() => (UplcValue | Promise<UplcValue>)} evaluator\n\t */\n\tconstructor(site, evaluator) {\n\t\tsuper(site);\n\t\tthis.#evaluator = evaluator;\n\t}\n\n\tget memSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcValue}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcDelayedValue(newSite, this.#evaluator);\n\t}\n\n\t/**\n\t * @return {Promise<UplcValue>}\n\t */\n\tforce() {\n\t\tlet res = this.#evaluator();\n\n\t\tif (res instanceof Promise) {\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn new Promise((resolve, _) => {\n\t\t\t\tresolve(res);\n\t\t\t});\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `delay`;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\tthrow new Error(\"a UplcDelayedValue value doesn't have a literal representation\");\n\t}\n\n\t/**\n\t * Encodes value with plutus flat encoding.\n\t * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValue(bitWriter) {\n\t\tthrow new Error(\"a UplcDelayedValue value doesn't have a literal representation\");\n\t}\n}\n\n/**\n * Plutus-core Integer class\n */\nclass UplcInt extends UplcValue {\n\t#value;\n\t#signed;\n\n\t/**\n\t * @param {Site} site\n\t * @param {bigint} value - supposed to be arbitrary precision\n\t * @param {boolean} signed - unsigned is only for internal use\n\t */\n\tconstructor(site, value, signed = true) {\n\t\tsuper(site);\n\t\tassert(typeof value == 'bigint', \"not a bigint\");\n\t\tthis.#value = value;\n\t\tthis.#signed = signed;\n\t}\n\n\t/**\n\t * Constructs a UplcInt without requiring a Site\n\t * @param {bigint | number} value\n\t * @returns {UplcInt} \n\t */\n\tstatic new(value) {\n\t\tif (typeof value == 'number') {\n\t\t\tassert(value % 1.0 == 0.0, \"must be whole number\");\n\t\t\treturn new UplcInt(Site.dummy(), BigInt(value));\n\t\t} else {\n\t\t\treturn new UplcInt(Site.dummy(), value);\n\t\t}\n\t}\n\n\tget signed() {\n\t\treturn this.#signed;\n\t}\n\n\t/**\n\t * Creates a UplcInt wrapped in a UplcConst, so it can be used a term\n\t * @param {Site} site \n\t * @param {bigint} value \n\t * @returns \n\t */\n\tstatic newSignedTerm(site, value) {\n\t\treturn new UplcConst(new UplcInt(site, value, true));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n        return IntData.memSizeInternal(this.#value);\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcInt}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcInt(newSite, this.#value, this.#signed);\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget int() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * Parses a single byte in the Plutus-core byte-list representation of an int\n\t * @param {number} b \n\t * @returns {number}\n\t */\n\tstatic parseRawByte(b) {\n\t\treturn b & 0b01111111;\n\t}\n\n\t/**\n\t * Returns true if 'b' is the last byte in the Plutus-core byte-list representation of an int.\n\t * @param {number} b \n\t * @returns {boolean}\n\t */\n\tstatic rawByteIsLast(b) {\n\t\treturn (b & 0b10000000) == 0;\n\t}\n\n\t/**\n\t * Combines a list of Plutus-core bytes into a bigint (leading bit of each byte is ignored).\n     * Differs from bytesToBigInt in utils.js because only 7 bits are used from each byte.\n\t * @param {number[]} bytes\n\t * @returns {bigint}\n\t */\n\tstatic bytesToBigInt(bytes) {\n\t\tlet value = BigInt(0);\n\n\t\tlet n = bytes.length;\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet b = bytes[i];\n\n\t\t\t// 7 (not 8), because leading bit isn't used here\n\t\t\tvalue = value + BigInt(b) * ipow2(BigInt(i) * 7n);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Applies zigzag encoding\n\t * @example\n\t * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().int => 1n\n\t * @example\n\t * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().toSigned().int => -1n\n\t * @example\n\t * (new UplcInt(Site.dummy(), -2n, true)).toUnsigned().toSigned().int => -2n\n\t * @example\n\t * (new UplcInt(Site.dummy(), -3n, true)).toUnsigned().toSigned().int => -3n\n\t * @example\n\t * (new UplcInt(Site.dummy(), -4n, true)).toUnsigned().toSigned().int => -4n\n\t * @returns {UplcInt}\n\t */\n\ttoUnsigned() {\n\t\tif (this.#signed) {\n\t\t\tif (this.#value < 0n) {\n\t\t\t\treturn new UplcInt(this.site, -this.#value*2n - 1n, false);\n\t\t\t} else {\n\t\t\t\treturn new UplcInt(this.site, this.#value * 2n, false);\n\t\t\t}\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/** \n\t * Unapplies zigzag encoding \n\t * @example\n\t * (new UplcInt(Site.dummy(), 1n, false)).toSigned().int => -1n\n\t * @returns {UplcInt}\n\t*/\n\ttoSigned() {\n\t\tif (this.#signed) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (this.#value % 2n == 0n) {\n\t\t\t\treturn new UplcInt(this.site, this.#value / 2n, true);\n\t\t\t} else {\n\t\t\t\treturn new UplcInt(this.site, -(this.#value + 1n) / 2n, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value.toString();\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatInternal(bitWriter) {\n\t\tlet zigzag = this.toUnsigned();\n\t\tlet bitString = padZeroes(zigzag.#value.toString(2), 7);\n\n\t\t// split every 7th\n\t\tlet parts = [];\n\t\tfor (let i = 0; i < bitString.length; i += 7) {\n\t\t\tparts.push(bitString.slice(i, i + 7));\n\t\t}\n\n\t\t// reverse the parts\n\t\tparts.reverse();\n\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (i == parts.length - 1) {\n\t\t\t\t// last\n\t\t\t\tbitWriter.write('0' + parts[i]);\n\t\t\t} else {\n\t\t\t\tbitWriter.write('1' + parts[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Encodes unsigned integer with plutus flat encoding.\n\t * Throws error if signed.\n\t * Used by encoding plutus core program version and debruijn indices.\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlatUnsigned(bitWriter) {\n\t\tassert(!this.#signed);\n\n\t\tthis.toFlatInternal(bitWriter);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn \"0000\";\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tassert(this.#signed);\n\n\t\tthis.toFlatInternal(bitWriter);\n\t}\n}\n\n/**\n * Plutus-core ByteArray value class\n * Wraps a regular list of uint8 numbers (so not Uint8Array)\n */\nclass UplcByteArray extends UplcValue {\n\t#bytes;\n\n\t/**\n\t * @param {Site} site\n\t * @param {number[]} bytes\n\t */\n\tconstructor(site, bytes) {\n\t\tsuper(site);\n\t\tassert(bytes != undefined);\n\t\tthis.#bytes = bytes;\n\t\tfor (let b of this.#bytes) {\n\t\t\tassert(typeof b == 'number');\n\t\t}\n\t}\n\n\t/**\n\t * Construct a UplcByteArray without requiring a Site\n\t * @param {number[]} bytes \n\t * @returns {UplcByteArray}\n\t */\n\tstatic new(bytes) {\n\t\treturn new UplcByteArray(Site.dummy(), bytes);\n\t}\n\n\t/**\n\t * Creates new UplcByteArray wrapped in UplcConst so it can be used as a term.\n\t * @param {Site} site \n\t * @param {number[]} bytes \n\t * @returns \n\t */\n\tstatic newTerm(site, bytes) {\n\t\treturn new UplcConst(new UplcByteArray(site, bytes));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n        return ByteArrayData.memSizeInternal(this.#bytes);\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcByteArray}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcByteArray(newSite, this.#bytes);\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget bytes() {\n\t\treturn this.#bytes.slice();\n\t}\n\n\t/**\n\t * Returns hex representation of byte array\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `#${bytesToHex(this.#bytes)}`;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn \"0001\";\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tUplcByteArray.writeBytes(bitWriter, this.#bytes);\n\t}\n\n\t/**\n\t * Write a list of bytes to the bitWriter using flat encoding.\n\t * Used by UplcString, UplcByteArray and UplcDataValue\n\t * Equivalent to E_B* function in Plutus-core docs\n\t * @param {BitWriter} bitWriter \n\t * @param {number[]} bytes \n\t */\n\tstatic writeBytes(bitWriter, bytes) {\n\t\tbitWriter.padToByteBoundary(true);\n\n\t\t// the rest of this function is equivalent to E_C* function in Plutus-core docs\n\t\tlet n = bytes.length;\n\t\tlet pos = 0;\n\n\t\t// write chunks of 255\n\t\twhile (pos < n) {\n\t\t\t// each iteration is equivalent to E_C function in Plutus-core docs\n\n\t\t\tlet nChunk = Math.min(n - pos, 255);\n\n\t\t\t// equivalent to E_8 function in Plutus-core docs\n\t\t\tbitWriter.write(padZeroes(nChunk.toString(2), 8));\n\n\t\t\tfor (let i = pos; i < pos + nChunk; i++) {\n\t\t\t\tlet b = bytes[i];\n\n\t\t\t\t// equivalent to E_8 function in Plutus-core docs\n\t\t\t\tbitWriter.write(padZeroes(b.toString(2), 8));\n\t\t\t}\n\n\t\t\tpos += nChunk;\n\t\t}\n\n\t\tbitWriter.write('00000000');\n\t}\n}\n\n/**\n * Plutus-core string value class\n */\nclass UplcString extends UplcValue {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * Constructs a UplcStrin without requiring a Site\n\t * @param {string} value \n\t * @returns {UplcString}\n\t */\n\tstatic new(value) {\n\t\treturn new UplcString(Site.dummy(), value);\n\t}\n\n\t/**\n\t * Creates a new UplcString wrapped with UplcConst so it can be used as a term.\n\t * @param {Site} site \n\t * @param {string} value \n\t * @returns {UplcConst}\n\t */\n\tstatic newTerm(site, value) {\n\t\treturn new UplcConst(new UplcString(site, value));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn this.#value.length;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcString}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcString(newSite, this.#value);\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget string() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `\"${this.#value}\"`;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn \"0010\";\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tlet bytes = Array.from((new TextEncoder()).encode(this.#value));\n\n\t\tUplcByteArray.writeBytes(bitWriter, bytes);\n\t}\n}\n\n/**\n * Plutus-core unit value class\n */\nclass UplcUnit extends UplcValue {\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\t/**\n\t * Constructs a UplcUnit without requiring a Site\n\t * @returns {UplcUnit}\n\t */\n\tstatic new () {\n\t\treturn new UplcUnit(Site.dummy());\n\t}\n\n\t/**\n\t * Creates a new UplcUnit wrapped with UplcConst so it can be used as a term\n\t * @param {Site} site \n\t * @returns {UplcConst}\n\t */\n\tstatic newTerm(site) {\n\t\treturn new UplcConst(new UplcUnit(site));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcUnit}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcUnit(newSite);\n\t}\n\n\ttoString() {\n\t\treturn \"()\";\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn \"0011\";\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t}\n\n\t/**\n\t * @returns {UplcUnit}\n\t */\n\tassertUnit() {\n\t\treturn this;\n\t}\n}\n\n/**\n * Plutus-core boolean value class\n */\nclass UplcBool extends UplcValue {\n\t#value;\n\n\t/**\n\t * @param {Site} site \n\t * @param {boolean} value \n\t */\n\tconstructor(site, value) {\n\t\tsuper(site);\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * Constructs a UplcBool without requiring a Site\n\t * @param {boolean} value \n\t * @returns {UplcBool}\n\t */\n\tstatic new(value) {\n\t\treturn new UplcBool(Site.dummy(), value);\n\t}\n\n\t/**\n\t * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.\n\t * @param {Site} site \n\t * @param {boolean} value \n\t * @returns {UplcConst}\n\t */\n\tstatic newTerm(site, value) {\n\t\treturn new UplcConst(new UplcBool(site, value));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcBool}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcBool(newSite, this.#value);\n\t}\n\n\t/**\n\t * @type {boolean}\n\t */\n\tget bool() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\treturn new ConstrData(this.#value ? 1 : 0, []);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value ? \"true\" : \"false\";\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn '0100';\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tif (this.#value) {\n\t\t\tbitWriter.write('1');\n\t\t} else {\n\t\t\tbitWriter.write('0');\n\t\t}\n\t}\n}\n\n/**\n * Plutus-core pair value class\n * Can contain any other value type.\n */\nclass UplcPair extends UplcValue {\n\t#first;\n\t#second;\n\n\t/**\n\t * @param {Site} site\n\t * @param {UplcValue} first\n\t * @param {UplcValue} second\n\t */\n\tconstructor(site, first, second) {\n\t\tsuper(site);\n\t\tthis.#first = first;\n\t\tthis.#second = second;\n\t}\n\n\t/**\n\t * Constructs a UplcPair without requiring a Site\n\t * @param {UplcValue} first \n\t * @param {UplcValue} second \n\t * @returns {UplcPair}\n\t */\n\tstatic new(first, second) {\n\t\treturn new UplcPair(Site.dummy(), first, second);\n\t}\n\n\t/**\n\t * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.\n\t * @param {Site} site \n\t * @param {UplcValue} first\n\t * @param {UplcValue} second\n\t * @returns {UplcConst}\n\t */\n\tstatic newTerm(site, first, second) {\n\t\treturn new UplcConst(new UplcPair(site, first, second));\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn this.#first.memSize + this.#second.memSize;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcPair}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcPair(newSite, this.#first, this.#second);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(${this.#first.toString()}, ${this.#second.toString()})`;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisPair() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget first() {\n\t\treturn this.#first;\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget second() {\n\t\treturn this.#second;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget key() {\n\t\treturn this.#first.data;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget value() {\n\t\treturn this.#second.data;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\t// 7 (7 (6) (fst)) (snd)\n\t\treturn [\"0111\", \"0111\", \"0110\", this.#first.typeBits(), this.#second.typeBits()].join(\"1\");\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tthis.#first.toFlatValueInternal(bitWriter);\n\t\tthis.#second.toFlatValueInternal(bitWriter);\n\t}\n}\n\n/** \n * Plutus-core list value class.\n * Only used during evaluation.\n*/\nclass UplcList extends UplcValue {\n\t#itemType;\n\t#items;\n\n\t/**\n\t * @param {Site} site \n\t * @param {UplcType} itemType \n\t * @param {UplcValue[]} items \n\t */\n\tconstructor(site, itemType, items) {\n\t\tsuper(site);\n\t\tthis.#itemType = itemType;\n\t\tthis.#items = items;\n\t}\n\n\t/**\n\t * Constructs a UplcList without requiring a Site\n\t * @param {UplcType} type \n\t * @param {UplcValue[]} items \n\t */\n\tstatic new(type, items) {\n\t\treturn new UplcList(Site.dummy(), type, items);\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget length() {\n\t\treturn this.#items.length;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\tlet sum = 0;\n\n\t\tfor (let item of this.#items) {\n\t\t\tsum += item.copy(this.site).memSize;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tget itemType() {\n\t\treturn this.#itemType;\n\t}\n\n\t/**\n\t * @param {Site} newSite\n\t * @returns {UplcList}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcList(newSite, this.#itemType, this.#items.slice());\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisList() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @type {UplcValue[]}\n\t */\n\tget list() {\n\t\treturn this.#items.slice();\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `[${this.#items.map(item => item.toString()).join(\", \")}]`;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\t// 7 (5) (type bits of content)\n\t\treturn [\"0111\", \"0101\", this.#itemType.typeBits()].join(\"1\");\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tfor (let item of this.#items) {\n\t\t\tbitWriter.write('1');\n\n\t\t\titem.copy(this.site).toFlatValueInternal(bitWriter);\n\t\t}\n\n\t\tbitWriter.write('0');\n\t}\n}\n\n/**\n * Wrapper for UplcData.\n */\nclass UplcDataValue extends UplcValue {\n\t#data;\n\n\t/**\n\t * @param {Site} site \n\t * @param {UplcData} data \n\t */\n\tconstructor(site, data) {\n\t\tsuper(site);\n\t\tthis.#data = assertDefined(data);\n\t\tassert(data instanceof UplcData);\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget memSize() {\n\t\treturn this.#data.memSize;\n\t}\n\n\t/**\n\t * @param {Site} newSite \n\t * @returns {UplcDataValue}\n\t */\n\tcopy(newSite) {\n\t\treturn new UplcDataValue(newSite, this.#data);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisData() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `data(${this.#data.toString()})`;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttypeBits() {\n\t\treturn UplcType.newDataType().typeBits();\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter\n\t */\n\ttoFlatValueInternal(bitWriter) {\n\t\tUplcByteArray.writeBytes(bitWriter, this.#data.toCbor());\n\t}\n\n\t/**\n\t * @param {UplcDataValue | UplcData} data \n\t * @returns {UplcData}\n\t */\n\tstatic unwrap(data) {\n\t\tif (data instanceof UplcDataValue) {\n\t\t\treturn data.data;\n\t\t} else {\n\t\t\treturn data;\n\t\t}\n\t}\n}\n\n/**\n * Base class of Plutus-core terms\n * @package\n */\nclass UplcTerm {\n\t#site;\n\t#type;\n\n\t/**\n\t * @param {Site} site\n\t * @param {number} type\n\t */\n\tconstructor(site, type) {\n\t\tassert(site != undefined && site instanceof Site);\n\t\tthis.#site = site;\n\t\tthis.#type = type;\n\t}\n\n\t/**\n\t * @type {Site}\n\t */\n\tget site() {\n\t\treturn this.#site;\n\t}\n\n\t/**\n\t * Generic term toString method\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(Term ${this.#type.toString()})`;\n\t}\n\n\t/**\n\t * Calculates a value, and also increments the cost\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Writes bits of flat encoded Plutus-core terms to bitWriter. Doesn't return anything.\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Plutus-core variable ref term (index is a Debruijn index)\n * @package\n */\nclass UplcVariable extends UplcTerm {\n\t#index;\n\n\t/**\n\t * @param {Site} site \n\t * @param {UplcInt} index \n\t */\n\tconstructor(site, index) {\n\t\tsuper(site, 0);\n\t\tthis.#index = index;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `x${this.#index.toString()}`;\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0000');\n\t\tthis.#index.toFlatUnsigned(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte\n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\t// add costs before get the value\n\t\trte.incrVariableCost();\n\n\t\treturn rte.get(Number(this.#index.int));\n\t}\n}\n\n/**\n * Plutus-core delay term.\n * @package\n */\nclass UplcDelay extends UplcTerm {\n\t#expr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {UplcTerm} expr \n\t */\n\tconstructor(site, expr) {\n\t\tsuper(site, 1);\n\t\tthis.#expr = expr;\n\t}\n\n\t/**\n\t * @returns {string} \n\t */\n\ttoString() {\n\t\treturn `(delay ${this.#expr.toString()})`;\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0001');\n\t\tthis.#expr.toFlat(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\trte.incrDelayCost();\n\n\t\treturn new UplcDelayedValue(this.site, () =>  this.#expr.eval(rte));\n\t}\n}\n\n/**\n * Plutus-core lambda term\n * @package\n */\nclass UplcLambda extends UplcTerm {\n\t#rhs;\n\t#argName;\n\n\t/**\n\t * @param {Site} site\n\t * @param {UplcTerm} rhs\n\t * @param {?string} argName\n\t */\n\tconstructor(site, rhs, argName = null) {\n\t\tsuper(site, 2);\n\t\tthis.#rhs = rhs;\n\t\tthis.#argName = argName;\n\t}\n\n\t/**\n\t * Returns string with unicode lambda symbol\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(\\u039b${this.#argName !== null ? \" \" + this.#argName + \" ->\" : \"\"} ${this.#rhs.toString()})`;\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0010');\n\t\tthis.#rhs.toFlat(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\trte.incrLambdaCost();\n\n\t\treturn new UplcAnon(this.site, rte, this.#argName !== null ? [this.#argName] : 1, (callSite, subStack) => {\n\t\t\treturn this.#rhs.eval(subStack);\n\t\t});\n\t}\n}\n\n/**\n * Plutus-core function application term (i.e. function call)\n * @package\n */\nclass UplcCall extends UplcTerm {\n\t#a;\n\t#b;\n\n\t/**\n\t * @param {Site} site\n\t * @param {UplcTerm} a\n\t * @param {UplcTerm} b\n\t */\n\tconstructor(site, a, b) {\n\t\tsuper(site, 3);\n\t\tthis.#a = a;\n\t\tthis.#b = b;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `[${this.#a.toString()} ${this.#b.toString()}]`;\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0011');\n\t\tthis.#a.toFlat(bitWriter);\n\t\tthis.#b.toFlat(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns \n\t */\n\tasync eval(rte) {\n\t\trte.incrCallCost();\n\n\t\tlet fn = await this.#a.eval(rte);\n\t\tlet arg = await this.#b.eval(rte);\n\n\t\treturn await fn.call(rte, this.site, arg);\n\t}\n}\n\n/**\n * Plutus-core const term (i.e. a literal in conventional sense)\n * @package\n */\nclass UplcConst extends UplcTerm {\n\t#value;\n\n\t/**\n\t * @param {UplcValue} value \n\t */\n\tconstructor(value) {\n\t\tsuper(value.site, 4);\n\n\t\tthis.#value = value;\n\n\t\tif (value instanceof UplcInt) {\n\t\t\tassert(value.signed);\n\t\t}\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#value.toString();\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0100');\n\t\tthis.#value.toFlatValue(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcStack | UplcRte} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\trte.incrConstCost();\n\n\t\treturn await this.#value.eval(rte);\n\t}\n}\n\n/**\n * Plutus-core force term\n * @package\n */\nclass UplcForce extends UplcTerm {\n\t#expr;\n\n\t/**\n\t * @param {Site} site\n\t * @param {UplcTerm} expr\n\t */\n\tconstructor(site, expr) {\n\t\tsuper(site, 5);\n\t\tthis.#expr = expr;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(force ${this.#expr.toString()})`;\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0101');\n\t\tthis.#expr.toFlat(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\trte.incrForceCost();\n\n\t\treturn await (await this.#expr.eval(rte)).force();\n\t}\n}\n\n/**\n * Plutus-core error term\n * @package\n */\nclass UplcError extends UplcTerm {\n\t/** 'msg' is only used for debuggin and doesn't actually appear in the final program */\n\t#msg;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} msg \n\t */\n\tconstructor(site, msg = \"\") {\n\t\tsuper(site, 6);\n\t\tthis.#msg = msg;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn \"(error)\";\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0110');\n\t}\n\n\t/**\n\t * Throws a RuntimeError when evaluated.\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\tthrow this.site.runtimeError(this.#msg);\n\t}\n}\n\n/**\n * Plutus-core builtin function ref term\n * @package\n */\nclass UplcBuiltin extends UplcTerm {\n\t/** unknown builtins stay integers */\n\t#name;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string | number} name \n\t */\n\tconstructor(site, name) {\n\t\tsuper(site, 7);\n\t\tthis.#name = name;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#name.toString();\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tif (typeof this.#name == \"string\") {\n\t\t\treturn `(builtin ${this.#name})`;\n\t\t} else {\n\t\t\treturn `(builtin unknown${this.#name.toString()})`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tbitWriter.write('0111');\n\n\t\t/** @type {number} */\n\t\tlet i;\n\n\t\tif (typeof this.#name == \"string\") {\n\t\t\ti = UPLC_BUILTINS.findIndex(info => info.name == this.#name);\n\t\t} else {\n\t\t\ti = this.#name;\n\t\t}\n\n\t\tlet bitString = padZeroes(i.toString(2), 7);\n\n\t\tbitWriter.write(bitString);\n\t}\n\n\t/**\n\t * @param {NetworkParams} params\n\t * @param  {...UplcValue} args\n\t * @returns {Cost}\n\t */\n\tcalcCost(params, ...args) {\n\t\tlet i = UPLC_BUILTINS.findIndex(info => info.name == this.#name);\n\n\t\tlet argSizes = args.map(a => a.memSize);\n\n\t\tif (!argSizes.every(size => !Number.isNaN(size) && size >= 0)) {\n\t\t\tthrow new Error(\"invalid arg size\");\n\t\t}\n\n\t\treturn UPLC_BUILTINS[i].calcCost(params, argSizes);\n\t}\n\n\t/**\n\t * Used by IRCoreCallExpr\n\t * @param {Word} name\n\t * @param {UplcValue[]} args\n\t * @returns {UplcValue}\n\t */\n\tstatic evalStatic(name, args) {\n\t\tlet builtin = new UplcBuiltin(name.site, name.value);\n\n\t\tlet dummyRte = new UplcRte();\n\n\t\tlet anon = builtin.evalInternal(dummyRte);\n\n\t\tlet subStack = new UplcStack(dummyRte);\n\n\t\tlet res = anon.callSync(name.site, subStack, args);\n\n\t\tif (res instanceof Promise) {\n\t\t\tthrow new Error(\"can't call trace through evalStatic\");\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * @param {UplcRte | UplcStack} rte\n\t * @returns {UplcAnon}\n\t */\n\tevalInternal(rte = new UplcRte()) {\n\t\tif (typeof this.#name == \"number\") {\n\t\t\tthrow new Error(\"can't evaluate unknown Plutus-core builtin\");\n\t\t}\n\n\t\tswitch (this.#name) {\n\t\t\tcase \"addInteger\":\n\t\t\t\t// returning a lambda is assumed to be free\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\t// but calling a lambda has a cost associated\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcInt(callSite, a.int + b.int);\n\t\t\t\t});\n\t\t\tcase \"subtractInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcInt(callSite, a.int - b.int);\n\t\t\t\t});\n\t\t\tcase \"multiplyInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcInt(callSite, a.int * b.int);\n\t\t\t\t});\n\t\t\tcase \"divideInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tif (b.int === 0n) {\n\t\t\t\t\t\tthrow callSite.runtimeError(\"division by zero\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcInt(callSite, a.int / b.int);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"modInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tif (b.int === 0n) {\n\t\t\t\t\t\tthrow callSite.runtimeError(\"division by zero\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcInt(callSite, a.int % b.int);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"equalsInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, a.int == b.int);\n\t\t\t\t});\n\t\t\tcase \"lessThanInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, a.int < b.int);\n\t\t\t\t});\n\t\t\tcase \"lessThanEqualsInteger\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, a.int <= b.int);\n\t\t\t\t});\n\t\t\tcase \"appendByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, a.bytes.concat(b.bytes));\n\t\t\t\t});\n\t\t\tcase \"consByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tlet bytes = b.bytes;\n\t\t\t\t\tbytes.unshift(Number(a.int % 256n));\n\t\t\t\t\treturn new UplcByteArray(callSite, bytes);\n\t\t\t\t});\n\t\t\tcase \"sliceByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 3, (callSite, _, a, b, c) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b, c);\n\n\t\t\t\t\tlet start = Number(a.int);\n\t\t\t\t\tlet n = Number(b.int);\n\t\t\t\t\tlet bytes = c.bytes;\n\t\t\t\t\tif (start < 0) {\n\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (start + n > bytes.length) {\n\t\t\t\t\t\tn = bytes.length - start;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (n < 0) {\n\t\t\t\t\t\tn = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sub = bytes.slice(start, start + n);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, sub);\n\t\t\t\t});\n\t\t\tcase \"lengthOfByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcInt(callSite, BigInt(a.bytes.length));\n\t\t\t\t});\n\t\t\tcase \"indexByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tlet bytes = a.bytes;\n\t\t\t\t\tlet i = b.int;\n\t\t\t\t\tif (i < 0 || i >= bytes.length) {\n\t\t\t\t\t\tthrow new Error(\"index out of range\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new UplcInt(callSite, BigInt(bytes[Number(i)]));\n\t\t\t\t});\n\t\t\tcase \"equalsByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, ByteArrayData.comp(a.bytes, b.bytes) == 0);\n\t\t\t\t});\n\t\t\tcase \"lessThanByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, ByteArrayData.comp(a.bytes, b.bytes) == -1);\n\t\t\t\t});\n\t\t\tcase \"lessThanEqualsByteString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, ByteArrayData.comp(a.bytes, b.bytes) <= 0);\n\t\t\t\t});\n\t\t\tcase \"appendString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcString(callSite, a.string + b.string);\n\t\t\t\t});\n\t\t\tcase \"equalsString\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcBool(callSite, a.string == b.string);\n\t\t\t\t});\n\t\t\tcase \"encodeUtf8\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, textToBytes(a.string));\n\t\t\t\t});\n\t\t\tcase \"decodeUtf8\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn new UplcString(callSite, bytesToText(a.bytes));\n\t\t\t\t\t} catch(_) {\n\t\t\t\t\t\tthrow callSite.runtimeError(\"invalid utf-8\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"sha2_256\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, Crypto.sha2_256(a.bytes))\n\t\t\t\t});\n\t\t\tcase \"sha3_256\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, Crypto.sha3(a.bytes))\n\t\t\t\t});\n\t\t\tcase \"blake2b_256\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, Crypto.blake2b(a.bytes)); \n\t\t\t\t});\n\t\t\tcase \"verifyEd25519Signature\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 3, (callSite, _, key, msg, signature) => {\n\t\t\t\t\trte.calcAndIncrCost(this, key, msg, signature);\n\n\t\t\t\t\tlet keyBytes = key.bytes;\n\t\t\t\t\tif (keyBytes.length != 32) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`expected key of length 32 for verifyEd25519Signature, got key of length ${keyBytes.length}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet msgBytes = msg.bytes;\n\t\t\t\t\t\n\t\t\t\t\tlet signatureBytes = signature.bytes;\n\t\t\t\t\tif (signatureBytes.length != 64) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`expected signature of length 64 for verifyEd25519Signature, got signature of length ${signatureBytes.length}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet ok = Crypto.Ed25519.verify(signatureBytes, msgBytes, keyBytes);\n\n\t\t\t\t\treturn new UplcBool(callSite, ok);\n\t\t\t\t});\n\t\t\tcase \"ifThenElse\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 3, (callSite, _, a, b, c) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b, c);\n\n\t\t\t\t\treturn a.bool ? b.copy(callSite) : c.copy(callSite);\n\t\t\t\t});\n\t\t\tcase \"chooseUnit\":\n\t\t\t\t// what is the point of this function?\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\ta.assertUnit();\n\n\t\t\t\t\treturn b.copy(callSite);\n\t\t\t\t});\n\t\t\tcase \"trace\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn rte.print(a.string).then(() => {\n\t\t\t\t\t\treturn b.copy(callSite);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\tcase \"fstPair\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (a.isPair()) {\n\t\t\t\t\t\treturn a.first.copy(callSite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`expected pair or data-pair for first arg, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"sndPair\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (a.isPair()) {\n\t\t\t\t\t\treturn a.second.copy(callSite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`expected pair or data-pair for first arg, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"chooseList\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 3, (callSite, _, a, b, c) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b, c);\n\n\t\t\t\t\tif (a.isList()) {\n\t\t\t\t\t\tif (a.length == 0) {\n\t\t\t\t\t\t\treturn b.copy(callSite);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn c.copy(callSite);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`expected list or map first arg, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"mkCons\":\n\t\t\t\t// only allow data items in list\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tif (b.isList()) {\n\t\t\t\t\t\tif (!b.itemType.isSameType(a)) {\n\t\t\t\t\t\t\tthrow callSite.typeError(`wrong type for 2nd arg of mkCons`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet lst = b.list;\n\t\t\t\t\t\tlst.unshift(a);\n\n\t\t\t\t\t\treturn new UplcList(callSite, b.itemType, lst);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`expected list or map for second arg, got '${b.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"headList\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (a.isList()) {\n\t\t\t\t\t\tconst lst = a.list;\n\t\t\t\t\t\tif (lst.length == 0) {\n\t\t\t\t\t\t\tthrow callSite.runtimeError(\"empty list\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lst[0].copy(callSite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`__core__head expects list or map, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"tailList\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (a.isList()) {\n\t\t\t\t\t\tlet lst = a.list;\n\t\t\t\t\t\tif (lst.length == 0) {\n\t\t\t\t\t\t\tthrow callSite.runtimeError(\"empty list\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn new UplcList(callSite, a.itemType, lst.slice(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`__core__tail expects list or map, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"nullList\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (a.isList()) {\n\t\t\t\t\t\treturn new UplcBool(callSite, a.list.length == 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow callSite.typeError(`__core__nullList expects list or map, got '${a.toString()}'`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"chooseData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 6, (callSite, _, a, b, c, d, e, f) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b, c, d, e, f);\n\n\t\t\t\t\tlet data = a.data;\n\n\t\t\t\t\tif (data instanceof ConstrData) {\n\t\t\t\t\t\treturn b;\n\t\t\t\t\t} else if (data instanceof MapData) {\n\t\t\t\t\t\treturn c;\n\t\t\t\t\t} else if (data instanceof ListData) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t} else if (data instanceof IntData) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t} else if (data instanceof ByteArrayData) {\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"constrData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tconst i = a.int;\n\t\t\t\t\tassert(i >= 0);\n\n\t\t\t\t\tconst lst = b.list;\n\n\t\t\t\t\treturn new UplcDataValue(callSite, new ConstrData(Number(i), lst.map(item => item.data)));\n\t\t\t\t});\n\t\t\tcase \"mapData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcDataValue(callSite, new MapData(a.list.map(pair => {\n\t\t\t\t\t\treturn [pair.first.data, pair.second.data];\n\t\t\t\t\t})));\n\t\t\t\t});\n\t\t\tcase \"listData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcDataValue(callSite, new ListData(a.list.map(item => item.data)));\n\t\t\t\t});\n\t\t\tcase \"iData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\t\t\t\t\t\n\t\t\t\t\treturn new UplcDataValue(callSite, new IntData(a.int));\n\t\t\t\t});\n\t\t\tcase \"bData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcDataValue(callSite, new ByteArrayData(a.bytes));\n\t\t\t\t});\n\t\t\tcase \"unConstrData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for arg of unConstrData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data = a.data;\n\t\t\t\t\tif (!(data instanceof ConstrData)) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`unexpected unConstrData argument '${data.toString()}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcPair(callSite, new UplcInt(callSite, BigInt(data.index)), new UplcList(callSite, UplcType.newDataType(), data.fields.map(f => new UplcDataValue(callSite, f))));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"unMapData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for arg of unMapData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data = a.data;\n\t\t\t\t\tif (!(data instanceof MapData)) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`unexpected unMapData argument '${data.toString()}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcList(callSite, UplcType.newDataPairType(), data.map.map(([fst, snd]) => new UplcPair(callSite, new UplcDataValue(callSite, fst), new UplcDataValue(callSite, snd))));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"unListData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for arg of unListData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data = a.data;\n\t\t\t\t\tif (!(data instanceof ListData)) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`unexpected unListData argument '${data.toString()}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcList(callSite, UplcType.newDataType(), data.list.map(item => new UplcDataValue(callSite, item)));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"unIData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for arg of unIData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data = a.data;\n\t\t\t\t\tif (!(data instanceof IntData)) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`unexpected unIData argument '${data.toString()}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcInt(callSite, data.value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"unBData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for arg of unBData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data = a.data;\n\t\t\t\t\tif (!(data instanceof ByteArrayData)) {\n\t\t\t\t\t\tthrow callSite.runtimeError(`unexpected unBData argument '${data.toString()}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new UplcByteArray(callSite, data.bytes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tcase \"equalsData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\tif (!a.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for 1st arg of equalsData, got ${a.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!b.isData()) {\n\t\t\t\t\t\tthrow callSite.typeError(`expected data for 2nd arg of equalsData, got ${b.toString()}`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new UplcBool(callSite, a.data.isSame(b.data));\n\t\t\t\t});\n\t\t\tcase \"mkPairData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 2, (callSite, _, a, b) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a, b);\n\n\t\t\t\t\treturn new UplcPair(callSite, new UplcDataValue(callSite, a.data), new UplcDataValue(callSite, b.data));\n\t\t\t\t});\n\t\t\tcase \"mkNilData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\ta.assertUnit();\n\n\t\t\t\t\treturn new UplcList(callSite, UplcType.newDataType(), []);\n\t\t\t\t});\n\t\t\tcase \"mkNilPairData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\ta.assertUnit();\n\n\t\t\t\t\treturn new UplcList(callSite, UplcType.newDataPairType(), []);\n\t\t\t\t});\n\t\t\tcase \"serialiseData\":\n\t\t\t\treturn new UplcAnon(this.site, rte, 1, (callSite, _, a) => {\n\t\t\t\t\trte.calcAndIncrCost(this, a);\n\n\t\t\t\t\treturn new UplcByteArray(callSite, a.data.toCbor());\n\t\t\t\t});\n\t\t\tcase \"verifyEcdsaSecp256k1Signature\":\n\t\t\tcase \"verifySchnorrSecp256k1Signature\":\n\t\t\t\tthrow new Error(\"no immediate need, so don't bother yet\");\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`builtin ${this.#name} not yet implemented`);\n\t\t}\n\t}\n\n\t/**\n\t * Returns appropriate callback wrapped with UplcAnon depending on builtin name.\n\t * Emulates every Plutus-core that Helios exposes to the user.\n\t * @param {UplcRte | UplcStack} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\trte.incrBuiltinCost();\n\n\t\t/**\n\t\t * @type {UplcValue}\n\t\t */\n\t\tlet v = this.evalInternal(rte);\n\n\t\tif  (typeof this.#name === 'string') {\n\t\t\tlet nForce = UPLC_BUILTINS[findUplcBuiltin(\"__core__\" + this.#name)].forceCount;\n\n\t\t\tfor  (let i = 0; i < nForce; i++) {\n\t\t\t\tconst vPrev = v;\n\n\t\t\t\tv = new UplcDelayedValue(this.site, () => vPrev);\n\t\t\t}\n\t\t}\n \n\t\treturn v;\n\t}\n}\n\n\n\n///////////////////////////\n// Section 11: Uplc program\n///////////////////////////\n\n/**\n * This library uses version \"1.0.0\" of Plutus-core\n * @package\n */\nconst UPLC_VERSION_COMPONENTS = [1n, 0n, 0n];\n\n /**\n  * i.e. \"1.0.0\"\n  * @package\n  * @type {string}\n  */\nconst UPLC_VERSION = UPLC_VERSION_COMPONENTS.map(c => c.toString()).join(\".\");\n\n/**\n * This library uses V2 of the Plutus Ledger API, and is no longer compatible with V1\n * @package\n */\nconst PLUTUS_SCRIPT_VERSION = \"PlutusScriptV2\";\n\n/**\n * @package\n * @type {Object.<string, number>}\n */\n const UPLC_TAG_WIDTHS = {\n\tterm:      4,\n\ttype:      3,\n\tconstType: 4,\n\tbuiltin:   7,\n\tconstant:  4,\n\tkind:      1\n};\n\n/**\n * Plutus-core program class\n */\n class UplcProgram {\n\t#version;\n\t#expr;\n\t#purpose;\n\n\t/**\n\t * @param {UplcTerm} expr \n\t * @param {?number} purpose // TODO: enum type\n\t * @param {UplcInt[]} version\n\t */\n\tconstructor(expr, purpose = null, version = UPLC_VERSION_COMPONENTS.map(v => new UplcInt(expr.site, v, false))) {\n\t\tthis.#version = version;\n\t\tthis.#expr = expr;\n\t\tthis.#purpose = purpose;\n\t}\n\n\t/**\n\t * @type {UplcTerm}\n\t */\n\tget expr() {\n\t\treturn this.#expr;\n\t}\n\n\t/**\n\t * @type {Site}\n\t */\n\tget site() {\n\t\treturn new Site(this.#expr.site.src, 0);\n\t}\n\n\t/**\n\t * Returns the IR source\n\t * @type {string}\n\t */\n\tget src() {\n\t\treturn this.site.src.raw;\n\t}\n\n\t/**\n\t * Returns version of Plutus-core (!== Plutus script version!)\n\t * @type {string}\n\t */\n\tget versionString() {\n\t\treturn this.#version.map(v => v.toString()).join(\".\");\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tplutusScriptVersion() {\n\t\t// Note: only supports PlutusScriptV2 for now\n\t\treturn PLUTUS_SCRIPT_VERSION;\n\t}\n\n\t/**\n\t * Returns 1 for PlutusScriptV1, 2 for PlutusScriptV2\n\t * @returns {number}\n\t */\n\tversionTag() {\n\t\tlet v = this.plutusScriptVersion();\n\n\t\tswitch (v) {\n\t\t\tcase \"PlutusScriptV1\":\n\t\t\t\treturn 1;\n\t\t\tcase \"PlutusScriptV2\":\n\t\t\t\treturn 2;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`unhandled script version '${v}'`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(program ${this.versionString} ${this.#expr.toString()})`;\n\t}\n\n\t/**\n\t * Flat encodes the entire Plutus-core program.\n\t * Note that final padding isn't added now but is handled by bitWriter upon finalization.\n\t * @param {BitWriter} bitWriter \n\t */\n\ttoFlat(bitWriter) {\n\t\tfor (let v of this.#version) {\n\t\t\tv.toFlatUnsigned(bitWriter);\n\t\t}\n\n\t\tthis.#expr.toFlat(bitWriter);\n\t}\n\n\t/**\n\t * @param {UplcRte} rte \n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync eval(rte) {\n\t\treturn this.#expr.eval(rte);\n\t}\n\n\t/**\n\t * Evaluates the term contained in UplcProgram (assuming it is a lambda term)\n\t * @param {?UplcValue[]} args\n\t * @param {UplcRTECallbacks} callbacks\n\t * @param {?NetworkParams} networkParams\n\t * @returns {Promise<UplcValue>}\n\t */\n\tasync runInternal(args, callbacks = DEFAULT_UPLC_RTE_CALLBACKS, networkParams = null) {\n\t\tassertDefined(callbacks);\n\n\t\tlet rte = new UplcRte(callbacks, networkParams);\n\n\t\t// add the startup costs\n\t\trte.incrStartupCost();\n\n\t\tlet fn = await this.eval(rte);\n\n\t\t// program site is at pos 0, but now the call site is actually at the end \n\t\tlet globalCallSite = new Site(this.site.src, this.site.src.length);\n\t\t\n\t\t/** @type {UplcValue} */\n\t\tlet result = fn;\n\n\t\tif (args !== null) {\n\t\t\tif (args.length === 0 && fn instanceof UplcDelayedValue) {\n\t\t\t\tresult = await fn.force();\n\t\t\t} else {\n\t\t\t\tfor (let arg of args) {\n\t\t\t\t\t// each call also adds to the total cost\n\t\t\t\t\trte.incrCallCost();\n\t\t\t\t\trte.incrConstCost();\n\n\t\t\t\t\tresult = await result.call(rte, globalCallSite, arg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Wrap the top-level term with consecutive UplcCall terms\n\t * No checks are performed whether this makes sense or not, so beware\n\t * Throws an error if you are trying to apply an  with anon func.\n\t * @param {(UplcValue | HeliosData)[]} args\n\t * @returns {UplcProgram} - a new UplcProgram instance\n\t */\n\tapply(args) {\n\t\tlet expr = this.expr;\n\n\t\tfor (let arg of args) {\n\t\t\tif (arg instanceof UplcValue) {\n\t\t\t\tif (arg instanceof UplcAnon) {\n\t\t\t\t\tthrow new Error(\"UplcAnon cannot be applied to UplcProgram\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\texpr = new UplcCall(arg.site, expr, new UplcConst(arg));\n\t\t\t} else if (arg instanceof HeliosData) {\n\t\t\t\texpr = new UplcCall(Site.dummy(), expr, new UplcConst(new UplcDataValue(Site.dummy(), arg._toUplcData())));\n\t\t\t}\n\t\t}\n\n\t\treturn new UplcProgram(expr, this.#purpose, this.#version);\n\t}\n\n\t/**\n\t * @param {?UplcValue[]} args - if null the top-level term is returned as a value\n\t * @param {UplcRTECallbacks} callbacks \n\t * @param {?NetworkParams} networkParams\n\t * @returns {Promise<UplcValue | UserError>}\n\t */\n\tasync run(args, callbacks = DEFAULT_UPLC_RTE_CALLBACKS, networkParams = null) {\n\t\ttry {\n\t\t\treturn await this.runInternal(args, callbacks, networkParams);\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof UserError)) {\n\t\t\t\tthrow e;\n\t\t\t} else {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {?UplcValue[]} args\n\t * @returns {Promise<[(UplcValue | UserError), string[]]>}\n\t */\n\tasync runWithPrint(args) {\n\t\t/**\n\t\t * @type {string[]}\n\t\t */\n\t\tconst messages = [];\n\n\t\tconst callbacks = Object.assign({}, DEFAULT_UPLC_RTE_CALLBACKS);\n\n\t\tcallbacks.onPrint = async function(msg) {\n\t\t\tmessages.push(msg);\n\t\t};\n\n\t\tconst res = await this.run(args, callbacks);\n\n\t\treturn [res, messages];\n\t}\n\n\t/**\n\t * @typedef {{\n\t *   mem: bigint, \n\t *   cpu: bigint,\n\t *   size: number,\n\t *   builtins: {[name: string]: Cost},\n\t *   terms: {[name: string]: Cost},\n\t *   result: UserError | UplcValue,\n\t *   messages: string[]\n\t * }} Profile\n\t * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)\n\t * cpu:  in reference cpu microseconds\n\t * size: in bytes\n\t * builtins: breakdown per builtin\n\t * terms: breakdown per termtype\n\t * result: result of evaluation\n\t * messages: printed messages (can be helpful when debugging)\n\t */\n\n\t/**\n\t * @param {UplcValue[]} args\n\t * @param {NetworkParams} networkParams\n\t * @returns {Promise<Profile>}\n\t */\n\tasync profile(args, networkParams) {\n\t\tlet callbacks = Object.assign({}, DEFAULT_UPLC_RTE_CALLBACKS);\n\n\t\tlet memCost = 0n;\n\t\tlet cpuCost = 0n;\n\n\t\t/**\n\t\t * @type {{[name: string]: Cost}}\n\t\t */\n\t\tconst builtins = {};\n\n\t\t/**\n\t\t * @type {{[name: string]: Cost}}\n\t\t */\n\t\tconst terms = {};\n\t\t\n\t\t/**\n\t\t * @type {(name: string, isTerm: boolean, cost: Cost) => void}\n\t\t */\n\t\tcallbacks.onIncrCost = (name, isTerm, cost) => {\n\t\t\tmemCost += cost.mem;\n\t\t\tcpuCost += cost.cpu;\n\n\t\t\tif (name !== undefined) {\n\t\t\t\tif (isTerm) {\n\t\t\t\t\tconst prev = terms[name];\n\t\t\t\t\tif (prev !== undefined) {\n\t\t\t\t\t\tterms[name] = {\n\t\t\t\t\t\t\tmem: prev.mem + cost.mem,\n\t\t\t\t\t\t\tcpu: prev.cpu + cost.cpu\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tterms[name] = cost;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst prev = builtins[name];\n\n\t\t\t\t\tif (prev !== undefined) {\n\t\t\t\t\t\tbuiltins[name] = {\n\t\t\t\t\t\t\tmem: prev.mem + cost.mem,\n\t\t\t\t\t\t\tcpu: prev.cpu + cost.cpu\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuiltins[name] = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t/** @type {string[]} */\n\t\tlet messages = [];\n\n\t\t/**\n\t\t * @type {(msg: string) => Promise<void>}\n\t\t */\n\t\tcallbacks.onPrint = async function(msg) {\n\t\t\tmessages.push(msg);\n\t\t};\n\n\t\tlet result = await this.run(args, callbacks, networkParams);\n\n\t\treturn {\n\t\t\tmem: memCost,\n\t\t\tcpu: cpuCost,\n\t\t\tsize: this.calcSize(),\n\t\t\tbuiltins: builtins,\n\t\t\tterms: terms,\n\t\t\tresult: result,\n\t\t\tmessages: messages\n\t\t};\n\t}\n\n\t/**\n\t * Returns flat bytes of serialized script\n\t * @returns {number[]}\n\t */\n\tserializeBytes() {\n\t\tlet bitWriter = new BitWriter();\n\n\t\tthis.toFlat(bitWriter);\n\n\t\treturn bitWriter.finalize();\n\t}\n\n\t/**\n\t * Calculates the on chain size of the program (number of bytes).\n\t * @returns {number}\n\t */\n\tcalcSize() {\n\t\treturn this.serializeBytes().length;\n\t}\n\n\t/**\n\t * Returns the Cbor encoding of a script (flat bytes wrapped twice in Cbor bytearray)\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeBytes(CborData.encodeBytes(this.serializeBytes()));\n\t}\n\n\t/**\n\t * Returns Plutus-core script in JSON format (as string, not as object!)\n\t * @returns {string}\n\t */\n\tserialize() {\n\t\tlet cborHex = bytesToHex(this.toCbor());\n\n\t\treturn `{\"type\": \"${this.plutusScriptVersion()}\", \"description\": \"\", \"cborHex\": \"${cborHex}\"}`;\n\t}\n\n\t/**\n\t * @returns {number[]} - 28 byte hash\n\t */\n\thash() {\n\t\tlet innerBytes = CborData.encodeBytes(this.serializeBytes());\n\n\t\tinnerBytes.unshift(this.versionTag());\n\n\t\t// used for both script addresses and minting policy hashes\n\t\treturn Crypto.blake2b(innerBytes, 28);\n\t}\n\n\t/**\n\t * @type {ValidatorHash}\n\t */\n\tget validatorHash() {\n\t\tassert(this.#purpose === null || this.#purpose === ScriptPurpose.Spending);\n\n\t\treturn new ValidatorHash(this.hash());\n\t}\n\n\t/**\n\t * @type {MintingPolicyHash}\n\t */\n\tget mintingPolicyHash() {\n\t\tassert(this.#purpose === null || this.#purpose === ScriptPurpose.Minting);\n\n\t\treturn new MintingPolicyHash(this.hash());\n\t}\n\n\t/**\n\t * @type {StakingValidatorHash}\n\t */\n\tget stakingValidatorHash() {\n\t\tassert(this.#purpose === null || this.#purpose === ScriptPurpose.Staking);\n\n\t\treturn new StakingValidatorHash(this.hash());\n\t}\n\n\t/**\n\t * @param {number[] | string} bytes \n\t * @returns {UplcProgram}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tif (typeof bytes == \"string\") {\n\t\t\treturn UplcProgram.fromCbor(hexToBytes(bytes))\n\t\t} else {\n\t\t\treturn deserializeUplcBytes(CborData.decodeBytes(CborData.decodeBytes(bytes)));\n\t\t}\n\t}\n}\n\n/**\n * Plutus-core deserializer creates a Plutus-core form an array of bytes\n */\n class UplcDeserializer extends BitReader {\n\t\n\t/**\n\t * @param {number[]} bytes \n\t */\n\tconstructor(bytes) {\n\t\tsuper(bytes);\n\t}\n\n\t/**\n\t * @param {string} category \n\t * @returns {number}\n\t */\n\ttagWidth(category) {\n\t\tassert(category in UPLC_TAG_WIDTHS, `unknown tag category ${category.toString()}`);\n\n\t\treturn UPLC_TAG_WIDTHS[category];\n\t}\n\n\t/**\n\t * Returns the name of a known builtin\n\t * Returns the integer id if id is out of range (thus if the builtin is unknown)\n\t * @param {number} id\n\t * @returns {string | number}\n\t */\n\tbuiltinName(id) {\n\t\tlet all = UPLC_BUILTINS;\n\n\t\tif (id >= 0 && id < all.length) {\n\t\t\treturn all[id].name;\n\t\t} else {\n\t\t\tconsole.error(`Warning: builtin id ${id.toString()} out of range`);\n\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t/**\n\t * Reads a Plutus-core list with a specified size per element\n\t * Calls itself recursively until the end of the list is reached\n\t * @param {number} elemSize \n\t * @returns {number[]}\n\t */\n\treadLinkedList(elemSize) {\n\t\t// Cons and Nil constructors come from Lisp/Haskell\n\t\t//  cons 'a' creates a linked list node,\n\t\t//  nil      creates an empty linked list\n\t\tlet nilOrCons = this.readBits(1);\n\n\t\tif (nilOrCons == 0) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn [this.readBits(elemSize)].concat(this.readLinkedList(elemSize));\n\t\t}\n\t}\n\n\t/**\n\t * Reads a single UplcTerm\n\t * @returns {UplcTerm}\n\t */\n\treadTerm() {\n\t\tlet tag = this.readBits(this.tagWidth(\"term\"));\n\n\t\tswitch (tag) {\n\t\t\tcase 0:\n\t\t\t\treturn this.readVariable();\n\t\t\tcase 1:\n\t\t\t\treturn this.readDelay();\n\t\t\tcase 2:\n\t\t\t\treturn this.readLambda();\n\t\t\tcase 3:\n\t\t\t\treturn this.readCall(); // aka function application\n\t\t\tcase 4:\n\t\t\t\treturn this.readConstant();\n\t\t\tcase 5:\n\t\t\t\treturn this.readForce();\n\t\t\tcase 6:\n\t\t\t\treturn new UplcError(Site.dummy());\n\t\t\tcase 7:\n\t\t\t\treturn this.readBuiltin();\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"term tag \" + tag.toString() + \" unhandled\");\n\t\t}\n\t}\n\n\t/**\n\t * Reads a single unbounded integer\n\t * @param {boolean} signed \n\t * @returns {UplcInt}\n\t */\n\treadInteger(signed = false) {\n\t\tlet bytes = [];\n\n\t\tlet b = this.readByte();\n\t\tbytes.push(b);\n\n\t\twhile (!UplcInt.rawByteIsLast(b)) {\n\t\t\tb = this.readByte();\n\t\t\tbytes.push(b);\n\t\t}\n\n\t\t// strip the leading bit\n\t\tlet res = new UplcInt(Site.dummy(), UplcInt.bytesToBigInt(bytes.map(b => UplcInt.parseRawByte(b))), false); // raw int is unsigned\n\n\t\tif (signed) {\n\t\t\tres = res.toSigned(); // unzigzag is performed here\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Reads bytearray or string characters\n\t * @returns {number[]}\n\t */\n\treadBytes() {\n\t\tthis.moveToByteBoundary(true);\n\n\t\tlet bytes = [];\n\n\t\tlet nChunk = this.readByte();\n\n\t\twhile (nChunk > 0) {\n\t\t\tfor (let i = 0; i < nChunk; i++) {\n\t\t\t\tbytes.push(this.readByte());\n\t\t\t}\n\n\t\t\tnChunk = this.readByte();\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\t/**\n\t * Reads a literal bytearray\n\t * @returns {UplcByteArray}\n\t */\n\treadByteArray() {\n\t\tlet bytes = this.readBytes();\n\n\t\treturn new UplcByteArray(Site.dummy(), bytes);\n\t}\n\n\t/**\n\t * Reads a literal string\n\t * @returns {UplcString}\n\t */\n\treadString() {\n\t\tlet bytes = this.readBytes();\n\n\t\tlet s = bytesToText(bytes);\n\n\t\treturn new UplcString(Site.dummy(), s);\n\t}\n\n\t/**\n\t * @param {() => UplcValue} typedReader \n\t * @returns {UplcValue[]}\n\t */\n\treadList(typedReader) {\n\t\t/** @type {UplcValue[]} */\n\t\tlet items = [];\n\n\t\twhile (this.readBits(1) == 1) {\n\t\t\titems.push(typedReader());\n\t\t}\n\n\t\treturn items;\n\t}\n\n\t/**\n\t * Reads a data object\n\t * @returns {UplcData}\n\t */\n\treadData() {\n\t\tlet bytes = this.readBytes();\n\n\t\treturn UplcData.fromCbor(bytes);\n\t}\n\n\t/**\n\t * Reads a variable term\n\t * @returns {UplcVariable}\n\t */\n\treadVariable() {\n\t\tlet index = this.readInteger()\n\n\t\treturn new UplcVariable(Site.dummy(), index);\n\t}\n\n\t/**\n\t * Reads a lambda expression term\n\t * @returns {UplcLambda}\n\t */\n\treadLambda() {\n\t\tlet rhs = this.readTerm();\n\n\t\treturn new UplcLambda(Site.dummy(), rhs);\n\t}\n\n\t/**\n\t * Reads a function application term\n\t * @returns {UplcCall}\n\t */\n\treadCall() {\n\t\tlet a = this.readTerm();\n\t\tlet b = this.readTerm();\n\n\t\treturn new UplcCall(Site.dummy(), a, b);\n\t}\n\n\t/**\n\t * Reads a single constant\n\t * @returns {UplcConst}\n\t */\n\treadConstant() {\n\t\tlet typeList = this.readLinkedList(this.tagWidth(\"constType\"));\n\n\t\tlet res = new UplcConst(this.readTypedValue(typeList));\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Reads a single constant\n\t * @param {number[]} typeList \n\t * @returns {UplcValue}\n\t */\n\treadTypedValue(typeList) {\n\t\tconst typedReader = this.constructTypedReader(typeList);\n\n\t\tassertEq(typeList.length, 0, \"Did not consume all type parameters\");\n\n\t\treturn typedReader();\n\t}\n\n\t/**\n\t * Constructs a reader for a single construct recursively\n\t * @param {number[]} typeList \n\t * NOTE: the implicit assumption is that this functions modifies the typeList\n\t * by removing all elements that it \"consumed\" to define a type\n\t * @returns {() => UplcValue}\n\t */\n\tconstructTypedReader(typeList){\n\t\tconst type = assertDefined(typeList.shift());\n\n\t\tswitch (type) {\n\t\t\tcase 0: // signed Integer\n\t\t\t\treturn () => this.readInteger(true);\n\t\t\tcase 1: // bytearray\n\t\t\t\treturn () => this.readByteArray();\n\t\t\tcase 2: // utf8-string\n\t\t\t\treturn () => this.readString();\n\t\t\tcase 3:\n\t\t\t\treturn () => new UplcUnit(Site.dummy()); // no reading needed\n\t\t\tcase 4: // Bool\n\t\t\t\treturn () => new UplcBool(Site.dummy(), this.readBits(1) == 1);\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\t\tthrow new Error(\"unexpected type tag without type application\");\n\t\t\tcase 7:\n\t\t\t\tlet containerType = assertDefined(typeList.shift());\n\t\t\t\tif (containerType == 5) {\n\t\t\t\t\t// typeList is consumed by the construct call, so make sure to read it before!\n\t\t\t\t\tconst listType = UplcType.fromNumbers(typeList);\n\t\t\t\t\tconst typeReader = this.constructTypedReader(typeList);\n\n\t\t\t\t\treturn () => new UplcList(Site.dummy(), listType, this.readList(typeReader));\n\t\t\t\t} else {\n\t\t\t\t\tassertEq(containerType, 7, \"Unexpected type tag\");\n\t\t\t\t\tcontainerType = assertDefined(typeList.shift());\n\t\t\t\t\tif (containerType == 6) {\n\t\t\t\t\t\t// typeList is consumed by the construct call, so make sure to read it in correct order!\n\t\t\t\t\t\tconst leftReader = this.constructTypedReader(typeList);\n\t\t\t\t\t\tconst rightReader = this.constructTypedReader(typeList);\n\t\t\t\t\t\treturn () => new UplcPair(Site.dummy(), leftReader(), rightReader())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase 8:\n\t\t\t\treturn () => new UplcDataValue(Site.dummy(), this.readData());\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`unhandled constant type ${type.toString()}`);\n\t\t}\n\t}\n\n\t/**\n\t * Reads a delay term\n\t * @returns {UplcDelay}\n\t */\n\treadDelay() {\n\t\tlet expr = this.readTerm();\n\n\t\treturn new UplcDelay(Site.dummy(), expr);\n\t}\n\n\t/**\n\t * Reads a force term\n\t * @returns {UplcForce}\n\t */\n\treadForce() {\n\t\tlet expr = this.readTerm();\n\n\t\treturn new UplcForce(Site.dummy(), expr);\n\t}\n\n\t/**\n\t * Reads a builtin function ref term\n\t * @returns {UplcBuiltin}\n\t */\n\treadBuiltin() {\n\t\tlet id = this.readBits(this.tagWidth(\"builtin\"));\n\n\t\tlet name = this.builtinName(id);\n\n\t\treturn new UplcBuiltin(Site.dummy(), name);\n\t}\n\n\t/**\n\t * Move to the next byteboundary\n\t * (and check that we are at the end)\n\t */\n\tfinalize() {\n\t\tthis.moveToByteBoundary(true);\n\t}\n}\n\n/**\n * @param {number[]} bytes \n * @returns {UplcProgram}\n */\nfunction deserializeUplcBytes(bytes) {\n\tlet reader = new UplcDeserializer(bytes);\n\n\tlet version = [\n\t\treader.readInteger(),\n\t\treader.readInteger(),\n\t\treader.readInteger(),\n\t];\n\n\tlet versionKey = version.map(v => v.toString()).join(\".\");\n\n\tif (versionKey != UPLC_VERSION) {\n\t\tconsole.error(`Warning: Plutus-core script doesn't match version of Helios (expected ${UPLC_VERSION}, got ${versionKey})`);\n\t}\n\n\tlet expr = reader.readTerm();\n\n\treader.finalize();\n\n\treturn new UplcProgram(expr, null, version);\n}\n\n/**\n * Parses a plutus core program. Returns a UplcProgram object\n * @param {string} jsonString \n * @returns {UplcProgram}\n */\nfunction deserializeUplc(jsonString) {\n\tlet obj = JSON.parse(jsonString);\n\n\tif (!(\"cborHex\" in obj)) {\n\t\tthrow UserError.syntaxError(new Source(jsonString), 0, 1, \"cborHex field not in json\")\n\t}\n\n\tlet cborHex = obj.cborHex;\n\tif (typeof cborHex !== \"string\") {\n\t\tlet src = new Source(jsonString);\n\t\tlet re = /cborHex/;\n\t\tlet cborHexMatch = jsonString.match(re);\n\t\tif (cborHexMatch === null) {\n\t\t\tthrow UserError.syntaxError(src, 0, 1, \"'cborHex' key not found\");\n\t\t} else {\n\t\t\tconst pos = jsonString.search(re)\n\t\t\tthrow UserError.syntaxError(src, pos, pos+1, \"cborHex not a string\");\n\t\t}\n\t}\n\n\treturn UplcProgram.fromCbor(hexToBytes(cborHex));\n}\n\n\n///////////////////////////\n// Section 12: Tokenization\n///////////////////////////\n\nclass Tokenizer {\n\t#src;\n\t#pos;\n\n\t/**\n\t * Tokens are accumulated in '#ts'\n\t * @type {Token[]} \n\t */\n\t#ts;\n\t#codeMap;\n\t#codeMapPos;\n\n\t/**\n\t * @param {Source} src \n\t * @param {?CodeMap} codeMap \n\t */\n\tconstructor(src, codeMap = null) {\n\t\tassert(src instanceof Source);\n\n\t\tthis.#src = src;\n\t\tthis.#pos = 0;\n\t\tthis.#ts = []; // reset to empty to list at start of tokenize()\n\t\tthis.#codeMap = codeMap; // can be a list of pairs [pos, site in another source]\n\t\tthis.#codeMapPos = 0; // not used if codeMap === null\n\t}\n\n\tincrPos() {\n\t\tthis.#pos += 1;\n\t}\n\n\tdecrPos() {\n\t\tthis.#pos -= 1;\n\t\tassert(this.#pos >= 0);\n\t}\n\n\tget currentSite() {\n\t\treturn new Site(this.#src, this.#pos);\n\t}\n\n\t/**\n\t * @param {Token} t \n\t */\n\tpushToken(t) {\n\t\tthis.#ts.push(t);\n\n\t\tif (this.#codeMap !== null && this.#codeMapPos < this.#codeMap.length) {\n\t\t\tlet pair = (this.#codeMap[this.#codeMapPos]);\n\n\t\t\tif (pair[0] == t.site.startPos) {\n\t\t\t\tt.site.setCodeMapSite(pair[1]);\n\t\t\t\tthis.#codeMapPos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reads a single char from the source and advances #pos by one\n\t * @returns {string}\n\t */\n\treadChar() {\n\t\tassert(this.#pos >= 0);\n\n\t\tlet c;\n\t\tif (this.#pos < this.#src.length) {\n\t\t\tc = this.#src.getChar(this.#pos);\n\t\t} else {\n\t\t\tc = '\\0';\n\t\t}\n\n\t\tthis.incrPos();\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Decreases #pos by one\n\t */\n\tunreadChar() {\n\t\tthis.decrPos();\n\t}\n\n\t/**\n\t * Start reading precisely one token\n\t * @param {Site} site \n\t * @param {string} c \n\t */\n\treadToken(site, c) {\n\t\tif (c == '_' || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\tthis.readWord(site, c);\n\t\t} else if (c == '/') {\n\t\t\tthis.readMaybeComment(site);\n\t\t} else if (c == '0') {\n\t\t\tthis.readSpecialInteger(site);\n\t\t} else if (c >= '1' && c <= '9') {\n\t\t\tthis.readDecimalInteger(site, c);\n\t\t} else if (c == '#') {\n\t\t\tthis.readByteArray(site);\n\t\t} else if (c == '\"') {\n\t\t\tthis.readString(site);\n\t\t} else if (c == '?' || c == '!' || c == '%' || c == '&' || (c >= '(' && c <= '.') || (c >= ':' && c <= '>') || c == '[' || c == ']' || (c >= '{' && c <= '}')) {\n\t\t\tthis.readSymbol(site, c);\n\t\t} else if (!(c == ' ' || c == '\\n' || c == '\\t' || c == '\\r')) {\n\t\t\tsite.syntaxError(`invalid source character '${c}' (utf-8 not yet supported outside string literals)`);\n\t\t}\n\t}\n\n\t/**\n\t * Tokenize the complete source.\n\t * Nests groups before returning a list of tokens\n\t * @returns {Token[] | null}\n\t */\n\ttokenize() {\n\t\t// reset #ts\n\t\tthis.#ts = [];\n\n\t\tlet site = this.currentSite;\n\t\tlet c = this.readChar();\n\n\t\twhile (c != '\\0') {\n\t\t\tthis.readToken(site, c);\n\n\t\t\tsite = this.currentSite;\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\treturn this.nestGroups(this.#ts);\n\t}\n\n\t/** \n\t * Returns a generator\n\t * Use gen.next().value to access to the next Token\n\t * Doesn't perform any grouping\n\t * Used for quickly parsing the ScriptPurpose header of a script\n\t * @returns {Generator<Token>}\n\t */\n\t*streamTokens() {\n\t\tthis.#ts = [];\n\n\t\tlet site = this.currentSite;\n\t\tlet c = this.readChar();\n\n\t\twhile (c != '\\0') {\n\t\t\tthis.readToken(site, c);\n\n\t\t\tlet t = this.#ts.shift();\n\t\t\twhile (t != undefined) {\n\t\t\t\tyield t;\n\t\t\t\tt = this.#ts.shift();\n\t\t\t}\n\n\t\t\tsite = this.currentSite;\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\tassert(this.#ts.length == 0);\n\t}\n\n\t/**\n\t * Reads one word token.\n\t * Immediately turns \"true\" or \"false\" into a BoolLiteral instead of keeping it as Word\n\t * @param {Site} site\n\t * @param {string} c0 - first character \n\t */\n\treadWord(site, c0) {\n\t\tlet chars = [];\n\n\t\tlet c = c0;\n\t\twhile (c != '\\0') {\n\t\t\tif (c == '_' || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\tchars.push(c);\n\t\t\t\tc = this.readChar();\n\t\t\t} else {\n\t\t\t\tthis.unreadChar();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet value = chars.join('');\n\n\t\tif (value == \"true\" || value == \"false\") {\n\t\t\tthis.pushToken(\n\t\t\t\tnew BoolLiteral(\n\t\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\t\tvalue == \"true\"\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pushToken(\n\t\t\t\tnew Word(\n\t\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\t\tvalue\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Reads and discards a comment if current '/' char is followed by '/' or '*'.\n\t * Otherwise pushes Symbol('/') onto #ts\n\t * @param {Site} site \n\t */\n\t// comments are discarded\n\treadMaybeComment(site) {\n\t\tlet c = this.readChar();\n\n\t\tif (c == '\\0') {\n\t\t\tthis.pushToken(new SymbolToken(site, '/'));\n\t\t} else if (c == '/') {\n\t\t\tthis.readSingleLineComment();\n\t\t} else if (c == '*') {\n\t\t\tthis.readMultiLineComment(site);\n\t\t} else {\n\t\t\tthis.pushToken(new SymbolToken(site, '/'));\n\t\t\tthis.unreadChar();\n\t\t}\n\t}\n\n\t/**\n\t * Reads and discards a single line comment (from '//' to end-of-line)\n\t */\n\treadSingleLineComment() {\n\t\tlet c = this.readChar();\n\n\t\twhile (c != '\\n' && c != '\\0') {\n\t\t\tc = this.readChar();\n\t\t}\n\t}\n\n\t/**\n\t * Reads and discards a multi-line comment (from '/' '*' to '*' '/')\n\t * @param {Site} site \n\t */\n\treadMultiLineComment(site) {\n\t\tlet prev = '';\n\t\tlet c = this.readChar();\n\n\t\twhile (true) {\n\t\t\tprev = c;\n\t\t\tc = this.readChar();\n\n\t\t\tif (c == '/' && prev == '*') {\n\t\t\t\tbreak;\n\t\t\t} else if (c == '\\0') {\n\t\t\t\tconst errorSite = new Site(site.src, site.startPos, this.currentSite.startPos);\n\t\t\t\terrorSite.syntaxError(\"unterminated multiline comment\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * REads a literal integer\n\t * @param {Site} site \n\t */\n\treadSpecialInteger(site) {\n\t\tlet c = this.readChar();\n\n\t\tif (c == '\\0') {\n\t\t\tthis.pushToken(new IntLiteral(site, 0n));\n\t\t} else if (c == 'b') {\n\t\t\tthis.readBinaryInteger(site);\n\t\t} else if (c == 'o') {\n\t\t\tthis.readOctalInteger(site);\n\t\t} else if (c == 'x') {\n\t\t\tthis.readHexInteger(site);\n\t\t} else if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\tsite.syntaxError(`bad literal integer type 0${c}`);\n\t\t} else if (c >= '0' && c <= '9') {\n\t\t\tthis.readDecimalInteger(site, c);\n\t\t} else {\n\t\t\tthis.pushToken(new IntLiteral(site, 0n));\n\t\t\tthis.unreadChar();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t */\n\treadBinaryInteger(site) {\n\t\tthis.readRadixInteger(site, \"0b\", c => (c == '0' || c == '1'));\n\t}\n\n\t/**\n\t * @param {Site} site \n\t */\n\treadOctalInteger(site) {\n\t\tthis.readRadixInteger(site, \"0o\", c => (c >= '0' && c <= '7'));\n\t}\n\n\t/**\n\t * @param {Site} site \n\t */\n\treadHexInteger(site) {\n\t\tthis.readRadixInteger(site, \"0x\",\n\t\t\tc => ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')));\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} c0 - first character\n\t */\n\treadDecimalInteger(site, c0) {\n\t\tlet chars = [];\n\n\t\tlet c = c0;\n\t\twhile (c != '\\0') {\n\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\tchars.push(c);\n\t\t\t} else {\n\t\t\t\tif ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tconst errorSite = new Site(site.src, site.startPos, this.currentSite.startPos);\n\n\t\t\t\t\terrorSite.syntaxError(\"invalid syntax for decimal integer literal\");\n\t\t\t\t}\n\n\t\t\t\tthis.unreadChar();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\tthis.pushToken(\n\t\t\tnew IntLiteral(\n\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\tBigInt(chars.join(''))\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} prefix \n\t * @param {(c: string) => boolean} valid - checks if character is valid as part of the radix\n\t */\n\treadRadixInteger(site, prefix, valid) {\n\t\tlet c = this.readChar();\n\n\t\tlet chars = [];\n\n\t\tif (!(valid(c))) {\n\t\t\tconst errorSite = new Site(site.src, site.startPos, this.currentSite.startPos);\n\n\t\t\terrorSite.syntaxError(`expected at least one char for ${prefix} integer literal`);\n\n\t\t\tthis.unreadChar();\n\t\t\treturn;\n\t\t}\n\n\t\twhile (c != '\\0') {\n\t\t\tif (valid(c)) {\n\t\t\t\tchars.push(c);\n\t\t\t} else {\n\t\t\t\tif ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n\t\t\t\t\tconst errorSite = new Site(site.src, site.startPos, this.currentSite.startPos);\n\n\t\t\t\t\terrorSite.syntaxError(`invalid syntax for ${prefix} integer literal`);\n\t\t\t\t}\n\n\t\t\t\tthis.unreadChar();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\tthis.pushToken(\n\t\t\tnew IntLiteral(\n\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\tBigInt(prefix + chars.join(''))\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Reads literal hexadecimal representation of ByteArray\n\t * @param {Site} site \n\t */\n\treadByteArray(site) {\n\t\tlet c = this.readChar();\n\n\t\tlet chars = [];\n\n\t\t// case doesn't matter\n\t\twhile ((c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {\n\t\t\tchars.push(c);\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\t// empty byteArray is allowed (eg. for Ada mintingPolicyHash)\n\n\t\t// last char is the one that made the while loop break, so should be unread\n\t\tthis.unreadChar();\n\n\t\tlet bytes = hexToBytes(chars.join(''));\n\n\t\tthis.pushToken(\n\t\t\tnew ByteArrayLiteral(\n\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\tbytes\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Reads literal string delimited by double quotes.\n\t * Allows for three escape character: '\\\\', '\\n' and '\\t'\n\t * @param {Site} site \n\t */\n\treadString(site) {\n\t\tlet c = this.readChar();\n\n\t\tlet chars = [];\n\n\t\tlet escaping = false;\n\t\t/** @type {?Site} */\n\t\tlet escapeSite = null; // for escape syntax errors\n\n\t\twhile (!(!escaping && c == '\"')) {\n\t\t\tif (c == '\\0') {\n\t\t\t\tsite.syntaxError(\"unmatched '\\\"'\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (escaping) {\n\t\t\t\tif (c == 'n') {\n\t\t\t\t\tchars.push('\\n');\n\t\t\t\t} else if (c == 't') {\n\t\t\t\t\tchars.push('\\t');\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\tchars.push('\\\\');\n\t\t\t\t} else if (c == '\"') {\n\t\t\t\t\tchars.push(c);\n\t\t\t\t} else if (escapeSite !== null) {\n\t\t\t\t\tconst errorSite = new Site(escapeSite.src, escapeSite.startPos, this.currentSite.startPos);\n\n\t\t\t\t\terrorSite.syntaxError(`invalid escape sequence ${c}`);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"escape site should be non-null\");\n\t\t\t\t}\n\n\t\t\t\tescaping = false;\n\t\t\t\tescapeSite = null;\n\t\t\t} else {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\tescapeSite = this.currentSite;\n\t\t\t\t\tescaping = true;\n\t\t\t\t} else {\n\t\t\t\t\tchars.push(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = this.readChar();\n\t\t}\n\n\t\tthis.pushToken(\n\t\t\tnew StringLiteral(\n\t\t\t\tnew Site(site.src, site.startPos, this.currentSite.startPos),\n\t\t\t\tchars.join('')\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Reads single or double character symbols\n\t * @param {Site} site \n\t * @param {string} c0 - first character\n\t */\n\treadSymbol(site, c0) {\n\t\tlet chars = [c0];\n\n\t\t/** @type {(second: string) => boolean} */\n\t\tlet parseSecondChar = (second) => {\n\t\t\tlet d = this.readChar();\n\n\t\t\tif (d == second) {\n\t\t\t\tchars.push(d);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.unreadChar();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (c0 == '|') {\n\t\t\tparseSecondChar('|');\n\t\t} else if (c0 == '&') {\n\t\t\tparseSecondChar('&');\n\t\t} else if (c0 == '=') {\n\t\t\tif (!parseSecondChar('=')) {\n\t\t\t\tparseSecondChar('>');\n\t\t\t}\n\t\t} else if (c0 == '!' || c0 == '<' || c0 == '>') { // could be !=, ==, <= or >=\n\t\t\tparseSecondChar('=');\n\t\t} else if (c0 == ':') {\n\t\t\tparseSecondChar(':');\n\t\t} else if (c0 == '-') {\n\t\t\tparseSecondChar('>');\n\t\t}\n\n\t\tthis.pushToken(\n\t\t\tnew SymbolToken(\n\t\t\t\tnew Site(site.src, site.startPos, site.endPos),\n\t\t\t\tchars.join('')\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Separates tokens in fields (separted by commas)\n\t * @param {Token[]} ts \n\t * @returns {Group | null}\n\t */\n\tbuildGroup(ts) {\n\t\tconst open = assertDefined(ts.shift()).assertSymbol();\n\n\t\tif (!open) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst stack = [open]; // stack of symbols\n\t\tlet curField = [];\n\t\tlet fields = [];\n\n\t\t/** @type {?SymbolToken} */\n\t\tlet firstComma = null;\n\n\t\t/** @type {?SymbolToken} */\n\t\tlet lastComma = null;\n\n\t\t/** @type {?Site} */\n\t\tlet endSite = null;\n\n\t\twhile (stack.length > 0 && ts.length > 0) {\n\t\t\tconst t = assertToken(ts.shift(), open.site);\n\n\t\t\tif (!t) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst prev = stack.pop();\n\n\t\t\tendSite = t.site;\n\n\t\t\tif (t != undefined && prev != undefined) {\n\t\t\t\tif (!t.isSymbol(Group.matchSymbol(prev))) {\n\t\t\t\t\tstack.push(prev);\n\n\t\t\t\t\tif (Group.isCloseSymbol(t)) {\n\t\t\t\t\t\tt.site.syntaxError(`unmatched '${assertDefined(t.assertSymbol()).value}'`);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (Group.isOpenSymbol(t)) {\n\t\t\t\t\t\tstack.push(assertDefined(t.assertSymbol()));\n\t\t\t\t\t\tcurField.push(t);\n\t\t\t\t\t} else if (t.isSymbol(\",\") && stack.length == 1) {\n\t\t\t\t\t\tif (firstComma === null) {\n\t\t\t\t\t\t\tfirstComma = t.assertSymbol();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlastComma = t.assertSymbol();\n\t\t\t\t\t\tif (curField.length == 0) {\n\t\t\t\t\t\t\tt.site.syntaxError(\"empty field\");\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfields.push(curField);\n\t\t\t\t\t\t\tcurField = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurField.push(t);\n\t\t\t\t\t}\n\t\t\t\t} else if (stack.length > 0) {\n\t\t\t\t\tcurField.push(t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t}\n\t\t}\n\n\t\tlet last = stack.pop();\n\t\tif (last != undefined) {\n\t\t\tlast.syntaxError(`EOF while matching '${last.value}'`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (curField.length > 0) {\n\t\t\t// add removing field\n\t\t\tfields.push(curField);\n\t\t} else if (lastComma !== null) {\n\t\t\tlastComma.syntaxError(`trailing comma`);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst groupedFields = reduceNull(fields.map(f => this.nestGroups(f)));\n\n\t\tif (!groupedFields) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet site = open.site;\n\n\t\tif (endSite) {\n\t\t\tsite = site.merge(endSite);\n\t\t}\n\n\t\treturn new Group(site, open.value, groupedFields, firstComma);\n\t}\n\n\t/**\n\t * Match group open with group close symbols in order to form groups.\n\t * This is recursively applied to nested groups.\n\t * @param {Token[]} ts \n\t * @returns {Token[] | null}\n\t */\n\tnestGroups(ts) {\n\t\t/**\n\t\t * @type {(Token | null)[]}\n\t\t */\n\t\tlet res = [];\n\n\t\tlet t = ts.shift();\n\t\twhile (t != undefined) {\n\t\t\tif (Group.isOpenSymbol(t)) {\n\t\t\t\tts.unshift(t);\n\n\t\t\t\tres.push(this.buildGroup(ts));\n\t\t\t} else if (Group.isCloseSymbol(t)) {\n\t\t\t\tt.syntaxError(`unmatched '${assertDefined(t.assertSymbol()).value}'`);\n\t\t\t} else {\n\t\t\t\tres.push(t);\n\t\t\t}\n\n\t\t\tt = ts.shift();\n\t\t}\n\n\t\treturn reduceNull(res);\n\t}\n}\n\n/**\n * Tokenizes a string (wrapped in Source)\n * Also used by VSCode plugin\n * @param {Source} src \n * @returns {Token[] | null}\n */\nfunction tokenize(src) {\n\tlet tokenizer = new Tokenizer(src);\n\n\treturn tokenizer.tokenize();\n}\n\n/**\n * Tokenizes an IR string with a codemap to the original source\n * @package\n * @param {string} rawSrc \n * @param {CodeMap} codeMap \n * @returns {Token[]}\n */\nfunction tokenizeIR(rawSrc, codeMap) {\n\tlet src = new Source(rawSrc);\n\n\t// the Tokenizer for Helios can simply be reused for the IR\n\tlet tokenizer = new Tokenizer(src, codeMap);\n\n\tconst ts = tokenizer.tokenize();\n\n\tif (src.errors.length > 0) {\n\t\tthrow src.errors[0];\n\t} else if (ts === null) {\n\t\tthrow new Error(\"should've been thrown above\");\n\t}\n\n\treturn ts;\n}\n\n\n\n///////////////////////////////////\n// Section 13: Helios eval entities\n///////////////////////////////////\n\n/**\n * We can't use StructStatement etc. directly because that would give circular dependencies\n * @typedef {{\n *   name: Word,\n *   getTypeMember(key: Word): EvalEntity,\n *   getInstanceMember(key: Word): Instance,\n *   nFields(site: Site): number,\n *   hasField(key: Word): boolean,\n *   getFieldType(site: Site, i: number): Type,\n * \t getFieldIndex(site: Site, name: string): number,\n *   getFieldName(i: number): string,\n *   getConstrIndex(site: Site): number,\n *   nEnumMembers(site: Site): number,\n *   path: string,\n *   use: () => void\n * }} UserTypeStatement\n */\n\n/**\n * We can't use ConstStatement directly because that would give a circular dependency\n * @typedef {{\n *   name: Word,\n *   path: string,\n *   use: () => void\n * }} ConstTypeStatement\n */\n\n/**\n * We can't use EnumMember directly because that would give a circular dependency\n * @typedef {UserTypeStatement & {\n * \t parent: EnumTypeStatement,\n *   getConstrIndex(site: Site): number\n*  }} EnumMemberTypeStatement\n */\n\n/**\n * We can't use EnumStatement directly because that would give a circular dependency\n * @typedef {UserTypeStatement & {\n *   type: Type,\n *   nEnumMembers(site: Site): number,\n *   getEnumMember(site: Site, i: number): EnumMemberTypeStatement\n * }} EnumTypeStatement\n */\n\n/**\n * We can't use FuncStatement directly because that would give a circular dependency\n * @typedef {{\n *   path: string,\n *   use: () => void,\n *   setRecursive: () => void,\n *   isRecursive: () => boolean\n * }} RecurseableStatement\n */\n\n/**\n * We can't use Scope directly because that would give a circular dependency\n * @typedef {{\n *   isRecursive: (statement: RecurseableStatement) => boolean\n * }} RecursivenessChecker\n */\n\n/**\n * Base class of Instance and Type.\n * Any member function that takes 'site' as its first argument throws a TypeError if used incorrectly (eg. calling a non-FuncType).\n * @package\n */\nclass EvalEntity {\n\tconstructor() {\n\t\tthis.used_ = false;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {Type}\n\t */\n\tassertType(site) {\n\t\tthrow site.typeError(\"not a type\");\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisType() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {Instance}\n\t */\n\tassertValue(site) {\n\t\tthrow site.typeError(\"not a value\");\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisValue() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisUsed() {\n\t\treturn this.used_;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Used by Scope to mark named Values/Types as used.\n\t * At the end of the Scope an error is thrown if any named Values/Types aren't used.\n\t */\n\tmarkAsUsed() {\n\t\tthis.used_ = true;\n\t}\n\n\t/**\n\t * Gets type of a value. Throws error when trying to get type of type.\n\t * @param {Site} site\n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is a base-type of 'type'. Throws an error if 'this' isn't a Type.\n\t * @param {Site} site\n\t * @param {Type} type\n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns 'true' if 'this' is an instance of 'type'. Throws an error if 'this' isn't a Instance.\n\t * 'type' can be a class, or a class instance.\n\t * @param {Site} site \n\t * @param {Type | TypeClass} type \n\t * @returns {boolean}\n\t */\n\tisInstanceOf(site, type) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns the return type of a function (wrapped as a Instance) if the args have the correct types. \n\t * Throws an error if 'this' isn't a function value, or if the args don't correspond.\n\t * @param {Site} site \n\t * @param {Instance[]} args\n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Gets a member of a Type (i.e. the '::' operator).\n\t * Throws an error if the member doesn't exist or if 'this' isn't a DataType.\n\t * @param {Word} name\n\t * @returns {EvalEntity} - can be Instance or Type\n\t */\n\tgetTypeMember(name) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Gets a member of a Instance (i.e. the '.' operator).\n\t * Throws an error if the member doesn't exist or if 'this' isn't a DataInstance.\n\t * @param {Word} name\n\t * @returns {Instance} - can be FuncInstance or DataInstance\n\t */\n\tgetInstanceMember(name) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns the number of fields in a struct.\n\t * Used to check if a literal struct constructor is correct.\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns the type of struct or enumMember fields.\n\t * Used to check if literal struct constructor is correct.\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns the index of struct or enumMember fields.\n\t * Used to order literal struct fields.\n\t * @param {Site} site\n\t * @param {string} name\n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns the constructor index so Plutus-core data can be created correctly.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Types are used during type-checking of Helios\n * @package\n */\nclass Type extends EvalEntity {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Compares two types. Throws an error if neither is a Type.\n\t * @example\n\t * Type.same(Site.dummy(), new IntType(), new IntType()) => true\n\t * @param {Site} site \n\t * @param {Type} a \n\t * @param {Type} b \n\t * @returns {boolean}\n\t */\n\tstatic same(site, a, b) {\n\t\treturn a.isBaseOf(site, b) && b.isBaseOf(site, a);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisType() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {Type}\n\t */\n\tassertType(site) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisValue() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the underlying Type. Throws an error in this case because a Type can't return another Type.\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\tthrow site.typeError(`can't use getType(), '${this.toString()}' isn't an instance`);\n\t}\n\n\t/**\n\t * Throws an error because a Type can't be an instance of another Type.\n\t * @param {Site} site \n\t * @param {Type | TypeClass} type\n\t * @returns {boolean}\n\t */\n\tisInstanceOf(site, type) {\n\t\tthrow site.typeError(`can't use isInstanceOf(), '${this.toString()}' isn't an instance`);\n\t}\n\n\t/**\n\t * Throws an error because a Type isn't callable.\n\t * @param {Site} site \n\t * @param {Instance[]} args \n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\tthrow site.typeError(\"not callable\");\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisEnumMember() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Throws error for non-enum members\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tparentType(site) {\n\t\tthrow site.typeError(`'${this.toString}' isn't an enum member`);\n\t}\n\n\t/**\n\t * Returns number of members of an enum type\n\t * Throws an error if not an enum type\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\tthrow site.typeError(`'${this.toString()}' isn't an enum type`);\n\t}\n\n\t/**\n\t * Returns the base path in the IR (eg. __helios__bool, __helios__error, etc.)\n\t * @type {string}\n\t */\n\tget path() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\tthrow new Error(`${this.toString()} doesn't have a corresponding userType`);\n\t}\n}\n\n\n/**\n * AnyType matches any other type in the type checker.\n * @package\n */\nclass AnyType extends Type {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} other \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, other) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn \"Any\";\n\t}\n}\n\n/**\n * Base class of non-FuncTypes.\n */\nclass DataType extends Type {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\treturn Object.getPrototypeOf(this) == Object.getPrototypeOf(type);\n\t}\n}\n\n/**\n * Matches everything except FuncType.\n * Used by find_datum_hash.\n */\nclass AnyDataType extends Type {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {Type} type\n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\treturn !(type instanceof FuncType);\n\t}\n}\n\n/**\n * Base class of all builtin types (eg. IntType)\n * Note: any builtin type that inherits from BuiltinType must implement get path()\n * @package\n */\nclass BuiltinType extends DataType {\n\t#macrosAllowed; // macros are allowed after the definition of the main function\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.#macrosAllowed = false;\n\t}\n\n\tallowMacros() {\n\t\tthis.#macrosAllowed = true;\n\t}\n\n\tget macrosAllowed() {\n\t\treturn this.#macrosAllowed;\n\t}\n\n\t/**\n\t * Returns Type member (i.e. '::' operator).\n\t * @param {Word} name\n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__eq\":\n\t\t\tcase \"__neq\":\n\t\t\t\treturn Instance.new(new FuncType([this, this], new BoolType()));\n\t\t\tcase \"from_data\":\n\t\t\t\treturn Instance.new(new FuncType([new RawDataType()], this));\n\t\t\tdefault:\n\t\t\t\tthrow name.referenceError(`${this.toString()}::${name.value} undefined`);\n\t\t}\n\t}\n\n\t/**\n\t * Returns one of default instance members, or throws an error.\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"serialize\":\n\t\t\t\treturn Instance.new(new FuncType([], new ByteArrayType()));\n\t\t\tdefault:\n\t\t\t\tthrow name.referenceError(`${this.toString()}.${name.value} undefined`);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of data fields in a builtin type (not yet used)\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns the constructor index of a builtin type (eg. 1 for Option::None).\n\t * By default non-enum builtin types that are encoded as Plutus-core data use the '0' constructor index.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Use 'path' getter instead of 'toIR()' in order to get the base path.\n\t */\n\ttoIR() {\n\t\tthrow new Error(\"use path getter instead\");\n\t}\n}\n\n/**\n * @package\n */\nclass BuiltinEnumMember extends BuiltinType {\n\t#parentType;\n\n\t/**\n\t * @param {BuiltinType} parentType \n\t */\n\tconstructor(parentType) {\n\t\tsuper();\n\t\tthis.#parentType = parentType;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisEnumMember() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tparentType(site) {\n\t\treturn this.#parentType;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__eq\":\n\t\t\tcase \"__neq\":\n\t\t\t\treturn Instance.new(new FuncType([this.#parentType, this.#parentType], new BoolType()));\n\t\t\tcase \"from_data\":\n\t\t\t\tthrow name.referenceError(`'${this.toString()}::from_data' undefined`);\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n}\n\n/**\n * Type wrapper for Struct statements and Enums and Enum members.\n * @package\n * @template {UserTypeStatement} T\n */\nclass StatementType extends DataType {\n\t#statement;\n\n\t/**\n\t * @param {T} statement \n\t */\n\tconstructor(statement) {\n\t\tsuper();\n\t\tthis.#statement = statement;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#statement.name.value;\n\t}\n\n\t/**\n\t * @returns {T}\n\t */\n\tget statement() {\n\t\treturn this.#statement;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof StatementType) {\n\t\t\treturn type.path.startsWith(this.path);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the name of the type.\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#statement.name.toString();\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\treturn this.#statement.getTypeMember(name);\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\treturn this.#statement.getInstanceMember(name);\n\t}\n\n\t/**\n\t * Returns the number of fields in a Struct or in an EnumMember.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\treturn this.#statement.nFields(site);\n\t}\n\n\t/**\n\t * Returns the i-th field of a Struct or an EnumMember\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\treturn this.#statement.getFieldType(site, i);\n\t}\n\n\t/**\n\t * Returns the index of a named field of a Struct or an EnumMember\n\t * @param {Site} site\n\t * @param {string} name\n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\treturn this.#statement.getFieldIndex(site, name);\n\t}\n\n\t/**\n\t * Returns the constructor index so that __core__constrData can be called correctly.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn this.#statement.getConstrIndex(site);\n\t}\n\n\t/**\n\t * Returns the number of members of an EnumStatement\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn this.#statement.nEnumMembers(site);\n\t}\n\n\tget path() {\n\t\treturn this.#statement.path;\n\t}\n\n\t/**\n\t * A StatementType can instantiate itself if the underlying statement is an enum member with no fields\n\t * @param {Site} site\n\t * @returns {Instance}\n\t */\n\tassertValue(site) {\n\t\tthrow site.typeError(`expected a value, got a type`);\n\t}\n}\n\n/**\n * @package\n * @extends {StatementType<UserTypeStatement>}\n */\nclass StructStatementType extends StatementType {\n\t/**\n\t * @param {UserTypeStatement} statement - can't use StructStatement because that would give a circular dependency\n\t */\n\tconstructor(statement) {\n\t\tsuper(statement);\n\t}\n\n\t/**\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\tconst statement = this.statement;\n\n\t\tconst nFields = this.nFields(Site.dummy());\n\n\t\t/**\n\t\t * @type {[string, Type][]} - [name, type]\n\t\t */\n\t\tconst fields = [];\n\n\t\tfor (let i = 0; i < nFields; i++) {\n\t\t\tfields.push([statement.getFieldName(i), statement.getFieldType(Site.dummy(), i)]);\n\t\t}\n\n\t\tclass Struct extends HeliosData {\n\t\t\t/**\n\t\t\t * So we can access fields by index\n\t\t\t * @type {HeliosData[]}\n\t\t\t */\n\t\t\t#fields;\n\n\t\t\t/**\n\t\t\t * @param  {...any} args\n\t\t\t */\n\t\t\tconstructor(...args) {\n\t\t\t\tsuper();\n\t\t\t\tif (args.length != nFields) {\n\t\t\t\t\tthrow new Error(`expected ${nFields} args, got ${args.length}`);\n\t\t\t\t}\n\n\t\t\t\tthis.#fields = [];\n\n\t\t\t\targs.forEach((arg, i) => {\n\t\t\t\t\tconst [fieldName, fieldType] = fields[i];\n\t\t\t\t\tconst FieldClass = fieldType.userType;\n\n\t\t\t\t\tconst instance = arg instanceof FieldClass ? arg : new FieldClass(arg);\n\n\t\t\t\t\tthis.#fields.push(instance);\n\t\t\t\t\tthis[fieldName] = instance;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Overload 'instanceof' operator\n\t\t\t * @param {any} other \n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tstatic [Symbol.hasInstance](other) {\n\t\t\t\treturn (other._structStatement === statement) && (other instanceof HeliosData);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {UserTypeStatement}\n\t\t\t */\n\t\t\tget _structStatement() {\n\t\t\t\treturn statement;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @returns {UplcData}\n\t\t\t */\n\t\t\t_toUplcData() {\n\t\t\t\tif (this.#fields.length == 1) {\n\t\t\t\t\treturn this.#fields[0]._toUplcData();\n\t\t\t\t} else {\n\t\t\t\t\treturn new ListData(this.#fields.map(f => f._toUplcData()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {string | number[]} bytes \n\t\t\t * @returns {Struct}\n\t\t\t */\n\t\t\tstatic fromUplcCbor(bytes) {\n\t\t\t\treturn Struct.fromUplcData(UplcData.fromCbor(bytes));\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {UplcData} data \n\t\t\t * @returns {Struct}\n\t\t\t */\n\t\t\tstatic fromUplcData(data) {\n\t\t\t\tconst dataItems = data.list;\n\n\t\t\t\tif (dataItems.length != nFields) {\n\t\t\t\t\tthrow new Error(\"unexpected number of fields\");\n\t\t\t\t}\n\n\t\t\t\tconst args = dataItems.map((item, i) => {\n\t\t\t\t\treturn fields[i][1].userType.fromUplcData(item);\n\t\t\t\t});\n\n\t\t\t\treturn new Struct(...args);\n\t\t\t}\n\t\t}\n\n\t\tObject.defineProperty(Struct, \"name\", {value: this.name, writable: false});\t\t\n\n\t\treturn Struct;\n\t}\n}\n\n/**\n * @package\n * @extends {StatementType<EnumTypeStatement>}\n */\nclass EnumStatementType extends StatementType {\n\t/**\n\t * @param {EnumTypeStatement} statement - can't use EnumStatement because that would give a circular dependency\n\t */\n\tconstructor(statement) {\n\t\tsuper(statement);\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\tconst statement = this.statement;\n\n\t\tconst nVariants = statement.nEnumMembers(Site.dummy());\n\n\t\t/**\n\t\t * @type {HeliosDataClass<HeliosData>[]}\n\t\t */\n\t\tconst variants = [];\n\n\t\tfor (let i = 0; i < nVariants; i++) {\n\t\t\tvariants.push(\n\t\t\t\t(new EnumMemberStatementType(statement.getEnumMember(Site.dummy(), i))).userType\n\t\t\t);\n\t\t}\n\n\t\tclass Enum extends HeliosData {\n\t\t\tconstructor() {\n\t\t\t\tsuper();\n\t\t\t\tthrow new Error(\"can't be constructed (hint: construct an enum)\");\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Overload 'instanceof' operator\n\t\t\t * @param {any} other \n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tstatic [Symbol.hasInstance](other) {\n\t\t\t\treturn (other._enumStatement === statement) && (other instanceof HeliosData);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {EnumTypeStatement}\n\t\t\t */\n\t\t\tget _enumStatement() {\n\t\t\t\treturn statement;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {string | number[]} bytes\n\t\t\t * @returns {HeliosData}\n\t\t\t */\n\t\t\tstatic fromUplcCbor(bytes) {\n\t\t\t\treturn Enum.fromUplcData(UplcData.fromCbor(bytes));\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {UplcData} data \n\t\t\t * @returns {HeliosData}\n\t\t\t */\n\t\t\tstatic fromUplcData(data) {\n\t\t\t\tconst variant = assertDefined(variants[data.index], \"index out of range\");\n\n\t\t\t\treturn variant.fromUplcData(data);\n\t\t\t}\n\t\t}\n\n\t\tObject.defineProperty(Enum, \"name\", {value: this.name, writable: false});\n\n\t\tfor (let v of variants) {\n\t\t\tObject.defineProperty(Enum, v.name, {value: v, writable: false});\n\t\t}\n\n\t\treturn Enum;\n\t}\n}\n\n/**\n * @package\n * @extends {StatementType<EnumMemberTypeStatement>}\n */\nclass EnumMemberStatementType extends StatementType {\n    /**\n     * @param {EnumMemberTypeStatement} statement - can't use EnumMember because that would give a circular dependency\n     */\n    constructor(statement) {\n        super(statement);\n    }\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisEnumMember() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tparentType(site) {\n\t\treturn this.statement.parent.type;\n\t}\n\n    /**\n\t * A StatementType can instantiate itself if the underlying statement is an enum member with no fields\n\t * @package\n\t * @param {Site} site\n\t * @returns {Instance}\n\t */\n    assertValue(site) {\n        if (this.statement.nFields(site) == 0) {\n            return Instance.new(this);\n        } else {\n            throw site.typeError(`expected '{...}' after '${this.statement.name.toString()}'`);\n        }\n    }\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\tconst statement = this.statement;\n\n\t\tconst enumStatement = statement.parent;\n\n\t\tconst index = statement.getConstrIndex(Site.dummy());\n\n\t\tconst nFields = this.nFields(Site.dummy());\n\n\t\t/**\n\t\t * @type {[string, Type][]} - [name, type]\n\t\t */\n\t\tconst fields = [];\n\n\t\tfor (let i = 0; i < nFields; i++) {\n\t\t\tfields.push([statement.getFieldName(i), statement.getFieldType(Site.dummy(), i)]);\n\t\t}\n\n\t\t// similar to Struct\n\t\tclass EnumVariant extends HeliosData {\n\t\t\t/**\n\t\t\t * So we can access fields by index\n\t\t\t * @type {HeliosData[]}\n\t\t\t */\n\t\t\t#fields;\n\n\t\t\t/**\n\t\t\t * @param  {...any} args\n\t\t\t */\n\t\t\tconstructor(...args) {\n\t\t\t\tsuper();\n\t\t\t\tif (args.length != nFields) {\n\t\t\t\t\tthrow new Error(`expected ${nFields} args, got ${args.length}`);\n\t\t\t\t}\n \n\t\t\t\tthis.#fields = [];\n \n\t\t\t\targs.forEach((arg, i) => {\n\t\t\t\t\tconst [fieldName, fieldType] = fields[i];\n\t\t\t\t\tconst FieldClass = fieldType.userType;\n \n\t\t\t\t\tconst instance = arg instanceof FieldClass ? arg : new FieldClass(arg);\n\n \t\t\t\t\tthis.#fields.push(instance);\n\t\t\t\t\tthis[fieldName] = instance;\n\n\t\t\t\t});\n\t\t\t}\n \n\t\t\t/**\n\t\t\t * Overload 'instanceof' operator\n\t\t\t * @param {any} other \n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tstatic [Symbol.hasInstance](other) {\n\t\t\t\treturn (other._enumVariantStatement === statement) && (other instanceof HeliosData);\n\t\t\t}\n \n\t\t\t/**\n\t\t\t * @type {EnumTypeStatement}\n\t\t\t */\n\t\t\tget _enumStatement() {\n\t\t\t\treturn enumStatement;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {EnumMemberTypeStatement}\n\t\t\t */\n\t\t\tget _enumVariantStatement() {\n\t\t\t\treturn statement;\n\t\t\t}\n \n\t\t\t/**\n\t\t\t * @returns {UplcData}\n\t\t\t */\n\t\t\t_toUplcData() {\n\t\t\t\treturn new ConstrData(index, this.#fields.map(f => f._toUplcData()));\n\t\t\t}\n \n\t\t\t/**\n\t\t\t * @param {string | number[]} bytes \n\t\t\t * @returns {EnumVariant}\n\t\t\t */\n\t\t\tstatic fromUplcCbor(bytes) {\n\t\t\t\treturn EnumVariant.fromUplcData(UplcData.fromCbor(bytes));\n\t\t\t}\n \n\t\t\t/**\n\t\t\t * @param {UplcData} data \n\t\t\t * @returns {EnumVariant}\n\t\t\t */\n\t\t\tstatic fromUplcData(data) {\n\t\t\t\tassert(data.index == index, \"wrong index\");\n\n\t\t\t\tconst dataItems = data.list;\n \n\t\t\t\tif (dataItems.length != nFields) {\n\t\t\t\t\tthrow new Error(\"unexpected number of fields\");\n\t\t\t\t}\n \n\t\t\t\tconst args = dataItems.map((item, i) => {\n\t\t\t\t\treturn fields[i][1].userType.fromUplcData(item);\n\t\t\t\t});\n \n\t\t\t\treturn new EnumVariant(...args);\n\t\t\t}\n\t\t}\n\n\t\tObject.defineProperty(EnumVariant, \"name\", {value: this.name, writable: false});\n\n\t\treturn EnumVariant;\n\t}\n}\n\n/**\n * @package\n */\nclass ArgType {\n\t#name;\n\t#type;\n\t#optional;\n\n\t/**\n\t * \n\t * @param {null | Word} name \n\t * @param {Type} type \n\t * @param {boolean} optional \n\t */\n\tconstructor(name, type, optional = false) {\n\t\tthis.#name = name;\n\t\tthis.#type = type;\n\t\tthis.#optional = optional;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\tif (this.#name === null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.#name.toString();\n\t\t}\n\t}\n\t/**\n\t * @type {Type}\n\t */\n\tget type() {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisNamed() {\n\t\treturn this.#name !== null;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisOptional() {\n\t\treturn this.#optional;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn [\n\t\t\tthis.#name != null ? `${this.#name.toString()}: ` : \"\",\n\t\t\tthis.#optional ? \"?\" : \"\",\n\t\t\tthis.#type.toString()\n\t\t].join(\"\");\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {ArgType} other \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, other) {\n\t\t// if this arg has a default value, the other arg must also have a default value\n\t\tif (this.#optional && !other.#optional) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if this is named, the other must be named as well\n\t\tif (this.#name != null) {\n\t\t\treturn this.#name.toString() == (other.#name?.toString() ?? \"\");\n\t\t}\n\n\t\tif (this.#type instanceof ParamType) {\n\t\t\tthis.#type.setType(site, other.#type);\n\t\t} else {\n\t\t\tif (!other.#type.isBaseOf(site, this.#type)) { // note the reversal of the check\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\n/**\n * Function type with arg types and a return type\n * @package\n */\nclass FuncType extends Type {\n\t/**\n\t * @type {ArgType[]}\n\t */\n\t#argTypes;\n\n\t/**\n\t * @type {Type[]}\n\t */\n\t#retTypes;\n\n\t/**\n\t * @param {Type[] | ArgType[]} argTypes \n\t * @param {Type | Type[]} retTypes \n\t */\n\tconstructor(argTypes, retTypes) {\n\t\tsuper();\n\t\tthis.#argTypes = argTypes.map(at => {\n\t\t\tif (at instanceof Type) {\n\t\t\t\treturn new ArgType(null, at);\n\t\t\t} else {\n\t\t\t\treturn at;\n\t\t\t}\n\t\t});\n\n\t\tif (!Array.isArray(retTypes)) {\n\t\t\tretTypes = [retTypes];\n\t\t}\n\n\t\tthis.#retTypes = retTypes;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget nArgs() {\n\t\treturn this.#argTypes.length;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget nNonOptArgs() {\n\t\treturn this.#argTypes.filter(at => !at.isOptional()).length;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget nOptArgs() {\n\t\treturn this.#argTypes.filter(at => at.isOptional()).length;\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget argTypes() {\n\t\treturn this.#argTypes.slice().map(at => at.type);\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget retTypes() {\n\t\treturn this.#retTypes;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tif (this.#retTypes.length === 1) {\n\t\t\treturn `(${this.#argTypes.map(a => a.toString()).join(\", \")}) -> ${this.#retTypes.toString()}`;\n\t\t} else {\n\t\t\treturn `(${this.#argTypes.map(a => a.toString()).join(\", \")}) -> (${this.#retTypes.map(t => t.toString()).join(\", \")})`;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the type of the first arg is the same as 'type'\n\t * Also returns false if there are no args.\n\t * For a method to be a valid instance member its first argument must also be named 'self', but that is checked elsewhere\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisMaybeMethod(site, type) {\n\t\tif (this.#argTypes.length > 0) {\n\t\t\treturn Type.same(site, this.#argTypes[0].type, type);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** \n\t * Checks if any of 'this' argTypes or retType is same as Type.\n\t * Only if this checks return true is the association allowed.\n\t * @param {Site} site\n\t * @param {Type} type\n\t * @returns {boolean}\n\t */\n\tisAssociated(site, type) {\n\t\tfor (let arg of this.#argTypes) {\n\t\t\tif (Type.same(site, arg.type, type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (let rt of this.#retTypes) {\n\t\t\tif (Type.same(site, type, rt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if 'this' is a base type of another FuncType.\n\t * The number of args needs to be the same.\n\t * Each argType of the FuncType we are checking against needs to be the same or less specific (i.e. isBaseOf(this.#argTypes[i]))\n\t * The retType of 'this' needs to be the same or more specific\n\t * @param {Site} site \n\t * @param {Type} other \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, other) {\n\t\tif (other instanceof FuncType) {\n\t\t\tif (this.nNonOptArgs != other.nNonOptArgs) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < this.nNonOptArgs; i++) {\n\t\t\t\t\tif (!this.#argTypes[i].isBaseOf(site, other.#argTypes[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.#retTypes.length === other.#retTypes.length) {\n\t\t\t\t\tfor (let i = 0; i < this.#retTypes.length; i++) {\n\t\t\t\t\t\tif (!this.#retTypes[i].isBaseOf(site, other.#retTypes[i])) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Throws an error if name isn't found\n\t * @param {Site} site \n\t * @param {string} name \n\t * @returns {number}\n\t */\n\tgetNamedIndex(site, name) {\n\t\tconst i = this.#argTypes.findIndex(at => at.name == name);\n\n\t\tif (i == -1) {\n\t\t\tthrow site.typeError(`arg name ${name} not found`);\n\t\t} else {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if arg types are valid.\n\t * Throws errors if not valid. Returns the return type if valid. \n\t * @param {Site} site \n\t * @param {Instance[]} posArgs\n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Type[]}\n\t */\n\tcheckCall(site, posArgs, namedArgs = {}) {\n\t\tif (posArgs.length < this.nNonOptArgs) {\n\t\t\t// check if each nonOptArg is covered by the named args\n\t\t\tfor (let i = 0; i < this.nNonOptArgs; i++) {\n\t\t\t\tif (!this.#argTypes[i].isNamed()) {\n\t\t\t\t\tthrow site.typeError(`expected at least ${this.#argTypes.filter(at => !at.isNamed()).length} positional arg(s), got ${posArgs.length} positional arg(s)`);\n\t\t\t\t} else {\n\t\t\t\t\tif (!(this.#argTypes[i].name in namedArgs)) {\n\t\t\t\t\t\tthrow site.typeError(`named arg ${this.#argTypes[i].name} missing from call`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (posArgs.length > this.#argTypes.length) {\n\t\t\tthrow site.typeError(`expected at most ${this.#argTypes.length} arg(s), got ${posArgs.length} arg(s)`);\n\t\t}\n\n\t\tfor (let i = 0; i < posArgs.length; i++) {\n\t\t\tif (!posArgs[i].isInstanceOf(site, this.#argTypes[i].type)) {\n\t\t\t\tthrow site.typeError(`expected '${this.#argTypes[i].type.toString()}' for arg ${i + 1}, got '${posArgs[i].toString()}'`);\n\t\t\t}\n\t\t}\n\n\t\tfor (let key in namedArgs) {\n\t\t\tconst i = this.#argTypes.findIndex(at => at.name == key);\n\n\t\t\tif (i == -1) {\n\t\t\t\tthrow site.typeError(`arg named ${key} not found in function type ${this.toString()}`);\n\t\t\t}\n\n\t\t\tif (i < posArgs.length) {\n\t\t\t\tthrow site.typeError(`named arg '${key}' already covered by positional arg ${i+1}`);\n\t\t\t}\n\n\t\t\tconst thisArg = this.#argTypes[i];\n\n\t\t\tif (!namedArgs[key].isInstanceOf(site, thisArg.type)) {\n\t\t\t\tthrow site.typeError(`expected '${thisArg.type.toString()}' for arg '${key}', got '${namedArgs[key].toString()}`);\n\t\t\t}\n\t\t}\n\n\t\treturn this.#retTypes;\n\t}\n}\n\nclass NotType extends EvalEntity {\n\tconstructor() {\n\t\tsuper();\n\t}\n\t\n\t/**\n\t * @returns {boolean}\n\t */\n\tisType() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Throws an error because NotType can't be a base-Type of anything.\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tthrow site.typeError(\"not a type\");\n\t}\n\n\t/**\n\t * @param {Word} name\n\t * @returns {EvalEntity} - can be Instance or Type\n\t */\n\tgetTypeMember(name) {\n\t\tthrow new Error(\"not a type\");\n\t}\n}\n\n/**\n * Base class for DataInstance and FuncInstance\n * @package\n */\nclass Instance extends NotType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Type | Type[]} type \n\t * @returns {Instance}\n\t */\n\tstatic new(type) {\n\t\tif (Array.isArray(type)) {\n\t\t\tif (type.length === 1) {\n\t\t\t\treturn Instance.new(type[0]);\n\t\t\t} else {\n\t\t\t\treturn new MultiInstance(type.map(t => Instance.new(t)));\n\t\t\t}\n\t\t} else if (type instanceof FuncType) {\n\t\t\treturn new FuncInstance(type);\n\t\t} else if (type instanceof ParamType) {\n\t\t\tconst t = type.type;\n\t\t\tif (t == null) {\n\t\t\t\tthrow new Error(\"expected non-null type\");\n\t\t\t} else {\n\t\t\t\treturn Instance.new(t);\n\t\t\t}\n\t\t} else if (type instanceof ErrorType) {\n\t\t\treturn new ErrorInstance();\n\t\t} else if (type instanceof VoidType) {\n\t\t\treturn new VoidInstance();\n\t\t} else {\n\t\t\treturn new DataInstance(type);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisValue() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {Instance}\n\t */\n\tassertValue(site) {\n\t\treturn this;\n\t}\n}\n\n\n/**\n * A regular non-Func Instance. DataValues can always be compared, serialized, used in containers.\n * @package\n */\nclass DataInstance extends Instance {\n\t#type;\n\n\t/**\n\t * @param {DataType} type \n\t */\n\tconstructor(type) {\n\t\tassert(!(type instanceof FuncType));\n\n\t\tsuper();\n\t\tthis.#type = type;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#type.toString();\n\t}\n\n\t/**\n\t * Gets the underlying Type.\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * @typedef {new(...any) => Type} TypeClass\n\t */\n\n\t/**\n\t * Checks if 'this' is instance of 'type'.\n\t * 'type' can be a class, or a class instance.\n\t * @param {Site} site \n\t * @param {Type | TypeClass} type \n\t * @returns \n\t */\n\tisInstanceOf(site, type) {\n\t\tif (typeof type == 'function') {\n\t\t\treturn this.#type instanceof type;\n\t\t} else {\n\t\t\treturn type.isBaseOf(site, this.#type);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of fields of a struct, enum member, or builtin type.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\treturn this.#type.nFields(site);\n\t}\n\n\t/**\n\t * Returns the i-th field of a Struct or an EnumMember\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\treturn this.#type.getFieldType(site, i);\n\t}\n\n\t/**\n\t * Returns the index of a named field\n\t * @param {Site} site \n\t * @param {string} name \n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\treturn this.#type.getFieldIndex(site, name);\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\treturn this.#type.getInstanceMember(name);\n\t}\n\n\t/**\n\t * Throws an error bec\n\t * @param {Site} site \n\t * @param {Instance[]} args \n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\tthrow site.typeError(\"not callable\");\n\t}\n}\n\n/**\n * @package\n */\nclass ConstStatementInstance extends DataInstance {\n\t#statement;\n\n\t/**\n\t * @param {DataType} type \n\t * @param {ConstTypeStatement} statement - can't use ConstStatement because that would give circular dependency\n\t */\n\tconstructor(type, statement) {\n\t\tsuper(type);\n\t\tthis.#statement = statement;\n\t}\n\n\t/**\n\t * @type {ConstTypeStatement}\n\t */\n\tget statement() {\n\t\treturn this.#statement\n\t}\n}\n\n/**\n * A callable Instance.\n * @package\n */\nclass FuncInstance extends Instance {\n\t#type;\n\n\t/**\n\t * @param {FuncType} type \n\t */\n\tconstructor(type) {\n\t\tassert(type instanceof FuncType);\n\n\t\tsuper();\n\t\tthis.#type = type;\n\t}\n\n\t/**\n\t * @param {RecursivenessChecker} scope\n\t * @returns {boolean}\n\t */\n\tisRecursive(scope) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a string representing the type.\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#type.toString();\n\t}\n\n\t/**\n\t * Returns the underlying FuncType as Type.\n\t * @param {Site} site\n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * Returns the underlying FuncType directly.\n\t * @returns {FuncType}\n\t */\n\tgetFuncType() {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * Checks if 'this' is an instance of 'type'.\n\t * Type can be a class or a class instance. \n\t * @param {Site} site \n\t * @param {Type | TypeClass} type \n\t * @returns {boolean}\n\t */\n\tisInstanceOf(site, type) {\n\t\tif (typeof type == 'function') {\n\t\t\treturn this.#type instanceof type;\n\t\t} else {\n\t\t\treturn type.isBaseOf(site, this.#type);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Instance[]} args \n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\treturn Instance.new(this.#type.checkCall(site, args, namedArgs));\n\t}\n\n\t/**\n\t * Throws an error because a function value doesn't have any fields.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\tthrow site.typeError(\"a function doesn't have fields\");\n\t}\n\n\t/**\n\t * Throws an error because a function value doesn't have any fields.\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tthrow site.typeError(\"a function doesn't have fields\");\n\t}\n\n\t/**\n\t * Throws an error because a function value have any fields.\n\t * @param {Site} site \n\t * @param {string} name \n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tthrow site.typeError(\"a function doesn't have fields\");\n\t}\n\n\t/**\n\t * Throws an error because a function value doesn't have members.\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tthrow name.typeError(\"a function doesn't have any members\");\n\t}\n}\n\n/**\n * Special function value class for top level functions because they can be used recursively.\n * @package\n */\nclass FuncStatementInstance extends FuncInstance {\n\t#statement\n\n\t/**\n\t * @param {FuncType} type \n\t * @param {RecurseableStatement} statement - can't use FuncStatement because that would give circular dependency\n\t */\n\tconstructor(type, statement) {\n\t\tsuper(type);\n\t\tthis.#statement = statement;\n\t}\n\n\t/**\n\t * @type {RecurseableStatement}\n\t */\n\tget statement() {\n\t\treturn this.#statement;\n\t}\n\n\t/**\n\t * @param {RecursivenessChecker} scope\n\t * @returns {boolean}\n\t */\n\tisRecursive(scope) {\n\t\tif (this.#statement.isRecursive()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn scope.isRecursive(this.#statement);\n\t\t}\n\t}\n}\n\n/**\n * Wraps multiple return values\n * @package\n */\nclass MultiInstance extends Instance {\n\t#values;\n\n\t/**\n\t * @param {Instance[]} values \n\t */\n\tconstructor(values) {\n\t\tsuper();\n\t\tthis.#values = values;\n\t}\n\n\tget values() {\n\t\treturn this.#values;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `(${this.#values.map(v => v.toString()).join(\", \")})`;\n\t}\n\n\t/**\n\t * @param {Instance[]} vals\n\t * @returns {Instance[]}\n\t */\n\tstatic flatten(vals) {\n\t\t/**\n\t\t * @type {Instance[]}\n\t\t */\n\t\tlet result = [];\n\n\t\tfor (let v of vals) {\n\t\t\tif (v instanceof MultiInstance) {\n\t\t\t\tresult = result.concat(v.values);\n\t\t\t} else {\n\t\t\t\tresult.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Returned by functions that don't return anything (eg. assert, error, print)\n * @package\n */\nclass VoidInstance extends Instance {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn \"()\"\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type | TypeClass} type \n\t * @returns {boolean}\n\t */\n\tisInstanceOf(site, type) {\n\t\treturn type instanceof VoidType;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\treturn new VoidType();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Instance[]} args\n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\tthrow new Error(\"can't call void\");\n\t}\n\n\t/**\n\t * @param {Word} name\n\t * @returns {Instance} - can be FuncInstance or DataInstance\n\t */\n\tgetInstanceMember(name) {\n\t\tthrow new Error(\"can't get member of void\");\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\tthrow new Error(\"can't get nFields of void\");\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tthrow new Error(\"can't get field-type of void\");\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {string} name\n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tthrow new Error(\"can't get field-type of void\");\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\tthrow new Error(\"can't get constr index of void\");\n\t}\n}\n\n/**\n * Returned by an error()\n * Special case of no-return-value that indicates that execution can't proceed.\n * @package\n */\nclass ErrorInstance extends VoidInstance {\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\t getType(site) {\n\t\treturn new ErrorType();\n\t}\n}\n\n/**\n * Parent-class for AssertFunc, ErrorFunc and PrintFunc\n * @package\n */\nclass BuiltinFuncInstance extends FuncInstance {\n\t/**\n\t * Returns the base path in the IR (eg. __helios__bool, __helios__error, etc.)\n\t * @type {string}\n\t */\n\tget path() {\n\t\tthrow new Error(\"not implemented\")\n\t}\n}\n\n/**\n * Special builtin function that throws an error if condition is false and returns Void\n * @package\n */\n class AssertFunc extends BuiltinFuncInstance {\n\tconstructor() {\n\t\tsuper(new FuncType([new BoolType(), new StringType()], new VoidType()));\n\t}\n\n\tget path() {\n\t\treturn \"__helios__assert\";\n\t}\n}\n\n/**\n * Special builtin function that throws an error and returns ErrorInstance (special case of Void)\n * @package\n */\n class ErrorFunc extends BuiltinFuncInstance {\n\tconstructor() {\n\t\tsuper(new FuncType([new StringType()], new ErrorType()));\n\t}\n\n\tget path() {\n\t\treturn \"__helios__error\";\n\t}\n}\n\n/**\n * Special builtin function that prints a message and returns void\n * @package\n */\nclass PrintFunc extends BuiltinFuncInstance {\n\tconstructor() {\n\t\tsuper(new FuncType([new StringType()], new VoidType()));\n\t}\n\n\tget path() {\n\t\treturn \"__helios__print\";\n\t}\n}\n\n/**\n * Type of return-value of functions that don't return anything (eg. assert, print, error)\n * @package\n */\nclass VoidType extends Type {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\ttoString() {\n\t\treturn \"()\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\treturn type instanceof VoidType;\n\t}\n}\n\n/**\n * Type of special case of no-return value where execution can't continue.\n * @package\n */\nclass ErrorType extends VoidType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\treturn type instanceof ErrorType;\n\t}\n}\n\n/**\n * Builtin Int type\n * @package\n */\nclass IntType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\ttoString() {\n\t\treturn \"Int\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__neg\":\n\t\t\tcase \"__pos\":\n\t\t\t\treturn Instance.new(new FuncType([this], new IntType()));\n\t\t\tcase \"__add\":\n\t\t\tcase \"__sub\":\n\t\t\tcase \"__mul\":\n\t\t\tcase \"__div\":\n\t\t\tcase \"__mod\":\n\t\t\t\treturn Instance.new(new FuncType([this, new IntType()], new IntType()));\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new IntType()], new BoolType()));\n\t\t\tcase \"from_big_endian\":\n\t\t\tcase \"from_little_endian\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType()], new IntType()));\n\t\t\tcase \"max\":\n\t\t\tcase \"min\": \n\t\t\t\treturn Instance.new(new FuncType([new IntType(), new IntType()], new IntType()));\n\t\t\tcase \"from_base58\":\n\t\t\tcase \"parse\":\n\t\t\t\treturn Instance.new(new FuncType([new StringType()], new IntType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"decode_zigzag\":\n\t\t\tcase \"encode_zigzag\":\n\t\t\tcase \"abs\":\n\t\t\t\treturn Instance.new(new FuncType([], new IntType()));\n\t\t\tcase \"bound\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType(), new IntType()], new IntType()));\n\t\t\tcase \"bound_min\":\n\t\t\tcase \"bound_max\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], new IntType()));\n\t\t\tcase \"to_bool\":\n\t\t\t\treturn Instance.new(new FuncType([], new BoolType()));\n\t\t\tcase \"to_big_endian\":\n\t\t\tcase \"to_little_endian\":\n\t\t\t\treturn Instance.new(new FuncType([], new ByteArrayType()));\n\t\t\tcase \"to_base58\":\n\t\t\tcase \"to_hex\":\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__int\";\n\t}\n\n\tget userType() {\n\t\treturn HInt;\n\t}\n}\n\n/**\n * Builtin bool type\n * @package\n */\nclass BoolType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn \"Bool\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__not\":\n\t\t\t\treturn Instance.new(new FuncType([this], new BoolType()));\n\t\t\tcase \"__and\":\n\t\t\tcase \"__or\":\n\t\t\t\treturn Instance.new(new FuncType([this, new BoolType()], new BoolType()));\n\t\t\tcase \"and\":\n\t\t\tcase \"or\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([], new BoolType()), new FuncType([], new BoolType())], new BoolType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"to_int\":\n\t\t\t\treturn Instance.new(new FuncType([], new IntType()));\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tcase \"trace\":\n\t\t\t\treturn Instance.new(new FuncType([new StringType()], new BoolType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__bool\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn Bool;\n\t}\n}\n\n/**\n * Builtin string type\n * @package\n */\nclass StringType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\ttoString() {\n\t\treturn \"String\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\t\treturn Instance.new(new FuncType([this, new StringType()], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"starts_with\":\n\t\t\tcase \"ends_with\":\n\t\t\t\treturn Instance.new(new FuncType([new StringType()], new BoolType()));\n\t\t\tcase \"encode_utf8\":\n\t\t\t\treturn Instance.new(new FuncType([], new ByteArrayType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__string\";\n\t}\n\n\t/**\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn HString;\n\t}\n}\n\n/**\n * Builtin bytearray type\n * @package\n */\nclass ByteArrayType extends BuiltinType {\n\t#size;\n\n\t/**\n\t * @param {?number} size - can be null or 32 (result of hashing)\n\t */\n\tconstructor(size = null) {\n\t\tsuper();\n\n\t\tthis.#size = size;\n\t}\n\n\ttoString() {\n\t\treturn \"ByteArray\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\t\treturn Instance.new(new FuncType([this, new ByteArrayType()], new ByteArrayType()));\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new ByteArrayType()], new BoolType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"length\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tcase \"slice\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType(), new IntType()], new ByteArrayType()));\n\t\t\tcase \"starts_with\":\n\t\t\tcase \"ends_with\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType()], new BoolType()));\n\t\t\tcase \"prepend\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], new ByteArrayType()));\n\t\t\tcase \"sha2\":\n\t\t\tcase \"sha3\":\n\t\t\tcase \"blake2b\":\n\t\t\t\treturn Instance.new(new FuncType([], new ByteArrayType(32)));\n\t\t\tcase \"decode_utf8\":\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn `__helios__bytearray${this.#size === null ? \"\" : this.#size}`;\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn ByteArray;\n\t}\n}\n\n\nclass ParamType extends Type {\n\t/** @type {?Type} */\n\t#type;\n\n\t/** @type {string} */\n\t#name;\n\n\t#checkType;\n\n\t/**\n\t * @param {string} name - typically \"a\" or \"b\"\n\t * @param {?(site: Site, type: Type) => void} checkType\n\t */\n\tconstructor(name, checkType = null) {\n\t\tsuper();\n\t\tthis.#type = null;\n\t\tthis.#name = name;\n\t\tthis.#checkType = checkType;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisInferred() {\n\t\treturn this.#type !== null;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {Type} type \n\t */\n\tsetType(site, type) {\n\t\tif (this.#checkType !== null) {\n\t\t\tthis.#checkType(site, type);\n\t\t}\n\n\t\tthis.#type = type;\n\t}\n\n\t/**\n\t * @param {Type} type \n\t * @param {?Type} expected\n\t * @returns {Type}\n\t */\n\tstatic unwrap(type, expected = null) {\n\t\tif (type instanceof AnyType) {\n\t\t\tif (expected !== null) {\n\t\t\t\treturn expected;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unable to infer type of AnyType\");\n\t\t\t}\n\t\t} else if (type instanceof ParamType) {\n\t\t\tlet origType = type.type;\n\n\t\t\tif (origType === null) {\n\t\t\t\tif (expected !== null) {\n\t\t\t\t\ttype.setType(Site.dummy(), expected);\n\t\t\t\t\treturn expected;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"unable to infer ParamType\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn origType;\n\t\t\t}\n\t\t} else {\n\t\t\treturn type;\n\t\t}\n\t}\n\n\t/**\n\t * @type {?Type}\n\t */\n\tget type() {\n\t\tif (this.#type instanceof ParamType) {\n\t\t\treturn this.#type.type;\n\t\t} else {\n\t\t\treturn this.#type;\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.#type === null) {\n\t\t\treturn this.#name;\n\t\t} else {\n\t\t\treturn this.#type.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Returns number of members of an enum type\n\t * Throws an error if not an enum type\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"param type not yet infered\");\n\t\t} else {\n\t\t\treturn this.#type.nEnumMembers(site);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of fields of a struct, enum member, or builtin type.\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"should've been set\");\n\t\t} else {\n\t\t\treturn this.#type.nFields(site);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the i-th field of a Struct or an EnumMember\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"should've been set\");\n\t\t} else {\n\t\t\treturn this.#type.getFieldType(site, i);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the i-th field of a Struct or an EnumMember\n\t * @param {Site} site\n\t * @param {string} name\n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"should've been set\");\n\t\t} else {\n\t\t\treturn this.#type.getFieldIndex(site, name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"should've been set\");\n\t\t} else {\n\t\t\treturn this.#type.getInstanceMember(name);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns 'true' if 'this' is a base-type of 'type'. Throws an error if 'this' isn't a Type.\n\t * @param {Site} site\n\t * @param {Type} type\n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tif (this.#type === null) {\n\t\t\tthis.setType(site, type);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn this.#type.isBaseOf(site, type);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the base path of type (eg. __helios__bool).\n\t * This is used extensively in the Intermediate Representation.\n\t * @type {string}\n\t */\n\tget path() {\n\t\tif (this.#type === null) {\n\t\t\tthrow new Error(\"param type not yet infered\");\n\t\t} else {\n\t\t\treturn this.#type.path;\n\t\t}\n\t}\n}\n\n/**\n * @package\n */\nclass ParamFuncValue extends FuncInstance {\n\t#params;\n\t#fnType;\n\t#correctMemberName;\n\n\t/**\n\t * @param {ParamType[]} params\n\t * @param {FuncType} fnType \n\t * @param {?() => string} correctMemberName\n\t */\n\tconstructor(params, fnType, correctMemberName = null) {\n\t\tsuper(fnType);\n\t\tthis.#params = params;\n\t\tthis.#fnType = fnType;\n\t\tthis.#correctMemberName = correctMemberName;\n\t}\n\n\tget correctMemberName() {\n\t\treturn this.#correctMemberName;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tallInferred() {\n\t\treturn this.#params.every(p => p.isInferred());\n\t}\n\n\ttoString() {\n\t\treturn this.#fnType.toString();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tgetType(site) {\n\t\tif (this.allInferred()) {\n\t\t\treturn this.#fnType;\n\t\t} else {\n\t\t\tthrow site.typeError(\"can't get type of type parametric function\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisInstanceOf(site, type) {\n\t\tif (this.allInferred()) {\n\t\t\treturn (new FuncInstance(this.#fnType)).isInstanceOf(site, type);\n\t\t} else {\n\t\t\tthrow site.typeError(\"can't determine if type parametric function is instanceof a type\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Instance[]} args\n\t * @param {{[name: string]: Instance}} namedArgs\n\t * @returns {Instance}\n\t */\n\tcall(site, args, namedArgs = {}) {\n\t\treturn (new FuncInstance(this.#fnType)).call(site, args, namedArgs);\n\t}\n}\n\n/**\n * Builtin list type\n * @package\n */\nclass ListType extends BuiltinType {\n\t#itemType;\n\n\t/**\n\t * @param {Type} itemType \n\t */\n\tconstructor(itemType) {\n\t\tsuper();\n\t\tthis.#itemType = itemType;\n\t}\n\n\t/**\n\t * @package\n\t * @type {Type}\n\t */\n\tget itemType() {\n\t\treturn this.#itemType;\n\t}\n\n\ttoString() {\n\t\treturn `[]${this.#itemType.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof ListType) {\n\t\t\treturn this.#itemType.isBaseOf(site, type.itemType);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\t\treturn Instance.new(new FuncType([this, this], this));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType(), new FuncType([new IntType()], this.#itemType)], this));\n\t\t\tcase \"new_const\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType(), this.#itemType], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"length\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tcase \"head\":\n\t\t\t\treturn Instance.new(this.#itemType);\n\t\t\tcase \"tail\":\n\t\t\t\treturn Instance.new(new ListType(this.#itemType));\n\t\t\tcase \"is_empty\":\n\t\t\t\treturn Instance.new(new FuncType([], new BoolType()));\n\t\t\tcase \"get\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], this.#itemType));\n\t\t\tcase \"prepend\":\n\t\t\t\treturn Instance.new(new FuncType([this.#itemType], new ListType(this.#itemType)));\n\t\t\tcase \"any\":\n\t\t\tcase \"all\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType], new BoolType())], new BoolType()));\n\t\t\tcase \"find\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType], new BoolType())], this.#itemType));\n\t\t\tcase \"find_safe\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType], new BoolType())], new OptionType(this.#itemType)));\n\t\t\tcase \"filter\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType], new BoolType())], new ListType(this.#itemType)));\n\t\t\tcase \"for_each\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType], new VoidType())], new VoidType()));\n\t\t\tcase \"fold\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([a, this.#itemType], a), a], a));\n\t\t\t}\n\t\t\tcase \"fold_lazy\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([this.#itemType, new FuncType([], a)], a), a], a));\n\t\t\t}\n\t\t\tcase \"map\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([this.#itemType], a)], new ListType(a)), () => {\n\t\t\t\t\tlet type = a.type;\n\t\t\t\t\tif (type === null) {\n\t\t\t\t\t\tthrow new Error(\"should've been inferred by now\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((new BoolType()).isBaseOf(Site.dummy(), type)) {\n\t\t\t\t\t\t\treturn \"map_to_bool\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn \"map\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcase \"get_singleton\":\n\t\t\t\treturn Instance.new(new FuncType([], this.#itemType));\n\t\t\tcase \"sort\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#itemType, this.#itemType], new BoolType())], new ListType(this.#itemType)));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn `__helios__${this.#itemType instanceof BoolType ? \"bool\" : \"\"}list`;\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn HList(this.#itemType.userType);\n\t}\n}\n\n/**\n * Builtin map type (in reality list of key-value pairs)\n * @package\n */\nclass MapType extends BuiltinType {\n\t#keyType;\n\t#valueType;\n\n\t/**\n\t * @param {Type} keyType \n\t * @param {Type} valueType \n\t */\n\tconstructor(keyType, valueType) {\n\t\tsuper();\n\t\tthis.#keyType = keyType;\n\t\tthis.#valueType = valueType;\n\t}\n\n\t/**\n\t * @package\n\t * @type {Type}\n\t */\n\tget keyType() {\n\t\treturn this.#keyType;\n\t}\n\n\t/**\n\t * @package\n\t * @type {Type}\n\t */\n\tget valueType() {\n\t\treturn this.#valueType;\n\t}\n\n\ttoString() {\n\t\treturn `Map[${this.#keyType.toString()}]${this.#valueType.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof MapType) {\n\t\t\treturn this.#keyType.isBaseOf(site, type.#keyType) && this.#valueType.isBaseOf(site, type.#valueType);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\t\treturn Instance.new(new FuncType([this, this], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"all\":\n\t\t\tcase \"any\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType], new BoolType())], new BoolType()));\n\t\t\tcase \"delete\":\n\t\t\t\treturn Instance.new(new FuncType([this.#keyType], this));\n\t\t\tcase \"filter\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType], new BoolType())], this));\n\t\t\tcase \"find\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType], new BoolType())], [this.#keyType, this.#valueType]));\n\t\t\tcase \"find_safe\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType], new BoolType())], [new FuncType([], [this.#keyType, this.#valueType]), new BoolType()]))\n\t\t\tcase \"find_key\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType], new BoolType())], this.#keyType));\n\t\t\tcase \"find_key_safe\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType], new BoolType())], new OptionType(this.#keyType)));\n\t\t\tcase \"find_value\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#valueType], new BoolType())], this.#valueType));\n\t\t\tcase \"find_value_safe\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#valueType], new BoolType())], new OptionType(this.#valueType)));\n\t\t\tcase \"fold\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([a, this.#keyType, this.#valueType], a), a], a));\n\t\t\t}\n\t\t\tcase \"fold_lazy\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([this.#keyType, this.#valueType, new FuncType([], a)], a), a], a));\n\t\t\t}\n\t\t\tcase \"for_each\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType], new VoidType())], new VoidType()));\n\t\t\tcase \"get\":\n\t\t\t\treturn Instance.new(new FuncType([this.#keyType], this.#valueType));\n\t\t\tcase \"get_safe\":\n\t\t\t\treturn Instance.new(new FuncType([this.#keyType], new OptionType(this.#valueType)));\n\t\t\tcase \"head\":\n\t\t\t\treturn Instance.new(new FuncType([], [this.#keyType, this.#valueType]));\n\t\t\tcase \"head_key\":\n\t\t\t\treturn Instance.new(this.#keyType);\n\t\t\tcase \"head_value\":\n\t\t\t\treturn Instance.new(this.#valueType);\n\t\t\tcase \"is_empty\":\n\t\t\t\treturn Instance.new(new FuncType([], new BoolType()));\n\t\t\tcase \"length\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tcase \"map\": {\n\t\t\t\tlet a = new ParamType(\"a\", (site, type) => {\n\t\t\t\t\tif ((new BoolType()).isBaseOf(site, type)) {\n\t\t\t\t\t\tthrow site.typeError(\"Map keys can't be of 'Bool' type\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tlet b = new ParamType(\"b\");\n\n\t\t\t\treturn new ParamFuncValue([a, b], new FuncType([new FuncType([this.#keyType, this.#valueType], [a, b])], new MapType(a, b)), () => {\n\t\t\t\t\tlet type = b.type;\n\t\t\t\t\tif (type === null) {\n\t\t\t\t\t\tthrow new Error(\"should've been inferred by now\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((new BoolType()).isBaseOf(Site.dummy(), type)) {\n\t\t\t\t\t\t\treturn \"map_to_bool\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn \"map\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcase \"prepend\":\n\t\t\t\treturn Instance.new(new FuncType([this.#keyType, this.#valueType], this));\n\t\t\tcase \"set\":\n\t\t\t\treturn Instance.new(new FuncType([this.#keyType, this.#valueType], this));\n\t\t\tcase \"sort\":\n\t\t\t\treturn Instance.new(new FuncType([new FuncType([this.#keyType, this.#valueType, this.#keyType, this.#valueType], new BoolType())], new MapType(this.#keyType, this.#valueType)));\n\t\t\tcase \"tail\":\n\t\t\t\treturn Instance.new(this);\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn `__helios__${this.#valueType instanceof BoolType ? \"bool\" : \"\"}map`;\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn HMap(this.#keyType.userType, this.#valueType.userType);\n\t}\n}\n\n/**\n * Builtin option type\n * @package\n */\nclass OptionType extends BuiltinType {\n\t#someType;\n\n\t/**\n\t * @param {Type} someType \n\t */\n\tconstructor(someType) {\n\t\tsuper();\n\t\tthis.#someType = someType;\n\t}\n\n\ttoString() {\n\t\treturn `Option[${this.#someType.toString()}]`;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 2;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof OptionType) {\n\t\t\treturn this.#someType.isBaseOf(site, type.#someType);\n\t\t} else {\n\t\t\treturn (new OptionSomeType(this.#someType)).isBaseOf(site, type) || \n\t\t\t\t(new OptionNoneType(this.#someType)).isBaseOf(site, type);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"Some\":\n\t\t\t\treturn new OptionSomeType(this.#someType);\n\t\t\tcase \"None\":\n\t\t\t\treturn new OptionNoneType(this.#someType);\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"map\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([new FuncType([this.#someType], a)], new OptionType(a)), () => {\n\t\t\t\t\tlet type = a.type;\n\t\t\t\t\tif (type === null) {\n\t\t\t\t\t\tthrow new Error(\"should've been inferred by now\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((new BoolType()).isBaseOf(Site.dummy(), type)) {\n\t\t\t\t\t\t\treturn \"map_to_bool\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn \"map\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcase \"unwrap\":\n\t\t\t\treturn Instance.new(new FuncType([], this.#someType));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn `__helios__${this.#someType instanceof BoolType ? \"bool\" : \"\"}option`;\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn Option(this.#someType.userType);\n\t}\n}\n\n/**\n * Member type of OptionType with some content\n */\nclass OptionSomeType extends BuiltinEnumMember {\n\t#someType;\n\n\t/**\n\t * @param {Type} someType \n\t */\n\tconstructor(someType) {\n\t\tsuper(new OptionType(someType));\n\t\tthis.#someType = someType;\n\t}\n\n\ttoString() {\n\t\treturn `Option[${this.#someType.toString()}]::Some`;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof OptionSomeType) {\n\t\t\treturn this.#someType.isBaseOf(site, type.#someType);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tassert(i == 0);\n\t\treturn this.#someType;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {string} name\n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tassert(name == \"some\");\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"some\":\n\t\t\t\treturn Instance.new(this.#someType);\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn `__helios__${this.#someType instanceof BoolType ? \"bool\" : \"\"}option__some`;\n\t}\n}\n\n/**\n * Member type of OptionType with no content\n * @package\n */\nclass OptionNoneType extends BuiltinEnumMember {\n\t#someType;\n\n\t/**\n\t * @param {Type} someType \n\t */\n\tconstructor(someType) {\n\t\tsuper(new OptionType(someType));\n\t\tthis.#someType = someType;\n\t}\n\n\ttoString() {\n\t\treturn `Option[${this.#someType.toString()}]::None`;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\ttype = ParamType.unwrap(type, this);\n\n\t\tif (type instanceof OptionNoneType) {\n\t\t\treturn this.#someType.isBaseOf(site, type.#someType);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn `__helios__${this.#someType instanceof BoolType ? \"bool\" : \"\"}option__none`;\n\t}\n\n\t/**\n\t * Instantiates self as value\n\t * @param {Site} site\n\t * @returns {Instance}\n\t */\n\tassertValue(site) {\n\t\treturn Instance.new(this);\n\t}\n}\n\n/**\n * Base type of other ValidatorHash etc. (all functionality is actually implemented here)\n * @package\n */\nclass HashType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, this], new BoolType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType()], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__hash\";\n\t}\n}\n\n/**\n * Builtin PubKeyHash type\n * @package\n */\nclass PubKeyHashType extends HashType {\n\ttoString() {\n\t\treturn \"PubKeyHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn PubKeyHash;\n\t}\n}\n\n/**\n * Builtin StakeKeyHash type\n * @package\n */\nclass StakeKeyHashType extends HashType {\n\ttoString() {\n\t\treturn \"StakeKeyHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn StakeKeyHash;\n\t}\n}\n\n/**\n * Builtin PubKey type\n * @package\n */\nclass PubKeyType extends BuiltinType {\n\ttoString() {\n\t\treturn \"PubKey\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType()], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name\n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tcase \"verify\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType(), new ByteArrayType()], new BoolType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__pubkey\";\n\t}\n}\n\n/**\n * Generalization of ValidatorHash type and MintingPolicyHash type\n * Must be cast before being able to use the Hash type methods\n * @package\n */\nclass ScriptHashType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptHash\";\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scripthash\";\n\t}\n}\n\n/**\n * Builtin ValidatorHash type\n * @package\n */\nclass ValidatorHashType extends HashType {\n\t#purpose;\n\n\t/**\n\t * @param {number} purpose \n\t */\n\tconstructor(purpose = -1) {\n\t\tsuper();\n\t\tthis.#purpose = purpose;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"CURRENT\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Spending || this.#purpose == ScriptPurpose.Testing) {\n\t\t\t\t\t\treturn Instance.new(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ValidatorHash::CURRENT' only available in spending script\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'ValidatorHash::CURRENT' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tcase \"from_script_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new ScriptHashType()], new ValidatorHashType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"ValidatorHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn ValidatorHash;\n\t}\n}\n\n/**\n * Builtin MintingPolicyHash type\n * @package\n */\nclass MintingPolicyHashType extends HashType {\n\t#purpose;\n\n\t/**\n\t * @param {number} purpose \n\t */\n\tconstructor(purpose = -1) {\n\t\tsuper();\n\t\tthis.#purpose = purpose;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"CURRENT\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Minting) {\n\t\t\t\t\t\treturn Instance.new(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'MintingPolicyHash::CURRENT' only available in minting script\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'MintingPolicyHash::CURRENT' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tcase \"from_script_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new ScriptHashType()], new MintingPolicyHashType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"MintingPolicyHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn MintingPolicyHash;\n\t}\n}\n\n/**\n * Builtin StakingValidatorHash type\n * @package\n */\nclass StakingValidatorHashType extends HashType {\n\t#purpose;\n\n\t/**\n\t * @param {number} purpose \n\t */\n\tconstructor(purpose = -1) {\n\t\tsuper();\n\t\tthis.#purpose = purpose;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"CURRENT\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\t\treturn Instance.new(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'StakingValidatorHash::CURRENT' only available in minting script\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'StakingValidatorHash::CURRENT' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tcase \"from_script_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new ScriptHashType()], new StakingValidatorHashType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"StakingValidatorHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn StakingValidatorHash;\n\t}\n}\n\n/**\n * Builtin DatumHash type\n * @package\n */\nclass DatumHashType extends HashType {\n\ttoString() {\n\t\treturn \"DatumHash\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn DatumHash;\n\t}\n}\n\n/**\n * Builtin ScriptContext type\n * @package\n */\nclass ScriptContextType extends BuiltinType {\n\t#purpose;\n\n\t/**\n\t * @param {number} purpose \n\t */\n\tconstructor(purpose) {\n\t\tsuper();\n\t\tthis.#purpose = purpose;\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptContext\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new_spending\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Spending || this.#purpose == ScriptPurpose.Testing) {\n\t\t\t\t\t\treturn Instance.new(new FuncType([new TxType(), new TxOutputIdType()], this));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_spending' only avaiable for spending\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Staking || this.#purpose == ScriptPurpose.Minting) {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_spending' only avaiable for spending  scripts\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_spending' can only be used after 'main'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"new_minting\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Testing) {\n\t\t\t\t\t\treturn Instance.new(new FuncType([new TxType(), new MintingPolicyHashType()], this));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_minting' only avaiable for minting scripts\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Staking || this.#purpose == ScriptPurpose.Spending) {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_minting' only avaiable for minting scripts\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_minting' can only be used after 'main'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"new_rewarding\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Staking || this.#purpose == ScriptPurpose.Testing) {\n\t\t\t\t\t\treturn Instance.new(new FuncType([new TxType(), new StakingCredentialType()], this));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_rewarding' only avaiable for staking scripts\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Spending || this.#purpose == ScriptPurpose.Minting) {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_rewarding' only avaiable for staking scripts\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_rewarding' can only be used after 'main'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"new_certifying\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Staking || this.#purpose == ScriptPurpose.Testing) {\n\t\t\t\t\t\treturn Instance.new(new FuncType([new TxType(), new DCertType()], this));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_certifying' only avaiable for staking scripts\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.#purpose == ScriptPurpose.Spending || this.#purpose == ScriptPurpose.Minting) {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_certifying' only avaiable for staking scripts\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow name.referenceError(\"'ScriptContext::new_certifying' can only be used after 'main'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"tx\":\n\t\t\t\treturn Instance.new(new TxType());\n\t\t\tcase \"get_spending_purpose_output_id\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\tthrow name.referenceError(\"not available in minting/staking script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new TxOutputIdType()));\n\t\t\t\t}\n\t\t\tcase \"get_current_validator_hash\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\tthrow name.referenceError(\"not available in minting/staking script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new ValidatorHashType(this.#purpose)));\n\t\t\t\t}\n\t\t\tcase \"get_current_minting_policy_hash\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Spending || this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\tthrow name.referenceError(\"not available in spending/staking script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new MintingPolicyHashType(this.#purpose)));\n\t\t\t\t}\n\t\t\tcase \"get_current_input\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\tthrow name.referenceError(\"not available in minting/staking script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new TxInputType()));\n\t\t\t\t}\n\t\t\tcase \"get_cont_outputs\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Staking) {\n\t\t\t\t\tthrow name.referenceError(\"not available in minting/staking script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new ListType(new TxOutputType())));\n\t\t\t\t}\n\t\t\tcase \"get_staking_purpose\":\n\t\t\t\tif (this.#purpose == ScriptPurpose.Minting || this.#purpose == ScriptPurpose.Spending) {\n\t\t\t\t\tthrow name.referenceError(\"not available in minting/spending script\");\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(new FuncType([], new StakingPurposeType()));\n\t\t\t\t}\n\t\t\tcase \"get_script_purpose\":\n\t\t\t\treturn Instance.new(new FuncType([], new ScriptPurposeType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptcontext\";\n\t}\n}\n\n/**\n * Builtin ScriptPurpose type (Minting| Spending| Rewarding | Certifying)\n * @package\n */\nclass ScriptPurposeType extends BuiltinType {\n\ttoString() {\n\t\treturn \"ScriptPurpose\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new MintingScriptPurposeType()).isBaseOf(site, type) || \n\t\t\t\t(new SpendingScriptPurposeType()).isBaseOf(site, type) || \n\t\t\t\t(new RewardingScriptPurposeType()).isBaseOf(site, type) || \n\t\t\t\t(new CertifyingScriptPurposeType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new_minting\":\n\t\t\t\treturn Instance.new(new FuncType([new MintingPolicyHashType()], new MintingScriptPurposeType()));\n\t\t\tcase \"new_spending\":\n\t\t\t\treturn Instance.new(new FuncType([new TxOutputIdType()], new SpendingScriptPurposeType()));\n\t\t\tcase \"new_rewarding\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingCredentialType()], new RewardingScriptPurposeType()));\n\t\t\tcase \"new_certifying\":\n\t\t\t\treturn Instance.new(new FuncType([new DCertType()], new CertifyingScriptPurposeType()));\n\t\t\tcase \"Minting\":\n\t\t\t\treturn new MintingScriptPurposeType();\n\t\t\tcase \"Spending\":\n\t\t\t\treturn new SpendingScriptPurposeType();\n\t\t\tcase \"Rewarding\":\n\t\t\t\treturn new RewardingScriptPurposeType();\n\t\t\tcase \"Certifying\":\n\t\t\t\treturn new CertifyingScriptPurposeType();\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 4;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptpurpose\";\n\t}\n}\n\n/**\n * Builtin ScriptPurpose::Minting\n */\nclass MintingScriptPurposeType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new ScriptPurposeType());\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptPurpose::Minting\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"policy_hash\":\n\t\t\t\treturn Instance.new(new MintingPolicyHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptpurpose__minting\";\n\t}\n}\n\n/**\n * Builtin ScriptPurpose::Spending\n */\nclass SpendingScriptPurposeType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new ScriptPurposeType());\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptPurpose::Spending\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"output_id\":\n\t\t\t\treturn Instance.new(new TxOutputIdType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptpurpose__spending\";\n\t}\n}\n\n/**\n * Builtin ScriptPurpose::Rewarding\n */\nclass RewardingScriptPurposeType extends BuiltinEnumMember {\n\t/**\n\t * @param {?BuiltinType} parentType \n\t */\n\tconstructor(parentType = null) {\n\t\tsuper(parentType === null ? new ScriptPurposeType() : parentType);\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptPurpose::Rewarding\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"credential\":\n\t\t\t\treturn Instance.new(new StakingCredentialType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptpurpose__rewarding\";\n\t}\n}\n\n/**\n * Builtin ScriptPurpose::Certifying type\n */\nclass CertifyingScriptPurposeType extends BuiltinEnumMember {\n\t/**\n\t * @param {?BuiltinType} parentType\n\t */\n\tconstructor(parentType = null) {\n\t\tsuper(parentType === null ? new ScriptPurposeType() : parentType);\n\t}\n\n\ttoString() {\n\t\treturn \"ScriptPurpose::Certifying\";\n\t}\n\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"dcert\":\n\t\t\t\treturn Instance.new(new DCertType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 3;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__scriptpurpose__certifying\";\n\t}\n}\n\n/**\n * Builtin StakingPurpose type (Rewarding or Certifying)\n * @package\n */\nclass StakingPurposeType extends BuiltinType {\n\ttoString() {\n\t\treturn \"StakingPurpose\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new StakingRewardingPurposeType()).isBaseOf(site, type) || \n\t\t\t\t(new StakingCertifyingPurposeType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"Rewarding\":\n\t\t\t\treturn new StakingRewardingPurposeType();\n\t\t\tcase \"Certifying\":\n\t\t\t\treturn new StakingCertifyingPurposeType();\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingpurpose\";\n\t}\n}\n\n/**\n * Builtin StakingPurpose::Rewarding\n */\nclass StakingRewardingPurposeType extends RewardingScriptPurposeType {\n\tconstructor() {\n\t\tsuper(new StakingPurposeType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingPurpose::Rewarding\";\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingpurpose__rewarding\";\n\t}\n}\n\n/**\n * Builtin StakingPurpose::Certifying type\n */\nclass StakingCertifyingPurposeType extends CertifyingScriptPurposeType {\n\tconstructor() {\n\t\tsuper(new StakingPurposeType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingPurpose::Certifying\";\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingpurpose__certifying\";\n\t}\n}\n\n/**\n * Staking action type (confusingly named D(igest)(of)?Cert(ificate))\n * TODO: think of better name\n * @package\n */\nclass DCertType extends BuiltinType {\n\ttoString() {\n\t\treturn \"DCert\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new RegisterDCertType()).isBaseOf(site, type) || \n\t\t\t\t(new DeregisterDCertType()).isBaseOf(site, type) || \n\t\t\t\t(new DelegateDCertType()).isBaseOf(site, type) || \n\t\t\t\t(new RegisterPoolDCertType()).isBaseOf(site, type) ||\n\t\t\t\t(new RetirePoolDCertType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new_register\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingCredentialType()], new RegisterDCertType()));\n\t\t\tcase \"new_deregister\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingCredentialType()], new DeregisterDCertType()));\n\t\t\tcase \"new_delegate\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingCredentialType(), new PubKeyHashType()], new DelegateDCertType()));\n\t\t\tcase \"new_register_pool\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType(), new PubKeyHashType()], new RegisterPoolDCertType()));\n\t\t\tcase \"new_retire_pool\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType(), new IntType()], new RetirePoolDCertType()));\n\t\t\tcase \"Register\":\n\t\t\t\treturn new RegisterDCertType();\n\t\t\tcase \"Deregister\":\n\t\t\t\treturn new DeregisterDCertType();\n\t\t\tcase \"Delegate\":\n\t\t\t\treturn new DelegateDCertType();\n\t\t\tcase \"RegisterPool\":\n\t\t\t\treturn new RegisterPoolDCertType();\n\t\t\tcase \"RetirePool\":\n\t\t\t\treturn new RetirePoolDCertType();\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 5;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert\";\n\t}\n}\n\nclass RegisterDCertType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new DCertType());\n\t}\n\n\ttoString() {\n\t\treturn \"DCert::Register\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"credential\":\n\t\t\t\treturn Instance.new(new StakingCredentialType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert__register\";\n\t}\n}\n\nclass DeregisterDCertType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new DCertType());\n\t}\n\n\ttoString() {\n\t\treturn \"DCert::Deregister\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"credential\":\n\t\t\t\treturn Instance.new(new StakingCredentialType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert__deregister\";\n\t}\n}\n\nclass DelegateDCertType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new DCertType());\n\t}\n\n\ttoString() {\n\t\treturn \"DCert::Delegate\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"delegator\":\n\t\t\t\treturn Instance.new(new StakingCredentialType());\n\t\t\tcase \"pool_id\":\n\t\t\t\treturn Instance.new(new PubKeyHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert__delegate\";\n\t}\n}\n\nclass RegisterPoolDCertType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new DCertType());\n\t}\n\n\ttoString() {\n\t\treturn \"DCert::RegisterPool\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"pool_id\":\n\t\t\t\treturn Instance.new(new PubKeyHashType());\n\t\t\tcase \"pool_vrf\":\n\t\t\t\treturn Instance.new(new PubKeyHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 3;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert__registerpool\";\n\t}\n}\n\nclass RetirePoolDCertType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new DCertType());\n\t}\n\n\ttoString() {\n\t\treturn \"DCert::RetirePool\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"pool_id\":\n\t\t\t\treturn Instance.new(new PubKeyHashType());\n\t\t\tcase \"epoch\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 4;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__dcert__retirepool\";\n\t}\n}\n\n/**\n * Builtin Tx type\n * @package\n */\nclass TxType extends BuiltinType {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\ttoString() {\n\t\treturn \"Tx\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\treturn Instance.new(new FuncType([\n\t\t\t\t\t\tnew ListType(new TxInputType()), // 0\n\t\t\t\t\t\tnew ListType(new TxInputType()), // 1\n\t\t\t\t\t\tnew ListType(new TxOutputType()), // 2\n\t\t\t\t\t\tnew ValueType(), // 3\n\t\t\t\t\t\tnew ValueType(), // 4\n\t\t\t\t\t\tnew ListType(new DCertType()), // 5\n\t\t\t\t\t\tnew MapType(new StakingCredentialType(), new IntType()), // 6\n\t\t\t\t\t\tnew TimeRangeType(), // 7\n\t\t\t\t\t\tnew ListType(new PubKeyHashType()), // 8\n\t\t\t\t\t\tnew MapType(new ScriptPurposeType(), new AnyDataType()), // 9\n\t\t\t\t\t\tnew MapType(new DatumHashType(), new AnyDataType()) // 10\n\t\t\t\t\t], this));\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'Tx::new' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"inputs\":\n\t\t\t\treturn Instance.new(new ListType(new TxInputType()));\n\t\t\tcase \"ref_inputs\":\n\t\t\t\treturn Instance.new(new ListType(new TxInputType()));\n\t\t\tcase \"outputs\":\n\t\t\t\treturn Instance.new(new ListType(new TxOutputType()));\n\t\t\tcase \"fee\":\n\t\t\t\treturn Instance.new(new ValueType());\n\t\t\tcase \"minted\":\n\t\t\t\treturn Instance.new(new ValueType());\n\t\t\tcase \"dcerts\":\n\t\t\t\treturn Instance.new(new ListType(new DCertType()));\n\t\t\tcase \"withdrawals\":\n\t\t\t\treturn Instance.new(new MapType(new StakingCredentialType(), new IntType()));\n\t\t\tcase \"time_range\":\n\t\t\t\treturn Instance.new(new TimeRangeType());\n\t\t\tcase \"signatories\":\n\t\t\t\treturn Instance.new(new ListType(new PubKeyHashType()));\n\t\t\tcase \"redeemers\":\n\t\t\t\treturn Instance.new(new MapType(new ScriptPurposeType(), new RawDataType()));\n\t\t\tcase \"datums\":\n\t\t\t\treturn Instance.new(new MapType(new DatumHashType(), new RawDataType()));\n\t\t\tcase \"id\":\n\t\t\t\treturn Instance.new(new TxIdType());\n\t\t\tcase \"find_datum_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new AnyDataType()], new DatumHashType()));\n\t\t\tcase \"get_datum_data\":\n\t\t\t\treturn Instance.new(new FuncType([new TxOutputType()], new RawDataType()));\n\t\t\tcase \"outputs_sent_to\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType()], new ListType(new TxOutputType())));\n\t\t\tcase \"outputs_sent_to_datum\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType(), new AnyDataType(), new BoolType()], new ListType(new TxOutputType())));\n\t\t\tcase \"outputs_locked_by\":\n\t\t\t\treturn Instance.new(new FuncType([new ValidatorHashType()], new ListType(new TxOutputType())));\n\t\t\tcase \"outputs_locked_by_datum\":\n\t\t\t\treturn Instance.new(new FuncType([new ValidatorHashType(), new AnyDataType(), new BoolType()], new ListType(new TxOutputType())));\n\t\t\tcase \"value_sent_to\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType()], new ValueType()));\n\t\t\tcase \"value_sent_to_datum\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType(), new AnyDataType(), new BoolType()], new ValueType()));\n\t\t\tcase \"value_locked_by\":\n\t\t\t\treturn Instance.new(new FuncType([new ValidatorHashType()], new ValueType()));\n\t\t\tcase \"value_locked_by_datum\":\n\t\t\t\treturn Instance.new(new FuncType([new ValidatorHashType(), new AnyDataType(), new BoolType()], new ValueType()));\n\t\t\tcase \"is_signed_by\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType()], new BoolType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__tx\";\n\t}\n}\n\n/**\n * Builtin TxId type\n * @package\n */\nclass TxIdType extends BuiltinType {\n\ttoString() {\n\t\treturn \"TxId\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, this], new BoolType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new ByteArrayType()], this));\n\t\t\tcase \"CURRENT\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\treturn Instance.new(this);\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'TxId::CURRENT' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__txid\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn TxId;\n\t}\n}\n\n/**\n * Builtin TxInput type\n * @package\n */\nclass TxInputType extends BuiltinType {\n\ttoString() {\n\t\treturn \"TxInput\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\tif (this.macrosAllowed) {\n\t\t\t\t\treturn Instance.new(new FuncType([\n\t\t\t\t\t\tnew TxOutputIdType(), // 0\n\t\t\t\t\t\tnew TxOutputType(), // 1\n\t\t\t\t\t], this));\n\t\t\t\t} else {\n\t\t\t\t\tthrow name.referenceError(\"'TxInput::new' can only be used after 'main'\");\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"output_id\":\n\t\t\t\treturn Instance.new(new TxOutputIdType());\n\t\t\tcase \"output\":\n\t\t\t\treturn Instance.new(new TxOutputType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__txinput\";\n\t}\n}\n\n/**\n * Builtin TxOutput type\n * @package\n */\nclass TxOutputType extends BuiltinType {\n\ttoString() {\n\t\treturn \"TxOutput\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([\n\t\t\t\t\tnew AddressType(), // 0\n\t\t\t\t\tnew ValueType(), // 1\n\t\t\t\t\tnew OutputDatumType(), // 2\n\t\t\t\t], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"address\":\n\t\t\t\treturn Instance.new(new AddressType());\n\t\t\tcase \"value\":\n\t\t\t\treturn Instance.new(new ValueType());\n\t\t\tcase \"datum\":\n\t\t\t\treturn Instance.new(new OutputDatumType());\n\t\t\tcase \"ref_script_hash\":\n\t\t\t\treturn Instance.new(new OptionType(new ScriptHashType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__txoutput\";\n\t}\n}\n\n/**\n * @package\n */\nclass OutputDatumType extends BuiltinType {\n\ttoString() {\n\t\treturn \"OutputDatum\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new NoOutputDatumType()).isBaseOf(site, type) || \n\t\t\t\t(new HashedOutputDatumType()).isBaseOf(site, type) || \n\t\t\t\t(new InlineOutputDatumType()).isBaseOf(site, type);; \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new_none\":\n\t\t\t\treturn Instance.new(new FuncType([], new NoOutputDatumType()));\n\t\t\tcase \"new_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new DatumHashType()], new HashedOutputDatumType()));\n\t\t\tcase \"new_inline\": {\n\t\t\t\tlet a = new ParamType(\"a\");\n\t\t\t\treturn new ParamFuncValue([a], new FuncType([a], new InlineOutputDatumType()), () => {\n\t\t\t\t\tlet type = a.type;\n\t\t\t\t\tif (type === null) {\n\t\t\t\t\t\tthrow new Error(\"should've been inferred by now\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (a.type instanceof FuncType) {\n\t\t\t\t\t\t\tthrow name.site.typeError(\"can't use function as argument to OutputDatum::new_inline()\");\n\t\t\t\t\t\t} else if ((new BoolType()).isBaseOf(Site.dummy(), type)) {\n\t\t\t\t\t\t\treturn \"new_inline_from_bool\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn \"new_inline\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcase \"None\":\n\t\t\t\treturn new NoOutputDatumType();\n\t\t\tcase \"Hash\":\n\t\t\t\treturn new HashedOutputDatumType();\n\t\t\tcase \"Inline\":\n\t\t\t\treturn new InlineOutputDatumType();\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"get_inline_data\":\n\t\t\t\treturn Instance.new(new FuncType([], new RawDataType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 3;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__outputdatum\";\n\t}\n}\n\n/**\n * @package\n */\nclass NoOutputDatumType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new OutputDatumType);\n\t}\n\n\ttoString() {\n\t\treturn \"OutputDatum::None\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__outputdatum__none\";\n\t}\n}\n\n/**\n * @package\n */\nclass HashedOutputDatumType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new OutputDatumType());\n\t}\n\n\ttoString() {\n\t\treturn \"OutputDatum::Hash\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new DatumHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__outputdatum__hash\";\n\t}\n}\n\n/**\n * @package\n */\nclass InlineOutputDatumType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new OutputDatumType());\n\t}\n\n\ttoString() {\n\t\treturn \"OutputDatum::Inline\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"data\":\n\t\t\t\treturn Instance.new(new RawDataType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__outputdatum__inline\";\n\t}\n}\n\n/**\n * Type of external data that must be cast/type-checked before using\n * Not named 'Data' in Js because it's too generic\n * @package\n */\nclass RawDataType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Data\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"from_data\":\n\t\t\t\tthrow name.referenceError(`calling Data::from_data(data) is useless`);\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"tag\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__data\";\n\t}\n}\n\n/**\n * Builtin TxOutputId type\n * @package\n */\nclass TxOutputIdType extends BuiltinType {\n\ttoString() {\n\t\treturn \"TxOutputId\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__lt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__geq\":\n\t\t\t\treturn Instance.new(new FuncType([this, new TxOutputIdType()], new BoolType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new TxIdType(), new IntType()], new TxOutputIdType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"tx_id\":\n\t\t\t\treturn Instance.new(new TxIdType());\n\t\t\tcase \"index\":\n\t\t\t\treturn Instance.new(new IntType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__txoutputid\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn TxOutputId;\n\t}\n}\n\n/**\n * Buitin Address type\n * @package\n */\nclass AddressType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Address\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([\n\t\t\t\t\tnew CredentialType(), // 0\n\t\t\t\t\tnew OptionType(new StakingCredentialType()), // 1\n\t\t\t\t], this));\n\t\t\tcase \"new_empty\":\n\t\t\t\treturn Instance.new(new FuncType([], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"credential\":\n\t\t\t\treturn Instance.new(new CredentialType());\n\t\t\tcase \"staking_credential\":\n\t\t\t\treturn Instance.new(new OptionType(new StakingCredentialType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__address\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn Address;\n\t}\n}\n\n/**\n * Builtin Credential type\n * @package\n */\nclass CredentialType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Credential\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new CredentialPubKeyType()).isBaseOf(site, type) || \n\t\t\t\t(new CredentialValidatorType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"PubKey\":\n\t\t\t\treturn new CredentialPubKeyType();\n\t\t\tcase \"Validator\":\n\t\t\t\treturn new CredentialValidatorType();\n\t\t\tcase \"new_pubkey\":\n\t\t\t\treturn Instance.new(new FuncType([new PubKeyHashType()], new CredentialPubKeyType()));\n\t\t\tcase \"new_validator\":\n\t\t\t\treturn Instance.new(new FuncType([new ValidatorHashType()], new CredentialValidatorType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 2;\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__credential\";\n\t}\n}\n\n/**\n * Builtin Credential::PubKey\n */\nclass CredentialPubKeyType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new CredentialType());\n\t}\n\n\ttoString() {\n\t\treturn \"Credential::PubKey\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new PubKeyHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__credential__pubkey\";\n\t}\n}\n\n/**\n * Builtin Credential::Validator type\n */\nclass CredentialValidatorType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new CredentialType());\n\t}\n\n\ttoString() {\n\t\treturn \"Credential::Validator\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new ValidatorHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__credential__validator\";\n\t}\n}\n\n/**\n * Builtin StakingHash type\n * @package\n */\nclass StakingHashType extends BuiltinType {\n\ttoString() {\n\t\treturn \"StakingHash\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new StakingHashStakeKeyType()).isBaseOf(site, type) || \n\t\t\t\t(new StakingHashValidatorType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"StakeKey\":\n\t\t\t\treturn new StakingHashStakeKeyType();\n\t\t\tcase \"Validator\":\n\t\t\t\treturn new StakingHashValidatorType();\n\t\t\tcase \"new_stakekey\":\n\t\t\t\treturn Instance.new(new FuncType([new StakeKeyHashType()], new StakingHashStakeKeyType()));\n\t\t\tcase \"new_validator\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingValidatorHashType()], new StakingHashValidatorType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakinghash\";\n\t}\n}\n\n/**\n * Builtin StakingHash::StakeKey\n */\nclass StakingHashStakeKeyType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new StakingHashType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingHash::StakeKey\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new StakeKeyHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakinghash__stakekey\";\n\t}\n}\n\n/**\n * Builtin StakingHash::Validator type\n */\nclass StakingHashValidatorType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new StakingHashType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingHash::Validator\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new StakingValidatorHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakinghash__validator\";\n\t}\n}\n\n/**\n * Builtin StakingCredential type\n * @package\n */\nclass StakingCredentialType extends BuiltinType {\n\ttoString() {\n\t\treturn \"StakingCredential\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type \n\t * @returns {boolean}\n\t */\n\tisBaseOf(site, type) {\n\t\tlet b = super.isBaseOf(site, type) ||\n\t\t\t\t(new StakingHashCredentialType()).isBaseOf(site, type) || \n\t\t\t\t(new StakingPtrCredentialType()).isBaseOf(site, type); \n\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"Hash\":\n\t\t\t\treturn new StakingHashCredentialType();\n\t\t\tcase \"Ptr\":\n\t\t\t\treturn new StakingPtrCredentialType();\n\t\t\tcase \"new_hash\":\n\t\t\t\treturn Instance.new(new FuncType([new StakingHashType()], new StakingHashCredentialType()));\n\t\t\tcase \"new_ptr\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType(), new IntType(), new IntType()], new StakingPtrCredentialType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn 2;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingcredential\";\n\t}\n}\n\n/**\n * Builtin StakingCredential::Hash\n */\nclass StakingHashCredentialType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new StakingCredentialType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingCredential::Hash\";\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"hash\":\n\t\t\t\treturn Instance.new(new StakingHashType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 0;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingcredential__hash\";\n\t}\n}\n\n/**\n * Builtin StakingCredential::Ptr\n */\nclass StakingPtrCredentialType extends BuiltinEnumMember {\n\tconstructor() {\n\t\tsuper(new StakingCredentialType());\n\t}\n\n\ttoString() {\n\t\treturn \"StakingCredential::Ptr\";\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn 1;\n\t}\n\n\tget path() {\n\t\treturn \"__helios__stakingcredential__ptr\";\n\t}\n}\n\n/**\n * Builtin Time type. Opaque alias of Int representing milliseconds since 1970\n */\nclass TimeType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Time\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\t\treturn Instance.new(new FuncType([this, new DurationType()], new TimeType()));\n\t\t\tcase \"__sub\":\n\t\t\t\treturn Instance.new(new FuncType([this, new TimeType()], new DurationType()));\n\t\t\tcase \"__sub_alt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new DurationType()], new TimeType()));\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new TimeType()], new BoolType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], this));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__time\";\n\t}\n\n\t/**\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn Time;\n\t}\n}\n\n/**\n * Builtin Duration type\n * @package\n */\nclass DurationType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Duration\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\tcase \"__sub\":\n\t\t\tcase \"__mod\":\n\t\t\t\treturn Instance.new(new FuncType([this, new DurationType()], new DurationType()));\n\t\t\tcase \"__mul\":\n\t\t\tcase \"__div\":\n\t\t\t\treturn Instance.new(new FuncType([this, new IntType()], new DurationType()));\n\t\t\tcase \"__div_alt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new DurationType()], new IntType()));\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new DurationType()], new BoolType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], this));\n\t\t\tcase \"SECOND\":\n\t\t\tcase \"MINUTE\":\n\t\t\tcase \"HOUR\":\n\t\t\tcase \"DAY\":\n\t\t\tcase \"WEEK\":\n\t\t\t\treturn Instance.new(this)\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__duration\";\n\t}\n\n\tget userType() {\n\t\treturn Duration;\n\t}\n}\n\n/**\n * Builtin TimeRange type\n * @package\n */\nclass TimeRangeType extends BuiltinType {\n\ttoString() {\n\t\treturn \"TimeRange\";\n\t}\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new TimeType(), new TimeType()], new TimeRangeType()));\n\t\t\tcase \"ALWAYS\":\n\t\t\t\treturn Instance.new(new TimeRangeType());\n\t\t\tcase \"NEVER\":\n\t\t\t\treturn Instance.new(new TimeRangeType());\n\t\t\tcase \"from\":\n\t\t\t\treturn Instance.new(new FuncType([new TimeType()], new TimeRangeType()));\n\t\t\tcase \"to\":\n\t\t\t\treturn Instance.new(new FuncType([new TimeType()], new TimeRangeType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"is_before\": // is_before condition never overlaps with contains\n\t\t\tcase \"is_after\": // is_after condition never overlaps with contains\n\t\t\tcase \"contains\":\n\t\t\t\treturn Instance.new(new FuncType([new TimeType()], new BoolType()));\n\t\t\tcase \"start\":\n\t\t\tcase \"end\":\n\t\t\t\treturn Instance.new(new TimeType());\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__timerange\";\n\t}\n}\n\n/**\n * Builtin AssetClass type\n * @package\n */\nclass AssetClassType extends BuiltinType {\n\ttoString() {\n\t\treturn \"AssetClass\";\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"ADA\":\n\t\t\t\treturn Instance.new(new AssetClassType());\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new MintingPolicyHashType(), new ByteArrayType()], new AssetClassType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"mph\":\n\t\t\t\treturn Instance.new(new MintingPolicyHashType());\n\t\t\tcase \"token_name\":\n\t\t\t\treturn Instance.new(new ByteArrayType());\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn \"__helios__assetclass\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn AssetClass;\n\t}\n}\n\n/**\n * Builtin money Value type\n * @package\n */\nclass ValueType extends BuiltinType {\n\ttoString() {\n\t\treturn \"Value\";\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__add\":\n\t\t\tcase \"__sub\":\n\t\t\t\treturn Instance.new(new FuncType([this, new ValueType()], new ValueType()));\n\t\t\tcase \"__mul\":\n\t\t\tcase \"__div\":\n\t\t\t\treturn Instance.new(new FuncType([this, new IntType()], new ValueType()));\n\t\t\tcase \"__geq\":\n\t\t\tcase \"__gt\":\n\t\t\tcase \"__leq\":\n\t\t\tcase \"__lt\":\n\t\t\t\treturn Instance.new(new FuncType([this, new ValueType()], new BoolType()));\n\t\t\tcase \"ZERO\":\n\t\t\t\treturn Instance.new(new ValueType());\n\t\t\tcase \"lovelace\":\n\t\t\t\treturn Instance.new(new FuncType([new IntType()], new ValueType()));\n\t\t\tcase \"new\":\n\t\t\t\treturn Instance.new(new FuncType([new AssetClassType(), new IntType()], new ValueType()));\n\t\t\tcase \"from_map\":\n\t\t\t\treturn Instance.new(new FuncType([new MapType(new MintingPolicyHashType(), new MapType(new ByteArrayType(), new IntType()))], new ValueType()));\n\t\t\tdefault:\n\t\t\t\treturn super.getTypeMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {Word} name \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name) {\n\t\tswitch (name.value) {\n\t\t\tcase \"contains\":\n\t\t\t\treturn Instance.new(new FuncType([new ValueType()], new BoolType()));\n\t\t\tcase \"is_zero\":\n\t\t\t\treturn Instance.new(new FuncType([], new BoolType()));\n\t\t\tcase \"get\":\n\t\t\t\treturn Instance.new(new FuncType([new AssetClassType()], new IntType()));\n\t\t\tcase \"get_safe\":\n\t\t\t\treturn Instance.new(new FuncType([new AssetClassType()], new IntType()));\n\t\t\tcase \"get_lovelace\":\n\t\t\t\treturn Instance.new(new FuncType([], new IntType()));\n\t\t\tcase \"get_assets\":\n\t\t\t\treturn Instance.new(new FuncType([], new ValueType()));\n\t\t\tcase \"get_policy\":\n\t\t\t\treturn Instance.new(new FuncType([new MintingPolicyHashType()], new MapType(new ByteArrayType(), new IntType())));\n\t\t\tcase \"contains_policy\":\n\t\t\t\treturn Instance.new(new FuncType([new MintingPolicyHashType()], new BoolType()));\n\t\t\tcase \"show\":\n\t\t\t\treturn Instance.new(new FuncType([], new StringType()));\n\t\t\tcase \"to_map\":\n\t\t\t\treturn Instance.new(new FuncType([], new MapType(new MintingPolicyHashType(), new MapType(new ByteArrayType(), new IntType()))));\n\t\t\tdefault:\n\t\t\t\treturn super.getInstanceMember(name);\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @type {string}\n\t */\n\tget path() {\n\t\treturn \"__helios__value\";\n\t}\n\n\t/**\n\t * @package\n\t * @type {HeliosDataClass<HeliosData>}\n\t */\n\tget userType() {\n\t\treturn Value;\n\t}\n}\n\n\n/////////////////////\n// Section 14: Scopes\n/////////////////////\n\n/**\n * GlobalScope sits above the top-level scope and contains references to all the builtin Values and Types\n * @package\n */\nclass GlobalScope {\n\t/**\n\t * @type {[Word, EvalEntity][]}\n\t */\n\t#values;\n\n\tconstructor() {\n\t\tthis.#values = [];\n\t}\n\n\t/**\n\t * Checks if scope contains a name\n\t * @param {Word} name \n\t * @returns {boolean}\n\t */\n\thas(name) {\n\t\tfor (let pair of this.#values) {\n\t\t\tif (pair[0].toString() == name.toString()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets a global name, doesn't check for uniqueness\n\t * Called when initializing GlobalScope\n\t * @param {string | Word} name\n\t * @param {EvalEntity} value\n\t */\n\tset(name, value) {\n\t\t/** @type {Word} */\n\t\tlet nameWord = !(name instanceof Word) ? Word.new(name) : name;\n\n\t\tthis.#values.push([nameWord, value]);\n\t}\n\n\t/**\n\t * Gets a named value from the scope.\n\t * Throws an error if not found.\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tget(name) {\n\t\tfor (let pair of this.#values) {\n\t\t\tif (pair[0].toString() == name.toString()) {\n\t\t\t\tpair[1].markAsUsed();\n\t\t\t\treturn pair[1];\n\t\t\t}\n\t\t}\n\n\t\tthrow name.referenceError(`'${name.toString()}' undefined`);\n\t}\n\n\t/**\n\t * Check if funcstatement is called recursively (always false here)\n\t * @param {RecurseableStatement} statement\n\t * @returns {boolean}\n\t */\n\tisRecursive(statement) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisStrict() {\n\t\tthrow new Error(\"should've been returned be TopScope\");\n\t}\n\n\t/**\n\t * Initialize the GlobalScope with all the builtins\n\t * @param {number} purpose\n\t * @returns {GlobalScope}\n\t */\n\tstatic new(purpose) {\n\t\tlet scope = new GlobalScope();\n\n\t\t// List (aka '[]'), Option, and Map types are accessed through special expressions\n\n\t\t// fill the global scope with builtin types\n        scope.set(\"Address\",              new AddressType());\n        scope.set(\"AssetClass\",           new AssetClassType());\n        scope.set(\"Bool\",                 new BoolType());\n        scope.set(\"ByteArray\",            new ByteArrayType());\n        scope.set(\"Credential\",           new CredentialType());\n        scope.set(\"DatumHash\",            new DatumHashType());\n        scope.set(\"Data\",                 new RawDataType());\n        scope.set(\"DCert\",                new DCertType());\n        scope.set(\"Duration\",             new DurationType());\n\t\tscope.set(\"Int\",                  new IntType());\n        scope.set(\"MintingPolicyHash\",    new MintingPolicyHashType(purpose));\n        scope.set(\"OutputDatum\",          new OutputDatumType());\n        scope.set(\"PubKey\",               new PubKeyType());\n\t\tscope.set(\"PubKeyHash\",           new PubKeyHashType());\n        scope.set(\"ScriptContext\",        new ScriptContextType(purpose));\n        scope.set(\"ScriptHash\",           new ScriptHashType());\n        scope.set(\"ScriptPurpose\",        new ScriptPurposeType());\n        scope.set(\"StakeKeyHash\",         new StakeKeyHashType());\n        scope.set(\"StakingCredential\",    new StakingCredentialType());\n        scope.set(\"StakingHash\",          new StakingHashType());\n        scope.set(\"StakingPurpose\",       new StakingPurposeType());\n        scope.set(\"StakingValidatorHash\", new StakingValidatorHashType(purpose));\n\t\tscope.set(\"String\",               new StringType());\n        scope.set(\"Time\",                 new TimeType());\n        scope.set(\"TimeRange\",            new TimeRangeType());\n        scope.set(\"Tx\",                   new TxType());\n        scope.set(\"TxId\",                 new TxIdType());\n        scope.set(\"TxInput\",              new TxInputType());\n        scope.set(\"TxOutput\",             new TxOutputType());\n        scope.set(\"TxOutputId\",           new TxOutputIdType());\n\t\tscope.set(\"ValidatorHash\",        new ValidatorHashType(purpose));\n        scope.set(\"Value\",                new ValueType());\n\n        // builtin functions\n        scope.set(\"assert\",               new AssertFunc());\n\t\tscope.set(\"error\",                new ErrorFunc());\n        scope.set(\"print\",                new PrintFunc());\n\t\t\n\n\t\treturn scope;\n\t}\n\n\tallowMacros() {\n\t\tfor (let [_, value] of this.#values) {\n\t\t\tif (value instanceof BuiltinType) {\n\t\t\t\tvalue.allowMacros();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {(name: string, type: Type) => void} callback \n\t */\n\tloopTypes(callback) {\n\t\tfor (let [k, v] of this.#values) {\n\t\t\tif (v instanceof Type) {\n\t\t\t\tcallback(k.value, v);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * User scope\n * @package\n */\nclass Scope {\n\t/** @type {GlobalScope | Scope} */\n\t#parent;\n\n\t/** \n\t * TopScope can elverage the #values to store ModuleScopes\n\t * @type {[Word, (EvalEntity | Scope)][]} \n\t */\n\t#values;\n\n\t/**\n\t * @param {GlobalScope | Scope} parent \n\t */\n\tconstructor(parent) {\n\t\tthis.#parent = parent;\n\t\tthis.#values = []; // list of pairs\n\t}\n\n\t/**\n\t * Used by top-scope to loop over all the statements\n\t */\n\tget values() {\n\t\treturn this.#values.slice();\n\t}\n\n\t/**\n\t * Checks if scope contains a name\n\t * @param {Word} name \n\t * @returns {boolean}\n\t */\n\thas(name) {\n\t\tfor (let pair of this.#values) {\n\t\t\tif (pair[0].toString() == name.toString()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (this.#parent !== null) {\n\t\t\treturn this.#parent.has(name);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Sets a named value. Throws an error if not unique\n\t * @param {Word} name \n\t * @param {EvalEntity | Scope} value \n\t */\n\tset(name, value) {\n\t\tif (this.has(name)) {\n\t\t\tthrow name.syntaxError(`'${name.toString()}' already defined`);\n\t\t}\n\n\t\tthis.#values.push([name, value]);\n\t}\n\n\t/**\n\t * Gets a named value from the scope. Throws an error if not found\n\t * @param {Word} name \n\t * @returns {EvalEntity | Scope}\n\t */\n\tget(name) {\n\t\tif (!(name instanceof Word)) {\n\t\t\tname = Word.new(name);\n\t\t}\n\n\t\tfor (let [key, entity] of this.#values) {\n\t\t\tif (key.toString() == name.toString()) {\n\t\t\t\tif (entity instanceof EvalEntity) {\n\t\t\t\t\tentity.markAsUsed();\n\t\t\t\t}\n\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\n\t\tif (this.#parent !== null) {\n\t\t\treturn this.#parent.get(name);\n\t\t} else {\n\t\t\tthrow name.referenceError(`'${name.toString()}' undefined`);\n\t\t}\n\t}\n\n\t/**\n\t * Check if function statement is called recursively\n\t * @param {RecurseableStatement} statement\n\t * @returns {boolean}\n\t */\n\tisRecursive(statement) {\n\t\treturn this.#parent.isRecursive(statement);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisStrict() {\n\t\treturn this.#parent.isStrict();\n\t}\n\n\t/**\n\t * Asserts that all named values are user.\n\t * Throws an error if some are unused.\n\t * Check is only run if we are in strict mode\n\t * @param {boolean} onlyIfStrict\n\t */\n\tassertAllUsed(onlyIfStrict = true) {\n\t\tif (!onlyIfStrict || this.isStrict()) {\n\t\t\tfor (let [name, entity] of this.#values) {\n\t\t\t\tif (entity instanceof EvalEntity && !entity.isUsed()) {\n\t\t\t\t\tthrow name.referenceError(`'${name.toString()}' unused`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {boolean}\n\t */\n\tisUsed(name) {\n\t\tfor (let [name, entity] of this.#values) {\n\t\t\tif (name.value == name.value && entity instanceof EvalEntity) {\n\t\t\t\treturn entity.isUsed();\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`${name.value} not found`);\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Type}\n\t */\n\tassertType(site) {\n\t\tthrow site.typeError(\"expected a type, got a module\");\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {Instance}\n\t */\n\tassertValue(site) {\n\t\tthrow site.typeError(\"expected a value, got a module\");\n\t}\n\n\tdump() {\n\t\tconsole.log(\"DUMPING SCOPE\", this.#values.length);\n\t\tthis.#values.forEach(([w, v]) => {\n\t\t\tconsole.log(w.value, v);\n\t\t});\n\t}\n\n\t/**\n\t * @param {(name: string, type: Type) => void} callback \n\t */\n\tloopTypes(callback) {\n\t\tthis.#parent.loopTypes(callback);\n\n\t\tfor (let [k, v] of this.#values) {\n\t\t\tif (v instanceof Type) {\n\t\t\t\tcallback(k.value, v);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * TopScope is a special scope that can contain UserTypes\n * @package\n */\nclass TopScope extends Scope {\n\t#strict;\n\n\t/**\n\t * @param {GlobalScope} parent \n\t * @param {boolean} strict\n\t */\n\tconstructor(parent, strict = true) {\n\t\tsuper(parent);\n\t\tthis.#strict = strict;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @param {EvalEntity | Scope} value \n\t */\n\tset(name, value) {\n\t\tsuper.set(name, value);\n\t}\n\n\t/**\n\t * @param {boolean} s \n\t */\n\tsetStrict(s) {\n\t\tthis.#strict = s;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisStrict() {\n\t\treturn this.#strict;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {ModuleScope}\n\t */\n\tgetModuleScope(name) {\n\t\tconst maybeModuleScope = this.get(name);\n\t\tif (maybeModuleScope instanceof ModuleScope) {\n\t\t\treturn maybeModuleScope;\n\t\t} else {\n\t\t\tthrow new Error(\"expected ModuleScope\");\n\t\t}\n\t}\n}\n\n/**\n * @package\n */\nclass ModuleScope extends Scope {\n}\n\n/**\n * FuncStatementScope is a special scope used to detect recursion\n * @package\n */\nclass FuncStatementScope extends Scope {\n\t#statement;\n\n\t/**\n\t * @param {Scope} parent\n\t * @param {RecurseableStatement} statement\n\t */\n\tconstructor(parent, statement) {\n\t\tsuper(parent);\n\n\t\tthis.#statement = statement;\n\t}\n\n\t/**\n\t * @param {RecurseableStatement} statement \n\t * @returns {boolean}\n\t */\n\tisRecursive(statement) {\n\t\tif (this.#statement === statement) {\n\t\t\tthis.#statement.setRecursive();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn super.isRecursive(statement);\n\t\t}\n\t}\n}\n\n\n/////////////////////////////////////\n// Section 15: Helios AST expressions\n/////////////////////////////////////\n\n/**\n * Base class of every Type and Instance expression.\n */\nclass Expr extends Token {\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\tuse() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Base class of every Type expression\n * Caches evaluated Type.\n * @package\n */\nclass TypeExpr extends Expr {\n\t#cache;\n\n\t/**\n\t * @param {Site} site \n\t * @param {?Type} cache\n\t */\n\tconstructor(site, cache = null) {\n\t\tsuper(site);\n\t\tthis.#cache = cache;\n\t}\n\n\tget type() {\n\t\tif (this.#cache === null) {\n\t\t\tthrow new Error(\"type not yet evaluated\");\n\t\t} else {\n\t\t\treturn this.#cache;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\teval(scope) {\n\t\tif (this.#cache === null) {\n\t\t\tthis.#cache = this.evalInternal(scope);\n\t\t}\n\n\t\treturn this.#cache;\n\t}\n}\n\n/**\n * Type reference class (i.e. using a Word)\n * @package\n */\nclass TypeRefExpr extends TypeExpr {\n\t#name;\n\n\t/**\n\t * @param {Word} name\n\t * @param {?Type} cache\n\t */\n\tconstructor(name, cache = null) {\n\t\tsuper(name.site, cache);\n\t\tthis.#name = name;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#name.toString();\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet type = scope.get(this.#name);\n\n\t\treturn type.assertType(this.#name.site);\n\t}\n\n\tget path() {\n\t\treturn this.type.path;\n\t}\n\n\tuse() {\n\t\tlet t = this.type;\n\n\t\tif (t instanceof StatementType) {\n\t\t\tt.statement.use();\n\t\t}\n\t}\n}\n\n/**\n * Type::Member expression\n * @package\n */\nclass TypePathExpr extends TypeExpr {\n\t#baseExpr;\n\t#memberName;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} baseExpr \n\t * @param {Word} memberName\n\t */\n\tconstructor(site, baseExpr, memberName) {\n\t\tsuper(site);\n\t\tthis.#baseExpr = baseExpr;\n\t\tthis.#memberName = memberName;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#baseExpr.toString()}::${this.#memberName.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet enumType = this.#baseExpr.eval(scope);\n\n\t\tlet memberType = enumType.getTypeMember(this.#memberName);\n\n\t\treturn memberType.assertType(this.#memberName.site);\n\t}\n\n\tget path() {\n\t\treturn this.type.path;\n\t}\n\n\tuse() {\n\t\tthis.#baseExpr.use();\n\t}\n}\n\n/**\n * []ItemType\n * @package\n */\nclass ListTypeExpr extends TypeExpr {\n\t#itemTypeExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} itemTypeExpr \n\t */\n\tconstructor(site, itemTypeExpr) {\n\t\tsuper(site);\n\t\tthis.#itemTypeExpr = itemTypeExpr;\n\t}\n\n\ttoString() {\n\t\treturn `[]${this.#itemTypeExpr.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet itemType = this.#itemTypeExpr.eval(scope);\n\n\t\tif (itemType instanceof FuncType) {\n\t\t\tthrow this.#itemTypeExpr.typeError(\"list item type can't be function\");\n\t\t}\n\n\t\treturn new ListType(itemType);\n\t}\n\n\tuse() {\n\t\tthis.#itemTypeExpr.use();\n\t}\n}\n\n/**\n * Map[KeyType]ValueType expression\n * @package\n */\nclass MapTypeExpr extends TypeExpr {\n\t#keyTypeExpr;\n\t#valueTypeExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} keyTypeExpr \n\t * @param {TypeExpr} valueTypeExpr \n\t */\n\tconstructor(site, keyTypeExpr, valueTypeExpr) {\n\t\tsuper(site);\n\t\tthis.#keyTypeExpr = keyTypeExpr;\n\t\tthis.#valueTypeExpr = valueTypeExpr;\n\t}\n\n\ttoString() {\n\t\treturn `Map[${this.#keyTypeExpr.toString()}]${this.#valueTypeExpr.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet keyType = this.#keyTypeExpr.eval(scope);\n\n\t\tif (keyType instanceof FuncType) {\n\t\t\tthrow this.#keyTypeExpr.typeError(\"map key type can't be function\");\n\t\t} else if (keyType instanceof BoolType) {\n\t\t\tthrow this.#keyTypeExpr.typeError(\"map key type can't be a boolean\");\n\t\t}\n\n\t\tlet valueType = this.#valueTypeExpr.eval(scope);\n\n\t\tif (valueType instanceof FuncType) {\n\t\t\tthrow this.#valueTypeExpr.typeError(\"map value type can't be function\");\n\t\t}\n\n\t\treturn new MapType(keyType, valueType);\n\t}\n\n\tuse() {\n\t\tthis.#keyTypeExpr.use();\n\t\tthis.#valueTypeExpr.use();\n\t}\n}\n\n/**\n * Option[SomeType] expression\n * @package\n */\nclass OptionTypeExpr extends TypeExpr {\n\t#someTypeExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} someTypeExpr \n\t */\n\tconstructor(site, someTypeExpr) {\n\t\tsuper(site);\n\t\tthis.#someTypeExpr = someTypeExpr;\n\t}\n\n\ttoString() {\n\t\treturn `Option[${this.#someTypeExpr.toString()}]`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet someType = this.#someTypeExpr.eval(scope);\n\n\t\tif (someType instanceof FuncType) {\n\t\t\tthrow this.#someTypeExpr.typeError(\"option some type can't be function\");\n\t\t}\n\n\t\treturn new OptionType(someType);\n\t}\n\n\tuse() {\n\t\tthis.#someTypeExpr.use();\n\t}\n}\n\n/**\n * '()' which can only be used as return type of func\n * @package\n */\nclass VoidTypeExpr extends TypeExpr {\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\ttoString() {\n\t\treturn \"()\";\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\treturn new VoidType();\n\t}\n\t\n\tuse() {\n\t}\n}\n\n/**\n * @package\n */\nclass FuncArgTypeExpr extends Token {\n\t#name;\n\t#typeExpr;\n\toptional;\n\n\t/**\n\t * @param {Site} site \n\t * @param {null | Word} name \n\t * @param {TypeExpr} typeExpr \n\t * @param {boolean} optional \n\t */\n\tconstructor(site, name, typeExpr, optional) {\n\t\tsuper(site);\n\t\tthis.#name = name;\n\t\tthis.#typeExpr = typeExpr;\n\t\tthis.optional = optional;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisNamed() {\n\t\treturn this.#name == null;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisOptional() {\n\t\treturn this.optional;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn [\n\t\t\tthis.#name != null ? `${this.#name.toString()}: ` : \"\",\n\t\t\tthis.optional ? \"?\" : \"\",\n\t\t\tthis.#typeExpr.toString()\n\t\t].join(\"\");\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {ArgType}\n\t */\n\teval(scope) {\n\t\treturn new ArgType(this.#name, this.#typeExpr.eval(scope), this.optional);\n\t}\n\n\tuse() {\n\t\tthis.#typeExpr.use();\n\t}\n}\n\n/**\n * (ArgType1, ...) -> RetType expression\n * @package\n */\nclass FuncTypeExpr extends TypeExpr {\n\t#argTypeExprs;\n\t#retTypeExprs;\n\n\t/**\n\t * @param {Site} site \n\t * @param {FuncArgTypeExpr[]} argTypeExprs \n\t * @param {TypeExpr[]} retTypeExprs \n\t */\n\tconstructor(site, argTypeExprs, retTypeExprs) {\n\t\tsuper(site);\n\t\tthis.#argTypeExprs = argTypeExprs;\n\t\tthis.#retTypeExprs = retTypeExprs;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tif (this.#retTypeExprs.length === 1) {\n\t\t\treturn `(${this.#argTypeExprs.map(a => a.toString()).join(\", \")}) -> ${this.#retTypeExprs.toString()}`;\n\t\t} else {\n\t\t\treturn `(${this.#argTypeExprs.map(a => a.toString()).join(\", \")}) -> (${this.#retTypeExprs.map(e => e.toString()).join(\", \")})`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalInternal(scope) {\n\t\tlet argTypes = this.#argTypeExprs.map(a => a.eval(scope));\n\n\t\tlet retTypes = this.#retTypeExprs.map(e => e.eval(scope));\n\n\t\treturn new FuncType(argTypes, retTypes);\n\t}\n\n\tuse() {\n\t\tthis.#argTypeExprs.forEach(arg => arg.use());\n\t\tthis.#retTypeExprs.forEach(e => e.use());\n\t}\n}\n\n/**\n * Base class of expression that evaluate to Values.\n * @package\n */\nclass ValueExpr extends Expr {\n\t/** @type {?Instance} */\n\t#cache;\n\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\n\t\tthis.#cache = null;\n\t}\n\n\t/**\n\t * @type {Instance}\n\t */\n\tget value() {\n\t\tif (this.#cache === null) {\n\t\t\tthrow new Error(\"type not yet evaluated\");\n\t\t} else {\n\t\t\treturn this.#cache;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this.value.getType(this.site);\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\teval(scope) {\n\t\tif (this.#cache === null) {\n\t\t\tthis.#cache = this.evalInternal(scope);\n\t\t}\n\n\t\treturn this.#cache;\n\t}\n\n\t/**\n\t * Returns Intermediate Representation of a value expression.\n\t * The IR should be indented to make debugging easier.\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tthrow new Error(\"not implemented\");\n\t}\n}\n\n/**\n * '... = ... ; ...' expression\n * @package\n */\nclass AssignExpr extends ValueExpr {\n\t#nameTypes;\n\t#upstreamExpr;\n\t#downstreamExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {DestructExpr[]} nameTypes \n\t * @param {ValueExpr} upstreamExpr \n\t * @param {ValueExpr} downstreamExpr \n\t */\n\tconstructor(site, nameTypes, upstreamExpr, downstreamExpr) {\n\t\tsuper(site);\n\t\tassert(nameTypes.length > 0);\n\t\tthis.#nameTypes = nameTypes;\n\t\tthis.#upstreamExpr = assertDefined(upstreamExpr);\n\t\tthis.#downstreamExpr = assertDefined(downstreamExpr);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tlet downstreamStr = this.#downstreamExpr.toString();\n\t\tassert(downstreamStr != undefined);\n\n\t\tif (this.#nameTypes.length === 1) {\n\t\t\treturn `${this.#nameTypes.toString()} = ${this.#upstreamExpr.toString()}; ${downstreamStr}`;\n\t\t} else {\n\t\t\treturn `(${this.#nameTypes.map(nt => nt.toString()).join(\", \")}) = ${this.#upstreamExpr.toString()}; ${downstreamStr}`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet subScope = new Scope(scope);\n\n\t\tlet upstreamVal = this.#upstreamExpr.eval(scope);\n\n\t\tif (this.#nameTypes.length > 1) {\n\t\t\tif (!(upstreamVal instanceof MultiInstance)) {\n\t\t\t\tthrow this.typeError(\"rhs ins't a multi-value\");\n\t\t\t} else {\n\t\t\t\tlet vals = upstreamVal.values;\n\n\t\t\t\tif (this.#nameTypes.length != vals.length) {\n\t\t\t\t\tthrow this.typeError(`expected ${this.#nameTypes.length} rhs in multi-assign, got ${vals.length}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.#nameTypes.forEach((nt, i) => nt.evalInAssignExpr(subScope, vals[i].getType(nt.site), i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!upstreamVal.isValue()) {\n\t\t\t\tthrow this.typeError(\"rhs isn't a value\");\n\t\t\t}\n\n\t\t\tif (this.#nameTypes[0].hasType()) {\n\t\t\t\tthis.#nameTypes[0].evalInAssignExpr(subScope, upstreamVal.getType(this.#nameTypes[0].site), 0);\n\t\t\t} else if (this.#upstreamExpr.isLiteral()) {\n\t\t\t\t// enum variant type resulting from a constructor-like associated function must be cast back into its enum type\n\t\t\t\tif ((this.#upstreamExpr instanceof CallExpr &&\n\t\t\t\t\tthis.#upstreamExpr.fnExpr instanceof ValuePathExpr) || \n\t\t\t\t\t(this.#upstreamExpr instanceof ValuePathExpr && \n\t\t\t\t\t!this.#upstreamExpr.isZeroFieldConstructor())) \n\t\t\t\t{\n\t\t\t\t\tlet upstreamType = upstreamVal.getType(this.#upstreamExpr.site);\n\n\t\t\t\t\tif (upstreamType.isEnumMember()) {\n\t\t\t\t\t\tupstreamVal = Instance.new(upstreamType.parentType(Site.dummy()));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsubScope.set(this.#nameTypes[0].name, upstreamVal);\n\t\t\t} else {\n\t\t\t\tthrow this.typeError(\"unable to infer type of assignment rhs\");\n\t\t\t}\n\t\t}\n\n\t\tconst downstreamVal = this.#downstreamExpr.eval(subScope);\n\n\t\tsubScope.assertAllUsed();\n\n\t\treturn downstreamVal;\n\t}\n\n\tuse() {\n\t\tthis.#nameTypes.forEach(nt => nt.use());\n\t\tthis.#upstreamExpr.use();\n\t\tthis.#downstreamExpr.use();\n\t}\n\n\t/**\n\t * \n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\t\n\t\tif (this.#nameTypes.length === 1) {\n\t\t\tlet inner = this.#downstreamExpr.toIR(indent + TAB);\n\n\t\t\tinner = this.#nameTypes[0].wrapDestructIR(indent, inner, 0);\n\n\t\t\tlet upstream = this.#upstreamExpr.toIR(indent);\n\n\t\t\t// enum member run-time error IR\n\t\t\tif (this.#nameTypes[0].hasType()) {\n\t\t\t\tconst t = this.#nameTypes[0].type;\n\n\t\t\t\tif (t.isEnumMember()) {\n\t\t\t\t\tupstream = new IR([\n\t\t\t\t\t\tnew IR(\"__helios__common__assert_constr_index(\"),\n\t\t\t\t\t\tupstream,\n\t\t\t\t\t\tnew IR(`, ${t.getConstrIndex(this.#nameTypes[0].site)})`)\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new IR([\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tthis.#nameTypes[0].toNameIR(0),\n\t\t\t\tnew IR(\") \"),\n\t\t\t\tnew IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}`),\n\t\t\t\tinner,\n\t\t\t\tnew IR(`\\n${indent}}(`),\n\t\t\t\tupstream,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t} else {\n\t\t\tlet inner = this.#downstreamExpr.toIR(indent + TAB + TAB);\n\n\t\t\tfor (let i = this.#nameTypes.length - 1; i >= 0; i--) {\n\t\t\t\t// internally generates enum-member error IR\n\t\t\t\tinner = this.#nameTypes[i].wrapDestructIR(indent, inner, i);\n\t\t\t}\n\n\t\t\tconst ir = new IR([\n\t\t\t\tthis.#upstreamExpr.toIR(indent),\n\t\t\t\tnew IR(`(\\n${indent + TAB}(`), new IR(this.#nameTypes.map((nt, i) => nt.toNameIR(i))).join(\", \"), new IR(\") ->\", this.site), new IR(` {\\n${indent}${TAB}${TAB}`),\n\t\t\t\tinner,\n\t\t\t\tnew IR(`\\n${indent + TAB}}\\n${indent})`)\n\t\t\t]);\n\n\t\t\treturn ir;\n\t\t}\n\t}\n}\n\n/**\n * print(...); ... expression\n * @package\n */\nclass PrintExpr extends ValueExpr {\n\t#msgExpr;\n\t#downstreamExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr} msgExpr \n\t * @param {ValueExpr} downstreamExpr \n\t */\n\tconstructor(site, msgExpr, downstreamExpr) {\n\t\tsuper(site);\n\t\tthis.#msgExpr = msgExpr;\n\t\tthis.#downstreamExpr = downstreamExpr;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tlet downstreamStr = this.#downstreamExpr.toString();\n\t\tassert(downstreamStr != undefined);\n\t\treturn `print(${this.#msgExpr.toString()}); ${downstreamStr}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet msgVal = this.#msgExpr.eval(scope);\n\n\t\tassert(msgVal.isValue());\n\n\t\tif (!msgVal.isInstanceOf(this.#msgExpr.site, StringType)) {\n\t\t\tthrow this.#msgExpr.typeError(\"expected string arg for print\");\n\t\t}\n\n\t\tlet downstreamVal = this.#downstreamExpr.eval(scope);\n\n\t\treturn downstreamVal;\n\t}\n\n\tuse() {\n\t\tthis.#msgExpr.use();\n\t\tthis.#downstreamExpr.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn new IR([\n\t\t\tnew IR(\"__core__trace\", this.site), new IR(\"(\"), new IR(\"__helios__common__unStringData(\"),\n\t\t\tthis.#msgExpr.toIR(indent),\n\t\t\tnew IR(`), () -> {\\n${indent}${TAB}`),\n\t\t\tthis.#downstreamExpr.toIR(indent + TAB),\n\t\t\tnew IR(`\\n${indent}})()`)\n\t\t]);\n\t}\n}\n\n/**\n * Helios equivalent of unit\n * @package\n */\nclass VoidExpr extends ValueExpr {\n\t/**\n\t * @param {Site} site\n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\ttoString() {\n\t\treturn \"()\";\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\treturn new VoidInstance();\n\t}\n\n\tuse() {\n\t}\n\n\ttoIR() {\n\t\treturn new IR(\"()\", this.site);\n\t}\n}\n\n/**\n * expr(...); ...\n * @package\n */\nclass ChainExpr extends ValueExpr {\n\t#upstreamExpr;\n\t#downstreamExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr} upstreamExpr \n\t * @param {ValueExpr} downstreamExpr \n\t */\n\tconstructor(site, upstreamExpr, downstreamExpr) {\n\t\tsuper(site);\n\t\tthis.#upstreamExpr = upstreamExpr;\n\t\tthis.#downstreamExpr = downstreamExpr;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#upstreamExpr.toString()}; ${this.#downstreamExpr.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope\n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet upstreamVal = this.#upstreamExpr.eval(scope);\n\n\t\tif (upstreamVal instanceof ErrorInstance) {\n\t\t\tthrow this.#downstreamExpr.typeError(\"unreachable code (upstream always throws error)\");\n\t\t} else if (!(upstreamVal instanceof VoidInstance)) {\n\t\t\tthrow this.#upstreamExpr.typeError(\"unexpected return value (hint: use '='\");\n\t\t}\n\n\t\treturn this.#downstreamExpr.eval(scope);\n\t}\n\n\tuse() {\n\t\tthis.#upstreamExpr.use();\n\t\tthis.#downstreamExpr.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn new IR([\n\t\t\tnew IR(\"__core__chooseUnit(\", this.site),\n\t\t\tthis.#upstreamExpr.toIR(indent),\n\t\t\tnew IR(\", \"),\n\t\t\tthis.#downstreamExpr.toIR(indent),\n\t\t\tnew IR(\")\")\n\t\t]);\n\t}\n}\n\n/**\n * Literal expression class (wraps literal tokens)\n * @package\n */\nclass PrimitiveLiteralExpr extends ValueExpr {\n\t#primitive;\n\n\t/**\n\t * @param {PrimitiveLiteral} primitive \n\t */\n\tconstructor(primitive) {\n\t\tsuper(primitive.site);\n\t\tthis.#primitive = primitive;\n\t}\n\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#primitive.toString();\n\t}\n\n\t/**\n\t * @type {Type}\n\t */\n\tget type() {\n\t\tif (this.#primitive instanceof IntLiteral) {\n\t\t\treturn new IntType();\n\t\t} else if (this.#primitive instanceof BoolLiteral) {\n\t\t\treturn new BoolType();\n\t\t} else if (this.#primitive instanceof StringLiteral) {\n\t\t\treturn new StringType();\n\t\t} else if (this.#primitive instanceof ByteArrayLiteral) {\n\t\t\treturn new ByteArrayType(this.#primitive.bytes.length == 32 ? 32 : null);\n\t\t} else {\n\t\t\tthrow new Error(\"unhandled primitive type\");\n\t\t}\t\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\treturn new DataInstance(this.type);\n\t}\n\n\tuse() {\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\t// all literals can be reused in their string-form in the IR\n\t\tlet inner = new IR(this.#primitive.toString(), this.#primitive.site);\n\n\t\tif (this.#primitive instanceof IntLiteral) {\n\t\t\treturn new IR([new IR(\"__core__iData\", this.site), new IR(\"(\"), inner, new IR(\")\")]);\n\t\t} else if (this.#primitive instanceof BoolLiteral) {\n\t\t\treturn inner;\n\t\t} else if (this.#primitive instanceof StringLiteral) {\n\t\t\treturn new IR([new IR(\"__helios__common__stringData\", this.site), new IR(\"(\"), inner, new IR(\")\")]);\n\t\t} else if (this.#primitive instanceof ByteArrayLiteral) {\n\t\t\treturn new IR([new IR(\"__core__bData\", this.site), new IR(\"(\"), inner, new IR(\")\")]);\n\t\t} else {\n\t\t\tthrow new Error(\"unhandled primitive type\");\n\t\t}\n\t}\n}\n\n/**\n * Literal UplcData which is the result of parameter substitutions.\n * @package\n */\nclass LiteralDataExpr extends ValueExpr {\n\t#type;\n\t#data;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Type} type\n\t * @param {UplcData} data\n\t */\n\tconstructor(site, type, data) {\n\t\tsuper(site);\n\t\tthis.#type = type;\n\t\tthis.#data = data;\n\t}\n\n\t/**\n\t * @package\n\t * @type {Type}\n\t */\n\tget type() {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `##${bytesToHex(this.#data.toCbor())}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\treturn Instance.new(this.#type);\n\t}\n\n\tuse() {\n\t}\n\n\ttoIR(indent = \"\") {\n\t\treturn new IR(this.toString(), this.site);\n\t}\n}\n\n/**\n * Struct field (part of a literal struct constructor)\n * @package\n */\nclass StructLiteralField {\n\t#name;\n\t#value;\n\n\t/**\n\t * @param {?Word} name \n\t * @param {ValueExpr} value \n\t */\n\tconstructor(name, value) {\n\t\tthis.#name = name;\n\t\tthis.#value = value;\n\t}\n\n\tget site() {\n\t\tif (this.#name === null) {\n\t\t\treturn this.#value.site;\n\t\t} else {\n\t\t\treturn this.#name.site;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisNamed() {\n\t\treturn this.#name !== null;\n\t}\n\n\tget name() {\n\t\tif (this.#name === null) {\n\t\t\tthrow new Error(\"name of field not given\");\n\t\t} else {\n\t\t\treturn this.#name;\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.#name === null) {\n\t\t\treturn this.#value.toString();\n\t\t} else {\n\t\t\treturn `${this.#name.toString()}: ${this.#value.toString()}`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\teval(scope) {\n\t\treturn this.#value.eval(scope);\n\t}\n\n\tuse() {\n\t\tthis.#value.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn this.#value.toIR(indent);\n\t}\n}\n\n/**\n * Struct literal constructor\n * @package\n */\nclass StructLiteralExpr extends ValueExpr {\n\t#typeExpr;\n\t#fields;\n\t/** @type {?number} - set during evaluation */\n\t#constrIndex;\n\n\t/**\n\t * @param {TypeExpr} typeExpr \n\t * @param {StructLiteralField[]} fields \n\t */\n\tconstructor(typeExpr, fields) {\n\t\tsuper(typeExpr.site);\n\t\tthis.#typeExpr = typeExpr;\n\t\tthis.#fields = fields;\n\t\tthis.#constrIndex = null;\n\t}\n\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#typeExpr.toString()}{${this.#fields.map(f => f.toString()).join(\", \")}}`;\n\t}\n\n\tisNamed() {\n\t\t// the expression builder already checked that all fields are named or all or positional (i.e. not mixed)\n\t\treturn this.#fields.length > 0 && this.#fields[0].isNamed();\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns \n\t */\n\tevalInternal(scope) {\n\t\tlet type = this.#typeExpr.eval(scope);\n\n\t\tassert(type.isType());\n\n\t\tthis.#constrIndex = type.getConstrIndex(this.site);\n\n\t\tlet instance = Instance.new(type);\n\n\t\tif (instance.nFields(this.site) != this.#fields.length) {\n\t\t\tthrow this.typeError(`wrong number of fields for ${type.toString()}, expected ${instance.nFields(this.site)}, got ${this.#fields.length}`);\n\t\t}\n\n\t\tfor (let i = 0; i < this.#fields.length; i++) {\n\t\t\tlet f = this.#fields[i];\n\t\t\n\t\t\tlet fieldVal = f.eval(scope);\n\n\t\t\tif (f.isNamed()) {\n\t\t\t\t// check the named type\n\t\t\t\tlet memberType = instance.getInstanceMember(f.name).getType(f.name.site);\n\n\t\t\t\tif (!fieldVal.isInstanceOf(f.site, memberType)) {\n\t\t\t\t\tthrow f.site.typeError(`wrong field type for '${f.name.toString()}', expected ${memberType.toString()}, got ${fieldVal.getType(Site.dummy()).toString()}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// check the positional type\n\t\t\t\tlet memberType = instance.getFieldType(f.site, i);\n\t\t\t\t\n\t\t\t\tif (!fieldVal.isInstanceOf(f.site, memberType)) {\n\t\t\t\t\tthrow f.site.typeError(`wrong field type for field ${i.toString()}, expected ${memberType.toString()}, got ${fieldVal.getType(Site.dummy()).toString()}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\tuse() {\n\t\tthis.#typeExpr.use();\n\n\t\tfor (let f of this.#fields) {\n\t\t\tf.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {Type} type\n\t * @param {IR[]} fields\n\t * @param {number | null} constrIndex\n\t */\n\tstatic toIRInternal(site, type, fields, constrIndex) {\n\t\tlet ir = new IR(\"__core__mkNilData(())\");\n\n\t\tconst instance = Instance.new(type);\n\n\t\tfor (let i = fields.length - 1; i >= 0; i--) {\n\t\t\tlet f = fields[i];\n\n\t\t\tconst isBool = instance.getFieldType(site, i) instanceof BoolType;\n\n\t\t\tif (isBool) {\n\t\t\t\tf = new IR([\n\t\t\t\t\tnew IR(\"__helios__common__boolData(\"),\n\t\t\t\t\tf,\n\t\t\t\t\tnew IR(\")\"),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// in case of a struct with only one field, return that field directly \n\t\t\tif (fields.length == 1 && type instanceof StructStatementType) {\n\t\t\t\treturn f;\n\t\t\t}\n\n\t\t\tir = new IR([\n\t\t\t\tnew IR(\"__core__mkCons(\"),\n\t\t\t\tf,\n\t\t\t\tnew IR(\", \"),\n\t\t\t\tir,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\n\t\tif (constrIndex === null) {\n\t\t\tthrow new Error(\"constrIndex not yet set\");\n\t\t} else if (constrIndex == -1) {\n\t\t\t// regular struct\n\t\t\treturn new IR([\n\t\t\t\tnew IR(\"__core__listData\", site),\n\t\t\t\tnew IR(\"(\"), \n\t\t\t\tir,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t} else {\n\t\t\treturn new IR([\n\t\t\t\tnew IR(\"__core__constrData\", site), new IR(`(${constrIndex.toString()}, `),\n\t\t\t\tir,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tconst type = this.#typeExpr.type;\n\n\t\tconst fields = this.#fields.slice();\n\n\t\t// sort fields by correct name\n\t\tif (this.isNamed()) {\n\t\t\tfields.sort((a, b) => type.getFieldIndex(this.site, a.name.value) - type.getFieldIndex(this.site, b.name.value));\n\t\t}\n\n\t\tconst irFields = fields.map(f => f.toIR(indent));\n\n\t\treturn StructLiteralExpr.toIRInternal(this.site, type, irFields, this.#constrIndex);\n\t}\n}\n\n/**\n * []{...} expression\n * @package\n */\nclass ListLiteralExpr extends ValueExpr {\n\t#itemTypeExpr;\n\t#itemExprs;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} itemTypeExpr \n\t * @param {ValueExpr[]} itemExprs \n\t */\n\tconstructor(site, itemTypeExpr, itemExprs) {\n\t\tsuper(site);\n\t\tthis.#itemTypeExpr = itemTypeExpr;\n\t\tthis.#itemExprs = itemExprs;\n\t}\n\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `[]${this.#itemTypeExpr.toString()}{${this.#itemExprs.map(itemExpr => itemExpr.toString()).join(', ')}}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope\n\t */\n\tevalInternal(scope) {\n\t\tlet itemType = this.#itemTypeExpr.eval(scope);\n\n\t\tif (itemType instanceof FuncType) {\n\t\t\tthrow this.#itemTypeExpr.typeError(\"content of list can't be func\");\n\t\t}\n\n\t\tfor (let itemExpr of this.#itemExprs) {\n\t\t\tlet itemVal = itemExpr.eval(scope);\n\n\t\t\tif (!itemVal.isInstanceOf(itemExpr.site, itemType)) {\n\t\t\t\tthrow itemExpr.typeError(`expected ${itemType.toString()}, got ${itemVal.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\treturn Instance.new(new ListType(itemType));\n\t}\n\n\tuse() {\n\t\tthis.#itemTypeExpr.use();\n\n\t\tfor (let item of this.#itemExprs) {\n\t\t\titem.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet isBool = this.#itemTypeExpr.type instanceof BoolType;\n\n\t\t// unsure if list literals in untyped Plutus-core accept arbitrary terms, so we will use the more verbose constructor functions \n\t\tlet res = new IR(\"__core__mkNilData(())\");\n\n\t\t// starting from last element, keeping prepending a data version of that item\n\n\t\tfor (let i = this.#itemExprs.length - 1; i >= 0; i--) {\n\t\t\tlet itemIR = this.#itemExprs[i].toIR(indent);\n\n\t\t\tif (isBool) {\n\t\t\t\titemIR = new IR([\n\t\t\t\t\tnew IR(\"__helios__common__boolData(\"),\n\t\t\t\t\titemIR,\n\t\t\t\t\tnew IR(\")\"),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tres = new IR([\n\t\t\t\tnew IR(\"__core__mkCons(\"),\n\t\t\t\titemIR,\n\t\t\t\tnew IR(\", \"),\n\t\t\t\tres,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\n\t\treturn new IR([new IR(\"__core__listData\", this.site), new IR(\"(\"), res, new IR(\")\")]);\n\t}\n}\n\n/**\n * Map[...]...{... : ...} expression\n * @package\n */\nclass MapLiteralExpr extends ValueExpr {\n\t#keyTypeExpr;\n\t#valueTypeExpr;\n\t#pairExprs;\n\n\t/**\n\t * @param {Site} site \n\t * @param {TypeExpr} keyTypeExpr \n\t * @param {TypeExpr} valueTypeExpr\n\t * @param {[ValueExpr, ValueExpr][]} pairExprs \n\t */\n\tconstructor(site, keyTypeExpr, valueTypeExpr, pairExprs) {\n\t\tsuper(site);\n\t\tthis.#keyTypeExpr = keyTypeExpr;\n\t\tthis.#valueTypeExpr = valueTypeExpr;\n\t\tthis.#pairExprs = pairExprs;\n\t}\n\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `Map[${this.#keyTypeExpr.toString()}]${this.#valueTypeExpr.toString()}{${this.#pairExprs.map(([keyExpr, valueExpr]) => `${keyExpr.toString()}: ${valueExpr.toString()}`).join(', ')}}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope\n\t */\n\tevalInternal(scope) {\n\t\tlet keyType = this.#keyTypeExpr.eval(scope);\n\t\tlet valueType = this.#valueTypeExpr.eval(scope);\n\n\t\tif (keyType instanceof FuncType) {\n\t\t\tthrow this.#keyTypeExpr.typeError(\"key-type of Map can't be func\");\n\t\t} else if (valueType instanceof FuncType) {\n\t\t\tthrow this.#valueTypeExpr.typeError(\"value-type of Map can't be func\");\n\t\t}\n\n\t\tfor (let [keyExpr, valueExpr] of this.#pairExprs) {\n\t\t\tlet keyVal = keyExpr.eval(scope);\n\t\t\tlet valueVal = valueExpr.eval(scope);\n\n\t\t\tif (!keyVal.isInstanceOf(keyExpr.site, keyType)) {\n\t\t\t\tthrow keyExpr.typeError(`expected ${keyType.toString()} for map key, got ${keyVal.toString()}`);\n\t\t\t} else if (!valueVal.isInstanceOf(valueExpr.site, valueType)) {\n\t\t\t\tthrow valueExpr.typeError(`expected ${valueType.toString()} for map value, got ${valueVal.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\treturn Instance.new(new MapType(keyType, valueType));\n\t}\n\n\tuse() {\n\t\tthis.#keyTypeExpr.use();\n\t\tthis.#valueTypeExpr.use();\n\n\t\tfor (let [fst, snd] of this.#pairExprs) {\n\t\t\tfst.use();\n\t\t\tsnd.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet isBoolValue = this.#valueTypeExpr.type instanceof BoolType;\n\n\t\t// unsure if list literals in untyped Plutus-core accept arbitrary terms, so we will use the more verbose constructor functions \n\t\tlet res = new IR(\"__core__mkNilPairData(())\");\n\n\t\t// starting from last element, keeping prepending a data version of that item\n\n\t\tfor (let i = this.#pairExprs.length - 1; i >= 0; i--) {\n\t\t\tlet [keyExpr, valueExpr] = this.#pairExprs[i];\n\n\t\t\tlet valueIR = valueExpr.toIR(indent);\n\n\t\t\tif (isBoolValue) {\n\t\t\t\tvalueIR = new IR([\n\t\t\t\t\tnew IR(\"__helios__common__boolData(\"),\n\t\t\t\t\tvalueIR,\n\t\t\t\t\tnew IR(\")\"),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tres = new IR([\n\t\t\t\tnew IR(\"__core__mkCons(\"),\n\t\t\t\tnew IR(\"__core__mkPairData(\"),\n\t\t\t\tkeyExpr.toIR(indent),\n\t\t\t\tnew IR(\",\"),\n\t\t\t\tvalueIR,\n\t\t\t\tnew IR(\")\"),\n\t\t\t\tnew IR(\", \"),\n\t\t\t\tres,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\n\t\treturn new IR([new IR(\"__core__mapData\", this.site), new IR(\"(\"), res, new IR(\")\")]);\n\t}\n}\n\n/**\n * NameTypePair is base class of FuncArg and DataField (differs from StructLiteralField) \n * @package\n */\nclass NameTypePair {\n\t#name;\n\t#typeExpr;\n\n\t/**\n\t * @param {Word} name \n\t * @param {?TypeExpr} typeExpr \n\t */\n\tconstructor(name, typeExpr) {\n\t\tthis.#name = name;\n\t\tthis.#typeExpr = typeExpr;\n\t}\n\n\t/**\n\t * @type {Site}\n\t */\n\tget site() {\n\t\treturn this.#name.site;\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\tisIgnored() {\n\t\treturn this.name.value === \"_\";\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\thasType() {\n\t\treturn this.#typeExpr !== null;\n\t}\n\n\t/**\n\t * Throws an error if called before evalType()\n\t * @type {Type}\n\t */\n\tget type() {\n\t\tif (this.isIgnored()) {\n\t\t\treturn new AnyType();\n\t\t} else if (this.#typeExpr === null) {\n\t\t\tthrow new Error(\"typeExpr not set\");\n\t\t} else {\n\t\t\treturn this.#typeExpr.type;\n\t\t}\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget typeName() {\n\t\tif (this.#typeExpr === null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.#typeExpr.toString();\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.#typeExpr === null) {\n\t\t\treturn this.name.toString();\n\t\t} else {\n\t\t\treturn `${this.name.toString()}: ${this.#typeExpr.toString()}`;\n\t\t}\n\t}\n\n\t/**\n\t * Evaluates the type, used by FuncLiteralExpr and DataDefinition\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalType(scope) {\n\t\tif (this.isIgnored()) {\n\t\t\treturn new AnyType();\n\t\t} else if (this.#typeExpr === null) {\n\t\t\tthrow new Error(\"typeExpr not set\");\n\t\t} else {\n\t\t\treturn this.#typeExpr.eval(scope);\n\t\t}\n\t}\n\n\tuse() {\n\t\tif (this.#typeExpr !== null) {\n\t\t\tthis.#typeExpr.use();\n\t\t}\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\treturn new IR(this.#name.toString(), this.#name.site);\n\t}\n}\n\n/**\n * Function argument class\n * @package\n */\nclass FuncArg extends NameTypePair {\n\t#defaultValueExpr;\n\n\t/**\n\t * @param {Word} name \n\t * @param {?TypeExpr} typeExpr\n\t * @param {null | ValueExpr} defaultValueExpr\n\t */\n\tconstructor(name, typeExpr, defaultValueExpr = null) {\n\t\tsuper(name, typeExpr);\n\n\t\tthis.#defaultValueExpr = defaultValueExpr;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t */\n\tevalDefault(scope) {\n\t\tif (this.#defaultValueExpr != null) {\n\t\t\tconst v = this.#defaultValueExpr.eval(scope);\n\n\t\t\tconst t = this.evalType(scope);\n\n\t\t\tif (!v.isInstanceOf(this.#defaultValueExpr.site, t)) {\n\t\t\t\tthrow this.#defaultValueExpr.site.typeError(`expected ${t.toString()}, got ${v.getType(Site.dummy()).toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {ArgType}\n\t */\n\tevalArgType(scope) {\n\t\tconst t = super.evalType(scope);\n\n\t\treturn new ArgType(this.name, t, this.#defaultValueExpr != null);\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\tconst name = super.toIR();\n\n\t\tif (this.#defaultValueExpr == null) {\n\t\t\treturn name;\n\t\t} else {\n\t\t\treturn new IR([\n\t\t\t\tnew IR(`__useopt__${this.name.toString()}`),\n\t\t\t\tnew IR(\", \"),\n\t\t\t\tname\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IR} bodyIR \n\t * @param {string} name \n\t * @param {IR} defaultIR \n\t * @returns {IR}\n\t */\n\tstatic wrapWithDefaultInternal(bodyIR, name, defaultIR) {\n\t\treturn new IR([\n\t\t\tnew IR(`(${name}) -> {`),\n\t\t\tbodyIR,\n\t\t\tnew IR([\n\t\t\t\tnew IR(`}(__core__ifThenElse(__useopt__${name}, () -> {${name}}, () -> {`),\n\t\t\t\tdefaultIR, \n\t\t\t\tnew IR(\"})())\")\n\t\t\t])\n\t\t]);\n\t}\n\n\t/**\n\t * (argName) -> {\n\t *   <bodyIR>\n\t * }(\n\t *   ifThenElse(\n\t * \t\t__useoptarg__argName,\n\t *  \t() -> {\n\t *        argName\n\t *      },\n\t *      () -> {\n\t *        <defaultValueExpr>\n\t *      }\n\t *   )()\n\t * )\n\t * TODO: indentation\n\t * @param {IR} bodyIR \n\t * @returns {IR}\n\t */\n\twrapWithDefault(bodyIR) {\n\t\tif (this.#defaultValueExpr == null) {\n\t\t\treturn bodyIR;\n\t\t} else {\n\t\t\tconst name = this.name.toString();\n\n\t\t\treturn FuncArg.wrapWithDefaultInternal(bodyIR, name, this.#defaultValueExpr.toIR(\"\"));\n\t\t}\n\t}\n}\n\n/**\n * (..) -> RetTypeExpr {...} expression\n * @package\n */\nclass FuncLiteralExpr extends ValueExpr {\n\t#args;\n\t#retTypeExprs;\n\t#bodyExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {FuncArg[]} args \n\t * @param {(?TypeExpr)[]} retTypeExprs \n\t * @param {ValueExpr} bodyExpr \n\t */\n\tconstructor(site, args, retTypeExprs, bodyExpr) {\n\t\tsuper(site);\n\t\tthis.#args = args;\n\t\tthis.#retTypeExprs = retTypeExprs;\n\t\tthis.#bodyExpr = bodyExpr;\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget argTypes() {\n\t\treturn this.#args.map(a => a.type);\n\t}\n\n\t/**\n\t * @type {string[]}\n\t */\n\tget argTypeNames() {\n\t\treturn this.#args.map(a => a.typeName)\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget retTypes() {\n\t\treturn this.#retTypeExprs.map(e => {\n\t\t\tif (e == null) {\n\t\t\t\treturn new AnyType();\n\t\t\t} else {\n\t\t\t\treturn e.type\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\tif (this.#retTypeExprs.length === 1) {\n\t\t\tlet retTypeExpr = this.#retTypeExprs[0];\n\t\t\tif (retTypeExpr == null) {\n\t\t\t\treturn `(${this.#args.map(a => a.toString()).join(\", \")}) -> {${this.#bodyExpr.toString()}}`;\n\t\t\t} else {\n\t\t\t\treturn `(${this.#args.map(a => a.toString()).join(\", \")}) -> ${retTypeExpr.toString()} {${this.#bodyExpr.toString()}}`;\n\t\t\t}\n\t\t} else {\n\t\t\treturn `(${this.#args.map(a => a.toString()).join(\", \")}) -> (${this.#retTypeExprs.map(e => assertDefined(e).toString()).join(\", \")}) {${this.#bodyExpr.toString()}}`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns \n\t */\n\tevalType(scope) {\n\t\tlet args = this.#args;\n\t\tif (this.isMethod()) {\n\t\t\targs = args.slice(1);\n\t\t}\n\n\t\tlet argTypes = args.map(a => a.evalArgType(scope));\n\n\t\tlet retTypes = this.#retTypeExprs.map(e => {\n\t\t\tif (e == null) {\n\t\t\t\treturn new AnyType();\n\t\t\t} else {\n\t\t\t\treturn e.eval(scope)\n\t\t\t}\n\t\t});\n\n\t\treturn new FuncType(argTypes, retTypes);\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {FuncInstance}\n\t */\n\tevalInternal(scope) {\n\t\tlet fnType = this.evalType(scope);\n\t\t\n\t\t// argTypes is calculated separately again here so it includes self\n\t\tlet argTypes = this.#args.map(a => a.evalType(scope));\n\n\t\tlet res = new FuncInstance(fnType);\n\n\t\tlet subScope = new Scope(scope);\n\t\targTypes.forEach((a, i) => {\n\t\t\tif (!this.#args[i].isIgnored()) {\n\t\t\t\tthis.#args[i].evalDefault(subScope);\n\n\t\t\t\tsubScope.set(this.#args[i].name, Instance.new(a));\n\t\t\t}\n\t\t});\n\n\t\tlet bodyVal = this.#bodyExpr.eval(subScope);\n\n\t\tif (this.#retTypeExprs.length === 1) {\n\t\t\tif (this.#retTypeExprs[0] == null) {\n\t\t\t\tif (bodyVal instanceof MultiInstance) {\n\t\t\t\t\treturn new FuncInstance(new FuncType(fnType.argTypes, bodyVal.values.map(v => v.getType(this.site))));\n\t\t\t\t} else {\n\t\t\t\t\treturn new FuncInstance(new FuncType(fnType.argTypes, bodyVal.getType(this.site)));\n\t\t\t\t}\n\t\t\t} else if (bodyVal instanceof MultiInstance) {\n\t\t\t\tthrow this.#retTypeExprs[0].typeError(\"unexpected multi-value body\");\n\t\t\t} else if (!bodyVal.isInstanceOf(this.#retTypeExprs[0].site, fnType.retTypes[0])) {\n\t\t\t\tthrow this.#retTypeExprs[0].typeError(`wrong return type, expected ${fnType.retTypes[0].toString()} but got ${this.#bodyExpr.type.toString()}`);\n\t\t\t}\n\t\t} else {\n\t\t\tif (bodyVal instanceof MultiInstance) {\n\t\t\t\t/** @type {Instance[]} */\n\t\t\t\tlet bodyVals = bodyVal.values;\n\n\t\t\t\tif (bodyVals.length !== this.#retTypeExprs.length) {\n\t\t\t\t\tthrow this.#bodyExpr.typeError(`expected multi-value function body with ${this.#retTypeExprs.length} values, but got ${bodyVals.length} values`);\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < bodyVals.length; i++) {\n\t\t\t\t\t\tlet v = bodyVals[i];\n\n\t\t\t\t\t\tlet retTypeExpr = assertDefined(this.#retTypeExprs[i]);\n\t\t\t\t\t\tif (!v.isInstanceOf(retTypeExpr.site, fnType.retTypes[i])) {\n\t\t\t\t\t\t\tthrow retTypeExpr.typeError(`wrong return type for value ${i}, expected ${fnType.retTypes[i].toString()} but got ${v.getType(this.#bodyExpr.site).toString()}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow this.#bodyExpr.typeError(`expected multi-value function body, but got ${this.#bodyExpr.type.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\tsubScope.assertAllUsed();\n\n\t\treturn res;\n\t}\n\n\tisMethod() {\n\t\treturn this.#args.length > 0 && this.#args[0].name.toString() == \"self\";\n\t}\n\n\tuse() {\n\t\tfor (let arg of this.#args) {\n\t\t\targ.use();\n\t\t}\n\n\t\tthis.#retTypeExprs.forEach(e => {\n\t\t\tif (e !== null) {\n\t\t\t\te.use();\n\t\t\t}\n\t\t});\n\t\tthis.#bodyExpr.use();\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\targsToIR() {\n\t\tlet args = this.#args.map(a => a.toIR());\n\t\tif (this.isMethod()) {\n\t\t\targs = args.slice(1);\n\t\t}\n\n\t\treturn (new IR(args)).join(\", \");\n\t}\n\n\t/**\n\t * In reverse order, because later opt args might depend on earlier args\n\t * @param {IR} innerIR \n\t * @returns {IR}\n\t */\n\twrapWithDefaultArgs(innerIR) {\n\t\tconst args = this.#args.slice().reverse();\n\n\t\tfor (let arg of args) {\n\t\t\tinnerIR = arg.wrapWithDefault(innerIR);\n\t\t}\n\n\t\treturn innerIR;\n\t}\n\n\t/**\n\t * @param {?string} recursiveName \n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIRInternal(recursiveName, indent = \"\") {\n\t\tlet argsWithCommas = this.argsToIR();\n\n\t\tlet innerIndent = indent;\n\t\tlet methodIndent = indent;\n\t\tif (this.isMethod()) {\n\t\t\tinnerIndent += TAB;\n\t\t}\n\n\t\tif (recursiveName !== null) {\n\t\t\tinnerIndent += TAB;\n\t\t\tmethodIndent += TAB;\n\t\t}\n\n\t\tlet innerIR = this.#bodyExpr.toIR(innerIndent + TAB);\n\n\t\tinnerIR = this.wrapWithDefaultArgs(innerIR);\n\n\t\tlet ir = new IR([\n\t\t\tnew IR(\"(\"),\n\t\t\targsWithCommas,\n\t\t\tnew IR(\") \"), new IR(\"->\", this.site), new IR(` {\\n${innerIndent}${TAB}`),\n\t\t\tinnerIR,\n\t\t\tnew IR(`\\n${innerIndent}}`),\n\t\t]);\n\n\t\t// wrap with 'self'\n\t\tif (this.isMethod()) {\n\t\t\tir = new IR([\n\t\t\t\tnew IR(`(self) -> {\\n${methodIndent}${TAB}`),\n\t\t\t\tir,\n\t\t\t\tnew IR(`\\n${methodIndent}}`),\n\t\t\t]);\n\t\t}\n\n\t\tif (recursiveName !== null) {\n\t\t\tir = new IR([\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tnew IR(recursiveName),\n\t\t\t\tnew IR(`) -> {\\n${indent}${TAB}`),\n\t\t\t\tir,\n\t\t\t\tnew IR(`\\n${indent}}`)\n\t\t\t]);\n\t\t}\n\n\t\treturn ir;\n\t}\n\n\t/**\n\t * @param {string} recursiveName \n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIRRecursive(recursiveName, indent = \"\") {\n\t\treturn this.toIRInternal(recursiveName, indent);\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn this.toIRInternal(null, indent);\n\t}\n}\n\n/**\n * Variable expression\n * @package\n */\nclass ValueRefExpr extends ValueExpr {\n\t#name;\n\t#isRecursiveFunc;\n\n\t/**\n\t * @param {Word} name \n\t */\n\tconstructor(name) {\n\t\tsuper(name.site);\n\t\tthis.#name = name;\n\t\tthis.#isRecursiveFunc = false;\n\t}\n\n\ttoString() {\n\t\treturn this.#name.toString();\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet val = scope.get(this.#name);\n\n\t\tif (val instanceof FuncInstance && val.isRecursive(scope)) {\n\t\t\tthis.#isRecursiveFunc = true;\n\t\t}\n\n\t\treturn val.assertValue(this.#name.site);\n\t}\n\n\tuse() {\n\t\tif (this.value instanceof FuncStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t} else if (this.value instanceof ConstStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet path = this.toString();\n\n\t\tif (this.value instanceof FuncStatementInstance || this.value instanceof ConstStatementInstance) {\n\t\t\tpath = this.value.statement.path;\n\t\t} else if (this.value instanceof BuiltinFuncInstance) {\n\t\t\tpath = this.value.path;\n\t\t}\n\n\t\tlet ir = new IR(path, this.site);\n\n\t\tif (this.#isRecursiveFunc) {\n\t\t\tir = new IR([\n\t\t\t\tir,\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tir,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\t\t\n\t\treturn ir;\n\t}\n}\n\n/**\n * Word::Word::... expression\n * @package\n */\nclass ValuePathExpr extends ValueExpr {\n\t#baseTypeExpr;\n\t#memberName;\n\t#isRecursiveFunc;\n\n\t/**\n\t * @param {TypeExpr} baseTypeExpr \n\t * @param {Word} memberName \n\t */\n\tconstructor(baseTypeExpr, memberName) {\n\t\tsuper(memberName.site);\n\t\tthis.#baseTypeExpr = baseTypeExpr;\n\t\tthis.#memberName = memberName;\n\t\tthis.#isRecursiveFunc = false;\n\t}\n\n\t/**\n\t * @type {Type}\n\t */\n\tget baseType() {\n\t\treturn this.#baseTypeExpr.type;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#baseTypeExpr.toString()}::${this.#memberName.toString()}`;\n\t}\n\n\tisZeroFieldConstructor() {\n\t\tlet type = this.type;\n\n\t\tif (type instanceof EnumMemberStatementType && type.statement.name.value === this.#memberName.value) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if ValuePathExpr constructs a literal enum member with zero field or\n\t * if this baseType is also a baseType of the returned value\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\tif (this.isZeroFieldConstructor()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tlet type = this.type;\n\n\t\t\tif (this.baseType.isBaseOf(this.site, type)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet baseType = this.#baseTypeExpr.eval(scope);\n\t\tassert(baseType.isType());\n\n\t\tlet memberVal = baseType.getTypeMember(this.#memberName);\n\n\t\tif (memberVal instanceof FuncInstance && memberVal.isRecursive(scope)) {\n\t\t\tthis.#isRecursiveFunc = true;\n\t\t}\n\n\t\treturn memberVal.assertValue(this.#memberName.site);\n\t}\n\n\tuse() {\n\t\tthis.#baseTypeExpr.use();\n\n\t\tif (this.value instanceof ConstStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t} else if (this.value instanceof FuncStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\t// if we are directly accessing an enum member as a zero-field constructor we must change the code a bit\n\t\tlet memberVal = this.#baseTypeExpr.type.getTypeMember(this.#memberName);\n\n\t\tif ((memberVal instanceof EnumMemberStatementType) || (memberVal instanceof OptionNoneType)) {\n\t\t\tlet cId = memberVal.getConstrIndex(this.#memberName.site);\n\n\t\t\tassert(cId >= 0);\n\n\t\t\treturn new IR(`__core__constrData(${cId.toString()}, __core__mkNilData(()))`, this.site)\n\t\t} else {\n\t\t\tlet ir = new IR(`${this.#baseTypeExpr.type.path}__${this.#memberName.toString()}`, this.site);\n\n\t\t\tif (this.#isRecursiveFunc) {\n\t\t\t\tir = new IR([\n\t\t\t\t\tir,\n\t\t\t\t\tnew IR(\"(\"),\n\t\t\t\t\tir,\n\t\t\t\t\tnew IR(\")\")\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\treturn ir;\n\t\t}\n\t}\n}\n\n/**\n * Unary operator expression\n * Note: there are no post-unary operators, only pre\n * @package\n */\nclass UnaryExpr extends ValueExpr {\n\t#op;\n\t#a;\n\n\t/**\n\t * @param {SymbolToken} op \n\t * @param {ValueExpr} a \n\t */\n\tconstructor(op, a) {\n\t\tsuper(op.site);\n\t\tthis.#op = op;\n\t\tthis.#a = a;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#op.toString()}${this.#a.toString()}`;\n\t}\n\n\t/**\n\t * Turns an op symbol into an internal name\n\t * @returns {Word}\n\t */\n\ttranslateOp() {\n\t\tlet op = this.#op.toString();\n\t\tlet site = this.#op.site;\n\n\t\tif (op == \"+\") {\n\t\t\treturn new Word(site, \"__pos\");\n\t\t} else if (op == \"-\") {\n\t\t\treturn new Word(site, \"__neg\");\n\t\t} else if (op == \"!\") {\n\t\t\treturn new Word(site, \"__not\");\n\t\t} else {\n\t\t\tthrow new Error(\"unhandled unary op\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet a = this.#a.eval(scope);\n\n\t\tlet fnVal = a.assertValue(this.#a.site).getType(this.site).getTypeMember(this.translateOp());\n\n\t\t// ops are immediately applied\n\t\treturn fnVal.call(this.#op.site, [a]);\n\t}\n\n\tuse() {\n\t\tthis.#a.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet path = this.type.path;\n\n\t\treturn new IR([\n\t\t\tnew IR(`${path}__${this.translateOp().value}`, this.site), new IR(\"(\"),\n\t\t\tthis.#a.toIR(indent),\n\t\t\tnew IR(\")\")\n\t\t]);\n\t}\n}\n\n/**\n * Binary operator expression\n * @package\n */\nclass BinaryExpr extends ValueExpr {\n\t#op;\n\t#a;\n\t#b;\n\t#swap; // swap a and b for commutative ops\n\t#alt; // use alt (each operator can have one overload)\n\n\t/**\n\t * @param {SymbolToken} op \n\t * @param {ValueExpr} a \n\t * @param {ValueExpr} b \n\t */\n\tconstructor(op, a, b) {\n\t\tsuper(op.site);\n\t\tthis.#op = op;\n\t\tthis.#a = a;\n\t\tthis.#b = b;\n\t\tthis.#swap = false;\n\t\tthis.#alt = false;\n\t}\n\n\t/** \n\t * @type {ValueExpr}\n\t */\n\tget first() {\n\t\treturn this.#swap ? this.#b : this.#a;\n\t}\n\n\t/**\n\t * @type {ValueExpr} \n\t */\n\tget second() {\n\t\treturn this.#swap ? this.#a : this.#b;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#a.toString()} ${this.#op.toString()} ${this.#b.toString()}`;\n\t}\n\n\t/**\n\t * Turns op symbol into internal name\n\t * @param {boolean} alt\n\t * @returns {Word}\n\t */\n\ttranslateOp(alt = false) {\n\t\tlet op = this.#op.toString();\n\t\tlet site = this.#op.site;\n\t\tlet name;\n\n\t\tif (op == \"||\") {\n\t\t\tname = \"__or\";\n\t\t} else if (op == \"&&\") {\n\t\t\tname = \"__and\";\n\t\t} else if (op == \"==\") {\n\t\t\tname = \"__eq\";\n\t\t} else if (op == \"!=\") {\n\t\t\tname = \"__neq\";\n\t\t} else if (op == \"<\") {\n\t\t\tname = \"__lt\";\n\t\t} else if (op == \"<=\") {\n\t\t\tname = \"__leq\";\n\t\t} else if (op == \">\") {\n\t\t\tname = \"__gt\";\n\t\t} else if (op == \">=\") {\n\t\t\tname = \"__geq\";\n\t\t} else if (op == \"+\") {\n\t\t\tname = \"__add\";\n\t\t} else if (op == \"-\") {\n\t\t\tname = \"__sub\";\n\t\t} else if (op == \"*\") {\n\t\t\tname = \"__mul\";\n\t\t} else if (op == \"/\") {\n\t\t\tname = \"__div\";\n\t\t} else if (op == \"%\") {\n\t\t\tname = \"__mod\";\n\t\t} else {\n\t\t\tthrow new Error(\"unhandled\");\n\t\t}\n\n\t\tif (alt) {\n\t\t\tname += \"_alt\";\n\t\t}\n\n\t\treturn new Word(site, name);\n\t}\n\n\tisCommutative() {\n\t\tlet op = this.#op.toString();\n\t\treturn op == \"+\" || op == \"*\";\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet a = this.#a.eval(scope);\n\t\tlet b = this.#b.eval(scope);\n\n\t\tassert(a.isValue() && b.isValue());\n\n\t\t/**\n\t\t * @type {?UserError}\n\t\t */\n\t\tlet firstError = null;\n\n\t\tfor (let swap of (this.isCommutative() ? [false, true] : [false])) {\n\t\t\tfor (let alt of [false, true]) {\n\t\t\t\tlet first  = swap ? b : a;\n\t\t\t\tlet second = swap ? a : b;\n\n\t\t\t\ttry {\n\t\t\t\t\tlet fnVal = first.getType(this.site).getTypeMember(this.translateOp(alt));\n\n\t\t\t\t\tlet res = fnVal.call(this.#op.site, [first, second]);\n\n\t\t\t\t\tthis.#swap = swap;\n\t\t\t\t\tthis.#alt  = alt;\n\n\t\t\t\t\treturn res;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof UserError) {\n\t\t\t\t\t\tif (firstError === null) {\n\t\t\t\t\t\t\tfirstError = e;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstError !== null) {\n\t\t\tthrow firstError;\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t}\n\t}\n\n\tuse() {\n\t\tthis.#a.use();\n\t\tthis.#b.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet path = this.first.type.path;\n\n\t\tlet op = this.translateOp(this.#alt).value;\n\n\t\tif (op == \"__and\" || op == \"__or\") {\n\t\t\treturn new IR([\n\t\t\t\tnew IR(`${path}${op}`, this.site), new IR(`(\\n${indent}${TAB}() -> {`),\n\t\t\t\tthis.first.toIR(indent + TAB),\n\t\t\t\tnew IR(`},\\n${indent}${TAB}() -> {`),\n\t\t\t\tthis.second.toIR(indent + TAB),\n\t\t\t\tnew IR(`}\\n${indent})`)\n\t\t\t]);\n\t\t} else {\n\t\t\treturn new IR([\n\t\t\t\tnew IR(`${path}__${op}`, this.site), new IR(\"(\"),\n\t\t\t\tthis.first.toIR(indent),\n\t\t\t\tnew IR(\", \"),\n\t\t\t\tthis.second.toIR(indent),\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\t}\n}\n\n/**\n * Parentheses expression\n * @package\n */\nclass ParensExpr extends ValueExpr {\n\t#exprs;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr[]} exprs\n\t */\n\tconstructor(site, exprs) {\n\t\tsuper(site);\n\t\tthis.#exprs = exprs;\n\t}\n\n\ttoString() {\n\t\treturn `(${this.#exprs.map(e => e.toString()).join(\", \")})`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tif (this.#exprs.length === 1) {\n\t\t\treturn this.#exprs[0].eval(scope);\n\t\t} else {\n\t\t\treturn new MultiInstance(this.#exprs.map(e => {\n\t\t\t\tconst v = e.eval(scope);\n\n\t\t\t\tif (v.getType(e.site) instanceof ErrorType) {\n\t\t\t\t\tthrow e.site.typeError(\"unexpected error call in multi-valued expression\");\n\t\t\t\t}\n\n\t\t\t\treturn v;\n\t\t\t}));\n\t\t}\n\t}\n\n\tuse() {\n\t\tthis.#exprs.forEach(e => e.use());\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tif (this.#exprs.length === 1) {\n\t\t\treturn this.#exprs[0].toIR(indent);\n\t\t} else {\n\t\t\treturn new IR(\n\t\t\t\t[new IR(`(callback) -> {\\n${indent + TAB}callback(\\n${indent + TAB + TAB}`, this.site)]\n\t\t\t\t.concat(new IR(this.#exprs.map(e => e.toIR(indent + TAB + TAB))).join(`,\\n${indent + TAB + TAB}`))\n\t\t\t\t.concat([new IR(`\\n${indent + TAB})\\n${indent}}`)])\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * @package\n */\nclass CallArgExpr extends Token {\n\t#name;\n\t#valueExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {null | Word} name \n\t * @param {ValueExpr} valueExpr \n\t */\n\tconstructor(site, name, valueExpr) {\n\t\tsuper(site);\n\n\t\tthis.#name = name;\n\t\tthis.#valueExpr = valueExpr;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#name?.toString() ?? \"\";\n\t}\n\n\t/**\n\t * @type {ValueExpr}\n\t */\n\tget valueExpr() {\n\t\treturn this.#valueExpr;\n\t}\n\n\t/**\n\t * @type {Instance}\n\t */\n\tget value() {\n\t\treturn this.#valueExpr.value;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisNamed() {\n\t\treturn this.#name != null;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisLiteral() {\n\t\treturn this.#valueExpr.isLiteral();\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn [\n\t\t\tthis.#name != null ? `${this.#name.toString()}: `: \"\",\n\t\t\tthis.#valueExpr.toString()\n\t\t].join(\"\");\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\teval(scope) {\n\t\treturn this.#valueExpr.eval(scope);\n\t}\n\n\tuse() {\n\t\tthis.#valueExpr.use();\n\t}\n}\n\n/**\n * ...(...) expression\n * @package\n */\nclass CallExpr extends ValueExpr {\n\t#fnExpr;\n\t#argExprs;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr} fnExpr \n\t * @param {CallArgExpr[]} argExprs \n\t */\n\tconstructor(site, fnExpr, argExprs) {\n\t\tsuper(site);\n\t\tthis.#fnExpr = fnExpr;\n\t\tthis.#argExprs = argExprs;\n\t}\n\n\tget fnExpr() {\n\t\treturn this.#fnExpr;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#fnExpr.toString()}(${this.#argExprs.map(a => a.toString()).join(\", \")})`;\n\t}\n\n\tisLiteral() {\n\t\tif (this.#fnExpr instanceof ValuePathExpr && this.#fnExpr.baseType.isBaseOf(this.site, this.type)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tconst fnVal = this.#fnExpr.eval(scope);\n\n\t\tconst argVals = this.#argExprs.map(ae => ae.eval(scope));\n\n\t\t/**\n\t\t * @type {Instance[]}\n\t\t */\n\t\tlet posArgVals = [];\n\n\t\tthis.#argExprs.forEach((argExpr, i) => {\n\t\t\tif (!argExpr.isNamed()) {\n\t\t\t\tposArgVals.push(argVals[i]);\n\t\t\t}\n\t\t});\n\n\t\tposArgVals = MultiInstance.flatten(posArgVals);\n\n\t\t/**\n\t\t * @type {{[name: string]: Instance}}\n\t\t */\n\t\tconst namedArgVals = {};\n\n\t\tthis.#argExprs.forEach((argExpr, i) => {\n\t\t\tif (argExpr.isNamed()) {\n\t\t\t\tconst val = argVals[i];\n\n\t\t\t\t// can't be multi instance\n\t\t\t\tif (val instanceof MultiInstance) {\n\t\t\t\t\tthrow argExpr.typeError(\"can't use multiple return values as named argument\");\n\t\t\t\t}\n\n\t\t\t\tnamedArgVals[argExpr.name] = val;\n\t\t\t}\n\t\t});\n\n\t\tassert(posArgVals.every(pav => pav != undefined));\n\n\t\treturn fnVal.call(this.site, posArgVals, namedArgVals);\n\t}\n\n\tuse() {\n\t\tthis.#fnExpr.use();\n\n\t\tfor (let arg of this.#argExprs) {\n\t\t\targ.use();\n\t\t}\n\t}\n\n\t/**\n\t * Don't call this inside eval() because param types won't yet be complete.\n\t * @type {FuncType}\n\t */\n\tget fn() {\n\t\treturn assertClass(this.#fnExpr.value.getType(this.#fnExpr.site), FuncType);\n\t}\n\n\t/**\n\t * @returns {[ValueExpr[], IR[]]} - first list are positional args, second list named args and remaining opt args\n\t */\n\texpandArgs() {\n\t\tconst fn = this.fn;\n\t\tconst nNonOptArgs = fn.nNonOptArgs;\n\n\t\t/**\n\t\t * @type {ValueExpr[]}\n\t\t */\n\t\tconst positional = [];\n\n\t\tthis.#argExprs.forEach(ae => {\n\t\t\tif (!ae.isNamed()) {\n\t\t\t\tpositional.push(ae.valueExpr);\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @type {IR[]}\n\t\t */\n\t\tconst namedOptional = [];\n\n\t\tthis.#argExprs.forEach(ae => {\n\t\t\tif (ae.isNamed()) {\n\t\t\t\tconst i = fn.getNamedIndex(ae.site, ae.name);\n\n\t\t\t\tif (i < nNonOptArgs) {\n\t\t\t\t\tpositional[i] = ae.valueExpr;\n\t\t\t\t} else {\n\t\t\t\t\tnamedOptional[i - nNonOptArgs] = new IR([\n\t\t\t\t\t\tnew IR(\"true\"),\n\t\t\t\t\t\tnew IR(\", \"),\n\t\t\t\t\t\tae.valueExpr.toIR()\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (let i = nNonOptArgs; i < fn.nArgs; i++) {\n\t\t\tif (namedOptional[i - nNonOptArgs] == undefined) {\n\t\t\t\tnamedOptional[i - nNonOptArgs] = new IR([\n\t\t\t\t\tnew IR(\"false\"),\n\t\t\t\t\tnew IR(\", \"),\n\t\t\t\t\tnew IR(\"()\")\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\treturn [positional.filter(p => p != undefined), namedOptional];\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tconst fn = this.fn;\n\n\t\t/**\n\t\t * First step is to eliminate the named args\n\t\t * @type {[ValueExpr[], IR[]]}\n\t\t */\n\t\tconst [positional, namedOptional] = this.expandArgs();\n\n\t\tif (positional.some(e => (!e.isLiteral()) && (e.value instanceof MultiInstance))) {\n\t\t\t// count the number of final args\n\t\t\tlet n = 0;\n\n\t\t\tpositional.forEach((e, i) => {\n\t\t\t\tif ((!e.isLiteral()) && (e.value instanceof MultiInstance)) {\n\t\t\t\t\tn += e.value.values.length;\n\t\t\t\t} else {\n\t\t\t\t\tn += 1;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tn += namedOptional.length;\n\n\t\t\tif (n > fn.nArgs) {\n\t\t\t\tnamedOptional.splice(0, n - fn.nArgs);\n\t\t\t}\n\n\t\t\tlet names = [];\n\n\t\t\tfor (let i = 0; i < fn.nArgs; i++) {\n\t\t\t\tif (i >= fn.nNonOptArgs) {\n\t\t\t\t\tnames.push(`__useopt__x${i}`);\n\t\t\t\t}\n\n\t\t\t\tnames.push(`x${i}`);\n\t\t\t}\n\n\t\t\tlet ir = new IR([\n\t\t\t\tthis.#fnExpr.toIR(),\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tnew IR(names.map(n => new IR(n))).join(\", \"),\n\t\t\t\tnew IR(\")\", this.site)\n\t\t\t]);\n\n\t\t\tfor (let namedIR of namedOptional.slice().reverse()) {\n\t\t\t\tconst n2 = assertDefined(names.pop());\n\t\t\t\tconst n1 = assertDefined(names.pop());\n\t\t\t\tassert(n1.startsWith(\"__useopt__\"));\n\n\t\t\t\tir = new IR([\n\t\t\t\t\tnew IR(\"(\"),\n\t\t\t\t\tnew IR(n1),\n\t\t\t\t\tnew IR(\", \"),\n\t\t\t\t\tnew IR(n2),\n\t\t\t\t\tnew IR(\") -> {\"),\n\t\t\t\t\tir,\n\t\t\t\t\tnew IR(\"}(\"),\n\t\t\t\t\tassertDefined(namedIR), // bool - val pair\n\t\t\t\t\tnew IR(\")\")\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tfor (let i = positional.length - 1; i >= 0; i--) {\n\t\t\t\tconst e = positional[i];\n\n\t\t\t\tif ((!e.isLiteral()) && (e.value instanceof MultiInstance)) {\n\t\t\t\t\tconst nMulti = e.value.values.length;\n\t\t\t\t\tconst multiNames = [];\n\t\t\t\t\tconst multiOpt = [];\n\n\t\t\t\t\twhile (multiNames.length < nMulti) {\n\t\t\t\t\t\tmultiNames.unshift(assertDefined(names.pop()));\n\n\t\t\t\t\t\tif (names.length > 0 && names[names.length-1] == `__useopt__${multiNames[0]}`) {\n\t\t\t\t\t\t\tmultiOpt.unshift(assertDefined(names.pop()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (multiOpt.length > 0) {\n\t\t\t\t\t\tir = new IR([\n\t\t\t\t\t\t\tnew IR(\"(\"),\n\t\t\t\t\t\t\tnew IR(multiOpt.map(n => new IR(n))).join(\", \"),\n\t\t\t\t\t\t\tnew IR(\") -> {\"),\n\t\t\t\t\t\t\tir,\n\t\t\t\t\t\t\tnew IR(\"}(\"),\n\t\t\t\t\t\t\tnew IR(multiOpt.map(n => new IR(\"true\"))).join(\", \"),\n\t\t\t\t\t\t\tnew IR(\")\")\n\t\t\t\t\t\t])\n\t\t\t\t\t}\n\n\t\t\t\t\tir = new IR([\n\t\t\t\t\t\te.toIR(),\n\t\t\t\t\t\tnew IR(\"((\"),\n\t\t\t\t\t\tnew IR(multiNames.map(n => new IR(n))).join(\", \"),\n\t\t\t\t\t\tnew IR(\") -> {\"),\n\t\t\t\t\t\tir,\n\t\t\t\t\t\tnew IR(\"})\")\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tconst name = assertDefined(names.pop());\n\n\t\t\t\t\tif (names.length > 0 && names[names.length - 1] == `__useopt__${name}`) {\n\t\t\t\t\t\tir = new IR([\n\t\t\t\t\t\t\tnew IR(\"(\"),\n\t\t\t\t\t\t\tnew IR(assertDefined(names.pop())),\n\t\t\t\t\t\t\tnew IR(\") -> {\"),\n\t\t\t\t\t\t\tnew IR(\"}(true)\")\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\n\t\t\t\t\tir = new IR([\n\t\t\t\t\t\tnew IR(\"(\"),\n\t\t\t\t\t\tnew IR(name),\n\t\t\t\t\t\tnew IR(\") -> {\"),\n\t\t\t\t\t\tir,\n\t\t\t\t\t\tnew IR(\"}(\"),\n\t\t\t\t\t\te.toIR(),\n\t\t\t\t\t\tnew IR(\")\")\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ir;\n\t\t} else {\n\t\t\tif (positional.length + namedOptional.length > fn.nArgs) {\n\t\t\t\tnamedOptional.splice(0, positional.length + namedOptional.length - fn.nArgs);\n\t\t\t}\n\n\t\t\tlet args = positional.map((a, i) => {\n\t\t\t\tlet ir = a.toIR(indent);\n\n\t\t\t\tif (i >= fn.nNonOptArgs) {\n\t\t\t\t\tir = new IR([\n\t\t\t\t\t\tnew IR(\"true, \"),\n\t\t\t\t\t\tir\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\treturn ir;\n\t\t\t}).concat(namedOptional);\n\n\t\t\treturn new IR([\n\t\t\t\tthis.#fnExpr.toIR(indent),\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\t(new IR(args)).join(\", \"),\n\t\t\t\tnew IR(\")\", this.site)\n\t\t\t]);\n\t\t}\n\t}\n}\n\n/**\n *  ... . ... expression\n * @package\n */\nclass MemberExpr extends ValueExpr {\n\t#objExpr;\n\t#memberName;\n\t#isRecursiveFunc;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr} objExpr \n\t * @param {Word} memberName \n\t */\n\tconstructor(site, objExpr, memberName) {\n\t\tsuper(site);\n\t\tthis.#objExpr = objExpr;\n\t\tthis.#memberName = memberName;\n\t\tthis.#isRecursiveFunc = false;\n\t}\n\n\ttoString() {\n\t\treturn `${this.#objExpr.toString()}.${this.#memberName.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet objVal = this.#objExpr.eval(scope);\n\n\t\tlet memberVal = objVal.assertValue(this.#objExpr.site).getInstanceMember(this.#memberName);\n\n\t\tif (memberVal instanceof FuncInstance && memberVal.isRecursive(scope)) {\n\t\t\tthis.#isRecursiveFunc = true;\n\t\t}\n\n\t\treturn memberVal;\n\t}\n\n\tuse() {\n\t\tthis.#objExpr.use();\n\n\t\tif (this.value instanceof FuncStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t} else if (this.value instanceof ConstStatementInstance) {\n\t\t\tthis.value.statement.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\t// members can be functions so, field getters are also encoded as functions for consistency\n\n\t\tlet objPath = this.#objExpr.type.path;\n\n\t\t// if we are getting the member of an enum member we should check if it a field or method, because for a method we have to use the parent type\n\t\tif ((this.#objExpr.type instanceof EnumMemberStatementType) && (!this.#objExpr.type.statement.hasField(this.#memberName))) {\n\t\t\tobjPath = this.#objExpr.type.statement.parent.path;\n\t\t}\n\n\t\t// if the memberVal was a ParamFuncValue then the member name might need to be modified if the output type of some callbacks is a Bool\n\t\tif (this.value instanceof ParamFuncValue && this.value.correctMemberName !== null) {\n\t\t\tthis.#memberName = new Word(this.#memberName.site, this.value.correctMemberName());\n\t\t}\n\n\t\tlet ir = new IR(`${objPath}__${this.#memberName.toString()}`, this.site);\n\n\t\tif (this.#isRecursiveFunc) {\n\t\t\tir = new IR([\n\t\t\t\tir,\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tir,\n\t\t\t\tnew IR(\")\"),\n\t\t\t]);\n\t\t}\n\n\t\treturn new IR([\n\t\t\tir, new IR(\"(\"),\n\t\t\tthis.#objExpr.toIR(indent),\n\t\t\tnew IR(\")\"),\n\t\t]);\n\t}\n}\n\n/**\n * if-then-else expression \n * @package\n */\nclass IfElseExpr extends ValueExpr {\n\t#conditions;\n\t#branches;\n\n\t/**\n\t * @param {Site} site \n\t * @param {ValueExpr[]} conditions \n\t * @param {ValueExpr[]} branches \n\t */\n\tconstructor(site, conditions, branches) {\n\t\tassert(branches.length == conditions.length + 1);\n\t\tassert(branches.length > 1);\n\n\t\tsuper(site);\n\t\tthis.#conditions = conditions;\n\t\tthis.#branches = branches;\n\t}\n\n\ttoString() {\n\t\tlet s = \"\";\n\t\tfor (let i = 0; i < this.#conditions.length; i++) {\n\t\t\ts += `if (${this.#conditions[i].toString()}) {${this.#branches[i].toString()}} else `;\n\t\t}\n\n\t\ts += `{${this.#branches[this.#conditions.length].toString()}}`;\n\n\t\treturn s;\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {?Type} prevType\n\t * @param {Type} newType\n\t */\n\tstatic reduceBranchType(site, prevType, newType) {\n\t\tif (prevType === null || prevType instanceof ErrorType) {\n\t\t\treturn newType;\n\t\t} else if (newType instanceof ErrorType) {\n\t\t\treturn prevType;\n\t\t} else if (!prevType.isBaseOf(site, newType)) {\n\t\t\tif (newType.isBaseOf(site, prevType)) {\n\t\t\t\treturn newType;\n\t\t\t} else {\n\t\t\t\t// check if enumparent is base of newType and of prevType\n\t\t\t\tif (newType.isEnumMember()) {\n\t\t\t\t\tconst parentType = newType.parentType(Site.dummy());\n\n\t\t\t\t\tif (parentType.isBaseOf(site, prevType) && parentType.isBaseOf(site, newType)) {\n\t\t\t\t\t\treturn parentType;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow site.typeError(\"inconsistent types\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn prevType;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {?Type[]} prevTypes\n\t * @param {Instance} newValue\n\t * @returns {?Type[]}\n\t */\n\tstatic reduceBranchMultiType(site, prevTypes, newValue) {\n\t\tif (!(newValue instanceof MultiInstance) && newValue.getType(site) instanceof ErrorType) {\n\t\t\treturn prevTypes;\n\t\t}\n\n\t\tconst newTypes = (newValue instanceof MultiInstance) ?\n\t\t\tnewValue.values.map(v => v.getType(site)) :\n\t\t\t[newValue.getType(site)];\n\n\t\tif (prevTypes === null) {\n\t\t\treturn newTypes;\n\t\t} else if (prevTypes.length !== newTypes.length) {\n\t\t\tthrow site.typeError(\"inconsistent number of multi-value types\");\n\t\t} else {\n\t\t\treturn prevTypes.map((pt, i) => IfElseExpr.reduceBranchType(site, pt, newTypes[i]));\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tfor (let c of this.#conditions) {\n\t\t\tlet cVal = c.eval(scope);\n\t\t\tif (!cVal.isInstanceOf(c.site, BoolType)) {\n\t\t\t\tthrow c.typeError(\"expected bool\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Supports multiple return values\n\t\t * @type {?Type[]}\n\t\t */\n\t\tlet branchMultiType = null;\n\n\t\tfor (let b of this.#branches) {\n\t\t\tlet branchVal = b.eval(scope);\n\n\t\t\tbranchMultiType = IfElseExpr.reduceBranchMultiType(\n\t\t\t\tb.site, \n\t\t\t\tbranchMultiType, \n\t\t\t\tbranchVal\n\t\t\t);\n\t\t}\n\n\t\tif (branchMultiType === null) {\n\t\t\t// i.e. every branch throws an error\n\t\t\treturn Instance.new(new ErrorType());\n\t\t} else  {\n\t\t\treturn Instance.new(branchMultiType);\n\t\t}\n\t}\n\n\tuse() {\n\t\tfor (let c of this.#conditions) {\n\t\t\tc.use();\n\t\t}\n\n\t\tfor (let b of this.#branches) {\n\t\t\tb.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet n = this.#conditions.length;\n\n\t\t// each branch actually returns a function to allow deferred evaluation\n\t\tlet res = new IR([\n\t\t\tnew IR(\"() -> {\"),\n\t\t\tthis.#branches[n].toIR(indent),\n\t\t\tnew IR(\"}\")\n\t\t]);\n\n\t\t// TODO: nice indentation\n\t\tfor (let i = n - 1; i >= 0; i--) {\n\t\t\tres = new IR([\n\t\t\t\tnew IR(\"__core__ifThenElse(\"),\n\t\t\t\tthis.#conditions[i].toIR(indent),\n\t\t\t\tnew IR(\", () -> {\"),\n\t\t\t\tthis.#branches[i].toIR(indent),\n\t\t\t\tnew IR(\"}, () -> {\"),\n\t\t\t\tres,\n\t\t\t\tnew IR(\"()})\"),\n\t\t\t]);\n\t\t}\n\n\t\treturn new IR([res, new IR(\"()\", this.site)]);\n\t}\n}\n\n/**\n * DestructExpr is for the lhs-side of assignments and for switch cases\n * @package\n */\nclass DestructExpr {\n\t#name;\n\t#typeExpr;\n\t#destructExprs;\n\n\t/**\n\t * @param {Word} name - use an underscore as a sink\n\t * @param {?TypeExpr} typeExpr \n\t * @param {DestructExpr[]} destructExprs\n\t */\n\tconstructor(name, typeExpr, destructExprs = []) {\n\t\tthis.#name = name;\n\t\tthis.#typeExpr = typeExpr;\n\t\tthis.#destructExprs = destructExprs;\n\n\t\tassert (!(this.#typeExpr == null && this.#destructExprs.length > 0));\n\t}\n\n\t/**\n\t * @type {Site}\n\t */\n\tget site() {\n\t\treturn this.#name.site;\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\thasDestructExprs() {\n\t\treturn this.#destructExprs.length > 0;\n\t}\n\n\tisIgnored() {\n\t\treturn this.name.value === \"_\";\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\thasType() {\n\t\treturn this.#typeExpr !== null;\n\t}\n\n\t/**\n\t * Throws an error if called before evalType()\n\t * @type {Type}\n\t */\n\tget type() {\n\t\tif (this.#typeExpr === null) {\n\t\t\tif (this.isIgnored()) {\n\t\t\t\treturn new AnyType();\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"typeExpr not set\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.#typeExpr.type;\n\t\t}\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget typeName() {\n\t\tif (this.#typeExpr === null) {\n\t\t\treturn new Word(this.site, \"\");\n\t\t} else {\n\t\t\treturn new Word(this.#typeExpr.site, this.#typeExpr.toString());\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.#typeExpr === null) {\n\t\t\treturn this.name.toString();\n\t\t} else {\n\t\t\tlet destructStr = \"\";\n\n\t\t\tif (this.#destructExprs.length > 0) {\n\t\t\t\tdestructStr = `{${this.#destructExprs.map(de => de.toString()).join(\", \")}}`;\n\t\t\t}\n\n\t\t\tif (this.isIgnored()) {\n\t\t\t\treturn `${this.#typeExpr.toString()}${destructStr}`;\n\t\t\t} else {\n\t\t\t\treturn `${this.name.toString()}: ${this.#typeExpr.toString()}${destructStr}`;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Evaluates the type, used by FuncLiteralExpr and DataDefinition\n\t * @param {Scope} scope \n\t * @returns {Type}\n\t */\n\tevalType(scope) {\n\t\tif (this.#typeExpr === null) {\n\t\t\tif (this.isIgnored()) {\n\t\t\t\treturn new AnyType();\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"typeExpr not set\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.#typeExpr.eval(scope);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @param {Type} upstreamType \n\t */\n\tevalDestructExprs(scope, upstreamType) {\n\t\tif (this.#destructExprs.length > 0) {\n\t\t\tif (!(upstreamType instanceof AnyType) && upstreamType.nFields(this.site) != this.#destructExprs.length) {\n\t\t\t\tthrow this.site.typeError(`wrong number of destruct fields, expected ${upstreamType.nFields(this.site)}, got ${this.#destructExprs.length}`);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < this.#destructExprs.length; i++) {\n\n\t\t\t\tthis.#destructExprs[i].evalInternal(\n\t\t\t\t\tscope, \n\t\t\t\t\tupstreamType.getFieldType(this.site, i), \n\t\t\t\t\ti\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @param {Type} upstreamType\n\t * @param {number} i\n\t */\n\tevalInternal(scope, upstreamType, i) {\n\t\tif (this.hasType()) {\n\t\t\tlet t = this.evalType(scope)\n\n\t\t\tassert(t.isType());\n\n\t\t\t// differs from upstreamType because can be enum parent\n\t\t\tlet checkType = t;\n\n\t\t\t// if t is enum variant, get parent instead (exact variant is checked at runtime instead)\n\t\t\tif (t.isEnumMember() && !upstreamType.isEnumMember()) {\n\t\t\t\tcheckType = t.parentType(this.site);\n\t\t\t}\n\n\t\t\tif (!Instance.new(upstreamType).isInstanceOf(this.site, checkType)) {\n\t\t\t\tthrow this.site.typeError(`expected ${checkType.toString()} for destructure field ${i+1}, got ${upstreamType.toString()}`);\n\t\t\t}\n\n\t\t\tif (!this.isIgnored()) {\n\t\t\t\t// TODO: take into account ghost type parameters\n\t\t\t\tscope.set(this.name, Instance.new(t));\n\t\t\t}\n\n\t\t\tthis.evalDestructExprs(scope, t);\n\t\t} else {\n\t\t\tif (!this.isIgnored()) {\n\t\t\t\t// TODO: take into account ghost type parameters\n\t\t\t\tscope.set(this.name, Instance.new(upstreamType));\n\t\t\t}\n\n\t\t\tthis.evalDestructExprs(scope, upstreamType);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope\n\t * @param {Type} caseType\n\t */\n\tevalInSwitchCase(scope, caseType) {\n\t\tif (!this.isIgnored()) {\n\t\t\tscope.set(this.#name, Instance.new(caseType));\n\t\t}\n\n\t\tthis.evalDestructExprs(scope, caseType)\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @param {Type} upstreamType\n\t * @param {number} i\n\t */\n\tevalInAssignExpr(scope, upstreamType, i) {\n\t\tlet t = this.evalType(scope)\n\n\t\tassert(t.isType());\n\n\t\t// differs from upstreamType because can be enum parent\n\t\tlet checkType = t;\n\n\t\t// if t is enum variant, get parent instead (exact variant is checked at runtime instead)\n\t\tif (t.isEnumMember() && !upstreamType.isEnumMember()) {\n\t\t\tcheckType = t.parentType(this.site);\n\t\t}\n\n\t\tif (!Instance.new(upstreamType).isInstanceOf(this.site, checkType)) {\n\t\t\tthrow this.site.typeError(`expected ${checkType.toString()} for rhs ${i+1}, got ${upstreamType.toString()}`);\n\t\t}\n\n\t\tif (!this.isIgnored()) {\n\t\t\t// TODO: take into account ghost type parameters\n\t\t\tscope.set(this.name, Instance.new(t));\n\t\t}\n\n\t\tthis.evalDestructExprs(scope, t);\n\t}\n\n\tuse() {\n\t\tif (this.#typeExpr !== null) {\n\t\t\tthis.#typeExpr.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} argIndex \n\t * @returns {IR}\n\t */\n\ttoNameIR(argIndex) {\n\t\tif (this.isIgnored()) {\n\t\t\treturn new IR(`__lhs_${argIndex}`);\n\t\t} else {\n\t\t\treturn new IR(this.#name.toString(), this.#name.site)\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} fieldIndex\n\t * @param {boolean} isSwitchCase\n\t * @returns {string}\n\t */\n\tgetFieldFn(fieldIndex, isSwitchCase = false) {\n\t\tif (isSwitchCase) {\n\t\t\treturn `__helios__common__field_${fieldIndex}`;\n\t\t}\n\n\t\tconst type = this.type;\n\n\t\tif (type.isEnumMember()) {\n\t\t\treturn `__helios__common__field_${fieldIndex}`;\n\t\t} else if (type instanceof StructStatementType) {\n\t\t\tif (type.nFields(Site.dummy()) == 1) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\treturn `__helios__common__tuple_field_${fieldIndex}`;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @param {IR} inner \n\t * @param {string} objName \n\t * @param {number} fieldIndex \n\t * @param {string} fieldFn\n\t * @returns {IR}\n\t */\n\twrapDestructIRInternal(indent, inner, objName, fieldIndex, fieldFn) {\n\t\tif (this.isIgnored() && this.#destructExprs.length == 0) {\n\t\t\treturn inner;\n\t\t} else {\n\t\t\tconst baseName = this.isIgnored() ? `${objName}_${fieldIndex}` : this.#name.toString();\n\n\t\t\tfor (let i = this.#destructExprs.length - 1; i >= 0; i--) {\n\t\t\t\tinner = this.#destructExprs[i].wrapDestructIRInternal(indent + TAB, inner, baseName, i, this.getFieldFn(i));\n\t\t\t}\n\n\t\t\tlet getter = `${fieldFn}(${objName})`;\n\n\t\t\t// assert correct constructor index\n\t\t\tif (this.#typeExpr && this.type.isEnumMember()) {\n\t\t\t\tconst constrIdx = this.type.getConstrIndex(this.#typeExpr.site);\n\n\t\t\t\tgetter = `__helios__common__assert_constr_index(${getter}, ${constrIdx})`;\n\t\t\t}\n\t\t\t\n\t\t\treturn new IR([\n\t\t\t\tnew IR(\"(\"),\n\t\t\t\tnew IR(baseName, this.#name.site),\n\t\t\t\tnew IR(\") \"),\n\t\t\t\tnew IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}`),\n\t\t\t\tinner,\n\t\t\t\tnew IR(`\\n${indent}}(${getter})`),\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @param {IR} inner \n\t * @param {number} argIndex \n\t * @param {boolean} isSwitchCase\n\t * @returns {IR}\n\t */\n\twrapDestructIR(indent, inner, argIndex, isSwitchCase = false) {\n\t\tif (this.#destructExprs.length == 0) {\n\t\t\treturn inner;\n\t\t} else {\n\t\t\tconst baseName = this.isIgnored() ? `__lhs_${argIndex}` : this.#name.toString();\n\n\t\t\tfor (let i = this.#destructExprs.length - 1; i >= 0; i--) {\n\t\t\t\tconst de = this.#destructExprs[i];\n\n\t\t\t\tinner = de.wrapDestructIRInternal(indent + TAB, inner, baseName, i, this.getFieldFn(i, isSwitchCase));\n\t\t\t}\n\n\t\t\treturn inner;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIR() {\n\t\treturn new IR(this.#name.toString(), this.#name.site);\n\t}\n}\n\n/**\n * Switch case for a switch expression\n * @package\n */\nclass SwitchCase extends Token {\n\t#lhs;\n\t#bodyExpr;\n\n\t/** @type {?number} */\n\t#constrIndex;\n\n\t/**\n\t * @param {Site} site \n\t * @param {DestructExpr} lhs\n\t * @param {ValueExpr} bodyExpr \n\t */\n\tconstructor(site, lhs, bodyExpr) {\n\t\tsuper(site);\n\t\tthis.#lhs = lhs;\n\t\tthis.#bodyExpr = bodyExpr;\n\t\tthis.#constrIndex = null;\n\t}\n\n\t/**\n\t * @type {ValueExpr}\n\t */\n\tget body() {\n\t\treturn this.#bodyExpr;\n\t}\n\n\t/**\n\t * Used by parser to check if typeExpr reference the same base enum\n\t * @type {Word} - word representation of type\n\t */\n\tget memberName() {\n\t\treturn this.#lhs.typeName;\n\t}\n\n\tisDataMember() {\n\t\tswitch (this.memberName.value) {\n\t\t\tcase \"Int\":\n\t\t\tcase \"[]Data\":\n\t\t\tcase \"ByteArray\":\n\t\t\tcase \"Map[Data]Data\":\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tget constrIndex() {\n\t\tif (this.#constrIndex === null) {\n\t\t\tthrow new Error(\"constrIndex not yet set\");\n\t\t} else {\n\t\t\treturn this.#constrIndex;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `${this.#lhs.toString()} => ${this.#bodyExpr.toString()}`;\n\t}\n\n\t/**\n\t * Evaluates the switch type and body value of a case.\n\t * @param {Scope} scope \n\t * @param {Type} enumType\n\t * @returns {Instance}\n\t */\n\tevalEnumMember(scope, enumType) {\n\t\tconst caseType = enumType.getTypeMember(this.memberName).assertType(this.memberName.site);\n\n\t\tthis.#constrIndex = caseType.getConstrIndex(this.memberName.site);\n\n\t\tassert(this.#constrIndex >= 0);\n\n\t\tconst caseScope = new Scope(scope);\n\n\t\tthis.#lhs.evalInSwitchCase(caseScope, caseType);\n\n\t\tconst bodyVal = this.#bodyExpr.eval(caseScope);\n\n\t\tcaseScope.assertAllUsed();\n\n\t\treturn bodyVal;\n\t}\n\n\t/**\n\t * Evaluates the switch type and body value of a case.\n\t * @param {Scope} scope\n\t * @returns {Instance}\n\t */\n\tevalDataMember(scope) {\n\t\t/** @type {Type} */\n\t\tlet memberType;\n\n\t\tswitch (this.memberName.value) {\n\t\t\tcase \"Int\":\n\t\t\t\tmemberType = new IntType();\n\t\t\t\tbreak;\n\t\t\tcase \"ByteArray\":\n\t\t\t\tmemberType = new ByteArrayType();\n\t\t\t\tbreak;\n\t\t\tcase \"[]Data\":\n\t\t\t\tmemberType = new ListType(new RawDataType());\n\t\t\t\tbreak;\n\t\t\tcase \"Map[Data]Data\":\n\t\t\t\tmemberType = new MapType(new RawDataType(), new RawDataType());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlet maybeMemberType = scope.get(this.memberName);\n\t\t\t\tif (maybeMemberType instanceof Type) {\n\t\t\t\t\tmemberType = maybeMemberType;\n\n\t\t\t\t\tif (!(memberType instanceof EnumStatementType)) {\n\t\t\t\t\t\tthrow this.memberName.typeError(\"expected an enum type\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow this.memberName.typeError(\"expected a type\");\n\t\t\t\t}\n\t\t}\n\n\t\tconst caseScope = new Scope(scope);\n\n\t\tthis.#lhs.evalInSwitchCase(caseScope, memberType);\n\n\t\tconst bodyVal = this.#bodyExpr.eval(caseScope);\n\n\t\tcaseScope.assertAllUsed();\n\n\t\treturn bodyVal;\n\t}\n\n\tuse() {\n\t\tthis.#bodyExpr.use();\n\t}\n\n\t/**\n\t * Accept an arg because will be called with the result of the controlexpr\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet inner = this.#bodyExpr.toIR(indent + TAB);\n\n\t\tinner = this.#lhs.wrapDestructIR(indent, inner, 0, true);\n\n\t\treturn new IR([\n\t\t\tnew IR(\"(\"),\n\t\t\tthis.#lhs.toNameIR(0), \n\t\t\tnew IR(\") \"),\n\t\t\tnew IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}`),\n\t\t\tinner,\n\t\t\tnew IR(`\\n${indent}}`),\n\t\t]);\n\t}\n}\n\n/**\n * @package\n */\nclass UnconstrDataSwitchCase extends SwitchCase {\n\t#intVarName;\n\t#lstVarName;\n\n\t/**\n\t * @param {Site} site \n\t * @param {?Word} intVarName \n\t * @param {?Word} lstVarName \n\t * @param {ValueExpr} bodyExpr \n\t */\n\tconstructor(site, intVarName, lstVarName, bodyExpr) {\n\t\tsuper(site, new DestructExpr(new Word(site, \"_\"), new TypeRefExpr(new Word(site, \"(Int, []Data)\"))), bodyExpr);\n\n\t\tthis.#intVarName = intVarName;\n\t\tthis.#lstVarName = lstVarName;\n\t}\n\n\tisDataMember() {\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\treturn `(${this.#intVarName === null ? \"\" : this.#intVarName.value + \": \"}Int, ${this.#lstVarName === null ? \"\" : this.#lstVarName.value + \": \"} []Data) => ${this.body.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @param {Type} enumType\n\t * @returns {Instance}\n\t */\n\tevalEnumMember(scope, enumType) {\n\t\tthrow new Error(\"not available\");\n\t}\n\n\t/**\n\t * Evaluates the switch type and body value of a case.\n\t * @param {Scope} scope\n\t * @returns {Instance}\n\t */\n\tevalDataMember(scope) {\n\t\tif (this.#intVarName !== null || this.#lstVarName !== null) {\n\t\t\tlet caseScope = new Scope(scope);\n\n\t\t\tif (this.#intVarName !== null) {\n\t\t\t\tcaseScope.set(this.#intVarName, Instance.new(new IntType()));\n\t\t\t}\n\n\t\t\tif (this.#lstVarName !== null) {\n\t\t\t\tcaseScope.set(this.#lstVarName, Instance.new(new ListType(new RawDataType())));\n\t\t\t}\n\n\t\t\tlet bodyVal = this.body.eval(caseScope);\n\n\t\t\tcaseScope.assertAllUsed();\n\n\t\t\treturn bodyVal;\n\t\t} else {\n\t\t\treturn this.body.eval(scope);\n\t\t}\n\t}\n\n\t/**\n\t * Accepts two args\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn new IR([\n\t\t\tnew IR(`(data) -> {\\n${indent}${TAB}`),\n\t\t\tnew IR(`(pair) -> {\\n${indent}${TAB}${TAB}`),\n\t\t\tnew IR(`(${this.#intVarName !== null ? this.#intVarName.toString() : \"_\"}, ${this.#lstVarName !== null ? this.#lstVarName.toString() : \"_\"}) `), new IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}${TAB}${TAB}`),\n\t\t\tthis.body.toIR(indent + TAB + TAB + TAB),\n\t\t\tnew IR(`\\n${indent}${TAB}${TAB}}(__core__iData(__core__fstPair(pair)), __core__listData(__core__sndPair(pair)))`),\n\t\t\tnew IR(`\\n${indent}${TAB}}(__core__unConstrData(data))`),\n\t\t\tnew IR(`\\n${indent}}`)\n\t\t]);\n\t}\n}\n\n/**\n * Default switch case\n * @package\n */\nclass SwitchDefault extends Token {\n\t#bodyExpr;\n\n\t/**\n\t * @param {Site} site\n\t * @param {ValueExpr} bodyExpr\n\t */\n\tconstructor(site, bodyExpr) {\n\t\tsuper(site);\n\t\tthis.#bodyExpr = bodyExpr;\n\t}\n\n\ttoString() {\n\t\treturn `else => ${this.#bodyExpr.toString()}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\teval(scope) {\n\t\treturn this.#bodyExpr.eval(scope);\n\t}\n\n\tuse() {\n\t\tthis.#bodyExpr.use();\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\treturn new IR([\n\t\t\tnew IR(`(_) `), new IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}`),\n\t\t\tthis.#bodyExpr.toIR(indent + TAB),\n\t\t\tnew IR(`\\n${indent}}`)\n\t\t]);\n\t}\n}\n\n/**\n * Parent class of EnumSwitchExpr and DataSwitchExpr\n */\nclass SwitchExpr extends ValueExpr {\n\t#controlExpr;\n\t#cases;\n\t#defaultCase;\n\n\t/** \n\t * @param {Site} site\n\t * @param {ValueExpr} controlExpr - input value of the switch\n\t * @param {SwitchCase[]} cases\n\t * @param {?SwitchDefault} defaultCase\n\t*/\n\tconstructor(site, controlExpr, cases, defaultCase = null) {\n\t\tsuper(site);\n\t\tthis.#controlExpr = controlExpr;\n\t\tthis.#cases = cases;\n\t\tthis.#defaultCase = defaultCase;\n\t}\n\n\tget controlExpr() {\n\t\treturn this.#controlExpr;\n\t}\n\n\tget cases() {\n\t\treturn this.#cases;\n\t}\n\n\tget defaultCase() {\n\t\treturn this.#defaultCase;\n\t}\n\n\t/**\n\t * If there isn't enough coverage then we can simply set the default case to void, so the other branches can be error, print or assert\n\t */\n\tsetDefaultCaseToVoid() {\n\t\tthis.#defaultCase = new SwitchDefault(this.site, new VoidExpr(this.site));\n\t}\n\n\ttoString() {\n\t\treturn `${this.#controlExpr.toString()}.switch{${this.#cases.map(c => c.toString()).join(\", \")}${this.#defaultCase === null ? \"\" : \", \" + this.#defaultCase.toString()}}`;\n\t}\n\n\tuse() {\n\t\tthis.#controlExpr.use();\n\n\t\tfor (let c of this.#cases) {\n\t\t\tc.use();\n\t\t}\n\n\t\tif (this.#defaultCase !== null) {\n\t\t\tthis.#defaultCase.use();\n\t\t}\n\t}\n}\n\n/**\n * Switch expression for Enum, with SwitchCases and SwitchDefault as children\n * @package\n */\nclass EnumSwitchExpr extends SwitchExpr {\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet controlVal = this.controlExpr.eval(scope);\n\t\tlet enumType = controlVal.getType(this.controlExpr.site);\n\t\tlet nEnumMembers = enumType.nEnumMembers(this.controlExpr.site);\n\n\t\t// check that we have enough cases to cover the enum members\n\t\tif (this.defaultCase === null && nEnumMembers > this.cases.length) {\n\t\t\t// mutate defaultCase to VoidExpr\n\t\t\tthis.setDefaultCaseToVoid();\n\t\t}\n\n\t\t/** @type {?Type[]} */\n\t\tlet branchMultiType = null;\n\n\t\tfor (let c of this.cases) {\n\t\t\tlet branchVal = c.evalEnumMember(scope, enumType);\n\t\n\t\t\tbranchMultiType = IfElseExpr.reduceBranchMultiType(\n\t\t\t\tc.site, \n\t\t\t\tbranchMultiType, \n\t\t\t\tbranchVal\n\t\t\t);\n\t\t}\n\n\t\tif (this.defaultCase !== null) {\n\t\t\tlet defaultVal = this.defaultCase.eval(scope);\n\n\t\t\tbranchMultiType = IfElseExpr.reduceBranchMultiType(\n\t\t\t\tthis.defaultCase.site,\n\t\t\t\tbranchMultiType, \n\t\t\t\tdefaultVal\n\t\t\t);\n\t\t}\n\n\t\tif (branchMultiType === null) {\n\t\t\treturn Instance.new(new ErrorType());\n\t\t} else {\n\t\t\treturn Instance.new(branchMultiType);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\tlet cases = this.cases.slice();\n\n\t\t/** @type {SwitchCase | SwitchDefault} */\n\t\tlet last;\n\t\tif (this.defaultCase !== null) {\n\t\t\tlast = this.defaultCase;\n\t\t} else {\n\t\t\tlast = assertDefined(cases.pop());\n\t\t}\n\n\t\tlet n = cases.length;\n\n\t\tlet res = last.toIR(indent + TAB + TAB + TAB);\n\n\t\tfor (let i = n - 1; i >= 0; i--) {\n\t\t\tres = new IR([\n\t\t\t\tnew IR(`__core__ifThenElse(__core__equalsInteger(i, ${cases[i].constrIndex.toString()}), () -> {`),\n\t\t\t\tcases[i].toIR(indent + TAB + TAB + TAB),\n\t\t\t\tnew IR(`}, () -> {`),\n\t\t\t\tres,\n\t\t\t\tnew IR(`})()`)\n\t\t\t]);\n\t\t}\n\n\t\treturn new IR([\n\t\t\tnew IR(`(e) `), new IR(\"->\", this.site), new IR(` {\\n${indent}${TAB}(\\n${indent}${TAB}${TAB}(i) -> {\\n${indent}${TAB}${TAB}${TAB}`),\n\t\t\tres,\n\t\t\tnew IR(`\\n${indent}${TAB}${TAB}}(__core__fstPair(__core__unConstrData(e)))\\n${indent}${TAB})(e)\\n${indent}}(`),\n\t\t\tthis.controlExpr.toIR(indent),\n\t\t\tnew IR(\")\"),\n\t\t]);\n\t}\n}\n\n/**\n * Switch expression for Data\n * @package\n */\nclass DataSwitchExpr extends SwitchExpr {\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet controlVal = this.controlExpr.eval(scope);\n\t\tlet dataType = controlVal.getType(this.controlExpr.site);\n\n\t\tlet controlSite = this.controlExpr.site;\n\t\tif (!dataType.isBaseOf(controlSite, new RawDataType())) {\n\t\t\tthrow this.controlExpr.typeError(`expected Data type, got ${controlVal.getType(controlSite).toString()}`);\n\t\t}\n\n\t\t// check that we have enough cases to cover the enum members\n\t\tif (this.defaultCase === null && this.cases.length < 5) {\n\t\t\t// mutate defaultCase to VoidExpr\n\t\t\tthis.setDefaultCaseToVoid();\n\t\t}\n\n\t\t/** @type {?Type[]} */\n\t\tlet branchMultiType = null;\n\n\t\tfor (let c of this.cases) {\n\t\t\tlet branchVal = c.evalDataMember(scope);\n\n\t\t\tbranchMultiType = IfElseExpr.reduceBranchMultiType(\n\t\t\t\tc.site, \n\t\t\t\tbranchMultiType, \n\t\t\t\tbranchVal\n\t\t\t);\n\t\t}\n\n\t\tif (this.defaultCase !== null) {\n\t\t\tlet defaultVal = this.defaultCase.eval(scope);\n\n\t\t\tbranchMultiType = IfElseExpr.reduceBranchMultiType(\n\t\t\t\tthis.defaultCase.site, \n\t\t\t\tbranchMultiType, \n\t\t\t\tdefaultVal\n\t\t\t);\n\t\t}\n\n\t\tif (branchMultiType === null) {\n\t\t\t// only possible if each branch is an error\n\t\t\treturn Instance.new(new ErrorType());\n\t\t} else {\n\t\t\treturn Instance.new(branchMultiType);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {IR}\n\t */\n\ttoIR(indent = \"\") {\n\t\t/** @type {[?IR, ?IR, ?IR, ?IR, ?IR]} */\n\t\tlet cases = [null, null, null, null, null]; // constr, map, list, int, byteArray\n\n\t\tfor (let c of this.cases) {\n\t\t\tlet ir = c.toIR(indent + TAB + TAB);\n\n\t\t\tswitch (c.memberName.value) {\n\t\t\t\tcase \"ByteArray\":\n\t\t\t\t\tcases[4] = ir;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Int\":\n\t\t\t\t\tcases[3] = ir;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"[]Data\":\n\t\t\t\t\tcases[2] = ir;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Map[Data]Data\":\n\t\t\t\t\tcases[1] = ir;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"(Int, []Data)\":\n\t\t\t\t\tcases[0] = ir;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (cases[0] !== null) {\n\t\t\t\t\t\tthrow new Error(\"should've been caught before\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcases[0] = ir;\n\t\t\t}\n\t\t}\n\n\t\tif (this.defaultCase !== null) {\n\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\tif (cases[i] === null) {\n\t\t\t\t\tcases[i] = new IR(`${indent}${TAB}def`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet res = new IR([\n\t\t\tnew IR(`${indent}__core__chooseData(e, `, this.site),\n\t\t\tnew IR(cases.map(c => assertDefined(c))).join(\", \"),\n\t\t\tnew IR(`${indent})`)\n\t\t]);\n\n\t\tif (this.defaultCase !== null) {\n\t\t\tres = new IR([\n\t\t\t\tnew IR(`${indent}(def) -> {\\n`),\n\t\t\t\tres,\n\t\t\t\tnew IR(`\\n${indent}}(`),\n\t\t\t\tthis.defaultCase.toIR(indent),\n\t\t\t\tnew IR(`)`)\n\t\t\t]);\n\t\t}\n\n\t\tres = new IR([\n\t\t\tnew IR(`${indent}(e) -> {\\n`),\n\t\t\tres,\n\t\t\tnew IR(\"(e)\"),\n\t\t\tnew IR(`${indent}}(`),\n\t\t\tthis.controlExpr.toIR(indent),\n\t\t\tnew IR(\")\")\n\t\t]);\n\n\t\treturn res;\n\t}\n}\n\n\n////////////////////////////////\n// Section 16: Literal functions\n////////////////////////////////\n\n/**\n * @package\n * @param {Site} site\n * @param {Type} type - expected type\n * @param {any} value - result of JSON.parse(string)\n * @param {string} path - context for debugging\n * @returns {ValueExpr}\n */\nfunction buildLiteralExprFromJson(site, type, value, path) {\n\tif (value === null) {\n\t\tthrow site.typeError(`expected non-null value for parameter '${path}'`);\n\t} else if (type instanceof BoolType) {\n\t\tif (typeof value == \"boolean\") {\n\t\t\treturn new PrimitiveLiteralExpr(new BoolLiteral(site, value));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected boolean for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof StringType) {\n\t\tif (typeof value == \"string\") {\n\t\t\treturn new PrimitiveLiteralExpr(new StringLiteral(site, value));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected string for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof IntType) {\n\t\tif (typeof value == \"number\") {\n\t\t\tif (value%1 == 0.0) {\n\t\t\t\treturn new PrimitiveLiteralExpr(new IntLiteral(site, BigInt(value)));\n\t\t\t} else {\n\t\t\t\tthrow site.typeError(`expected round number for parameter '${path}', got '${value}'`);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow site.typeError(`expected number for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof ByteArrayType || type instanceof HashType) {\n\t\tif (value instanceof Array) {\n\t\t\t/**\n\t\t\t * @type {number[]}\n\t\t\t */\n\t\t\tconst bytes = [];\n\n\t\t\tfor (let item of value) {\n\t\t\t\tif (typeof item == \"number\" && item%1 == 0.0 && item >= 0 && item < 256) {\n\t\t\t\t\tbytes.push(item);\n\t\t\t\t} else {\n\t\t\t\t\tthrow site.typeError(`expected uint8[] for parameter '${path}', got '${value}'`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/** @type {ValueExpr} */\n\t\t\tlet litExpr = new PrimitiveLiteralExpr(new ByteArrayLiteral(site, bytes));\n\n\t\t\tif (type instanceof HashType) {\n\t\t\t\tlitExpr = new CallExpr(site, new ValuePathExpr(new TypeRefExpr(new Word(site, type.toString()), type), new Word(site, \"new\")), [new CallArgExpr(litExpr.site, null, litExpr)]);\n\t\t\t}\n\n\t\t\treturn litExpr;\n\t\t} else {\n\t\t\tthrow site.typeError(`expected array for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof ListType) {\n\t\tif (value instanceof Array) {\n\t\t\t/**\n\t\t\t * @type {ValueExpr[]}\n\t\t\t */\n\t\t\tconst items = [];\n\n\t\t\tfor (let item of value) {\n\t\t\t\titems.push(buildLiteralExprFromJson(site, type.itemType, item, path + \"[]\"));\n\t\t\t}\n\n\t\t\treturn new ListLiteralExpr(site, new TypeExpr(site, type.itemType), items);\n\t\t} else {\n\t\t\tthrow site.typeError(`expected array for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof MapType) {\n\t\t/**\n\t\t * @type {[ValueExpr, ValueExpr][]}\n\t\t */\n\t\tconst pairs = [];\n\n\t\tif (value instanceof Object && type.keyType instanceof StringType) {\n\t\t\tfor (let key in value) {\n\t\t\t\tpairs.push([new PrimitiveLiteralExpr(new StringLiteral(site, key)), buildLiteralExprFromJson(site, type.valueType, value[key], path + \".\" + key)]);\n\t\t\t}\n\t\t} else if (value instanceof Array) {\n\t\t\tfor (let item of value) {\n\t\t\t\tif (item instanceof Array && item.length == 2) {\n\t\t\t\t\tpairs.push([\n\t\t\t\t\t\tbuildLiteralExprFromJson(site, type.keyType, item[0], path + \"[0]\"),\n\t\t\t\t\t\tbuildLiteralExprFromJson(site, type.valueType, item[1], path + \"[1]\"),\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow site.typeError(`expected array of pairs for parameter '${path}', got '${value}'`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow site.typeError(`expected array or object for parameter '${path}', got '${value}'`);\n\t\t}\n\n\t\treturn new MapLiteralExpr(\n\t\t\tsite, \n\t\t\tnew TypeExpr(site, type.keyType), \n\t\t\tnew TypeExpr(site, type.valueType),\n\t\t\tpairs\n\t\t);\n\t} else if (type instanceof StructStatementType || type instanceof EnumMemberStatementType) {\n\t\tif (value instanceof Object) {\n\t\t\tconst nFields = type.statement.nFields(site);\n\n\t\t\t/**\n\t\t\t * @type {StructLiteralField[]}\n\t\t\t */\n\t\t\tconst fields = new Array(nFields);\n\n\t\t\tconst nActual = Object.entries(value).length;\n\n\t\t\tif (nFields != nActual) {\n\t\t\t\tthrow site.typeError(`expected object with ${nFields.toString} fields for parameter '${path}', got '${value}' with ${nActual.toString()} fields`);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < nFields; i++) {\n\t\t\t\tconst key = type.statement.getFieldName(i);\n\n\t\t\t\tconst subValue = value[key];\n\n\t\t\t\tif (subValue === undefined) {\n\t\t\t\t\tthrow site.typeError(`expected object with key '${key}' for parameter '${path}', got '${value}`);\n\t\t\t\t}\n\n\t\t\t\tconst fieldType = type.statement.getFieldType(site, i);\n\n\t\t\t\tconst valueExpr = buildLiteralExprFromJson(site, fieldType, subValue, path + \".\" + key);\n\n\t\t\t\tfields[i] = new StructLiteralField(nFields == 1 ? null : new Word(site, key), valueExpr);\n\t\t\t}\n\n\t\t\treturn new StructLiteralExpr(new TypeExpr(site, type), fields);\n\t\t} else {\n\t\t\tthrow site.typeError(`expected object for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else {\n\t\tthrow site.typeError(`unhandled parameter type '${type.toString()}', for parameter ${path}`);\n\t}\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Type} type - expected type\n * @param {UplcValue} value \n * @param {string} path - context for debugging\n * @returns {ValueExpr}\n */\nfunction buildLiteralExprFromValue(site, type, value, path) {\n\tif (type instanceof BoolType) {\n\t\tif (value instanceof UplcBool) {\n\t\t\treturn new PrimitiveLiteralExpr(new BoolLiteral(site, value.bool));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected UplcBool for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof StringType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof ByteArrayData) {\n\t\t\treturn new PrimitiveLiteralExpr(new StringLiteral(site, bytesToText(value.data.bytes)));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected ByteArrayData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof IntType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof IntData) {\n\t\t\treturn new PrimitiveLiteralExpr(new IntLiteral(site, value.data.value));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected IntData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof ByteArrayType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof ByteArrayData) {\n\t\t\treturn new PrimitiveLiteralExpr(new ByteArrayLiteral(site, value.data.bytes));\n\t\t} else {\n\t\t\tthrow site.typeError(`expected ByteArrayData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof ListType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof ListData) {\n\t\t\t/**\n\t\t\t * @type {ValueExpr[]}\n\t\t\t */\n\t\t\tconst items = [];\n\n\t\t\tfor (let data of value.data.list) {\n\t\t\t\titems.push(buildLiteralExprFromValue(site, type.itemType, new UplcDataValue(site, data), path + \"[]\"));\n\t\t\t}\n\n\t\t\treturn new ListLiteralExpr(site, new TypeExpr(site, type.itemType), items);\n\t\t} else {\n\t\t\tthrow site.typeError(`expected ListData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof MapType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof MapData) {\n\t\t\t/**\n\t\t\t * @type {[ValueExpr, ValueExpr][]}\n\t\t\t */\n\t\t\tconst pairs = [];\n\n\t\t\tfor (let dataPair of value.data.map) {\n\t\t\t\tconst keyExpr = buildLiteralExprFromValue(site, type.keyType, new UplcDataValue(site, dataPair[0]), path + \"{key}\");\n\t\t\t\tconst valueExpr = buildLiteralExprFromValue(site, type.valueType, new UplcDataValue(site, dataPair[1]), path + \"{value}\");\n\n\t\t\t\tpairs.push([keyExpr, valueExpr]);\n\t\t\t}\n\n\t\t\treturn new MapLiteralExpr(\n\t\t\t\tsite, \n\t\t\t\tnew TypeExpr(site, type.keyType), \n\t\t\t\tnew TypeExpr(site, type.valueType),\n\t\t\t\tpairs\n\t\t\t);\n\t\t} else {\n\t\t\tthrow site.typeError(`expected ListData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else if (type instanceof StructStatementType || type instanceof EnumMemberStatementType) {\n\t\tif (value instanceof UplcDataValue && value.data instanceof ConstrData) {\n\t\t\tconst nFields = type.statement.nFields(site);\n\t\t\t/**\n\t\t\t * @type {StructLiteralField[]}\n\t\t\t */\n\t\t\tconst fields = new Array(nFields);\n\n\t\t\tif (nFields != value.data.fields.length) {\n\t\t\t\tthrow site.typeError(`expected ConstrData with ${nFields.toString} fields for parameter '${path}', got '${value}' with ${value.data.fields.length.toString()} fields`);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < nFields; i++) {\n\t\t\t\tconst f = value.data.fields[i];\n\n\t\t\t\tconst fieldType = type.statement.getFieldType(site, i);\n\n\t\t\t\tconst valueExpr = buildLiteralExprFromValue(site, fieldType, new UplcDataValue(site, f), path + \".\" + i.toString());\n\n\t\t\t\tfields[i] = new StructLiteralField(nFields == 1 ? null : new Word(site, type.statement.getFieldName(i)), valueExpr);\n\t\t\t}\n\n\t\t\treturn new StructLiteralExpr(new TypeExpr(site, type), fields);\n\t\t} else {\n\t\t\tthrow site.typeError(`expected ConstrData for parameter '${path}', got '${value}'`);\n\t\t}\n\t} else {\n\t\tthrow site.typeError(`unhandled parameter type '${type.toString()}', for parameter ${path}`);\n\t}\n}\n\n\n////////////////////////////////////\n// Section 17: Helios AST statements\n////////////////////////////////////\n\n/**\n * Base class for all statements\n * Doesn't return a value upon calling eval(scope)\n * @package\n */\nclass Statement extends Token {\n\t#name;\n\t#used;\n\t#basePath; // set by the parent Module\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t */\n\tconstructor(site, name) {\n\t\tsuper(site);\n\t\tthis.#name = name;\n\t\tthis.#used = false;\n\t\tthis.#basePath = \"__user\";\n\t}\n\n\t/**\n\t * @param {string} basePath \n\t */\n\tsetBasePath(basePath) {\n\t\tthis.#basePath = basePath;\n\t}\n\n\tget path() {\n\t\treturn `${this.#basePath}__${this.name.toString()}`;\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\t/**\n\t * @type {boolean}\n\t */\n\tget used() {\n\t\treturn this.#used;\n\t}\n\n\t/**\n\t * @param {ModuleScope} scope \n\t */\n\teval(scope) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\tuse() {\n\t\tthis.#used = true;\n\t}\n\n\t/**\n\t * @param {Uint8Array} mask\n\t */\n\thideUnused(mask) {\n\t\tif (!this.#used) {\n\t\t\tif (this.site.endSite === null) {\n\t\t\t\tmask.fill(0, this.site.startPos);\n\t\t\t} else {\n\t\t\t\tmask.fill(0, this.site.startPos, this.site.endSite.startPos);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns IR of statement.\n\t * No need to specify indent here, because all statements are top-level\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Each field is given a separate ImportStatement\n * @package\n */\nclass ImportStatement extends Statement {\n\t#origName;\n\t#moduleName;\n\n\t/** \n\t * @type {?Statement} \n\t */\n\t#origStatement;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name\n\t * @param {Word} origName\n\t * @param {Word} moduleName\n\t */\n\tconstructor(site, name, origName, moduleName) {\n\t\tsuper(site, name);\n\t\tthis.#origName = origName;\n\t\tthis.#moduleName = moduleName;\n\t\tthis.#origStatement = null;\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget moduleName() {\n\t\treturn this.#moduleName;\n\t}\n\n\t/**\n\t * @type {Statement}\n\t */\n\tget origStatement() {\n\t\tif (this.#origStatement == null) {\n\t\t\tthrow new Error(\"should be set\");\n\t\t} else {\n\t\t\treturn this.#origStatement;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleScope} scope\n\t * @returns {EvalEntity}\n\t */\n\tevalInternal(scope) {\n\t\tlet importedScope = scope.get(this.#moduleName);\n\n\t\tif (importedScope instanceof Scope) {\n\t\t\tlet importedEntity = importedScope.get(this.#origName);\n\n\t\t\tif (importedEntity instanceof Scope) {\n\t\t\t\tthrow this.#origName.typeError(`can't import a module from a module`);\n\t\t\t} else {\n\t\t\t\treturn importedEntity;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow this.#moduleName.typeError(`${this.name.toString()} isn't a module`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ModuleScope} scope \n\t */\n\teval(scope) {\n\t\tlet v = this.evalInternal(scope);\n\n\t\tif (v instanceof FuncStatementInstance || v instanceof ConstStatementInstance || v instanceof StatementType) {\n\t\t\tthis.#origStatement = assertClass(v.statement, Statement);\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected import entity\");\n\t\t}\n\n\t\tscope.set(this.name, v);\n\t}\n\n\tuse() {\n\t\tsuper.use();\n\n\t\tif (this.#origStatement === null) {\n\t\t\tthrow new Error(\"should be set\");\n\t\t} else {\n\t\t\tthis.#origStatement.use();\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\t// import statements only have a scoping function and don't do anything to the IR\n\t}\n}\n\n/**\n * Const value statement\n * @package\n */\nclass ConstStatement extends Statement {\n\t/**\n\t * @type {?TypeExpr}\n\t */\n\t#typeExpr;\n\n\t/**\n\t * @type {ValueExpr}\n\t */\n\t#valueExpr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t * @param {?TypeExpr} typeExpr - can be null in case of type inference\n\t * @param {ValueExpr} valueExpr \n\t */\n\tconstructor(site, name, typeExpr, valueExpr) {\n\t\tsuper(site, name);\n\t\tthis.#typeExpr = typeExpr;\n\t\tthis.#valueExpr = valueExpr;\n\t}\n\n\tget type() {\n\t\tif (this.#typeExpr === null) {\n\t\t\treturn this.#valueExpr.type;\n\t\t} else {\n\t\t\treturn this.#typeExpr.type;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string | UplcValue} value \n\t */\n\tchangeValue(value) {\n\t\tlet type = this.type;\n\t\tlet site = this.#valueExpr.site;\n\n\t\tif (typeof value == \"string\") {\n\t\t\tthis.#valueExpr = buildLiteralExprFromJson(site, type, JSON.parse(value), this.name.value);\n\t\t} else {\n\t\t\tthis.#valueExpr = buildLiteralExprFromValue(site, type, value, this.name.value);\n\t\t}\n\t}\n\n\t/**\n\t * Use this to change a value of something that is already typechecked.\n\t * @param {UplcData} data\n\t */\n\tchangeValueSafe(data) {\n\t\tconst type = this.type;\n\t\tconst site = this.#valueExpr.site;\n\n\t\tif ((new BoolType()).isBaseOf(site, type)) {\n\t\t\tthis.#valueExpr = new PrimitiveLiteralExpr(new BoolLiteral(site, data.index == 1));\n\t\t} else {\n\t\t\tthis.#valueExpr = new LiteralDataExpr(site, type, data);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `const ${this.name.toString()}${this.#typeExpr === null ? \"\" : \": \" + this.#typeExpr.toString()} = ${this.#valueExpr.toString()};`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\tlet value = this.#valueExpr.eval(scope);\n\n\t\t/** @type {Type} */\n\t\tlet type;\n\n\t\tif (this.#typeExpr === null) {\n\t\t\tif (!this.#valueExpr.isLiteral()) {\n\t\t\t\tthrow this.typeError(\"can't infer type\");\n\t\t\t}\n\n\t\t\ttype = this.#valueExpr.type;\n\t\t} else {\n\t\t\ttype = this.#typeExpr.eval(scope);\n\n\t\t\tif (!value.isInstanceOf(this.#valueExpr.site, type)) {\n\t\t\t\tthrow this.#valueExpr.typeError(\"wrong type\");\n\t\t\t}\n\t\t}\n\n\t\treturn new ConstStatementInstance(type, this);\n\t}\n\n\t/**\n\t * Evaluates rhs and adds to scope\n\t * @param {TopScope} scope \n\t */\n\teval(scope) {\n\t\tscope.set(this.name, this.evalInternal(scope));\n\t}\n\n\tuse() {\n\t\tif (!this.used) {\n\t\t\tsuper.use();\n\n\t\t\tthis.#valueExpr.use();\n\n\t\t\tif (this.#typeExpr !== null) {\n\t\t\t\tthis.#typeExpr.use();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {IR}\n\t */\n\ttoIRInternal() {\n\t\treturn new IR([\n\t\t\tnew IR(\"const(\", this.site),\n\t\t\tthis.#valueExpr.toIR(),\n\t\t\tnew IR(\")\")\n\t\t])\n\t\t\n\t}\n\n\t/**\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\tmap.set(this.path, this.toIRInternal());\n\t}\n}\n\n/**\n * Single field in struct or enum member\n * @package\n */\nclass DataField extends NameTypePair {\n\t/**\n\t * @param {Word} name \n\t * @param {TypeExpr} typeExpr \n\t */\n\tconstructor(name, typeExpr) {\n\t\tsuper(name, typeExpr);\n\t}\n}\n\n/**\n * Base class for struct and enum member\n * @package\n */\nclass DataDefinition extends Statement {\n\t#fields;\n\n\t/** @type {Set<string>} */\n\t#usedAutoMethods;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t * @param {DataField[]} fields \n\t */\n\tconstructor(site, name, fields) {\n\t\tsuper(site, name);\n\t\tthis.#fields = fields;\n\t\tthis.#usedAutoMethods = new Set();\n\t}\n\n\t/**\n\t * @type {Type}\n\t */\n\tget type() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\tget fields() {\n\t\treturn this.#fields.slice();\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Returns index of a field.\n\t * Returns -1 if not found.\n\t * @param {Word} name \n\t * @returns {number}\n\t */\n\tfindField(name) {\n\t\tlet found = -1;\n\t\tlet i = 0;\n\t\tfor (let f of this.#fields) {\n\t\t\tif (f.name.toString() == name.toString()) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\treturn found;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {boolean}\n\t */\n\thasField(name) {\n\t\treturn this.findField(name) != -1;\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {boolean}\n\t */\n\thasMember(name) {\n\t\treturn this.hasField(name) || name.value == \"copy\";\n\t}\n\n\ttoString() {\n\t\treturn `${this.name.toString()} {${this.#fields.map(f => f.toString()).join(\", \")}}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope\n\t */\n\tevalInternal(scope) {\n\t\tfor (let f of this.#fields) {\n\t\t\tlet fieldType = f.evalType(scope);\n\n\t\t\tif (fieldType instanceof FuncType) {\n\t\t\t\tthrow f.site.typeError(\"field can't be function type\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\treturn this.#fields.length;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {number} i \n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\treturn this.#fields[i].type;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} name \n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tconst i = this.findField(new Word(Site.dummy(), name));\n\n\t\tif (i == -1) {\n\t\t\tthrow site.typeError(`field ${name} not find in ${this.toString()}`);\n\t\t} else {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t/**\n\t * @param {number} i\n\t * @returns {string}\n\t */\n\tgetFieldName(i) {\n\t\treturn this.#fields[i].name.toString();\n\t}\n\t\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\tthrow site.typeError(`'${this.name.value}' isn't an enum type`);\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name) {\n\t\tif (this.hasField(name)) {\n\t\t\tthrow name.referenceError(`'${this.name.toString()}::${name.toString()}' undefined (did you mean '${this.name.toString()}.${name.toString()}'?)`);\n\t\t} else {\n\t\t\tthrow name.referenceError(`'${this.name.toString()}::${name.toString()}' undefined`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets insance member value.\n\t * If dryRun == true usage is triggered\n\t * @param {Word} name \n\t * @param {boolean} dryRun \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name, dryRun = false) {\n\t\tswitch (name.value) {\n\t\t\tcase \"copy\":\n\t\t\t\tthis.#usedAutoMethods.add(name.value);\n\t\t\t\treturn Instance.new(new FuncType(this.#fields.map(f => new ArgType(f.name, f.type, true)), this.type));\n\t\t\tdefault:\n\t\t\t\tlet i = this.findField(name);\n\n\t\t\t\tif (i == -1) {\n\t\t\t\t\tthrow name.referenceError(`'${this.name.toString()}.${name.toString()}' undefined`);\n\t\t\t\t} else {\n\t\t\t\t\treturn Instance.new(this.#fields[i].type);\n\t\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tuse() {\n\t\tif (!this.used) {\n\t\t\tsuper.use();\n\t\t\t\n\t\t\tfor (let f of this.#fields) {\n\t\t\t\tf.use();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {IRDefinitions} map \n\t * @param {string[]} getterNames\n\t */\n\tcopyToIR(map, getterNames) {\n\t\tconst key = `${this.path}__copy`;\n\n\t\t// using existing IR generators as much as possible\n\n\t\tlet ir = StructLiteralExpr.toIRInternal(this.site, this.type, this.#fields.map(df => new IR(df.name.value)), this.getConstrIndex(this.site));\n\n\t\t// wrap with defaults\n\n\t\tfor (let i = getterNames.length - 1; i >= 0; i--) {\n\t\t\tconst fieldName = this.#fields[i].name.toString();\n\n\t\t\tir = FuncArg.wrapWithDefaultInternal(ir, fieldName, new IR([\n\t\t\t\tnew IR(getterNames[i]),\n\t\t\t\tnew IR(\"(self)\")\n\t\t\t]))\n\t\t}\n\n\t\tir = new IR([\n\t\t\tnew IR(\"(self) -> {\"),\n\t\t\tnew IR(\"(\"),\n\t\t\tnew IR(this.#fields.map(f => new IR(`__useopt__${f.name.toString()}, ${f.name.toString()}`))).join(\", \"),\n\t\t\tnew IR(\") -> {\"),\n\t\t\tir,\n\t\t\tnew IR(\"}}\")\n\t\t]);\n\n\t\tmap.set(key, ir);\n\t}\n\n\t/**\n\t * Doesn't return anything, but sets its IRdef in the map\n\t * @param {IRDefinitions} map\n\t * @param {boolean} isConstr\n\t */\n\ttoIR(map, isConstr = true) {\n\t\tconst getterBaseName = isConstr ? \"__helios__common__field\" : \"__helios__common__tuple_field\";\n\n\t\t/**\n\t\t * @type {string[]}\n\t\t */\n\t\tconst getterNames = [];\n\n\t\t// add a getter for each field\n\t\tfor (let i = 0; i < this.#fields.length; i++) {\n\t\t\tlet f = this.#fields[i];\n\t\t\tlet key = `${this.path}__${f.name.toString()}`;\n\t\t\tgetterNames.push(key);\n\t\t\tlet isBool = f.type instanceof BoolType;\n\n\t\t\t/**\n\t\t\t * @type {IR}\n\t\t\t */\n\t\t\tlet getter;\n\n\t\t\tif (i < 20) {\n\n\t\t\t\tgetter = new IR(`${getterBaseName}_${i}`, f.site);\n\n\t\t\t\tif (isBool) {\n\t\t\t\t\tgetter = new IR([\n\t\t\t\t\t\tnew IR(\"(self) \"), new IR(\"->\", f.site), new IR(\" {\"),\n\t\t\t\t\t\tnew IR(`__helios__common__unBoolData(${getterBaseName}_${i}(self))`),\n\t\t\t\t\t\tnew IR(\"}\"),\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet inner = isConstr ? new IR(\"__core__sndPair(__core__unConstrData(self))\") : new IR(\"__core__unListData(self)\");\n\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tinner = new IR([new IR(\"__core__tailList(\"), inner, new IR(\")\")]);\n\t\t\t\t}\n\n\t\t\t\tinner = new IR([\n\t\t\t\t\tnew IR(\"__core__headList(\"),\n\t\t\t\t\tinner,\n\t\t\t\t\tnew IR(\")\"),\n\t\t\t\t]);\n\n\t\t\t\tif (isBool) {\n\t\t\t\t\tinner = new IR([new IR(\"__helios__common__unBoolData(\"), inner, new IR(\")\")]);\n\t\t\t\t}\n\n\t\t\t\tgetter = new IR([\n\t\t\t\t\tnew IR(\"(self) \"), new IR(\"->\", f.site), new IR(\" {\"),\n\t\t\t\t\tinner,\n\t\t\t\t\tnew IR(\"}\"),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tmap.set(key, getter)\n\t\t}\n\n\t\tif (this.#usedAutoMethods.has(\"copy\")) {\n\t\t\tthis.copyToIR(map, getterNames);\n\t\t}\n\t}\n}\n\n/**\n * Struct statement\n * @package\n */\nclass StructStatement extends DataDefinition {\n\t#impl;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t * @param {DataField[]} fields \n\t * @param {ImplDefinition} impl\n\t */\n\tconstructor(site, name, fields, impl) {\n\t\tsuper(site, name, fields);\n\n\t\tthis.#impl = impl;\n\t}\n\n\tget type() {\n\t\treturn new StructStatementType(this);\n\t}\n\n\ttoString() {\n\t\treturn \"struct \" + super.toString();\n\t}\n\n\t/**\n\t * Returns -1, which means -> don't use ConstrData, but use []Data directly\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Evaluates own type and adds to scope\n\t * @param {TopScope} scope \n\t */\n\teval(scope) {\n\t\tif (scope.isStrict() && this.fields.length == 0) {\n\t\t\tthrow this.syntaxError(\"expected at least 1 struct field\");\n\t\t}\n\n\t\t// add before so recursive types are possible\n\t\tscope.set(this.name, this.type);\n\n\t\tthis.evalInternal(scope);\n\n\t\t// check the types of the member methods\n\t\tthis.#impl.eval(scope);\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @param {boolean} dryRun \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name, dryRun = false) {\n\t\tif (super.hasMember(name)) {\n\t\t\treturn super.getInstanceMember(name, dryRun);\n\t\t} else {\n\t\t\treturn this.#impl.getInstanceMember(name, dryRun);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name\n\t * @param {boolean} dryRun\n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name, dryRun = false) {\n\t\t// only the impl can contain potentially contain type members\n\t\treturn this.#impl.getTypeMember(name, dryRun);\n\t}\n\n\t/**\n\t * @param {Uint8Array} mask\n\t */\n\thideUnused(mask) {\n\t\tsuper.hideUnused(mask);\n\n\t\tthis.#impl.hideUnused(mask);\n\t}\n\n\t/**\n\t * @param {IRDefinitions} map\n\t */\n\ttoIR(map) {\n\t\tif (this.fields.length == 1) {\n\t\t\tlet f = this.fields[0];\n\t\t\tlet key = `${this.path}__${f.name.toString()}`;\n\t\t\tlet isBool = f.type instanceof BoolType;\n\n\t\t\tif (isBool) {\n\t\t\t\tmap.set(key, new IR(\"__helios__common__unBoolData\", f.site));\n\t\t\t} else {\n\t\t\t\tmap.set(key, new IR(\"__helios__common__identity\", f.site));\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.toIR(map, false);\n\t\t}\n\n\t\tthis.#impl.toIR(map);\n\t}\n}\n\n/**\n * Function statement\n * (basically just a named FuncLiteralExpr)\n * @package\n */\nclass FuncStatement extends Statement {\n\t#funcExpr;\n\t#recursive;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t * @param {FuncLiteralExpr} funcExpr \n\t */\n\tconstructor(site, name, funcExpr) {\n\t\tsuper(site, name);\n\t\tthis.#funcExpr = funcExpr;\n\t\tthis.#recursive = false;\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget argTypes() {\n\t\treturn this.#funcExpr.argTypes;\n\t}\n\n\t/**\n\t * @type {string[]}\n\t */\n\tget argTypeNames() {\n\t\treturn this.#funcExpr.argTypeNames;\n\t}\n\n\t/**\n\t * @type {Type[]}\n\t */\n\tget retTypes() {\n\t\treturn this.#funcExpr.retTypes;\n\t}\n\n\ttoString() {\n\t\treturn `func ${this.name.toString()}${this.#funcExpr.toString()}`;\n\t}\n\n\t/**\n\t * Evaluates a function and returns a func value\n\t * @param {Scope} scope \n\t * @returns {Instance}\n\t */\n\tevalInternal(scope) {\n\t\treturn this.#funcExpr.evalInternal(scope);\n\t}\n\n\t/**\n\t * Evaluates type of a funtion.\n\t * Separate from evalInternal so we can use this function recursively inside evalInternal\n\t * @param {Scope} scope \n\t * @returns {FuncType}\n\t */\n\tevalType(scope) {\n\t\treturn this.#funcExpr.evalType(scope);\n\t}\n\n\tuse() {\n\t\tif (!this.used) {\n\t\t\tsuper.use();\n\n\t\t\tthis.#funcExpr.use();\n\t\t}\n\t}\n\n\tisRecursive() {\n\t\treturn this.#recursive;\n\t}\n\n\t/**\n\t * Called in FuncStatementScope as soon as recursion is detected\n\t */\n\tsetRecursive() {\n\t\tthis.#recursive = true;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t */\n\teval(scope) {\n\t\t// add to scope before evaluating, to allow recursive calls\n\n\t\tlet fnType = this.evalType(scope);\n\n\t\tlet fnVal = new FuncStatementInstance(fnType, this);\n\n\t\tscope.set(this.name, fnVal);\n\n\t\tvoid this.#funcExpr.evalInternal(new FuncStatementScope(scope, this));\n\t}\n\n\t/**\n\t * Returns IR of function.\n\t * @param {string} fullName - fullName has been prefixed with a type path for impl members\n\t * @returns {IR}\n\t */\n\ttoIRInternal(fullName = this.path) {\n\t\tif (this.#recursive) {\n\t\t\treturn this.#funcExpr.toIRRecursive(fullName, TAB);\n\t\t} else {\n\t\t\treturn this.#funcExpr.toIR(TAB);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\tmap.set(this.path, this.toIRInternal());\n\t}\n\n\t/**\n\t * @param {Statement} s \n\t * @returns {boolean}\n\t */\n\tstatic isMethod(s) {\n\t\tif (s instanceof FuncStatement) {\n\t\t\treturn s.#funcExpr.isMethod();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n/**\n * EnumMember defintion is similar to a struct definition\n * @package\n */\nclass EnumMember extends DataDefinition {\n\t/** @type {?EnumStatement} */\n\t#parent;\n\n\t/** @type {?number} */\n\t#constrIndex;\n\n\t/**\n\t * @param {Word} name\n\t * @param {DataField[]} fields\n\t */\n\tconstructor(name, fields) {\n\t\tsuper(name.site, name, fields);\n\t\tthis.#parent = null; // registered later\n\t\tthis.#constrIndex = null;\n\t}\n\n\t/** \n\t * @param {EnumStatement} parent\n\t * @param {number} i\n\t*/\n\tregisterParent(parent, i) {\n\t\tthis.#parent = parent;\n\t\tthis.#constrIndex = i;\n\t}\n\t\n\t/**\n\t * @type {EnumStatement}\n\t */\n\tget parent() {\n\t\tif (this.#parent === null) {\n\t\t\tthrow new Error(\"parent not yet registered\");\n\t\t} else {\n\t\t\treturn this.#parent;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn new EnumMemberStatementType(this);\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\tif (this.#constrIndex === null) {\n\t\t\tthrow new Error(\"constrIndex not set\");\n\t\t} else {\n\t\t\treturn this.#constrIndex;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t */\n\teval(scope) {\n\t\tif (this.#parent === null) {\n\t\t\tthrow new Error(\"parent should've been registered\");\n\t\t}\n\n\t\tsuper.evalInternal(scope); // the internally created type isn't be added to the scope. (the parent enum type takes care of that)\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @param {boolean} dryRun \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name, dryRun = false) {\n\t\tif (this.hasField(name)) {\n\t\t\treturn super.getInstanceMember(name, dryRun);\n\t\t} else {\n\t\t\tif (this.#parent === null) {\n\t\t\t\tthrow new Error(\"parent should've been registered\");\n\t\t\t} else {\n\t\t\t\treturn this.#parent.getInstanceMember(name, dryRun);\n\t\t\t}\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn `${this.parent.path}__${this.name.toString()}`;\n\t}\n}\n\n/**\n * Enum statement, containing at least one member\n * @package\n */\nclass EnumStatement extends Statement {\n\t#members;\n\t#impl;\n\n\t/**\n\t * @param {Site} site \n\t * @param {Word} name \n\t * @param {EnumMember[]} members \n\t * @param {ImplDefinition} impl\n\t */\n\tconstructor(site, name, members, impl) {\n\t\tsuper(site, name);\n\t\tthis.#members = members;\n\t\tthis.#impl = impl;\n\t\t\n\t\tfor (let i = 0; i < this.#members.length; i++) {\n\t\t\tthis.#members[i].registerParent(this, i);\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn new EnumStatementType(this);\n\t}\n\n\t/**\n\t * Returns index of enum member.\n\t * Returns -1 if not found\n\t * @param {Word} name \n\t * @returns {number}\n\t */\n\t// returns an index\n\tfindEnumMember(name) {\n\t\tlet found = -1;\n\t\tlet i = 0;\n\t\tfor (let member of this.#members) {\n\t\t\tif (member.name.toString() == name.toString()) {\n\t\t\t\tfound = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\treturn found;\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @param {number} i\n\t * @returns {EnumMember}\n\t */\n\tgetEnumMember(site, i) {\n\t\treturn assertDefined(this.#members[i]);\n\t}\n\n\t/**\n\t * @param {Word} name\n\t * @returns {boolean}\n\t */\n\thasEnumMember(name) {\n\t\treturn this.findEnumMember(name) != -1;\n\t}\n\n\ttoString() {\n\t\treturn `enum ${this.name.toString()} {${this.#members.map(m => m.toString()).join(\", \")}}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t */\n\teval(scope) {\n\t\tscope.set(this.name, this.type);\n\n\t\tthis.#members.forEach(m => {\n\t\t\tm.eval(scope);\n\t\t});\n\n\t\tthis.#impl.eval(scope);\n\t}\n\n\tuse() {\n\t\tif (!this.used) {\n\t\t\tsuper.use();\n\n\t\t\tfor (let m of this.#members) {\n\t\t\t\tm.use();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnFields(site) {\n\t\tthrow site.typeError(\"enum doesn't have fields\");\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {number} i\n\t * @returns {Type}\n\t */\n\tgetFieldType(site, i) {\n\t\tthrow site.typeError(\"enum doesn't have fields\");\n\t}\n\n\t/**f\n\t * @param {Site} site \n\t * @param {string} name \n\t * @returns {number}\n\t */\n\tgetFieldIndex(site, name) {\n\t\tthrow site.typeError(\"enum doesn't have fields\");\n\t}\n\n\t/**\n\t * @param {number} i \n\t * @returns {string}\n\t */\n\tgetFieldName(i) {\n\t\tthrow Site.dummy().typeError(\"enum doesn't have fields\");\n\t}\n\t\n    /**\n     * @param {Word} name \n     * @returns {boolean}\n     */\n    hasField(name) {\n        throw name.site.typeError(\"enum doesn't have fields\");\n    }\n\n\t/** \n\t * @param {Word} name \n\t * @param {boolean} dryRun \n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name, dryRun = false) {\n\t\tif (this.hasEnumMember(name)) {\n\t\t\tthrow name.referenceError(`'${name.toString()}' is an enum of '${this.toString}' (did you mean '${this.toString()}::${name.toString()}'?)`);\n\t\t} else {\n\t\t\treturn this.#impl.getInstanceMember(name, dryRun);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name \n\t * @param {boolean} dryRun\n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name, dryRun = false) {\n\t\tlet i = this.findEnumMember(name);\n\t\tif (i == -1) {\n\t\t\treturn this.#impl.getTypeMember(name, dryRun);\n\t\t} else {\n\t\t\treturn this.#members[i].type;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tgetConstrIndex(site) {\n\t\tthrow site.typeError(\"can't construct an enum directly (cast to a concrete type first)\");\n\t}\n\n\t/**\n\t * @param {Site} site \n\t * @returns {number}\n\t */\n\tnEnumMembers(site) {\n\t\treturn this.#members.length;\n\t}\n\n\t/**\n\t * @param {Uint8Array} mask\n\t */\n\thideUnused(mask) {\n\t\tsuper.hideUnused(mask);\n\n\t\tthis.#impl.hideUnused(mask);\n\t}\n\n\t/**\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\tfor (let member of this.#members) {\n\t\t\tmember.toIR(map);\n\t\t}\n\n\t\tthis.#impl.toIR(map);\n\t}\n}\n\n/**\n * Impl statements, which add functions and constants to registry of user types (Struct, Enum Member and Enums)\n * @package\n */\nclass ImplDefinition {\n\t#selfTypeExpr;\n\t#statements;\n\n\t/** @type {Instance[]} - filled during eval to allow same recursive behaviour as for top-level statements */\n\t#statementValues;\n\n\t/** @type {Set<string>} */\n\t#usedStatements;\n\n\t/**\n\t * @param {TypeRefExpr} selfTypeExpr;\n\t * @param {(FuncStatement | ConstStatement)[]} statements \n\t */\n\tconstructor(selfTypeExpr, statements) {\n\t\tthis.#selfTypeExpr = selfTypeExpr;\n\t\tthis.#statements = statements;\n\t\tthis.#statementValues = [];\n\t\tthis.#usedStatements = new Set(); // used for code-generation, but not for cleanSource filtering\n\t}\n\n\ttoString() {\n\t\treturn `${this.#statements.map(s => s.toString()).join(\"\\n\")}`;\n\t}\n\n\t/**\n\t * @param {Scope} scope \n\t */\n\teval(scope) {\n\t\tlet selfType = this.#selfTypeExpr.eval(scope);\n\n\t\tif (!(selfType instanceof StatementType)) {\n\t\t\tthrow this.#selfTypeExpr.referenceError(\"not a user-type\");\n\t\t} else {\n\t\t\tfor (let s of this.#statements) {\n\t\t\t\tif (s instanceof FuncStatement) {\n\t\t\t\t\t// override eval() of FuncStatement because we don't want the function to add itself to the scope directly.\n\t\t\t\t\tlet v = new FuncStatementInstance(s.evalType(scope), s);\n\n\t\t\t\t\tthis.#statementValues.push(v); // add func type to #statementValues in order to allow recursive calls (acts as a special scope)\n\n\t\t\t\t\t// eval internal doesn't add anything to scope\n\t\t\t\t\tvoid s.evalInternal(new FuncStatementScope(scope, s));\n\t\t\t\t} else {\n\t\t\t\t\t// eval internal doesn't add anything to scope\n\t\t\t\t\tthis.#statementValues.push(s.evalInternal(scope));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Word} name\n\t * @param {boolean} dryRun\n\t * @returns {Instance}\n\t */\n\tgetInstanceMember(name, dryRun = false) {\n\t\tswitch (name.value) {\n\t\t\tcase \"serialize\":\n\t\t\t\tthis.#usedStatements.add(name.toString());\n\t\t\t\treturn Instance.new(new FuncType([], new ByteArrayType()));\n\t\t\t\n\t\t\tdefault:\n\t\t\t\t// loop the contained statements to find one with name 'name'\n\t\t\t\tfor (let i = 0; i < this.#statementValues.length; i++) {\n\t\t\t\t\tlet s = this.#statements[i];\n\n\t\t\t\t\tif (name.toString() == s.name.toString()) {\n\t\t\t\t\t\tif (FuncStatement.isMethod(s)) {\n\t\t\t\t\t\t\tif (!dryRun) {\n\t\t\t\t\t\t\t\tthis.#usedStatements.add(name.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn this.#statementValues[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow name.referenceError(`'${this.#selfTypeExpr.toString()}.${name.toString()}' isn't a method (did you mean '${this.#selfTypeExpr.toString()}::${name.toString()}'?)`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow name.referenceError(`'${this.#selfTypeExpr.toString()}.${name.toString()}' undefined`);\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {Word} name \n\t * @param {boolean} dryRun \n\t * @returns {EvalEntity}\n\t */\n\tgetTypeMember(name, dryRun = false) {\n\t\tswitch (name.value) {\n\t\t\tcase \"__eq\":\n\t\t\tcase \"__neq\":\n\t\t\t\tthis.#usedStatements.add(name.toString());\n\t\t\t\treturn Instance.new(new FuncType([this.#selfTypeExpr.type, this.#selfTypeExpr.type], new BoolType()));\n\t\t\tcase \"from_data\":\n\t\t\t\tthis.#usedStatements.add(name.toString());\n\t\t\t\treturn Instance.new(new FuncType([new RawDataType()], this.#selfTypeExpr.type));\n\t\t\tdefault:\n\t\t\t\tfor (let i = 0; i < this.#statementValues.length; i++) {\n\t\t\t\t\tlet s = this.#statements[i];\n\n\t\t\t\t\tif (name.toString() == s.name.toString()) {\n\t\t\t\t\t\tif (FuncStatement.isMethod(s)) {\n\t\t\t\t\t\t\tthrow name.referenceError(`'${this.#selfTypeExpr.toString()}::${name.value}' is a method (did you mean '${this.#selfTypeExpr.toString()}.${name.toString()}'?)`)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!dryRun) {\n\t\t\t\t\t\t\t\tthis.#usedStatements.add(name.toString());\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn this.#statementValues[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow name.referenceError(`'${this.#selfTypeExpr.toString()}::${name.toString()}' undefined`);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Uint8Array} mask\n\t */\n\thideUnused(mask) {\n\t\tfor (let s of this.#statements) {\n\t\t\tif (!s.used) {\n\t\t\t\tlet site = s.site;\n\n\t\t\t\tif (site.endSite === null) {\n\t\t\t\t\tmask.fill(0, site.startPos);\n\t\t\t\t} else {\n\t\t\t\t\tmask.fill(0, site.startPos, site.endSite.startPos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns IR of all impl members\n\t * @param {IRDefinitions} map \n\t */\n\ttoIR(map) {\n\t\tlet path = this.#selfTypeExpr.path;\n\t\tlet site = this.#selfTypeExpr.site;\n\n\t\tif (this.#usedStatements.has(\"__eq\")) {\n\t\t\tmap.set(`${path}____eq`, new IR(\"__helios__common____eq\", site));\n\t\t}\n\n\t\tif (this.#usedStatements.has(\"__neq\")) {\n\t\t\tmap.set(`${path}____neq`, new IR(\"__helios__common____neq\", site));\n\t\t}\n\n\t\tif (this.#usedStatements.has(\"serialize\")) {\n\t\t\tmap.set(`${path}__serialize`, new IR(\"__helios__common__serialize\", site));\n\t\t}\n\n\t\tif (this.#usedStatements.has(\"from_data\")) {\n\t\t\tmap.set(`${path}__from_data`, new IR(\"__helios__common__identity\", site));\n\t\t}\n\n\t\tfor (let s of this.#statements) {\n\t\t\tlet key = `${path}__${s.name.toString()}`\n\t\t\tif (s instanceof FuncStatement) {\n\t\t\t\tmap.set(key, s.toIRInternal(key));\n\t\t\t} else {\n\t\t\t\tmap.set(key, s.toIRInternal());\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//////////////////////////////////\n// Section 18: Helios AST building\n//////////////////////////////////\n\nconst AUTOMATIC_METHODS = [\n\t\"__eq\",\n\t\"__neq\",\n\t\"copy\",\n\t\"from_data\",\n\t\"serialize\"\n];\n\n/**\n * @type {null | ((path: StringLiteral) => (string | null))}\n */\nlet importPathTranslator = null\n\n/**\n * Used by VSCode plugin\n * @param {(path: StringLiteral) => (string | null)} fn \n */\nfunction setImportPathTranslator(fn) {\n\timportPathTranslator = fn\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @returns {Statement[]}\n */\nfunction buildProgramStatements(ts) {\n\t/**\n\t * @type {Statement[]}\n\t */\n\tlet statements = [];\n\n\twhile (ts.length != 0) {\n\t\tconst t = ts.shift()?.assertWord();\n\n\t\tif (!t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst kw = t.value;\n\n\t\t/**\n\t\t * @type {Statement | (Statement | null)[] | null}\n\t\t */\n\t\tlet s = null;\n\n\t\tif (kw == \"const\") {\n\t\t\ts = buildConstStatement(t.site, ts);\n\t\t} else if (kw == \"struct\") {\n\t\t\ts = buildStructStatement(t.site, ts);\n\t\t} else if (kw == \"func\") {\n\t\t\ts = buildFuncStatement(t.site, ts);\n\t\t} else if (kw == \"enum\") {\n\t\t\ts = buildEnumStatement(t.site, ts);\n\t\t} else if (kw == \"import\") {\n\t\t\ts = buildImportStatements(t.site, ts);\n\t\t} else {\n\t\t\tt.syntaxError(`invalid top-level keyword '${kw}'`);\n\t\t}\n\n\t\tif (s) {\n\t\t\tif (Array.isArray(s)) {\n\t\t\t\tfor (let s_ of s) {\n\t\t\t\t\tif (s_) {\n\t\t\t\t\t\tstatements.push(s_);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatements.push(s);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn statements;\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @param {null | number} expectedPurpose\n * @returns {[number, Word] | null} - [purpose, name] (ScriptPurpose is an integer)\n * @package\n */\nfunction buildScriptPurpose(ts, expectedPurpose = null) {\n\t// need at least 2 tokens for the script purpose\n\tif (ts.length < 2) {\n\n\t\tif (ts.length == 0) {\n\t\t\tSite.dummy().syntaxError(\"invalid script purpose syntax\");\n\t\t} else {\n\t\t\tts[0].syntaxError(\"invalid script purpose syntax\");\n\t\t\tts.splice(0);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tconst purposeWord = ts.shift()?.assertWord();\n\n\tif (!purposeWord) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @type {number | null}\n\t */\n\tlet purpose = null;\n\n\tif (purposeWord.isWord(\"spending\")) {\n\t\tpurpose = ScriptPurpose.Spending;\n\t} else if (purposeWord.isWord(\"minting\")) {\n\t\tpurpose = ScriptPurpose.Minting;\n\t} else if (purposeWord.isWord(\"staking\")) {\n\t\tpurpose = ScriptPurpose.Staking;\n\t} else if (purposeWord.isWord(\"testing\")) { // 'test' is not reserved as a keyword though\n\t\tpurpose = ScriptPurpose.Testing;\n\t} else if (purposeWord.isWord(\"module\")) {\n\t\tpurpose = ScriptPurpose.Module;\n\t} else if (purposeWord.isKeyword()) {\n\t\tpurposeWord.syntaxError(`script purpose missing`);\n\n\t\tts.unshift(purposeWord);\n\n\t\treturn null;\n\t} else {\n\t\tpurposeWord.syntaxError(`unrecognized script purpose '${purposeWord.value}' (expected 'testing', 'spending', 'staking', 'minting' or 'module')`);\n\t\tpurpose = -1;\n\t}\n\n\tif (expectedPurpose !== null && purpose !== null) {\n\t\tif (expectedPurpose != purpose) {\n\t\t\tpurposeWord.syntaxError(`expected '${getPurposeName(purpose)}' script purpose`);\n\t\t}\n\t}\n\n\tconst name = assertToken(ts.shift(), purposeWord.site)?.assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t}\n\n\tif (name.value === \"main\") {\n\t\tname.syntaxError(`${purposeWord.value} script can't be named 'main'`);\n\t}\n\n\treturn [purpose, name];\n}\n\n/**\n * Also used by VSCode plugin\n * @param {Token[]} ts \n * @param {number | null} expectedPurpose \n * @returns {[number | null, Word | null, Statement[], number]}\n */\nfunction buildScript(ts, expectedPurpose = null) {\n\tconst first = ts[0];\n\n\tconst purposeName = buildScriptPurpose(ts, expectedPurpose);\n\n\tconst statements = buildProgramStatements(ts);\n\n\tlet mainIdx = -1;\n\n\tconst [purpose, name] = purposeName !== null ? purposeName : [null, null];\n\n\tif (purpose != ScriptPurpose.Module) {\n\t\tmainIdx = statements.findIndex(s => s.name.value === \"main\");\n\n\t\tif (mainIdx == -1) {\n\t\t\tif (name !== null) {\n\t\t\t\tfirst.site.merge(name.site).syntaxError(\"entrypoint 'main' not found\");\n\t\t\t} else {\n\t\t\t\tfirst.site.syntaxError(\"entrypoint 'main' not found\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [purpose, name, statements, mainIdx];\n}\n\n/**\n * Parses Helios quickly to extract the script purpose header.\n * Returns null if header is missing or incorrectly formed (instead of throwing an error)\n * @param {string} rawSrc \n * @returns {?[string, string]} - [purpose, name]\n */\nfunction extractScriptPurposeAndName(rawSrc) {\n\ttry {\n\t\tlet src = new Source(rawSrc);\n\n\t\tlet tokenizer = new Tokenizer(src);\n\n\t\tlet gen = tokenizer.streamTokens();\n\n\t\t// Don't parse the whole script, just 'eat' 2 tokens: `<purpose> <name>`\n\t\tlet ts = [];\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tlet yielded = gen.next();\n\t\t\tif (yielded.done) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tts.push(yielded.value);\n\t\t}\n\n\t\tconst purposeName = buildScriptPurpose(ts);\n\n\t\tsrc.throwErrors();\n\n\t\tif (purposeName !== null) {\n\t\t\tconst [purpose, name] = purposeName;\n\n\t\t\treturn [getPurposeName(purpose), name.value];\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected\"); // should've been caught above by calling src.throwErrors()\n\t\t}\n\t} catch (e) {\n\t\tif (!(e instanceof UserError)) {\n\t\t\tthrow e;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {ConstStatement | null}\n */\nfunction buildConstStatement(site, ts) {\n\tif (ts.length == 0) {\n\t\tsite.syntaxError(\"invalid syntax (expected name after 'const')\");\n\t\treturn null;\n\t}\n\n\tconst name = assertToken(ts.shift(), site)?.assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t}\n\n\tlet typeExpr = null;\n\n\tif (ts.length > 0 && ts[0].isSymbol(\":\")) {\n\t\tconst colon = assertDefined(ts.shift());\n\n\t\tconst equalsPos = SymbolToken.find(ts, \"=\");\n\n\t\tif (equalsPos == -1) {\n\t\t\tts.unshift(colon);\n\t\t\tsite.merge(ts[ts.length-1].site).syntaxError(\"invalid syntax (expected '=' after 'const')\");\n\t\t\tts.splice(0);\n\t\t\treturn null;\n\t\t} else if (equalsPos == 0) {\n\t\t\tcolon.site.merge(ts[0].site).syntaxError(\"expected type expression between ':' and '='\");\n\t\t\tts.shift();\n\t\t\treturn null;\n\t\t}\n\n\t\ttypeExpr = buildTypeExpr(colon.site, ts.splice(0, equalsPos));\n\t}\n\n\tconst maybeEquals = ts.shift();\n\n\tif (maybeEquals === undefined) {\n\t\tsite.merge(name.site).syntaxError(\"expected '=' after 'const'\");\n\t\tts.splice(0);\n\t\treturn null;\n\t} else if (!maybeEquals.isSymbol(\"=\")) {\n\t\tsite.merge(maybeEquals.site).syntaxError(\"expected '=' after 'const'\");\n\t\treturn null;\n\t} else {\n\t\tconst equals = maybeEquals.assertSymbol(\"=\");\n\n\t\tif (!equals) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nextStatementPos = Word.find(ts, [\"const\", \"func\", \"struct\", \"enum\", \"import\"]);\n\n\t\tconst tsValue = nextStatementPos == -1 ? ts.splice(0) : ts.splice(0, nextStatementPos);\n\n\t\tif (tsValue.length == 0) {\n\t\t\tequals.syntaxError(\"expected expression after '='\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst endSite = tsValue[tsValue.length-1].site;\n\n\t\t\tconst valueExpr = buildValueExpr(tsValue);\n\n\t\t\tif (valueExpr === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn new ConstStatement(site.merge(endSite), name, typeExpr, valueExpr);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @returns {[Token[], Token[]]}\n */\nfunction splitDataImpl(ts) {\n\tconst implPos = Word.find(ts, [\"const\", \"func\"]);\n\n\tif (implPos == -1) {\n\t\treturn [ts, []];\n\t} else {\n\t\treturn [ts.slice(0, implPos), ts.slice(implPos)];\n\t}\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {StructStatement | null}\n */\nfunction buildStructStatement(site, ts) {\n\tconst maybeName = ts.shift();\n\n\tif (maybeName === undefined) {\n\t\tsite.syntaxError(\"expected name after 'struct'\");\n\t\treturn null;\n\t} else {\n\t\tif (!maybeName.isWord()) {\n\t\t\tmaybeName.syntaxError(\"expected name after 'struct'\");\n\t\t\treturn null;\n\t\t} else if (maybeName.isKeyword()) {\n\t\t\tmaybeName.syntaxError(\"unexpected keyword after 'struct'\");\n\t\t}\n\n\t\tconst name = maybeName?.assertWord();\n\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst maybeBraces = ts.shift();\n\n\t\tif (maybeBraces === undefined) {\n\t\t\tname.syntaxError(`expected '{...}' after 'struct ${name.toString()}'`);\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!maybeBraces.isGroup(\"{\", 1)) {\n\t\t\t\tmaybeBraces.syntaxError(\"expected non-empty '{..}' without separators\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst braces = maybeBraces.assertGroup(\"{\", 1);\n\n\t\t\tif (!braces) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [tsFields, tsImpl] = splitDataImpl(braces.fields[0]);\n\n\t\t\tconst fields = buildDataFields(tsFields);\n\n\t\t\tconst impl = buildImplDefinition(tsImpl, new TypeRefExpr(name), fields.map(f => f.name), braces.site.endSite);\n\n\t\t\tif (impl === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn new StructStatement(site.merge(braces.site), name, fields, impl);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {DataField[]}\n */\nfunction buildDataFields(ts) {\n\t/** @type {DataField[]} */\n\tconst fields = []\n\n\t/**\n\t * @param {Word} fieldName\n\t */\n\tfunction assertUnique(fieldName) {\n\t\tif (fields.findIndex(f => f.name.toString() == fieldName.toString()) != -1) {\n\t\t\tfieldName.typeError(`duplicate field \\'${fieldName.toString()}\\'`);\n\t\t}\n\t}\n\n\twhile (ts.length > 0) {\n\t\tconst colonPos = SymbolToken.find(ts, \":\");\n\n\t\tif (colonPos == -1) {\n\t\t\tts[0].site.merge(ts[ts.length-1].site).syntaxError(\"expected ':' in data field\");\n\t\t\treturn fields;\n\t\t}\n\n\t\tconst colon = ts[colonPos];\n\t\tconst tsBef = ts.slice(0, colonPos);\n\t\tconst tsAft = ts.slice(colonPos+1);\n\t\tconst maybeFieldName = tsBef.shift();\n\t\tif (maybeFieldName === undefined) {\n\t\t\tcolon.syntaxError(\"expected word before ':'\");\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tconst fieldName = maybeFieldName?.assertWord()?.assertNotKeyword();\n\n\t\t\tif (!fieldName) {\n\t\t\t\treturn fields;\n\t\t\t}\n\n\t\t\tassertUnique(fieldName);\n\n\t\t\tif (tsAft.length == 0) {\n\t\t\t\tcolon.syntaxError(\"expected type expression after ':'\");\n\t\t\t\treturn fields;\n\t\t\t}\n\n\t\t\tconst nextColonPos = SymbolToken.find(tsAft, \":\");\n\n\t\t\tif (nextColonPos != -1) {\n\t\t\t\tif (nextColonPos == 0) {\n\t\t\t\t\ttsAft[nextColonPos].syntaxError(\"expected word before ':'\");\n\t\t\t\t\treturn fields;\n\t\t\t\t}\n\n\t\t\t\tvoid tsAft[nextColonPos-1].assertWord();\n\n\t\t\t\tts = tsAft.splice(nextColonPos-1);\n\t\t\t} else {\n\t\t\t\tts = [];\n\t\t\t}\n\n\t\t\tconst typeExpr = buildTypeExpr(colon.site, tsAft);\n\n\t\t\tif (!typeExpr) {\n\t\t\t\treturn fields;\n\t\t\t}\n\n\t\t\tfields.push(new DataField(fieldName, typeExpr));\n\t\t}\n\t}\n\n\treturn fields;\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @param {?TypeExpr} methodOf - methodOf !== null then first arg can be named 'self'\n * @returns {FuncStatement | null}\n */\nfunction buildFuncStatement(site, ts, methodOf = null) {\n\tconst name = assertToken(ts.shift(), site)?.assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t}\n\n\tif (ts.length == 0) {\n\t\tname.site.syntaxError(\"invalid syntax\");\n\t\treturn null;\n\t}\n\n\tconst fnExpr = buildFuncLiteralExpr(ts, methodOf, false);\n\n\tif (!fnExpr) {\n\t\treturn null;\n\t}\n\n\treturn new FuncStatement(site.merge(fnExpr.site), name, fnExpr);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @param {?TypeExpr} methodOf - methodOf !== null then first arg can be named 'self'\n * @param {boolean} allowInferredRetType\n * @returns {FuncLiteralExpr | null}\n */\nfunction buildFuncLiteralExpr(ts, methodOf = null, allowInferredRetType = false) {\n\tconst parens = assertDefined(ts.shift()).assertGroup(\"(\");\n\n\tif (!parens) {\n\t\treturn null;\n\t}\n\n\tconst site = parens.site;\n\tconst args = buildFuncArgs(parens, methodOf);\n\n\tconst arrow = assertToken(ts.shift(), site)?.assertSymbol(\"->\");\n\n\tif (!arrow) {\n\t\treturn null;\n\t}\n\n\tconst bodyPos = Group.find(ts, \"{\");\n\n\tif (bodyPos == -1) {\n\t\tsite.syntaxError(\"no function body\");\n\t\treturn null;\n\t} else if (bodyPos == 0 && !allowInferredRetType) {\n\t\tsite.syntaxError(\"no return type specified\");\n\t}\n\n\tconst retTypeExprs = buildFuncRetTypeExprs(arrow.site, ts.splice(0, bodyPos), allowInferredRetType);\n\n\tif (retTypeExprs === null) {\n\t\treturn null;\n\t}\n\n\tconst bodyGroup = assertToken(ts.shift(), site)?.assertGroup(\"{\", 1)\n\n\tif (!bodyGroup) {\n\t\treturn null;\n\t}\n\n\tconst bodyExpr = buildValueExpr(bodyGroup.fields[0]);\n\n\tif (!bodyExpr) {\n\t\treturn null;\n\t}\n\n\treturn new FuncLiteralExpr(site, args, retTypeExprs, bodyExpr);\n}\n\n/**\n * @package\n * @param {Group} parens \n * @param {?TypeExpr} methodOf - methodOf !== nul then first arg can be named 'self'\n * @returns {FuncArg[]}\n */\nfunction buildFuncArgs(parens, methodOf = null) {\n\t/** @type {FuncArg[]} */\n\tconst args = [];\n\n\tlet hasDefaultArgs = false;\n\n\tfor (let i = 0; i < parens.fields.length; i++) {\n\t\tconst f = parens.fields[i];\n\t\tconst ts = f.slice();\n\n\t\tconst name = assertToken(ts.shift(), parens.site)?.assertWord();\n\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name.toString() == \"self\") {\n\t\t\tif (i != 0 || methodOf === null) {\n\t\t\t\tname.syntaxError(\"'self' is reserved\");\n\t\t\t} else {\n\t\t\t\tif (ts.length > 0) {\n\t\t\t\t\tif (ts[0].isSymbol(\":\")) {\n\t\t\t\t\t\tts[0].syntaxError(\"unexpected type expression after 'self'\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts[0].syntaxError(\"unexpected token\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\targs.push(new FuncArg(name, methodOf));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (name.toString() == \"_\") {\n\t\t\tif (ts.length > 0) {\n\t\t\t\tif (ts[0].isSymbol(\":\")) {\n\t\t\t\t\tts[0].syntaxError(\"unexpected type expression after '_'\");\n\t\t\t\t} else {\n\t\t\t\t\tts[0].syntaxError(\"unexpected token\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targs.push(new FuncArg(name, methodOf));\n\t\t\t}\n\t\t} else {\n\t\t\tif (name.isKeyword()) {\n\t\t\t\tname.syntaxError(\"unexpected keyword\");\n\t\t\t}\n\n\t\t\tfor (let prev of args) {\n\t\t\t\tif (prev.name.toString() == name.toString()) {\n\t\t\t\t\tname.syntaxError(`duplicate argument '${name.toString()}'`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst maybeColon = ts.shift();\n\t\t\tif (maybeColon === undefined) {\n\t\t\t\tname.syntaxError(`expected ':' after '${name.toString()}'`);\n\t\t\t} else {\n\t\t\t\tconst colon = maybeColon.assertSymbol(\":\");\n\n\t\t\t\tif (!colon) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst equalsPos = SymbolToken.find(ts, \"=\");\n\n\t\t\t\t/**\n\t\t\t\t * @type {null | ValueExpr}\n\t\t\t\t */\n\t\t\t\tlet defaultValueExpr = null;\n\n\t\t\t\tif (equalsPos != -1) {\n\t\t\t\t\tif (equalsPos == ts.length-1) {\n\t\t\t\t\t\tts[equalsPos].syntaxError(\"expected expression after '='\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst vts = ts.splice(equalsPos);\n\n\t\t\t\t\t\tvts.shift()?.assertSymbol(\"=\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdefaultValueExpr = buildValueExpr(vts);\n\n\t\t\t\t\t\thasDefaultArgs = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasDefaultArgs) {\n\t\t\t\t\t\tname.syntaxError(\"positional args must come before default args\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @type {TypeExpr | null}\n\t\t\t\t */\n\t\t\t\tlet typeExpr = null;\n\n\t\t\t\tif (ts.length == 0) {\n\t\t\t\t\tcolon.syntaxError(\"expected type expression after ':'\");\n\t\t\t\t} else {\n\t\t\t\t\ttypeExpr = buildTypeExpr(colon.site, ts);\n\t\t\t\t}\n\n\t\t\t\targs.push(new FuncArg(name, typeExpr, defaultValueExpr));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn args;\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {EnumStatement | null}\n */\nfunction buildEnumStatement(site, ts) {\n\tconst maybeName = ts.shift();\n\n\tif (maybeName === undefined) {\n\t\tsite.syntaxError(\"expected word after 'enum'\");\n\t\treturn null\n\t} else {\n\t\tconst name = maybeName.assertWord()?.assertNotKeyword();\n\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst maybeBraces = ts.shift();\n\n\t\tif (maybeBraces === undefined) {\n\t\t\tname.syntaxError(`expected '{...}' after 'enum ${name.toString()}'`);\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst braces = maybeBraces.assertGroup(\"{\", 1);\n\n\t\t\tif (!braces) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst [tsMembers, tsImpl] = splitDataImpl(braces.fields[0]);\n\n\t\t\tif (tsMembers.length == 0) {\n\t\t\t\tbraces.syntaxError(\"expected at least one enum member\");\n\t\t\t}\n\n\t\t\t/** @type {EnumMember[]} */\n\t\t\tconst members = [];\n\n\t\t\twhile (tsMembers.length > 0) {\n\t\t\t\tconst member = buildEnumMember(tsMembers);\n\n\t\t\t\tif (!member) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmembers.push(member);\n\t\t\t}\n\n\t\t\tconst impl = buildImplDefinition(tsImpl, new TypeRefExpr(name), members.map(m => m.name), braces.site.endSite);\n\n\t\t\tif (!impl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new EnumStatement(site.merge(braces.site), name, members, impl);\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {(ImportStatement | null)[] | null}\n */\nfunction buildImportStatements(site, ts) {\n\tconst maybeBraces = ts.shift();\n\n\tif (maybeBraces === undefined) {\n\t\tsite.syntaxError(\"expected '{...}' after 'import'\");\n\t\treturn null;\n\t} else {\n\t\tconst braces = maybeBraces.assertGroup(\"{\");\n\t\tif (!braces) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst maybeFrom = assertToken(ts.shift(), maybeBraces.site, \"expected 'from' after 'import {...}'\")?.assertWord(\"from\");\n\t\tif (!maybeFrom) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst maybeModuleName = assertToken(ts.shift(), maybeFrom.site, \"expected module name after 'import {...} from'\");\n\t\tif (!maybeModuleName) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * @type {null | undefined | Word}\n\t\t */\n\t\tlet moduleName = null;\n\n\t\tif (maybeModuleName instanceof StringLiteral && importPathTranslator) {\n\t\t\tlet translated = importPathTranslator(maybeModuleName);\n\n\t\t\tif (!translated) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tmoduleName = new Word(maybeModuleName.site, translated);\n\t\t} else {\n\t\t\tmoduleName = maybeModuleName.assertWord()?.assertNotKeyword();\n\t\t}\n\n\t\tif (!moduleName) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst mName = moduleName;\n\n\t\tif (braces.fields.length === 0) {\n\t\t\tbraces.syntaxError(\"expected at least 1 import field\");\n\t\t}\n\n\t\treturn braces.fields.map(fts => {\n\t\t\tconst ts = fts.slice();\n\t\t\tconst maybeOrigName = ts.shift();\n\n\t\t\tif (maybeOrigName === undefined) {\n\t\t\t\tbraces.syntaxError(\"empty import field\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst origName = maybeOrigName.assertWord();\n\n\t\t\t\tif (!origName) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (ts.length === 0) {\n\t\t\t\t\treturn new ImportStatement(site, origName, origName, mName);\n\t\t\t\t} else {\n\t\t\t\t\tconst maybeAs = ts.shift();\n\n\t\t\t\t\tif (maybeAs === undefined) {\n\t\t\t\t\t\tmaybeOrigName.syntaxError(`expected 'as' or nothing after '${origName.value}'`);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaybeAs.assertWord(\"as\");\n\n\t\t\t\t\t\tconst maybeNewName = ts.shift();\n\n\t\t\t\t\t\tif (maybeNewName === undefined) {\n\t\t\t\t\t\t\tmaybeAs.syntaxError(\"expected word after 'as'\");\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst newName = maybeNewName.assertWord();\n\n\t\t\t\t\t\t\tif (!newName) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst rem = ts.shift();\n\t\t\t\t\t\t\tif (rem !== undefined) {\n\t\t\t\t\t\t\t\trem.syntaxError(\"unexpected token\");\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn new ImportStatement(site, newName, origName, mName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).filter(f => f !== null)\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {EnumMember | null}\n */\nfunction buildEnumMember(ts) {\n\tconst name = assertDefined(ts.shift()).assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t} else if (ts.length == 0 || ts[0].isWord()) {\n\t\treturn new EnumMember(name, []);\n\t} else {\n\t\tconst braces = assertToken(ts.shift(), name.site)?.assertGroup(\"{\", 1);\n\n\t\tif (!braces) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst fields = buildDataFields(braces.fields[0]);\n\n\t\t\treturn new EnumMember(name, fields);\n\t\t}\n\t}\n}\n\n/** \n * @package\n * @param {Token[]} ts \n * @param {TypeRefExpr} selfTypeExpr - reference to parent type\n * @param {Word[]} fieldNames - to check if impl statements have a unique name\n * @param {?Site} endSite\n * @returns {ImplDefinition | null}\n */\nfunction buildImplDefinition(ts, selfTypeExpr, fieldNames, endSite) {\n\t/**\n\t * @param {Word} name\n\t * @returns {boolean}\n\t */\n\tfunction isNonAuto(name) {\n\t\tif (AUTOMATIC_METHODS.findIndex(n => n == name.toString()) != -1) {\n\t\t\tname.syntaxError(`'${name.toString()}' is a reserved member`);\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (let fieldName of fieldNames) {\n\t\tif (!isNonAuto(fieldName)) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst statements = buildImplMembers(ts, selfTypeExpr);\n\n\t/** \n\t * @param {number} i\n\t * @returns {boolean} - ok\n\t */\n\tfunction isUnique(i) {\n\t\tlet s = statements[i];\n\n\t\tisNonAuto(s.name);\n\n\t\tfor (let fieldName of fieldNames) {\n\t\t\tif (fieldName.toString() == s.name.toString()) {\n\t\t\t\ts.name.syntaxError(`'${s.name.toString()}' is duplicate`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = i+1; j < statements.length; j++) {\n\t\t\tif (statements[j].name.toString() == s.name.toString()) {\n\t\t\t\tstatements[j].name.syntaxError(`'${s.name.toString()}' is duplicate`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconst n = statements.length;\n\n\tfor (let i = 0; i < n; i++) {\n\t\tif (!isUnique(i)) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tif (n > 0 && endSite !== null) {\n\t\tstatements[n-1].site.setEndSite(endSite);\n\t}\n\n\treturn new ImplDefinition(selfTypeExpr, statements);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @param {TypeExpr} methodOf\n * @returns {(ConstStatement | FuncStatement)[]}\n */\nfunction buildImplMembers(ts, methodOf) {\n\t/** @type {(ConstStatement | FuncStatement)[]} */\n\tconst statements = [];\n\n\twhile (ts.length != 0) {\n\t\tconst t = assertDefined(ts.shift()).assertWord();\n\n\t\tif (!t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst kw = t.value;\n\n\t\t/**\n\t\t * @type {null | ConstStatement | FuncStatement}\n\t\t */\n\t\tlet s = null;\n\n\t\tif (kw == \"const\") {\n\t\t\ts = buildConstStatement(t.site, ts);\n\t\t} else if (kw == \"func\") {\n\t\t\ts = buildFuncStatement(t.site, ts, methodOf);\n\t\t} else {\n\t\t\tt.syntaxError(\"invalid impl syntax\");\n\t\t}\n\n\t\tif (s) {\n\t\t\tstatements.push(s);\n\t\t}\n\t}\n\n\treturn statements\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Token[]} ts \n * @returns {TypeExpr | null}\n */\nfunction buildTypeExpr(site, ts) {\n\tif (ts.length == 0) {\n\t\tsite.syntaxError(\"expected token\");\n\t\treturn null;\n\t}\n\n\tif (ts[0].isGroup(\"[\")) {\n\t\treturn buildListTypeExpr(ts);\n\t} else if (ts[0].isWord(\"Map\")) {\n\t\treturn buildMapTypeExpr(ts);\n\t} else if (ts[0].isWord(\"Option\")) {\n\t\treturn buildOptionTypeExpr(ts);\n\t} else if (ts.length > 1 && ts[0].isGroup(\"(\") && ts[1].isSymbol(\"->\")) {\n\t\treturn buildFuncTypeExpr(ts);\n\t} else if (ts.length > 1 && ts[0].isWord() && ts[1].isSymbol(\"::\")) {\n\t\treturn buildTypePathExpr(ts);\n\t} else if (ts[0].isWord()) {\n\t\treturn buildTypeRefExpr(ts);\n\t} else {\n\t\tts[0].syntaxError(\"invalid type syntax\");\n\t\treturn null;\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {ListTypeExpr | null}\n */\nfunction buildListTypeExpr(ts) {\n\tconst brackets = assertDefined(ts.shift()).assertGroup(\"[\", 0);\n\n\tif (!brackets) {\n\t\treturn null\n\t}\n\n\tconst itemTypeExpr = buildTypeExpr(brackets.site, ts);\n\n\tif (!itemTypeExpr) {\n\t\treturn null;\n\t}\n\n\treturn new ListTypeExpr(brackets.site, itemTypeExpr);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {MapTypeExpr | null}\n */\nfunction buildMapTypeExpr(ts) {\n\tconst kw = assertDefined(ts.shift()).assertWord(\"Map\");\n\n\tif (!kw) {\n\t\treturn null;\n\t}\n\n\tconst maybeKeyTypeExpr = assertToken(ts.shift(), kw.site, \"missing Map key-type\");\n\n\tif (!maybeKeyTypeExpr) {\n\t\treturn null;\n\t}\n\n\tconst keyTypeTs = maybeKeyTypeExpr.assertGroup(\"[\", 1)?.fields[0];\n\tif (keyTypeTs === null || keyTypeTs === undefined) {\n\t\treturn null;\n\t} else if (keyTypeTs.length == 0) {\n\t\tkw.syntaxError(\"missing Map key-type (brackets can't be empty)\");\n\t\treturn null;\n\t} \n\n\tconst keyTypeExpr = buildTypeExpr(kw.site, keyTypeTs);\n\tif (!keyTypeExpr) {\n\t\treturn null;\n\t}\n\n\tif (ts.length == 0) {\n\t\tkw.syntaxError(\"missing Map value-type\");\n\t\treturn null;\n\t} \n\n\tconst valueTypeExpr = buildTypeExpr(kw.site, ts);\n\n\tif (!valueTypeExpr) {\n\t\treturn null;\n\t}\n\n\treturn new MapTypeExpr(kw.site, keyTypeExpr, valueTypeExpr);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {TypeExpr | null}\n */\nfunction buildOptionTypeExpr(ts) {\n\tconst kw = assertDefined(ts.shift()).assertWord(\"Option\");\n\n\tif (!kw) {\n\t\treturn null;\n\t}\n\n\tconst typeTs = assertToken(ts.shift(), kw.site)?.assertGroup(\"[\", 1)?.fields[0];\n\n\tif (!typeTs) {\n\t\treturn null;\n\t}\n\n\tconst someTypeExpr = buildTypeExpr(kw.site, typeTs);\n\tif (!someTypeExpr) {\n\t\treturn null;\n\t}\n\n\tconst typeExpr = new OptionTypeExpr(kw.site, someTypeExpr);\n\tif (ts.length > 0) {\n\t\tif (ts[0].isSymbol(\"::\") && ts[1].isWord([\"Some\", \"None\"])) {\n\t\t\tif (ts.length > 2) {\n\t\t\t\tts[2].syntaxError(\"unexpected token\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst memberName = ts[1].assertWord()\n\n\t\t\t\tif (!memberName) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn new TypePathExpr(ts[0].site, typeExpr, memberName);\n\t\t\t}\n\t\t} else {\n\t\t\tts[0].syntaxError(\"invalid option type syntax\");\n\t\t\treturn null;\n\t\t}\n\t} else {\n\t\treturn typeExpr;\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {FuncTypeExpr | null}\n */\nfunction buildFuncTypeExpr(ts) {\n\tconst parens = assertDefined(ts.shift()).assertGroup(\"(\");\n\n\tif (!parens) {\n\t\treturn null;\n\t}\n\n\tlet hasOptArgs = false;\n\n\tconst argTypes = reduceNull(parens.fields.map(f => {\n\t\tconst fts = f.slice();\n\n\t\tif (fts.length == 0) {\n\t\t\tparens.syntaxError(\"expected func arg type\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst funcArgTypeExpr = buildFuncArgTypeExpr(fts);\n\n\t\tif (!funcArgTypeExpr) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (hasOptArgs) {\n\t\t\tif (!funcArgTypeExpr.isOptional()) {\n\t\t\t\tfuncArgTypeExpr.syntaxError(\"optional arguments must come last\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (funcArgTypeExpr.isOptional()) {\n\t\t\t\thasOptArgs = true;\n\t\t\t}\n\t\t}\n\n\t\treturn funcArgTypeExpr;\n\t}));\n\n\tif (!argTypes) {\n\t\treturn null;\n\t} else {\n\t\tif (argTypes.some(at => at.isNamed()) && argTypes.some(at => !at.isNamed())) {\n\t\t\targTypes[0].syntaxError(\"can't mix named and unnamed args in func type\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\tconst arrow = assertToken(ts.shift(), parens.site)?.assertSymbol(\"->\");\n\n\t\tif (!arrow) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tconst retTypes = buildFuncRetTypeExprs(arrow.site, ts, false);\n\n\t\tif (!retTypes) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new FuncTypeExpr(parens.site, argTypes, retTypes.map(t => assertDefined(t)));\n\t}\n}\n\n/**\n * \n * @param {Token[]} ts \n * @returns {FuncArgTypeExpr | null}\n */\nfunction buildFuncArgTypeExpr(ts) {\n\tconst colonPos = SymbolToken.find(ts, \":\");\n\n\tif (colonPos != -1 && colonPos != 1) {\n\t\tts[0].syntaxError(\"invalid syntax\");\n\t\treturn null;\n\t}\n\n\t/**\n\t * @type {Word | null}\n\t */\n\tlet name = null;\n\n\tif (colonPos != -1) {\n\t\tname = assertDefined(ts.shift()).assertWord()?.assertNotKeyword() ?? null;\n\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst colon = assertDefined(ts.shift()).assertSymbol(\":\");\n\n\t\tif (!colon) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (ts.length == 0) {\n\t\t\tcolon.syntaxError(\"expected type expression after ':'\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst next = assertDefined(ts[0]);\n\n\tconst hasDefault = next.isSymbol(\"?\");\n\tif (hasDefault) {\n\t\tconst opt = assertDefined(ts.shift());\n\n\t\tif (ts.length == 0) {\n\t\t\topt.syntaxError(\"invalid type expression after '?'\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst typeExpr = buildTypeExpr(next.site, ts);\n\tif (!typeExpr) {\n\t\treturn null;\n\t}\n\n\treturn new FuncArgTypeExpr(name !== null ? name.site : typeExpr.site, name, typeExpr, hasDefault);\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @param {boolean} allowInferredRetType\n * @returns {null | (null | TypeExpr)[]}\n */\nfunction buildFuncRetTypeExprs(site, ts, allowInferredRetType = false) {\n\tif (ts.length === 0) {\n\t\tif (allowInferredRetType) {\n\t\t\treturn [null];\n\t\t} else {\n\t\t\tsite.syntaxError(\"expected type expression after '->'\");\n\t\t\treturn null;\n\t\t}\n\t} else {\n\t\tif (ts[0].isGroup(\"(\") && (ts.length == 1 || !ts[1].isSymbol(\"->\"))) {\n\t\t\tconst group = assertToken(ts.shift(), site)?.assertGroup(\"(\");\n\n\t\t\tif (!group) {\n\t\t\t\treturn null;\n\t\t\t} else if (group.fields.length == 0) {\n\t\t\t\treturn [new VoidTypeExpr(group.site)];\n\t\t\t} else if (group.fields.length == 1) {\n\t\t\t\tgroup.syntaxError(\"expected 0 or 2 or more types in multi return type\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn group.fields.map(fts => {\n\t\t\t\t\tfts = fts.slice();\n\n\t\t\t\t\treturn buildTypeExpr(group.site, fts);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\treturn [buildTypeExpr(site, ts)];\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {null | TypePathExpr}\n */\nfunction buildTypePathExpr(ts) {\n\tconst baseName = assertDefined(ts.shift()).assertWord()?.assertNotKeyword();\n\n\tif (!baseName) {\n\t\treturn null;\n\t}\n\n\tconst symbol = assertToken(ts.shift(), baseName.site)?.assertSymbol(\"::\");\n\n\tif (!symbol) {\n\t\treturn null;\n\t}\n\n\tconst memberName = assertToken(ts.shift(), symbol.site)?.assertWord();\n\n\tif (!memberName) {\n\t\treturn null;\n\t}\n\n\tif (ts.length > 0) {\n\t\tts[0].syntaxError(\"invalid type syntax\");\n\t\treturn null;\n\t}\n\t\n\treturn new TypePathExpr(symbol.site, new TypeRefExpr(baseName), memberName);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {TypeRefExpr | null}\n */\nfunction buildTypeRefExpr(ts) {\n\tconst name = assertDefined(ts.shift()).assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t}\n\n\tif (ts.length > 0) {\n\t\tts[0].syntaxError(\"invalid type syntax\");\n\t\treturn null;\n\t}\n\n\treturn new TypeRefExpr(name);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @param {number} prec \n * @returns {ValueExpr | null}\n */\nfunction buildValueExpr(ts, prec = 0) {\n\tassert(ts.length > 0);\n\n\t// lower index in exprBuilders is lower precedence\n\t/** @type {((ts: Token[], prev: number) => (ValueExpr | null))[]} */\n\tconst exprBuilders = [\n\t\t/**\n\t\t * 0: lowest precedence is assignment\n\t\t * @param {Token[]} ts_ \n\t\t * @param {number} prec_ \n\t\t * @returns \n\t\t */\n\t\tfunction (ts_, prec_) {\n\t\t\treturn buildMaybeAssignOrPrintExpr(ts_, prec_);\n\t\t},\n\t\tmakeBinaryExprBuilder('||'), // 1: logical or operator\n\t\tmakeBinaryExprBuilder('&&'), // 2: logical and operator\n\t\tmakeBinaryExprBuilder(['==', '!=']), // 3: eq or neq\n\t\tmakeBinaryExprBuilder(['<', '<=', '>', '>=']), // 4: comparison\n\t\tmakeBinaryExprBuilder(['+', '-']), // 5: addition subtraction\n\t\tmakeBinaryExprBuilder(['*', '/', '%']), // 6: multiplication division remainder\n\t\tmakeUnaryExprBuilder(['!', '+', '-']), // 7: logical not, negate\n\t\t/**\n\t\t * 8: variables or literal values chained with: (enum)member access, indexing and calling\n\t\t * @param {Token[]} ts_ \n\t\t * @param {number} prec_ \n\t\t * @returns \n\t\t */\n\t\tfunction (ts_, prec_) {\n\t\t\treturn buildChainedValueExpr(ts_, prec_);\n\t\t}\n\t];\n\n\treturn exprBuilders[prec](ts, prec);\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @param {number} prec\n * @returns {ValueExpr | null}\n */\nfunction buildMaybeAssignOrPrintExpr(ts, prec) {\n\tlet semicolonPos = SymbolToken.find(ts, \";\");\n\tconst equalsPos = SymbolToken.find(ts, \"=\");\n\tconst printPos = Word.find(ts, \"print\");\n\n\tif (semicolonPos == -1) {\n\t\tif (equalsPos != -1) {\n\t\t\tts[equalsPos].syntaxError(\"invalid assignment syntax, expected ';' after '...=...'\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn buildValueExpr(ts, prec + 1);\n\t\t}\n\t} else {\n\t\tif ((equalsPos == -1 || equalsPos > semicolonPos) && (printPos == -1 || printPos > semicolonPos)) {\n\t\t\tconst upstreamExpr = buildValueExpr(ts.splice(0, semicolonPos), prec+1);\n\t\t\tconst site = assertDefined(ts.shift()).site;\n\n\t\t\tif (ts.length == 0) {\n\t\t\t\tsite.syntaxError(\"expected expression after ';'\");\n\t\t\t\treturn null;\n\t\t\t} else if (upstreamExpr === null) {\n\t\t\t\t// error will already have been created\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst downstreamExpr = buildValueExpr(ts, prec);\n\n\t\t\t\tif (downstreamExpr === null) {\n\t\t\t\t\t// error will already have been created\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn new ChainExpr(site, upstreamExpr, downstreamExpr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (equalsPos != -1 && equalsPos < semicolonPos) {\n\t\t\tif (printPos != -1) {\n\t\t\t\tif (printPos <= semicolonPos) {\n\t\t\t\t\tts[printPos].syntaxError(\"expected ';' after 'print(...)'\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst equals = ts[equalsPos].assertSymbol(\"=\");\n\n\t\t\tif (!equals) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst equalsSite = equals.site;\n\n\t\t\tconst lts = ts.splice(0, equalsPos);\n\n\t\t\tconst lhs = buildAssignLhs(equalsSite, lts);\n\t\t\t\n\t\t\tassertDefined(ts.shift()).assertSymbol(\"=\");\n\n\t\t\tsemicolonPos = SymbolToken.find(ts, \";\");\n\t\t\tassert(semicolonPos != -1);\n\n\t\t\tlet upstreamTs = ts.splice(0, semicolonPos);\n\t\t\tif (upstreamTs.length == 0) {\n\t\t\t\tequalsSite.syntaxError(\"expected expression between '=' and ';'\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst upstreamExpr = buildValueExpr(upstreamTs, prec + 1);\n\n\t\t\tconst semicolon  = assertToken(ts.shift(), equalsSite)?.assertSymbol(\";\");\n\n\t\t\tif (!semicolon) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst semicolonSite = semicolon.site;\n\n\t\t\tif (ts.length == 0) {\n\t\t\t\tsemicolonSite.syntaxError(\"expected expression after ';'\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst downstreamExpr = buildValueExpr(ts, prec);\n\n\t\t\tif (downstreamExpr === null || upstreamExpr === null || lhs === null) {\n\t\t\t\t// error will already have been thrown internally\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn new AssignExpr(equalsSite, lhs, upstreamExpr, downstreamExpr);\n\t\t\t}\n\t\t} else if (printPos != -1 && printPos < semicolonPos) {\n\t\t\tif (equalsPos != -1) {\n\t\t\t\tif (equalsPos <= semicolonPos) {\n\t\t\t\t\tts[equalsPos].syntaxError(\"expected ';' after '...=...'\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst print = assertDefined(ts.shift()).assertWord(\"print\");\n\n\t\t\tif (!print) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst printSite = print.site;\n\n\t\t\tconst maybeParens = ts.shift();\n\n\t\t\tif (maybeParens === undefined) {\n\t\t\t\tts[printPos].syntaxError(\"expected '(...)' after 'print'\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst parens = maybeParens.assertGroup(\"(\", 1);\n\n\t\t\t\tif (!parens) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst msgExpr = buildValueExpr(parens.fields[0]);\n\n\t\t\t\tconst semicolon = assertToken(ts.shift(), parens.site)?.assertSymbol(\";\")\n\n\t\t\t\tif (!semicolon) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst semicolonSite = semicolon.site;\n\n\t\t\t\tif (ts.length == 0) {\n\t\t\t\t\tsemicolonSite.syntaxError(\"expected expression after ';'\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst downstreamExpr = buildValueExpr(ts, prec);\n\n\t\t\t\tif (!downstreamExpr || !msgExpr) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn new PrintExpr(printSite, msgExpr, downstreamExpr);\n\t\t\t}\n\t\t} else {\n\t\t\tts[0].syntaxError(\"unhandled\");\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Token[]} ts \n * @param {boolean} isSwitchCase\n * @returns {DestructExpr | null}\n */\nfunction buildDestructExpr(site, ts, isSwitchCase = false) {\n\tif (ts.length == 0) {\n\t\tsite.syntaxError(\"expected token inside destructuring braces\");\n\t\treturn null;\n\t}\n\n\tlet maybeName = assertToken(ts.shift(), site);\n\n\tif (!maybeName) {\n\t\treturn null;\n\t}\n\n\tif (maybeName.isWord(\"_\")) {\n\t\tif (ts.length != 0) {\n\t\t\tmaybeName.syntaxError(\"unexpected tokens after '_'\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn new DestructExpr(new Word(maybeName.site, \"_\"), null);\n\t\t}\n\t} else {\n\t\tlet name = new Word(maybeName.site, \"_\");\n\n\t\tif (ts.length >= 1 && ts[0].isSymbol(\":\")) {\n\t\t\tlet name_ = maybeName.assertWord()?.assertNotKeyword();\n\n\t\t\tif (!name_) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tname = name_;\n\n\t\t\tconst colon = assertToken(ts.shift(), name.site)?.assertSymbol(\":\");\n\n\t\t\tif (!colon) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (ts.length == 0) {\n\t\t\t\tcolon.syntaxError(\"expected type expression after ':'\");\n\t\t\t\treturn null;\n\t\t\t} \n\n\t\t\tconst destructExprs = buildDestructExprs(ts);\n\n\t\t\tif (destructExprs === null || destructExprs === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tconst typeExpr = buildTypeExpr(colon.site, ts);\n\n\t\t\tif (!typeExpr) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new DestructExpr(name, typeExpr, destructExprs);\n\t\t} else if (ts.length == 0) {\n\t\t\tif (isSwitchCase) {\n\t\t\t\tconst typeName = maybeName.assertWord()?.assertNotKeyword();\n\n\t\t\t\tif (!typeName) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst typeExpr = new TypeRefExpr(typeName);\n\n\t\t\t\tif (!typeExpr) {\n\t\t\t\t\treturn null;\n\t\t\t\t} \n\n\t\t\t\treturn new DestructExpr(name, typeExpr);\n\t\t\t} else {\n\t\t\t\tconst name = maybeName.assertWord()?.assertNotKeyword();\n\n\t\t\t\tif (!name) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn new DestructExpr(name, null);\n\t\t\t}\n\t\t} else {\n\t\t\tts.unshift(maybeName);\n\n\t\t\tconst destructExprs = buildDestructExprs(ts);\n\n\t\t\tif (destructExprs === null || destructExprs === undefined) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tconst typeExpr = buildTypeExpr(site, ts);\n\n\t\t\tif (!typeExpr) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new DestructExpr(name, typeExpr, destructExprs);\n\t\t}\n\t}\n}\n\n/**\n * Pops the last element of ts if it is a braces group\n * @param {Token[]} ts\n * @returns {null | DestructExpr[]}\n */\nfunction buildDestructExprs(ts) {\n\tif (ts.length == 0) {\n\t\treturn [];\n\t} else if (ts[ts.length -1].isGroup(\"{\")) {\n\t\tconst group = assertDefined(ts.pop()).assertGroup(\"{\");\n\n\t\tif (!group) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst destructExprs = group.fields.map(fts => {\n\t\t\treturn buildDestructExpr(group.site, fts);\n\t\t});\n\t\n\t\tif (destructExprs.every(le => le !== null && le.isIgnored() && !le.hasDestructExprs())) {\n\t\t\tgroup.syntaxError(\"expected at least one used field while destructuring\")\n\t\t\treturn null;\n\t\t}\n\n\t\treturn reduceNull(destructExprs);\n\t} else {\n\t\treturn [];\n\t}\t\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {null | DestructExpr[]}\n */\nfunction buildAssignLhs(site, ts) {\n\tconst maybeName = ts.shift();\n\tif (maybeName === undefined) {\n\t\tsite.syntaxError(\"expected a name before '='\");\n\t\treturn null;\n\t} else {\n\t\t/**\n\t\t * @type {DestructExpr[]}\n\t\t */\n\t\tconst pairs = [];\n\n\t\tif (maybeName.isWord()) {\n\t\t\tts.unshift(maybeName);\n\n\t\t\tconst lhs = buildDestructExpr(maybeName.site, ts);\n\n\t\t\tif (lhs === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (lhs.isIgnored() && !lhs.hasDestructExprs()) {\n\t\t\t\tmaybeName.syntaxError(`unused assignment ${maybeName.toString()}`);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tpairs.push(lhs);\n\t\t} else if (maybeName.isGroup(\"(\")) {\n\t\t\tconst group = maybeName.assertGroup(\"(\");\n\n\t\t\tif (!group) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (group.fields.length < 2) {\n\t\t\t\tgroup.syntaxError(\"expected at least 2 lhs' for multi-assign\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet someNoneUnderscore = false;\n\t\t\tfor (let fts of group.fields) {\n\t\t\t\tif (fts.length == 0) {\n\t\t\t\t\tgroup.syntaxError(\"unexpected empty field for multi-assign\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tfts = fts.slice();\n\n\t\t\t\tconst lhs = buildDestructExpr(group.site, fts);\n\n\t\t\t\tif (!lhs) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!lhs.isIgnored() || lhs.hasDestructExprs()) {\n\t\t\t\t\tsomeNoneUnderscore = true;\n\t\t\t\t}\n\n\t\t\t\t// check that name is unique\n\t\t\t\tpairs.forEach(p => {\n\t\t\t\t\tif (!lhs.isIgnored() && p.name.value === lhs.name.value) {\n\t\t\t\t\t\tlhs.name.syntaxError(`duplicate name '${lhs.name.value}' in lhs of multi-assign`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tpairs.push(lhs);\n\t\t\t}\n\n\t\t\tif (!someNoneUnderscore) {\n\t\t\t\tgroup.syntaxError(\"expected at least one non-underscore in lhs of multi-assign\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tmaybeName.syntaxError(\"unexpected syntax for lhs of =\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pairs;\n\t}\n}\n\n/**\n * @package\n * @param {string | string[]} symbol \n * @returns {(ts: Token[], prec: number) => (ValueExpr | null)}\n */\nfunction makeBinaryExprBuilder(symbol) {\n\t// default behaviour is left-to-right associative\n\treturn function (ts, prec) {\n\t\tconst iOp = SymbolToken.findLast(ts, symbol);\n\n\t\tif (iOp == ts.length - 1) {\n\t\t\t// post-unary operator, which is invalid\n\t\t\tts[iOp].syntaxError(`invalid syntax, '${ts[iOp].toString()}' can't be used as a post-unary operator`);\n\t\t\treturn null;\n\t\t} else if (iOp > 0) { // iOp == 0 means maybe a (pre)unary op, which is handled by a higher precedence\n\t\t\tconst a = buildValueExpr(ts.slice(0, iOp), prec);\n\t\t\tconst b = buildValueExpr(ts.slice(iOp + 1), prec + 1);\n\t\t\tconst op = ts[iOp].assertSymbol();\n\n\t\t\tif (!a || !b || !op) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new BinaryExpr(op, a, b);\n\t\t} else {\n\t\t\treturn buildValueExpr(ts, prec + 1);\n\t\t}\n\t};\n}\n\n/**\n * @package\n * @param {string | string[]} symbol \n * @returns {(ts: Token[], prec: number) => (ValueExpr | null)}\n */\nfunction makeUnaryExprBuilder(symbol) {\n\t// default behaviour is right-to-left associative\n\treturn function (ts, prec) {\n\t\tif (ts[0].isSymbol(symbol)) {\n\t\t\tconst rhs = buildValueExpr(ts.slice(1), prec);\n\t\t\tconst op = ts[0].assertSymbol();\n\n\t\t\tif (!rhs || !op) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new UnaryExpr(op, rhs);\n\t\t} else {\n\t\t\treturn buildValueExpr(ts, prec + 1);\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @param {number} prec \n * @returns {ValueExpr | null}\n */\nfunction buildChainedValueExpr(ts, prec) {\n\t/** @type {ValueExpr | null} */\n\tlet expr = buildChainStartValueExpr(ts);\n\n\t// now we can parse the rest of the chaining\n\twhile (ts.length > 0) {\n\t\tif (expr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst t = assertDefined(ts.shift());\n\n\t\tif (t.isGroup(\"(\")) {\n\t\t\texpr = buildCallExpr(t.site, expr, assertDefined(t.assertGroup()));\n\t\t} else if (t.isGroup(\"[\")) {\n\t\t\tt.syntaxError(\"invalid expression '[...]'\");\n\t\t\treturn null;\n\t\t} else if (t.isSymbol(\".\") && ts.length > 0 && ts[0].isWord(\"switch\")) {\n\t\t\texpr = buildSwitchExpr(expr, ts);\n\t\t} else if (t.isSymbol(\".\")) {\n\t\t\tconst name = assertToken(ts.shift(), t.site)?.assertWord()?.assertNotKeyword();\n\n\t\t\tif (!name) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\texpr = new MemberExpr(t.site, expr, name);\n\t\t} else if (t.isGroup(\"{\")) {\n\t\t\tt.syntaxError(\"invalid syntax\");\n\t\t\treturn null;\n\t\t} else if (t.isSymbol(\"::\")) {\n\t\t\tt.syntaxError(\"invalid syntax\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\tt.syntaxError(`invalid syntax '${t.toString()}'`);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn expr;\n}\n\n/**\n * @param {Site} site \n * @param {ValueExpr} fnExpr \n * @param {Group} parens\n * @returns {CallExpr | null}\n */\nfunction buildCallExpr(site, fnExpr, parens) {\n\tconst callArgs = buildCallArgs(parens);\n\n\tif (callArgs === null) {\n\t\treturn null;\n\t} else {\n\t\treturn new CallExpr(site, fnExpr, callArgs);\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {ValueExpr | null}\n */\nfunction buildChainStartValueExpr(ts) {\n\tif (ts.length > 1 && ts[0].isGroup(\"(\") && ts[1].isSymbol(\"->\")) {\n\t\treturn buildFuncLiteralExpr(ts, null, true);\n\t} else if (ts[0].isWord(\"if\")) {\n\t\treturn buildIfElseExpr(ts);\n\t} else if (ts[0].isWord(\"switch\")) {\n\t\tts[0].syntaxError(\"expected '... .switch' instead of 'switch'\");\n\t\treturn null;\n\t} else if (ts[0].isLiteral()) {\n\t\treturn new PrimitiveLiteralExpr(assertDefined(ts.shift())); // can simply be reused\n\t} else if (ts[0].isGroup(\"(\")) {\n\t\treturn buildParensExpr(ts);\n\t} else if (Group.find(ts, \"{\") != -1) {\n\t\tif (ts[0].isGroup(\"[\")) {\n\t\t\treturn buildListLiteralExpr(ts);\n\t\t} else if (ts[0].isWord(\"Map\") && ts[1].isGroup(\"[\")) {\n\t\t\treturn buildMapLiteralExpr(ts); \n\t\t} else {\n\t\t\t// could be switch or literal struct construction\n\t\t\tconst iBraces = Group.find(ts, \"{\");\n\t\t\tconst iSwitch = Word.find(ts, \"switch\");\n\t\t\tconst iPeriod = SymbolToken.find(ts, \".\");\n\n\t\t\tif (iSwitch != -1 && iPeriod != -1 && iSwitch < iBraces && iPeriod < iBraces && iSwitch > iPeriod) {\n\t\t\t\treturn buildValueExpr(ts.splice(0, iPeriod));\n\t\t\t} else {\n\t\t\t\treturn buildStructLiteralExpr(ts);\n\t\t\t}\n\t\t}\n\t} else if (SymbolToken.find(ts, \"::\") != -1) {\n\t\treturn buildValuePathExpr(ts);\n\t} else if (ts[0].isWord()) {\n\t\tif (ts[0].isWord(\"const\") || ts[0].isWord(\"struct\") || ts[0].isWord(\"enum\") || ts[0].isWord(\"func\") || ts[0].isWord(\"import\")) {\n\t\t\tts[0].syntaxError(`invalid use of '${assertDefined(ts[0].assertWord()).value}', can only be used as top-level statement`);\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst name = assertDefined(ts.shift()?.assertWord());\n\n\t\t\tif (name.value == \"self\") {\n\t\t\t\treturn new ValueRefExpr(name);\n\t\t\t} else {\n\t\t\t\tconst n = name.assertNotKeyword();\n\n\t\t\t\tif (!n) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn new ValueRefExpr(n);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tts[0].syntaxError(\"invalid syntax\");\n\t\treturn null;\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @returns {ValueExpr | null}\n */\nfunction buildParensExpr(ts) {\n\tconst group = assertDefined(ts.shift()).assertGroup(\"(\");\n\n\tif (!group) {\n\t\treturn null;\n\t}\n\n\tconst site = group.site;\n\n\tif (group.fields.length === 0) {\n\t\tgroup.syntaxError(\"expected at least one expr in parens\");\n\t\treturn null;\n\t} else {\n\t\tconst fields = group.fields.map(fts => buildValueExpr(fts));\n\n\t\t/**\n\t\t * @type {ValueExpr[]}\n\t\t */\n\t\tconst nonNullFields = [];\n\n\t\tfields.forEach(f => {\n\t\t\tif (f !== null) {\n\t\t\t\tnonNullFields.push(f);\n\t\t\t}\n\t\t});\n\n\t\tif (nonNullFields.length == 0) {\n\t\t\t// error will already have been thrown internally\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn new ParensExpr(site, nonNullFields);\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Group} parens \n * @returns {CallArgExpr[] | null}\n */\nfunction buildCallArgs(parens) {\n\t/**\n\t * @type {Set<string>}\n\t */\n\tconst names = new Set();\n\n\tconst callArgs = reduceNull(parens.fields.map(fts => {\n\t\tconst callArg = buildCallArgExpr(parens.site, fts);\n\n\t\tif (callArg !== null && callArg.isNamed()) {\n\t\t\tif (names.has(callArg.name)) {\n\t\t\t\tcallArg.syntaxError(`duplicate named call arg ${callArg.name}`);\n\t\t\t}\n\n\t\t\tnames.add(callArg.name);\n\t\t}\n\n\t\treturn callArg;\n\t}));\n\n\tif (callArgs === null) {\n\t\treturn null;\n\t} else {\n\t\tif (callArgs.some(ca => ca.isNamed()) && callArgs.some(ca => !ca.isNamed())) {\n\t\t\tcallArgs[0].syntaxError(\"can't mix positional and named args\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn callArgs;\n\t}\n}\n\n/**\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {CallArgExpr | null}\n */\nfunction buildCallArgExpr(site, ts) {\n\tif (ts.length == 0) {\n\t\tsite.syntaxError(\"invalid syntax\");\n\t\treturn null;\n\t}\n\n\t/**\n\t * @type {null | undefined | Word}\n\t */\n\tlet name = null;\n\n\tif (ts.length >= 2 && ts[0].isWord() && ts[1].isSymbol(\":\")) {\n\t\tname = assertDefined(ts.shift()).assertWord()?.assertNotKeyword();\n\n\t\tif (!name) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst colon = assertDefined(ts.shift());\n\n\t\tif (ts.length == 0) {\n\t\t\tcolon.syntaxError(\"expected value expressions after ':'\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst value = buildValueExpr(ts);\n\n\tif (!value) {\n\t\treturn null;\n\t}\n\n\treturn new CallArgExpr(name != null ? name.site : value.site, name, value);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {IfElseExpr | null}\n */\nfunction buildIfElseExpr(ts) {\n\tconst ifWord = assertDefined(ts.shift()).assertWord(\"if\");\n\n\tif (!ifWord) {\n\t\treturn null;\n\t}\n\n\tconst site = ifWord.site;\n\n\t/** @type {ValueExpr[]} */\n\tconst conditions = [];\n\n\t/** @type {ValueExpr[]} */\n\tconst branches = [];\n\twhile (true) {\n\t\tconst parens = assertToken(ts.shift(), site)?.assertGroup(\"(\");\n\n\t\tif (!parens) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst braces = assertToken(ts.shift(), site)?.assertGroup(\"{\");\n\n\t\tif (!braces) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (parens.fields.length != 1) {\n\t\t\tparens.syntaxError(\"expected single if-else condition\");\n\t\t\treturn null;\n\t\t}\n\n\t\tif (braces.fields.length == 0) {\n\t\t\tbraces.syntaxError(\"branch body can't be empty\");\n\t\t\treturn null;\n\t\t} else if (braces.fields.length != 1) {\n\t\t\tbraces.syntaxError(\"expected single if-else branch expession\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst cond = buildValueExpr(parens.fields[0]);\n\t\tconst branch = buildValueExpr(braces.fields[0]);\n\n\t\tif (cond === null || branch === null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconditions.push(cond);\n\t\tbranches.push(branch);\n\n\t\tconst maybeElse = ts.shift();\n\n\t\tif (maybeElse === undefined ) {\n\t\t\t// add a void else branch\n\t\t\tbranches.push(new VoidExpr(braces.site));\n\t\t\tbreak;\n\t\t} else {\n\t\t\tconst elseWord = maybeElse.assertWord(\"else\");\n\n\t\t\tif (!elseWord) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst next = assertToken(ts.shift(), elseWord.site);\n\n\t\t\tif (!next) {\n\t\t\t\treturn null;\n\t\t\t} else if (next.isGroup(\"{\")) {\n\t\t\t\t// last group\n\t\t\t\tconst braces = next.assertGroup();\n\n\t\t\t\tif (!braces) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (braces.fields.length != 1) {\n\t\t\t\t\tbraces.syntaxError(\"expected single expession for if-else branch\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst elseBranch = buildValueExpr(braces.fields[0]);\n\n\t\t\t\tif (!elseBranch) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tbranches.push(elseBranch);\n\t\t\t\tbreak;\n\t\t\t} else if (next.isWord(\"if\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tnext.syntaxError(\"unexpected token\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new IfElseExpr(site, conditions, branches);\n}\n\n/**\n * @package\n * @param {ValueExpr} controlExpr\n * @param {Token[]} ts \n * @returns {ValueExpr | null} - EnumSwitchExpr or DataSwitchExpr\n */\nfunction buildSwitchExpr(controlExpr, ts) {\n\tconst switchWord = assertDefined(ts.shift()).assertWord(\"switch\");\n\n\tif (!switchWord) {\n\t\treturn null;\n\t}\n\n\tconst site = switchWord.site;\n\n\tconst braces = assertToken(ts.shift(), site)?.assertGroup(\"{\");\n\n\tif (!braces) {\n\t\treturn null;\n\t}\n\n\t/** @type {SwitchCase[]} */\n\tconst cases = [];\n\n\t/** @type {null | SwitchDefault} */\n\tlet def = null;\n\n\tfor (let tsInner of braces.fields) {\n\t\tif (tsInner[0].isWord(\"else\") || tsInner[0].isWord(\"_\")) {\n\t\t\tif (def !== null) {\n\t\t\t\tdef.syntaxError(\"duplicate default case in switch\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tdef = buildSwitchDefault(tsInner);\n\t\t} else {\n\t\t\tif (def !== null) {\n\t\t\t\tdef.syntaxError(\"switch default case must come last\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst c = buildSwitchCase(tsInner);\n\n\t\t\tif (c === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tcases.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check the uniqueness of each case here\n\t/** @type {Set<string>} */\n\tconst set = new Set()\n\tfor (let c of cases) {\n\t\tlet t = c.memberName.toString();\n\t\tif (set.has(t)) {\n\t\t\tc.memberName.syntaxError(`duplicate switch case '${t}')`);\n\t\t\treturn null;\n\t\t}\n\n\t\tset.add(t);\n\t}\n\n\tif (cases.length < 1) {\n\t\tsite.syntaxError(\"expected at least one switch case\");\n\t\treturn null;\n\t}\n\n\tif (cases.some(c => c.isDataMember())) {\n\t\tif (cases.length + (def === null ? 0 : 1) > 5) {\n\t\t\tsite.syntaxError(`too many cases for data switch, expected 5 or less, got ${cases.length.toString()}`);\n\t\t\treturn null;\n\t\t} else {\n\t\t\tlet count = 0;\n\t\t\tcases.forEach(c => {if (!c.isDataMember()){count++}});\n\n\t\t\tif (count > 1) {\n\t\t\t\tsite.syntaxError(`expected at most 1 enum case in data switch, got ${count}`);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tif (count === 1 && cases.some(c => c instanceof UnconstrDataSwitchCase)) {\n\t\t\t\t\tsite.syntaxError(`can't have both enum and (Int, []Data) in data switch`);\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn new DataSwitchExpr(site, controlExpr, cases, def);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn new EnumSwitchExpr(site, controlExpr, cases, def);\n\t}\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Token[]} ts\n * @param {boolean} isAfterColon\n * @returns {Word | null} \n */\nfunction buildSwitchCaseName(site, ts, isAfterColon) {\n\tconst first = ts.shift();\n\n\tif (first === undefined) {\n\t\tif (isAfterColon) {\n\t\t\tsite.syntaxError(\"invalid switch case syntax, expected member name after ':'\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\tsite.syntaxError(\"invalid switch case syntax\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t\t\n\tif (first.isWord(\"Map\")) {\n\t\tconst second = ts.shift();\n\n\t\tif (!second) {\n\t\t\tsite.syntaxError(\"expected token after 'Map'\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst keyTs = second.assertGroup(\"[]\", 1)?.fields[0];\n\n\t\tif (keyTs === undefined || keyTs === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst key = keyTs.shift();\n\n\t\tif (key === undefined) {\n\t\t\tsecond.syntaxError(\"expected 'Map[Data]Data'\");\n\t\t\treturn null;\n\t\t}\n\n\t\tkey.assertWord(\"Data\");\n\n\t\tif (keyTs.length > 0) {\n\t\t\tkeyTs[0].syntaxError(\"unexpected token after 'Data'\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst third = ts.shift();\n\n\t\tif (third === undefined) {\n\t\t\tsite.syntaxError(\"expected token after 'Map[Data]\");\n\t\t\treturn null;\n\t\t}\n\n\t\tthird.assertWord(\"Data\");\n\n\t\tif (ts.length > 0) {\n\t\t\tts[0].syntaxError(\"unexpected token after 'Map[Data]Data'\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new Word(first.site, \"Map[Data]Data\");\n\t} else if (first.isWord()) {\n\t\tif (ts.length > 0) {\n\t\t\tts[0].syntaxError(\"unexpected token\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn first?.assertWord()?.assertNotKeyword() ?? null;\n\t} else if (first.isGroup(\"[\")) {\n\t\t// list \n\t\tfirst.assertGroup(\"[\", 0);\n\n\t\tconst second = ts.shift();\n\n\t\tif (second === undefined) {\n\t\t\tsite.syntaxError(\"expected token after '[]'\");\n\t\t\treturn null;\n\t\t} else if (ts.length > 0) {\n\t\t\tts[0].syntaxError(\"unexpected token\");\n\t\t\treturn null;\n\t\t}\n\n\t\tsecond.assertWord(\"Data\");\n\n\t\treturn new Word(first.site, \"[]Data\");\n\t} else {\n\t\tfirst.syntaxError(\"invalid switch case name syntax\");\n\t\treturn null;\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {SwitchCase | null}\n */\nfunction buildSwitchCase(ts) {\n\tconst arrowPos = SymbolToken.find(ts, \"=>\");\n\n\tif (arrowPos == -1) {\n\t\tts[0].syntaxError(\"expected '=>' in switch case\");\n\t\treturn null;\n\t} else if (arrowPos == 0) {\n\t\tts[0].syntaxError(\"expected '<word>' or '<word>: <word>' to the left of '=>'\");\n\t\treturn null;\n\t}\n\n\tconst tsLeft = ts.splice(0, arrowPos);\n\n\tif (tsLeft.length === 1 && tsLeft[0].isGroup(\"(\")) {\n\t\treturn buildMultiArgSwitchCase(tsLeft, ts);\n\t} else {\n\t\treturn buildSingleArgSwitchCase(tsLeft, ts);\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {null | [?Word, Word]} - varName is optional\n */\nfunction buildSwitchCaseNameType(ts) {\n\tconst colonPos = SymbolToken.find(ts, \":\");\n\n\t/** @type {null | Word} */\n\tlet varName = null;\n\n\t/** @type {null | Word} */\n\tlet memberName = null;\n\n\tif (colonPos != -1) {\n\t\tconst maybeVarName = assertDefined(ts.shift()).assertWord()?.assertNotKeyword();\n\n\t\tif (!maybeVarName) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvarName = maybeVarName;\n\t\t\n\t\tconst maybeColon = ts.shift();\n\n\t\tif (maybeColon === undefined) {\n\t\t\tvarName.syntaxError(\"invalid switch case syntax, expected '(<name>: <enum-member>)', got '(<name>)'\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvoid maybeColon.assertSymbol(\":\");\n\n\t\t\tmemberName = buildSwitchCaseName(maybeColon.site, ts, true);\n\t\t}\n\t} else {\n\t\tmemberName = buildSwitchCaseName(ts[0].site, ts, false);\n\t}\n\n\tif (ts.length !== 0) {\n\t\tts[0].syntaxError(\"unexpected token\");\n\t\treturn null;\n\t}\n\n\tif (memberName === null) {\n\t\t// error will already have been thrown internally\n\t\treturn null;\n\t} else {\n\t\treturn [varName, memberName];\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} tsLeft\n * @param {Token[]} ts\n * @returns {SwitchCase | null}\n */\nfunction buildMultiArgSwitchCase(tsLeft, ts) {\n\tconst parens = assertDefined(tsLeft.shift()).assertGroup(\"(\");\n\n\tif (!parens) {\n\t\treturn null;\n\t}\n\n\tconst pairs = reduceNull(parens.fields.map(fts => buildSwitchCaseNameType(fts)));\n\n\tif (pairs === null) {\n\t\treturn null;\n\t}\n\n\tassert(tsLeft.length === 0);\n\n\tif (pairs.length !== 2) {\n\t\tparens.syntaxError(`expected (Int, []Data) case, got (${pairs.map(p => p[1].value).join(\", \")}`);\n\t\treturn null;\n\t} else if (pairs[0][1].value != \"Int\" || pairs[1][1].value != \"[]Data\") {\n\t\tparens.syntaxError(`expected (Int, []Data) case, got (${pairs[0][1].value}, ${pairs[1][1].value})`);\n\t\treturn null;\n\t} else {\n\t\tconst maybeArrow = ts.shift();\n\n\t\tif (maybeArrow === undefined) {\n\t\t\tparens.syntaxError(\"expected '=>'\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst arrow = maybeArrow.assertSymbol(\"=>\");\n\n\t\t\tif (!arrow) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst bodyExpr = buildSwitchCaseBody(arrow.site, ts);\n\n\t\t\tif (bodyExpr === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn new UnconstrDataSwitchCase(arrow.site, pairs[0][0], pairs[1][0], bodyExpr);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} tsLeft \n * @param {Token[]} ts \n * @returns {SwitchCase | null}\n */\nfunction buildSingleArgSwitchCase(tsLeft, ts) {\n\tconst site = tsLeft[tsLeft.length-1].site;\n\n\tconst destructExpr = buildDestructExpr(site, tsLeft, true);\n\n\tif (destructExpr === null) {\n\t\treturn null;\n\t} else if (!destructExpr.hasType()) {\n\t\tdestructExpr.site.syntaxError(\"invalid switch case syntax\");\n\t\treturn null;\n\t}\n\t\n\tconst maybeArrow = ts.shift();\n\n\tif (maybeArrow === undefined) {\n\t\tsite.syntaxError(\"expected '=>'\");\n\t\treturn null;\n\t} else {\n\t\tconst arrow = maybeArrow.assertSymbol(\"=>\");\n\n\t\tif (!arrow) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst bodyExpr = buildSwitchCaseBody(arrow.site, ts);\n\n\t\tif (bodyExpr === null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn new SwitchCase(arrow.site, destructExpr, bodyExpr);\n\t\t}\n\t}\n}\n\n/**\n * @package\n * @param {Site} site \n * @param {Token[]} ts \n * @returns {ValueExpr | null}\n */\nfunction buildSwitchCaseBody(site, ts) {\n\t/** @type {?ValueExpr} */\n\tlet bodyExpr = null;\n\n\tif (ts.length == 0) {\n\t\tsite.syntaxError(\"expected expression after '=>'\");\n\t\treturn null;\n\t} else if (ts[0].isGroup(\"{\")) {\n\t\tif (ts.length > 1) {\n\t\t\tts[1].syntaxError(\"unexpected token\");\n\t\t\treturn null;\n\t\t}\n\n\t\tconst tsBody = ts[0].assertGroup(\"{\", 1)?.fields[0];\n\n\t\tif (tsBody === undefined || tsBody === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbodyExpr = buildValueExpr(tsBody);\n\t} else {\n\t\tbodyExpr = buildValueExpr(ts);\n\t}\n\n\treturn bodyExpr;\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {SwitchDefault | null}\n */\nfunction buildSwitchDefault(ts) {\n\tconst elseWord = assertDefined(ts.shift()).assertWord();\n\n\tif (!elseWord) {\n\t\treturn null;\n\t} else if (!(elseWord.isWord(\"else\") || elseWord.isWord(\"_\"))) {\n\t\telseWord.syntaxError(\"expected 'else' or '_'\");\n\t\treturn null;\n\t}\n\n\tconst site = elseWord.site;\n\n\tconst maybeArrow = ts.shift();\n\tif (maybeArrow === undefined) {\n\t\tsite.syntaxError(`expected '=>' after '${elseWord.value}'`);\n\t\treturn null;\n\t} else {\n\t\tconst arrow = maybeArrow.assertSymbol(\"=>\");\n\n\t\tif (!arrow) {\n\t\t\treturn null;\n\t\t}\n\n\t\t/** @type {null | ValueExpr} */\n\t\tlet bodyExpr = null;\n\n\t\tif (ts.length == 0) {\n\t\t\tarrow.syntaxError(\"expected expression after '=>'\");\n\t\t\treturn null;\n\t\t} else if (ts[0].isGroup(\"{\")) {\n\t\t\tif (ts.length > 1) {\n\t\t\t\tts[1].syntaxError(\"unexpected token\");\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst bodyTs = ts[0].assertGroup(\"{\", 1)?.fields[0];\n\n\t\t\t\tif (bodyTs === undefined || bodyTs === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tbodyExpr = buildValueExpr(bodyTs);\n\t\t\t}\n\t\t} else {\n\t\t\tbodyExpr = buildValueExpr(ts);\n\t\t}\n\n\t\tif (!bodyExpr) {\n\t\t\tarrow.syntaxError(\"empty switch default case body\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new SwitchDefault(arrow.site, bodyExpr);\n\t}\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {ListLiteralExpr | null}\n */\nfunction buildListLiteralExpr(ts) {\n\tconst group = assertDefined(ts.shift()).assertGroup(\"[\", 0);\n\n\tif (!group) {\n\t\treturn null;\n\t}\n\n\tconst site = group.site;\n\n\tconst bracesPos = Group.find(ts, \"{\");\n\n\tif (bracesPos == -1) {\n\t\tsite.syntaxError(\"invalid list literal expression syntax\");\n\t\treturn null;\n\t}\n\n\tconst itemTypeExpr = buildTypeExpr(site, ts.splice(0, bracesPos));\n\n\tif (!itemTypeExpr) {\n\t\treturn null;\n\t}\n\n\tconst braces = assertToken(ts.shift(), site)?.assertGroup(\"{\");\n\n\tif (!braces) {\n\t\treturn null;\n\t}\n\n\tconst itemExprs = reduceNull(braces.fields.map(fts => buildValueExpr(fts)));\n\n\tif (itemExprs === null) {\n\t\t// error will have already been thrown internally\n\t\treturn null;\n\t}\n\n\treturn new ListLiteralExpr(site, itemTypeExpr, itemExprs);\n}\n\n/**\n * @package\n * @param {Token[]} ts\n * @returns {MapLiteralExpr | null}\n */\nfunction buildMapLiteralExpr(ts) {\n\tconst mapWord = assertDefined(ts.shift()).assertWord(\"Map\");\n\n\tif (!mapWord) {\n\t\treturn null;\n\t}\n\n\tconst site = mapWord.site;\n\n\tconst bracket = assertDefined(ts.shift()).assertGroup(\"[\", 1);\n\n\tif (!bracket) {\n\t\treturn null;\n\t}\n\n\tconst keyTypeExpr = buildTypeExpr(site, bracket.fields[0]);\n\n\tif (!keyTypeExpr) {\n\t\treturn null;\n\t}\n\n\tconst bracesPos = Group.find(ts, \"{\");\n\n\tif (bracesPos == -1) {\n\t\tsite.syntaxError(\"invalid map literal expression syntax\");\n\t\treturn null;\n\t}\n\n\tconst valueTypeExpr = buildTypeExpr(site, ts.splice(0, bracesPos));\n\n\tif (!valueTypeExpr) {\n\t\treturn null;\n\t}\n\n\tconst braces = assertDefined(ts.shift()).assertGroup(\"{\");\n\n\tif (!braces) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @type {null | [ValueExpr, ValueExpr][]}\n\t */\n\tconst pairs = reduceNullPairs(braces.fields.map(fts => {\n\t\tconst colonPos = SymbolToken.find(fts, \":\");\n\n\t\tif (colonPos == -1) {\n\t\t\tif (fts.length == 0) {\n\t\t\t\tbraces.syntaxError(\"unexpected empty field\");\n\t\t\t} else {\n\t\t\t\tfts[0].syntaxError(\"expected ':' in map literal field\");\n\t\t\t}\n\t\t} else if (colonPos == 0) {\n\t\t\tfts[colonPos].syntaxError(\"expected expression before ':' in map literal field\");\n\t\t} else if (colonPos == fts.length - 1) {\n\t\t\tfts[colonPos].syntaxError(\"expected expression after ':' in map literal field\");\n\t\t} else {\n\t\t\tconst keyExpr = buildValueExpr(fts.slice(0, colonPos));\n\n\t\t\tconst valueExpr = buildValueExpr(fts.slice(colonPos+1));\n\n\t\t\t/**\n\t\t\t * @type {[ValueExpr | null, ValueExpr | null]}\n\t\t\t */\n\t\t\treturn [keyExpr, valueExpr];\n\t\t}\n\n\t\treturn [null, null];\n\t}));\n\n\tif (pairs === null) {\n\t\treturn null;\n\t}\n\n\treturn new MapLiteralExpr(site, keyTypeExpr, valueTypeExpr, pairs);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {StructLiteralExpr | null}\n */\nfunction buildStructLiteralExpr(ts) {\n\tconst bracesPos = Group.find(ts, \"{\");\n\n\tassert(bracesPos != -1);\n\n\tconst site = ts[bracesPos].site;\n\n\tif (bracesPos == 0) {\n\t\tsite.syntaxError(\"expected struct type before braces\");\n\t\treturn null;\n\t}\n\t\n\tconst typeExpr = buildTypeExpr(site, ts.splice(0, bracesPos));\n\n\tif (!typeExpr) {\n\t\treturn null;\n\t}\n\n\tconst braces = assertDefined(ts.shift()).assertGroup(\"{\");\n\n\tif (!braces) {\n\t\treturn null;\n\t}\n\n\tconst fields = reduceNull(braces.fields.map(fts => buildStructLiteralField(braces.site, fts)));\n\n\tif (fields === null) {\n\t\treturn null;\n\t} \n\t\n\tif (fields.every(f => f.isNamed()) || fields.every(f => !f.isNamed())) {\n\t\treturn new StructLiteralExpr(typeExpr, fields);\n\t} else {\n\t\tbraces.site.syntaxError(\"mangled literal struct (hint: specify all fields positionally or all with keys)\");\n\t\treturn null;\n\t}\n}\n\n/**\n * @package\n * @param {Site} site - site of the braces\n * @param {Token[]} ts\n * @returns {StructLiteralField | null}\n */\nfunction buildStructLiteralField(site, ts) {\n\tif (ts.length > 2 && ts[0].isWord() && ts[1].isSymbol(\":\")) {\n\t\treturn buildStructLiteralNamedField(site, ts);\n\t} else {\n\t\treturn buildStructLiteralUnnamedField(site, ts);\n\t}\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Token[]} ts\n * @returns {StructLiteralField | null}\n */\nfunction buildStructLiteralNamedField(site, ts) {\n\tconst name = assertToken(ts.shift(), site, \"empty struct literal field\")?.assertWord()?.assertNotKeyword();\n\n\tif (!name) {\n\t\treturn null;\n\t}\n\n\tconst colon = assertToken(ts.shift(), name.site, \"expected ':' after struct field name\")?.assertSymbol(\":\");\n\n\tif (!colon) {\n\t\treturn null;\n\t}\n\n\tif (ts.length == 0) {\n\t\tcolon.syntaxError(\"expected expression after ':'\");\n\t\treturn null;\n\t}\n\tconst valueExpr = buildValueExpr(ts);\n\n\tif (!valueExpr) {\n\t\treturn null;\n\t}\n\n\treturn new StructLiteralField(name, valueExpr);\n}\n\n/**\n * @package\n * @param {Site} site\n * @param {Token[]} ts\n * @returns {StructLiteralField | null}\n */\nfunction buildStructLiteralUnnamedField(site, ts) {\n\tconst valueExpr = buildValueExpr(ts);\n\n\tif (!valueExpr) {\n\t\treturn null;\n\t}\n\n\treturn new StructLiteralField(null, valueExpr);\n}\n\n/**\n * @package\n * @param {Token[]} ts \n * @returns {ValueExpr | null}\n */\nfunction buildValuePathExpr(ts) {\n\tconst dcolonPos = SymbolToken.findLast(ts, \"::\");\n\n\tassert(dcolonPos != -1);\n\n\tconst typeExpr = buildTypeExpr(ts[dcolonPos].site, ts.splice(0, dcolonPos));\n\n\tif (!typeExpr) {\n\t\treturn null;\n\t}\n\n\tconst dcolon = assertDefined(ts.shift()?.assertSymbol(\"::\"));\n\n\tconst memberName = assertToken(ts.shift(), dcolon.site)?.assertWord()?.assertNotKeyword();\n\n\tif (!memberName) {\n\t\treturn null;\n\t}\n\t\n\treturn new ValuePathExpr(typeExpr, memberName);\n}\n\n\n/////////////////////////////\n// Section 19: IR definitions\n/////////////////////////////\n\n/**\n * For collecting test coverage statistics\n * @type {?((name: string, count: number) => void)}\n */\nvar onNotifyRawUsage = null;\n\n/**\n * Set the statistics collector (used by the test-suite)\n * @param {(name: string, count: number) => void} callback \n */\nfunction setRawUsageNotifier(callback) {\n\tonNotifyRawUsage = callback;\n}\n\n/**\n * Wrapper for a builtin function (written in IR)\n */\nclass RawFunc {\n\t#name;\n\t#definition;\n\n\t/** @type {Set<string>} */\n\t#dependencies;\n\n\t/**\n\t * Construct a RawFunc, and immediately scan the definition for dependencies\n\t * @param {string} name \n\t * @param {string} definition \n\t */\n\tconstructor(name, definition) {\n\t\tthis.#name = name;\n\t\tassert(definition != undefined);\n\t\tthis.#definition = definition;\n\t\tthis.#dependencies = new Set();\n\n\t\tlet re = new RegExp(\"__helios__[a-zA-Z_0-9]*\", \"g\");\n\n\t\tlet matches = this.#definition.match(re);\n\n\t\tif (matches !== null) {\n\t\t\tfor (let match of matches) {\n\t\t\t\tthis.#dependencies.add(match);\n\t\t\t}\n\t\t}\n\t}\n\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\t/**\n\t * Loads 'this.#dependecies' (if not already loaded), then load 'this'\n\t * @param {Map<string, RawFunc>} db \n\t * @param {Map<string, IR>} dst \n\t * @returns {void}\n\t */\n\tload(db, dst) {\n\t\tif (onNotifyRawUsage !== null) {\n\t\t\tonNotifyRawUsage(this.#name, 1);\n\t\t}\n\n\t\tif (dst.has(this.#name)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tfor (let dep of this.#dependencies) {\n\t\t\t\tif (!db.has(dep)) {\n\t\t\t\t\tthrow new Error(`InternalError: dependency ${dep} is not a builtin`);\n\t\t\t\t} else {\n\t\t\t\t\tassertDefined(db.get(dep)).load(db, dst);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdst.set(this.#name, new IR(replaceTabs(this.#definition)));\n\t\t}\n\t}\n}\n\n/**\n * Initializes the db containing all the builtin functions\n * @returns {Map<string, RawFunc>}\n */\n// only need to wrap these source in IR right at the very end\nfunction makeRawFunctions() {\n\t/** @type {Map<string, RawFunc>} */\n\tlet db = new Map();\n\n\t// local utility functions\n\n\t/**\n\t * @param {RawFunc} fn \n\t */\n\tfunction add(fn) {\n\t\tif (db.has(fn.name)) {\n\t\t\tthrow new Error(`builtin ${fn.name} duplicate`);\n\t\t}\n\t\tdb.set(fn.name, fn);\n\t}\n\n\t/**\n\t * Adds basic auto members to a fully named type\n\t * @param {string} ns \n\t */\n\tfunction addDataFuncs(ns) {\n\t\tadd(new RawFunc(`${ns}____eq`, \"__helios__common____eq\"));\n\t\tadd(new RawFunc(`${ns}____neq`, \"__helios__common____neq\"));\n\t\tadd(new RawFunc(`${ns}__serialize`, \"__helios__common__serialize\"));\n\t\tadd(new RawFunc(`${ns}__from_data`, \"__helios__common__identity\"));\n\t}\n\n\t/**\n\t * Adds basic auto members to a fully named enum type\n\t * @param {string} ns \n\t */\n\tfunction addEnumDataFuncs(ns) {\n\t\tadd(new RawFunc(`${ns}____eq`, \"__helios__common____eq\"));\n\t\tadd(new RawFunc(`${ns}____neq`, \"__helios__common____neq\"));\n\t\tadd(new RawFunc(`${ns}__serialize`, \"__helios__common__serialize\"));\n\t}\n\n\t/**\n\t * Generates the IR needed to unwrap a Plutus-core constrData\n\t * @param {string} dataExpr\n\t * @param {number} iConstr \n\t * @param {number} iField \n\t * @param {string} errorExpr \n\t * @returns {string}\n\t */\n\tfunction unData(dataExpr, iConstr, iField, errorExpr = \"error(\\\"unexpected constructor index\\\")\") {\n\t\tlet inner = \"__core__sndPair(pair)\";\n\t\tfor (let i = 0; i < iField; i++) {\n\t\t\tinner = `__core__tailList(${inner})`;\n\t\t}\n\n\t\t// deferred evaluation of ifThenElse branches\n\t\treturn `(pair) -> {__core__ifThenElse(__core__equalsInteger(__core__fstPair(pair), ${iConstr}), () -> {__core__headList(${inner})}, () -> {${errorExpr}})()}(__core__unConstrData(${dataExpr}))`;\n\t}\n\n\t/**\n\t * Generates verbose IR for unwrapping a Plutus-core constrData.\n\t * If config.DEBUG === false then returns IR without print statement\n\t * @param {string} dataExpr\n\t * @param {string} constrName\n\t * @param {number} iConstr\n\t * @param {number} iField\n\t * @returns {string}\n\t */\n\tfunction unDataVerbose(dataExpr, constrName, iConstr, iField) {\n\t\tif (!config.DEBUG) {\n\t\t\treturn unData(dataExpr, iConstr, iField);\n\t\t} else {\n\t\t\treturn unData(dataExpr, iConstr, iField, `__helios__common__verbose_error(__core__appendString(\"bad constr for ${constrName}, want ${iConstr.toString()} but got \", __helios__int__show(__core__fstPair(pair))()))`)\n\t\t}\n\t}\n\n\t/**\n\t * Generates IR for constructing a list.\n\t * By default the result is kept as list, and not converted to data\n\t * @param {string[]} args \n\t * @param {boolean} toData \n\t * @returns \n\t */\n\tfunction makeList(args, toData = false) {\n\t\tlet n = args.length;\n\t\tlet inner = \"__core__mkNilData(())\";\n\n\t\tfor (let i = n - 1; i >= 0; i--) {\n\t\t\tinner = `__core__mkCons(${args[i]}, ${inner})`;\n\t\t}\n\n\t\tif (toData) {\n\t\t\tinner = `__core__listData(${inner})`\n\t\t}\n\n\t\treturn inner;\n\t}\n\n\n\t// Common builtins\n\tadd(new RawFunc(\"__helios__common__verbose_error\",\n\t`(msg) -> {\n\t\t__core__trace(msg, () -> {error(\"\")})()\n\t}`));\n\tadd(new RawFunc(\"__helios__common__assert_constr_index\",\n\t`(data, i) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(data)), i),\n\t\t\t() -> {data},\n\t\t\t() -> {error(\"unexpected constructor index\")}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__common__identity\",\n\t`(self) -> {self}`));\n\tadd(new RawFunc(\"__helios__common__not\",\n\t`(b) -> {\n\t\t__core__ifThenElse(b, false, true)\n\t}`));\n\tadd(new RawFunc(\"__helios__common____eq\", \"__core__equalsData\"));\n\tadd(new RawFunc(\"__helios__common____neq\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__core__equalsData(a, b))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__serialize\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__core__bData(__core__serialiseData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__common__any\",\n\t`(self, fn) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {false}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList(self)),\n\t\t\t\t\t\t\t() -> {true}, \n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__all\", \n\t`(self, fn) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {true},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList(self)),\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)},\n\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__map\",\n\t`(self, fn, init) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, init)\n\t\t}(\n\t\t\t(recurse, rem, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\trem,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\tfn(__core__headList(rem)), \n\t\t\t\t\t\t\trecurse(recurse, __core__tailList(rem), lst)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__filter\", \n\t`(self, fn, nil) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {nil}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList(self)),\n\t\t\t\t\t\t\t() -> {__core__mkCons(__core__headList(self), recurse(recurse, __core__tailList(self), fn))}, \n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__filter_list\", \n\t`(self, fn) -> {\n\t\t__helios__common__filter(self, fn, __helios__common__list_0)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__filter_map\",\n\t`(self, fn) -> {\n\t\t__helios__common__filter(self, fn, __core__mkNilPairData(()))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__find\",\n\t`(self, fn, callback) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {error(\"not found\")}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList(self)), \n\t\t\t\t\t\t\t() -> {callback(__core__headList(self))}, \n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__find_safe\",\n\t`(self, fn, callback) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {__core__constrData(1, __helios__common__list_0)}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList(self)), \n\t\t\t\t\t\t\t() -> {__core__constrData(0, __helios__common__list_1(callback(__core__headList(self))))}, \n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__fold\",\n\t`(self, fn, z) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn, z)\n\t\t}(\n\t\t\t(recurse, self, fn, z) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {z}, \n\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn, fn(z, __core__headList(self)))}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__fold_lazy\",\n\t`(self, fn, z) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn, z)\n\t\t}(\n\t\t\t(recurse, self, fn, z) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself, \n\t\t\t\t\t() -> {z}, \n\t\t\t\t\t() -> {fn(__core__headList(self), () -> {recurse(recurse, __core__tailList(self), fn, z)})}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__insert_in_sorted\",\n\t`(x, lst, comp) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, lst)\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {__core__mkCons(x, lst)},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tcomp(x, head),\n\t\t\t\t\t\t\t\t() -> {__core__mkCons(x, lst)},\n\t\t\t\t\t\t\t\t() -> {__core__mkCons(head, recurse(recurse, __core__tailList(lst)))}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList(lst))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__sort\", \n\t`(lst, comp) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, lst)\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head, tail) -> {\n\t\t\t\t\t\t\t__helios__common__insert_in_sorted(head, tail, comp)\n\t\t\t\t\t\t}(__core__headList(lst), recurse(recurse, __core__tailList(lst)))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__map_get\",\n\t`(self, key, fnFound, fnNotFound) -> {\n\t\t(self) -> {\n\t\t\t(recurse) -> {\n\t\t\t\trecurse(recurse, self, key)\n\t\t\t}(\n\t\t\t\t(recurse, self, key) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tself, \n\t\t\t\t\t\tfnNotFound, \n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(__core__headList(self))), \n\t\t\t\t\t\t\t\t() -> {fnFound(__core__sndPair(__core__headList(self)))}, \n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), key)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__is_in_bytearray_list\",\n\t`(lst, key) -> {\n\t\t__helios__common__any(lst, (item) -> {__core__equalsData(item, key)})\n\t}`));\n\tadd(new RawFunc(\"__helios__common__unBoolData\",\n\t`(d) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(d)), 0), \n\t\t\tfalse, \n\t\t\ttrue\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__boolData\",\n\t`(b) -> {\n\t\t__core__constrData(__core__ifThenElse(b, 1, 0), __helios__common__list_0)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__unStringData\",\n\t`(d) -> {\n\t\t__core__decodeUtf8(__core__unBData(d))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__stringData\",\n\t`(s) -> {\n\t\t__core__bData(__core__encodeUtf8(s))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__length\", \n\t`(lst) -> {\n\t\t(recurse) -> {\n\t\t\t__core__iData(recurse(recurse, lst))\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst, \n\t\t\t\t\t() -> {0}, \n\t\t\t\t\t() -> {__core__addInteger(recurse(recurse, __core__tailList(lst)), 1)}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__max\",\n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(a, b),\n\t\t\tb,\n\t\t\ta\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__min\", \n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanEqualsInteger(a, b),\n\t\t\ta,\n\t\t\tb\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__concat\", \n\t`(a, b) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, b, a)\n\t\t}(\n\t\t\t(recurse, lst, rem) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\trem,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {__core__mkCons(__core__headList(rem), recurse(recurse, lst, __core__tailList(rem)))}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__common__slice_bytearray\",\n\t`(self, selfLengthFn) -> {\n\t\t(start, end) -> {\n\t\t\t(self) -> {\n\t\t\t\t(start, end) -> {\n\t\t\t\t\t(normalize) -> {\n\t\t\t\t\t\t__core__bData(\n\t\t\t\t\t\t\t(fn) -> {\n\t\t\t\t\t\t\t\tfn(normalize(start))\n\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t(start) -> {\n\t\t\t\t\t\t\t\t\t(fn) -> {\n\t\t\t\t\t\t\t\t\t\tfn(normalize(end))\n\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t(end) -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__sliceByteString(start, __core__subtractInteger(end, __helios__common__max(start, 0)), self)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}(\n\t\t\t\t\t\t(pos) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(pos, 0),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__addInteger(__core__addInteger(selfLengthFn(self), 1), pos)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tpos\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__core__unIData(start), __core__unIData(end))\n\t\t\t}(__core__unBData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__common__starts_with\", \n\t`(self, selfLengthFn) -> {\n\t\t(self) -> {\n\t\t\t(prefix) -> {\n\t\t\t\t(prefix) -> {\n\t\t\t\t\t(n, m) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(n, m),\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__equalsByteString(prefix, __core__sliceByteString(0, m, self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(selfLengthFn(self), __core__lengthOfByteString(prefix))\n\t\t\t\t}(__core__unBData(prefix))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__ends_with\",\n\t`(self, selfLengthFn) -> {\n\t\t(self) -> {\n\t\t\t(suffix) -> {\n\t\t\t\t(suffix) -> {\n\t\t\t\t\t(n, m) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(n, m),\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__equalsByteString(suffix, __core__sliceByteString(__core__subtractInteger(n, m), m, self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(selfLengthFn(self), __core__lengthOfByteString(suffix))\n\t\t\t\t}(__core__unBData(suffix))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__fields\", \n\t`(self) -> {\n\t\t__core__sndPair(__core__unConstrData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__field_0\", \n\t`(self) -> {\n\t\t__core__headList(__helios__common__fields(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__fields_after_0\",\n\t`(self) -> {\n\t\t__core__tailList(__helios__common__fields(self))\n\t}`));\n\tfor (let i = 1; i < 20; i++) {\n\t\tadd(new RawFunc(`__helios__common__field_${i.toString()}`,\n\t`(self) -> {\n\t\t__core__headList(__helios__common__fields_after_${(i-1).toString()}(self))\n\t}`));\n\t\tadd(new RawFunc(`__helios__common__fields_after_${i.toString()}`,\n\t`(self) -> {\n\t\t__core__tailList(__helios__common__fields_after_${(i-1).toString()}(self))\n\t}`));\n\t}\n\tadd(new RawFunc(\"__helios__common__tuple_field_0\",\n\t`(self) -> {\n\t\t__core__headList(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__tuple_fields_after_0\", \n\t`(self) -> {\n\t\t__core__tailList(__core__unListData(self))\n\t}`));\n\tfor (let i = 1; i < 20; i++) {\n\t\tadd(new RawFunc(`__helios__common__tuple_field_${i.toString()}`,\n\t`(self) -> {\n\t\t__core__headList(__helios__common__tuple_fields_after_${(i-1).toString()}(self))\n\t}`));\n\t\tadd(new RawFunc(`__helios__common__tuple_fields_after_${i.toString()}`,\n\t`(self) -> {\n\t\t__core__tailList(__helios__common__tuple_fields_after_${(i-1).toString()}(self))\n\t}`));\n\t}\n\tadd(new RawFunc(\"__helios__common__list_0\", \"__core__mkNilData(())\"));\n\tadd(new RawFunc(\"__helios__common__list_1\", \n\t`(a) -> {\n\t\t__core__mkCons(a, __helios__common__list_0)\n\t}`));\n\tfor (let i = 2; i < 20; i++) {\n\t\t/**\n\t\t * @type {string[]}\n\t\t */\n\t\tlet args = [];\n\n\t\tfor (let j = 0; j < i; j++) {\n\t\t\targs.push(`arg${j.toString()}`);\n\t\t}\n\n\t\tlet woFirst = args.slice()\n\t\tlet first = assertDefined(woFirst.shift());\n\n\t\tadd(new RawFunc(`__helios__common__list_${i.toString()}`,\n\t`(${args.join(\", \")}) -> {\n\t\t__core__mkCons(${first}, __helios__common__list_${(i-1).toString()}(${woFirst.join(\", \")}))\n\t}`));\n\t}\n\tadd(new RawFunc(\"__helios__common__hash_datum_data\", \n\t`(data) -> {\n\t\t__core__bData(__core__blake2b_256(__core__serialiseData(data)))\n\t}`));\n\n\n\t// Global builtin functions\n\tadd(new RawFunc(\"__helios__print\", \n\t`(msg) -> {\n\t\t__core__trace(__helios__common__unStringData(msg), ())\n\t}`));\n\tadd(new RawFunc(\"__helios__error\",\n\t`(msg) -> {\n\t\t__core__trace(\n\t\t\t__helios__common__unStringData(msg), \n\t\t\t() -> {\n\t\t\t\terror(\"error thrown by user-code\")\n\t\t\t}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__assert\",\n\t`(cond, msg) -> {\n\t\t__core__ifThenElse(\n\t\t\tcond,\n\t\t\t() -> {\n\t\t\t\t()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__trace(\n\t\t\t\t\t__helios__common__unStringData(msg),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror(\"assert failed\")\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}`));\n\n\n\t// Int builtins\n\taddDataFuncs(\"__helios__int\");\n\tadd(new RawFunc(\"__helios__int____neg\",\n\t`(self) -> {\n\t\t__core__iData(__core__multiplyInteger(__core__unIData(self), -1))\t\n\t}`));\n\tadd(new RawFunc(\"__helios__int____pos\", \"__helios__common__identity\"));\n\tadd(new RawFunc(\"__helios__int____add\",\n\t`(a, b) -> {\n\t\t__core__iData(__core__addInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____sub\",\n\t`(a, b) -> {\n\t\t__core__iData(__core__subtractInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____mul\",\n\t`(a, b) -> {\n\t\t__core__iData(__core__multiplyInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____div\",\n\t`(a, b) -> {\n\t\t__core__iData(__core__divideInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____mod\",\n\t`(a, b) -> {\n\t\t__core__iData(__core__modInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____geq\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__core__lessThanInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____gt\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__core__lessThanEqualsInteger(__core__unIData(a), __core__unIData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____leq\",\n\t`(a, b) -> {\n\t\t__core__lessThanEqualsInteger(__core__unIData(a), __core__unIData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__int____lt\",\n\t`(a, b) -> {\n\t\t__core__lessThanInteger(__core__unIData(a), __core__unIData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__min\",\n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(__core__unIData(a), __core__unIData(b)),\n\t\t\ta,\n\t\t\tb\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__int__max\",\n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(__core__unIData(a), __core__unIData(b)),\n\t\t\tb,\n\t\t\ta\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__int__bound_min\",\n\t`(self) -> {\n\t\t(other) -> {\n\t\t\t__helios__int__max(self, other)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__bound_max\",\n\t`(self) -> {\n\t\t(other) -> {\n\t\t\t__helios__int__min(self, other)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__bound\",\n\t`(self) -> {\n\t\t(min, max) -> {\n\t\t\t__helios__int__max(__helios__int__min(self, max), min)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__abs\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(i) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(i, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__iData(__core__multiplyInteger(i, -1))\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tself\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}(__core__unIData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__encode_zigzag\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(i) -> {\n\t\t\t\t__core__iData(\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(i, 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__subtractInteger(__core__multiplyInteger(i, -2), 1)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__multiplyInteger(i, 2)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t)\n\t\t\t}(__core__unIData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__decode_zigzag\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(i) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(i, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror(\"expected positive int\")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__iData(\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(__core__modInteger(i, 2), 0),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__divideInteger(i, 2)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__divideInteger(__core__addInteger(i, 1), -2)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}(__core__unIData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__to_bool\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(__core__equalsInteger(__core__unIData(self), 0), false, true)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__int__to_hex\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\t__core__bData(\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t45,\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__multiplyInteger(self, -1), #)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, self, #)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self, bytes) -> {\n\t\t\t\t\t\t(digit) -> {\n\t\t\t\t\t\t\t(bytes) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 16),\n\t\t\t\t\t\t\t\t\t() -> {bytes},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 16), bytes)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__lessThanInteger(digit, 10), \n\t\t\t\t\t\t\t\t\t\t__core__addInteger(digit, 48), \n\t\t\t\t\t\t\t\t\t\t__core__addInteger(digit, 87)\n\t\t\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(__core__modInteger(self, 16))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unIData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__common__BASE58_ALPHABET\", \"#31323334353637383941424344454647484a4b4c4d4e505152535455565758595a6162636465666768696a6b6d6e6f707172737475767778797a\"))\n\tadd(new RawFunc(\"__helios__int__to_base58\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__bData(\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\terror(\"expected positive number\")\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\t\t\trecurse(recurse, self, #)\n\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t(recurse, self, bytes) -> {\n\t\t\t\t\t\t\t\t\t(digit) -> {\n\t\t\t\t\t\t\t\t\t\t(bytes) -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 58),\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 58), bytes)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString(__helios__common__BASE58_ALPHABET, digit),\n\t\t\t\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}(__core__modInteger(self, 58))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unIData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__BASE58_INVERSE_ALPHABET_1\", \"#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000102030405060708ffffffffffff\"));\n\tadd(new RawFunc(\"__helios__int__BASE58_INVERSE_ALPHABET_2\", \"#ff090a0b0c0d0e0f10ff1112131415ff161718191a1b1c1d1e1f20ffffffffffff2122232425262728292a2bff2c2d2e2f30313233343536373839ffffffffff\"));\n\tadd(new RawFunc(\"__helios__int__invert_base58_char\", \n\t`(char) -> {\n\t\t(digit) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(digit, 0xff),\n\t\t\t\t() -> {\n\t\t\t\t\terror(\"invalid base58 character\")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tdigit\n\t\t\t\t}\n\t\t\t)()\n\t\t}(\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(char, 64),\n\t\t\t\t() -> {\n\t\t\t\t\t__core__indexByteString(__helios__int__BASE58_INVERSE_ALPHABET_1, char)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(char, 128),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__indexByteString(\n\t\t\t\t\t\t\t\t__helios__int__BASE58_INVERSE_ALPHABET_2,\n\t\t\t\t\t\t\t\t__core__subtractInteger(char, 64)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t0xff\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__int__from_base58\",\n\t`(str) -> {\n\t\t(bytes) -> {\n\t\t\t__core__iData(\n\t\t\t\t(n) -> {\n\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\trecurse(recurse, 0, 1, __core__subtractInteger(n, 1))\n\t\t\t\t\t}(\n\t\t\t\t\t\t(recurse, acc, pow, i) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(i, -1),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tacc\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t(new_acc) -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 58), __core__subtractInteger(i, 1))\n\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\tacc,\n\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__invert_base58_char(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString(bytes, i)\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\tpow\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__core__lengthOfByteString(bytes))\n\t\t\t)\n\t\t}(__core__unBData(str))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__show\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__helios__common__stringData(__core__decodeUtf8(\n\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t\t\t() -> {__core__consByteString(45, recurse(recurse, __core__multiplyInteger(self, -1)))},\n\t\t\t\t\t\t\t() -> {recurse(recurse, self)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(\n\t\t\t\t\t\t(recurse, i) -> {\n\t\t\t\t\t\t\t(bytes) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__lessThanInteger(i, 10),\n\t\t\t\t\t\t\t\t\t() -> {bytes},\n\t\t\t\t\t\t\t\t\t() -> {__core__appendByteString(recurse(recurse, __core__divideInteger(i, 10)), bytes)}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}(__core__consByteString(__core__addInteger(__core__modInteger(i, 10), 48), #))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t}\n\t\t}(__core__unIData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__parse_digit\",\n\t`(digit) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanEqualsInteger(digit, 57),\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(48, digit),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__subtractInteger(digit, 48)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror(\"not a digit\")\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\terror(\"not a digit\")\n\t\t\t}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__int__parse\",\n\t`(string) -> {\n\t\t(bytes) -> {\n\t\t\t__core__iData(\n\t\t\t\t(n, b0) -> {\n\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(b0, 48),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(n, 1),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\terror(\"zero padded integer can't be parsed\")\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(b0, 45),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__indexByteString(bytes, 1), 48),\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\terror(\"-0 not allowed\")\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, 0, 1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, 0, 0)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(\n\t\t\t\t\t\t(recurse, acc, i) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(i, n),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tacc\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t(new_acc) -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, new_acc, __core__addInteger(i, 1))\n\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(acc, 10), \n\t\t\t\t\t\t\t\t\t\t\t__helios__int__parse_digit(__core__indexByteString(bytes, i))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__core__lengthOfByteString(bytes), __core__indexByteString(bytes, 0))\n\t\t\t)\n\t\t}(__core__unBData(string))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__from_big_endian\",\n\t`(bytes) -> {\n\t\t(bytes) -> {\n\t\t\t__core__iData(\n\t\t\t\t(n) -> {\n\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\trecurse(recurse, 0, 1, __core__subtractInteger(n, 1))\n\t\t\t\t\t}(\n\t\t\t\t\t\t(recurse, acc, pow, i) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(i, -1),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tacc\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t(new_acc) -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 256), __core__subtractInteger(i, 1))\n\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\tacc,\n\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(__core__indexByteString(bytes, i), pow)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__core__lengthOfByteString(bytes))\n\t\t\t)\n\t\t}(__core__unBData(bytes))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__from_little_endian\", \n\t`(bytes) -> {\n\t\t(bytes) -> {\n\t\t\t__core__iData(\n\t\t\t\t(n) -> {\n\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\trecurse(recurse, 0, 1, 0)\n\t\t\t\t\t}(\n\t\t\t\t\t\t(recurse, acc, pow, i) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(i, n),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tacc\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t(new_acc) -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 256), __core__addInteger(i, 1))\n\t\t\t\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\tacc,\n\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(__core__indexByteString(bytes, i), pow)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__core__lengthOfByteString(bytes))\n\t\t\t)\n\t\t}(__core__unBData(bytes))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__to_big_endian\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror(\"can't convert negative number to big endian bytearray\")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\t\t__core__bData(recurse(recurse, self, #))\n\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t(recurse, self, bytes) -> {\n\t\t\t\t\t\t\t\t(bytes) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 256),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\trecurse(\n\t\t\t\t\t\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t\t\t\t\t\t__core__divideInteger(self, 256),\n\t\t\t\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__consByteString(self, bytes))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t}(__core__unIData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__int__to_little_endian\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror(\"can't convert negative number to big endian bytearray\")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(recurse) -> {\n\t\t\t\t\t\t\t__core__bData(recurse(recurse, self))\n\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t(recurse, self) -> {\n\t\t\t\t\t\t\t\t__core__consByteString(self,\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 256),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t#\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 256))\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t}(__core__unIData(self))\n\t}`))\n\n\n\t// Bool builtins\n\tadd(new RawFunc(`__helios__bool____eq`, \n\t`(a, b) -> {\n\t\t__core__ifThenElse(a, b, __helios__common__not(b))\n\t}`));\n\tadd(new RawFunc(`__helios__bool____neq`,\n\t`(a, b) -> {\n\t\t__core__ifThenElse(a, __helios__common__not(b), b)\n\t}`));\n\tadd(new RawFunc(`__helios__bool__serialize`, \n\t`(self) -> {\n\t\t__helios__common__serialize(__helios__common__boolData(self))\n\t}`));\n\tadd(new RawFunc(`__helios__bool__from_data`,\n\t`(data) -> {\n\t\t__helios__common__unBoolData(data)\n\t}`));\n\tadd(new RawFunc(\"__helios__bool__and\",\n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\ta(), \n\t\t\t() -> {b()}, \n\t\t\t() -> {false}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__bool__or\",\n\t`(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\ta(), \n\t\t\t() -> {true},\n\t\t\t() -> {b()}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__bool____not\", \"__helios__common__not\"));\n\tadd(new RawFunc(\"__helios__bool__to_int\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__core__iData(__core__ifThenElse(self, 1, 0))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__bool__show\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__stringData(__core__ifThenElse(self, \"true\", \"false\"))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__bool__trace\",\n\t`(self) -> {\n\t\t(prefix) -> {\n\t\t\t__core__trace(\n\t\t\t\t__helios__common__unStringData(\n\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\tprefix,\n\t\t\t\t\t\t__helios__bool__show(self)()\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tself\n\t\t\t)\n\t\t}\n\t}`));\n\n\n\t// String builtins\n\taddDataFuncs(\"__helios__string\");\n\tadd(new RawFunc(\"__helios__string____add\",\n\t`(a, b) -> {\n\t\t__helios__common__stringData(__core__appendString(__helios__common__unStringData(a), __helios__common__unStringData(b)))\t\n\t}`));\n\tadd(new RawFunc(\"__helios__string__starts_with\", \"__helios__bytearray__starts_with\"));\n\tadd(new RawFunc(\"__helios__string__ends_with\", \"__helios__bytearray__ends_with\"));\n\tadd(new RawFunc(\"__helios__string__encode_utf8\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__bData(__core__encodeUtf8(self))\n\t\t\t}\n\t\t}(__helios__common__unStringData(self))\n\t}`));\n\n\n\t// ByteArray builtins\n\taddDataFuncs(\"__helios__bytearray\");\n\tadd(new RawFunc(\"__helios__bytearray____add\",\n\t`(a, b) -> {\n\t\t__core__bData(__core__appendByteString(__core__unBData(a), __core__unBData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray____geq\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__core__lessThanByteString(__core__unBData(a), __core__unBData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray____gt\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__core__lessThanEqualsByteString(__core__unBData(a), __core__unBData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray____leq\",\n\t`(a, b) -> {\n\t\t__core__lessThanEqualsByteString(__core__unBData(a), __core__unBData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray____lt\",\n\t`(a, b) -> {\n\t\t__core__lessThanByteString(__core__unBData(a), __core__unBData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__length\",\n\t`(self) -> {\n\t\t__core__iData(__core__lengthOfByteString(__core__unBData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__slice\",\n\t`(self) -> {\n\t\t__helios__common__slice_bytearray(self, __core__lengthOfByteString)\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__starts_with\", \n\t`(self) -> {\n\t\t__helios__common__starts_with(self, __core__lengthOfByteString)\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__ends_with\",\n\t`(self) -> {\n\t\t__helios__common__ends_with(self, __core__lengthOfByteString)\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__prepend\", \n\t`(self) -> {\n\t\t(byte) -> {\n\t\t\t__core__bData(\n\t\t\t\t__core__consByteString(\n\t\t\t\t\t__core__unIData(byte),\n\t\t\t\t\t__core__unBData(self)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__sha2\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__bData(__core__sha2_256(self))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__sha3\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__bData(__core__sha3_256(self))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__blake2b\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__bData(__core__blake2b_256(self))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__decode_utf8\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__helios__common__stringData(__core__decodeUtf8(self))\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray__show\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\t__helios__common__stringData(recurse(recurse, self))\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self) -> {\n\t\t\t\t\t\t(n) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(0, n),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t\t\t__core__decodeUtf8((hexBytes) -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__lengthOfByteString(hexBytes), 1),\n\t\t\t\t\t\t\t\t\t\t\t\t__core__consByteString(48, hexBytes),\n\t\t\t\t\t\t\t\t\t\t\t\thexBytes\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}(__core__unBData(__helios__int__to_hex(__core__iData(__core__indexByteString(self, 0)))()))), \n\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__sliceByteString(1, n, self))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__lengthOfByteString(self))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unBData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray32____eq\", \"__helios__bytearray____eq\"));\n\tadd(new RawFunc(\"__helios__bytearray32____neq\", \"__helios__bytearray____neq\"));\n\tadd(new RawFunc(\"__helios__bytearray32__serialize\", \"__helios__bytearray__serialize\"));\n\tadd(new RawFunc(\"__helios__bytearray32____add\", \"__helios__bytearray____add\"));\n\tadd(new RawFunc(\"__helios__bytearray32__length\", \"(_) -> {__core__iData(32)}\"));\n\tadd(new RawFunc(\"__helios__bytearray32__slice\", \n\t`(self) -> {\n\t\t__helios__common__slice_bytearray(self, (self) -> {32})\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray32__starts_with\", \n\t`(self) -> {\n\t\t__helios__common__starts_with(self, (self) -> {32})\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray32__ends_with\", \n\t`(self) -> {\n\t\t__helios__common__ends_with(self, (self) -> {32})\n\t}`));\n\tadd(new RawFunc(\"__helios__bytearray32__sha2\", \"__helios__bytearray__sha2\"));\n\tadd(new RawFunc(\"__helios__bytearray32__sha3\", \"__helios__bytearray__sha3\"));\n\tadd(new RawFunc(\"__helios__bytearray32__blake2b\", \"__helios__bytearray__blake2b\"));\n\tadd(new RawFunc(\"__helios__bytearray32__decode_utf8\", \"__helios__bytearray__decode_utf8\"));\n\tadd(new RawFunc(\"__helios__bytearray32__show\", \"__helios__bytearray__show\"));\n\n\n\t// List builtins\n\taddDataFuncs(\"__helios__list\");\n\tadd(new RawFunc(\"__helios__list__new\",\n\t`(n, fn) -> {\n\t\t(n) -> {\n\t\t\t(recurse) -> {\n\t\t\t\t__core__listData(recurse(recurse, 0))\n\t\t\t}(\n\t\t\t\t(recurse, i) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(i, n),\n\t\t\t\t\t\t() -> {__core__mkCons(fn(__core__iData(i)), recurse(recurse, __core__addInteger(i, 1)))},\n\t\t\t\t\t\t() -> {__core__mkNilData(())}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__core__unIData(n))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__new_const\",\n\t`(n, item) -> {\n\t\t__helios__list__new(n, (i) -> {item})\n\t}`));\n\tadd(new RawFunc(\"__helios__list____add\",\n\t`(a, b) -> {\n\t\t__core__listData(__helios__common__concat(__core__unListData(a), __core__unListData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__length\",\n\t`(self) -> {\n\t\t__helios__common__length(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__head\",\n\t`(self) -> {\n\t\t__core__headList(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__tail\",\n\t`(self) -> {\n\t\t__core__listData(__core__tailList(__core__unListData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__is_empty\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__nullList(self)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__get\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(index) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, self, __core__unIData(index))\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self, index) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tself, \n\t\t\t\t\t\t\t() -> {error(\"index out of range\")}, \n\t\t\t\t\t\t\t() -> {__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(index, 0), \n\t\t\t\t\t\t\t\t() -> {error(\"index out of range\")}, \n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(index, 0), \n\t\t\t\t\t\t\t\t\t\t() -> {__core__headList(self)}, \n\t\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), __core__subtractInteger(index, 1))}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__get_singleton\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t__helios__assert(\n\t\t\t\t\t\t__core__nullList(__core__tailList(self)),\n\t\t\t\t\t\t__helios__common__stringData(\"not a singleton list\")\n\t\t\t\t\t),\n\t\t\t\t\t__core__headList(self)\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__any\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__common__any(self, fn)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__all\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__common__all(self, fn)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__prepend\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(item) -> {\n\t\t\t\t__core__listData(__core__mkCons(item, self))\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__find\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__common__find(self, fn, __helios__common__identity)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__find_safe\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__common__find_safe(self, fn, __helios__common__identity)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__filter\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__core__listData(__helios__common__filter_list(self, fn))\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__for_each\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, self)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, lst) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tlst,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t\t\t\tfn(__core__headList(lst)),\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList(lst))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__fold\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn, z) -> {\n\t\t\t\t__helios__common__fold(self, fn, z)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__fold_lazy\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn, z) -> {\n\t\t\t\t__helios__common__fold_lazy(self, fn, z)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__map\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__core__listData(__helios__common__map(self, fn, __core__mkNilData(())))\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__list__map_to_bool\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__map(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\t__helios__common__boolData(fn(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__list__sort\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(comp) -> {\n\t\t\t\t__core__listData(__helios__common__sort(self, comp))\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__new\", \n\t`(n, fn) -> {\n\t\t__helios__list__new(\n\t\t\tn, \n\t\t\t(i) -> {\n\t\t\t\t__helios__common__boolData(fn(i))\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__new_const\", \n\t`(n, item) -> {\n\t\t__helios__list__new_const(n, __helios__common__boolData(item))\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist____eq\", \"__helios__list____eq\"));\n\tadd(new RawFunc(\"__helios__boollist____neq\", \"__helios__list____neq\"));\n\tadd(new RawFunc(\"__helios__boollist__serialize\", \"__helios__list__serialize\"));\n\tadd(new RawFunc(\"__helios__boollist__from_data\", \"__helios__list__from_data\"));\n\tadd(new RawFunc(\"__helios__boollist____add\", \"__helios__list____add\"));\n\tadd(new RawFunc(\"__helios__boollist__length\", \"__helios__list__length\"));\n\tadd(new RawFunc(\"__helios__boollist__head\", \n\t`(self) -> {\n\t\t__helios__common__unBoolData(__helios__list__head(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__tail\", \"__helios__list__tail\"));\n\tadd(new RawFunc(\"__helios__boollist__is_empty\", \"__helios__list__is_empty\"));\n\tadd(new RawFunc(\"__helios__boollist__get\", \n\t`(self) -> {\n\t\t(index) -> {\n\t\t\t__helios__common__unBoolData(__helios__list__get(self)(index))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__get_singleton\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__unBoolData(__helios__list__get_singleton(self)())\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__any\", \n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__any(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__all\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__all(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__prepend\",\n\t`(self) -> {\n\t\t(item) -> {\n\t\t\t__helios__list__prepend(self)(__helios__common__boolData(item))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__find\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__unBoolData(\n\t\t\t\t__helios__list__find(self)(\n\t\t\t\t\t(item) -> {\n\t\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__find_safe\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__find_safe(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__filter\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__filter(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__for_each\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__for_each(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__fold\",\n\t`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__list__fold(self)(\n\t\t\t\t(prev, item) -> {\n\t\t\t\t\tfn(prev, __helios__common__unBoolData(item))\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__fold_lazy\",\n\t`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__list__fold_lazy(self)(\n\t\t\t\t(item, next) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item), next)\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__map\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__map(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__map_to_bool\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__list__map(self)(\n\t\t\t\t(item) -> {\n\t\t\t\t\t__helios__common__boolData(fn(__helios__common__unBoolData(item)))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boollist__sort\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(comp) -> {\n\t\t\t\t(comp) -> {\n\t\t\t\t\t__core__listData(__helios__common__sort(self, comp))\n\t\t\t\t}(\n\t\t\t\t\t(a, b) -> {\n\t\t\t\t\t\tcomp(__helios__common__unBoolData(a), __helios__common__unBoolData(b))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unListData(self))\n\t}`));\n\n\n\t// Map builtins\n\taddDataFuncs(\"__helios__map\");\n\tadd(new RawFunc(\"__helios__map____add\",\n\t`(a, b) -> {\n\t\t__core__mapData(__helios__common__concat(__core__unMapData(a), __core__unMapData(b)))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__prepend\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(key, value) -> {\n\t\t\t\t__core__mapData(__core__mkCons(__core__mkPairData(key, value), self))\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__head\",\n\t`(self) -> {\n\t\t(head) -> {\n\t\t\t() -> {\n\t\t\t\t(callback) -> {\n\t\t\t\t\tcallback(__core__fstPair(head), __core__sndPair(head))\n\t\t\t\t}\n\t\t\t}\n\t\t}(__core__headList(__core__unMapData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__head_key\",\n\t`(self) -> {\n\t\t__core__fstPair(__core__headList(__core__unMapData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__head_value\",\n\t`(self) -> {\n\t\t__core__sndPair(__core__headList(__core__unMapData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__length\",\n\t`(self) -> {\n\t\t__helios__common__length(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__tail\",\n\t`(self) -> {\n\t\t__core__mapData(__core__tailList(__core__unMapData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__is_empty\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__nullList(self)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__get\",\n\t`(self) -> {\n\t\t(key) -> {\n\t\t\t__helios__common__map_get(self, key, (x) -> {x}, () -> {error(\"key not found\")})\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__map__get_safe\",\n\t`(self) -> {\n\t\t(key) -> {\n\t\t\t__helios__common__map_get(\n\t\t\t\tself, \n\t\t\t\tkey, \n\t\t\t\t(x) -> {\n\t\t\t\t\t__core__constrData(0, __helios__common__list_1(x))\n\t\t\t\t}, \n\t\t\t\t() -> {\n\t\t\t\t\t__core__constrData(1, __helios__common__list_0)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__map__all\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__all(self, fn)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair), __core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__any\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__any(self, fn)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair), __core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__delete\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(key) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\t__core__mapData(recurse(recurse, self))\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\t() -> {self},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head, tail) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(head)),\n\t\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, tail)},\n\t\t\t\t\t\t\t\t\t\t() -> {__core__mkCons(head, recurse(recurse, tail))}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__headList(self), __core__tailList(self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__filter\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__core__mapData(__helios__common__filter_map(self, fn))\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair), __core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, self, fn)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self, fn) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tself, \n\t\t\t\t\t\t\t() -> {error(\"not found\")}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\tfn(__core__fstPair(head), __core__sndPair(head)), \n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(__core__fstPair(head), __core__sndPair(head))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}, \n\t\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__headList(self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find_safe\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, self, fn)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self, fn) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tself, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\tcallback(() -> {error(\"not found\")}, false)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\tfn(__core__fstPair(head), __core__sndPair(head)), \n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(__core__fstPair(head), __core__sndPair(head))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}, \n\t\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(self), fn)}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__headList(self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find_key\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find(\n\t\t\t\t\t\tself, \n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t__core__fstPair\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find_key_safe\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find_safe(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t__core__fstPair\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find_value\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find(\n\t\t\t\t\t\tself, \n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t__core__sndPair\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__find_value_safe\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find_safe(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t__core__sndPair\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__map\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__core__mapData(__helios__common__map(self, fn, __core__mkNilPairData(())))\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t(mapped_pair) -> {\n\t\t\t\t\t\t\tmapped_pair(\n\t\t\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t\t\t__core__mkPairData(key, value)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(fn(__core__fstPair(pair), __core__sndPair(pair)))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__map_to_bool\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__core__mapData(__helios__common__map(self, fn, __core__mkNilPairData(())))\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t(mapped_pair) -> {\n\t\t\t\t\t\t\tmapped_pair(\n\t\t\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t\t\t__core__mkPairData(key, __helios__common__boolData(value))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(fn(__core__fstPair(pair), __core__sndPair(pair)))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__fold\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn, z) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__fold(self, fn, z)\n\t\t\t\t}(\n\t\t\t\t\t(z, pair) -> {\n\t\t\t\t\t\tfn(z, __core__fstPair(pair), __core__sndPair(pair))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__fold_lazy\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn, z) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__fold_lazy(self, fn, z)\n\t\t\t\t}(\n\t\t\t\t\t(pair, next) -> {\n\t\t\t\t\t\tfn(__core__fstPair(pair), __core__sndPair(pair), next)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t\t\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__for_each\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, self)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t\t\t\t\tfn(__core__fstPair(head), __core__sndPair(head)),\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList(map))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}(__core__headList(map))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__set\", \n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(key, value) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\t__core__mapData(recurse(recurse, self))\n\t\t\t\t}(\n\t\t\t\t\t(recurse, self) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tself,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(__core__mkPairData(key, value), __core__mkNilPairData(()))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head, tail) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(head)),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__mkCons(__core__mkPairData(key, value), tail)\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__mkCons(head, recurse(recurse, tail))\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__headList(self), __core__tailList(self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__map__sort\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(comp) -> {\n\t\t\t\t(comp) -> {\n\t\t\t\t\t__core__mapData(__helios__common__sort(self, comp))\n\t\t\t\t}(\n\t\t\t\t\t(a, b) -> {\n\t\t\t\t\t\tcomp(__core__fstPair(a), __core__sndPair(a), __core__fstPair(b), __core__sndPair(b))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap____eq\", \"__helios__map____eq\"));\n\tadd(new RawFunc(\"__helios__boolmap____neq\", \"__helios__map____neq\"));\n\tadd(new RawFunc(\"__helios__boolmap__serialize\", \"__helios__map__serialize\"));\n\tadd(new RawFunc(\"__helios__boolmap__from_data\", \"__helios__map__from_data\"));\n\tadd(new RawFunc(\"__helios__boolmap____add\", \"__helios__map____add\"));\n\tadd(new RawFunc(\"__helios__boolmap__prepend\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(key, value) -> {\n\t\t\t\t__core__mapData(\n\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t__core__mkPairData(key, __helios__common__boolData(value)),\n\t\t\t\t\t\tself\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__head\",\n\t`(self) -> {\n\t\t(head) -> {\n\t\t\t() -> {\n\t\t\t\t(callback) -> {\n\t\t\t\t\tcallback(__core__fstPair(head), __helios__common__unBoolData(__core__sndPair(head)))\n\t\t\t\t}\n\t\t\t}\n\t\t}(__core__headList(__core__unMapData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__head_key\", \"__helios__map__head_key\"));\n\tadd(new RawFunc(\"__helios__boolmap__head_value\",\n\t`(self) -> {\n\t\t__helios__common__unBoolData(__helios__map__head_value(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__length\", \"__helios__map__length\"));\n\tadd(new RawFunc(\"__helios__boolmap__tail\", \"__helios__map__tail\"));\n\tadd(new RawFunc(\"__helios__boolmap__is_empty\", \"__helios__map__is_empty\"));\n\tadd(new RawFunc(\"__helios__boolmap__get\", \n\t`(self) -> {\n\t\t(key) -> {\n\t\t\t__helios__common__unBoolData(__helios__map__get(self)(key))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__all\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__map__all(self)(\n\t\t\t\t(key, value) -> {\n\t\t\t\t\tfn(key, __helios__common__unBoolData(value))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__any\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__map__any(self)(\n\t\t\t\t(key, value) -> {\n\t\t\t\t\tfn(key, __helios__common__unBoolData(value))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__delete\", \"__helios__map__delete\"));\n\tadd(new RawFunc(\"__helios__boolmap__filter\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__map__filter(self)(\n\t\t\t\t(key, value) -> {\n\t\t\t\t\tfn(key, __helios__common__unBoolData(value))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__find\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(result) -> {\n\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\tresult((key, value) -> {\n\t\t\t\t\t\t\tcallback(key, __helios__common__unBoolData(value))\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}(__helios__map__find(self)(fn))\n\t\t\t}(\n\t\t\t\t(fst, snd) -> {\n\t\t\t\t\tfn(fst, __helios__common__unBoolData(snd))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__find_safe\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(resultok) -> {\n\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\tresultok((result, ok) -> {\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t(inner_callback) -> {\n\t\t\t\t\t\t\t\t\t\tresult()(\n\t\t\t\t\t\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t\t\t\t\t\tinner_callback(key, __helios__common__unBoolData(value))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, \n\t\t\t\t\t\t\t\tok\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}(__helios__map__find_safe(self)(fn))\n\t\t\t}(\n\t\t\t\t(fst, snd) -> {\n\t\t\t\t\tfn(fst, __helios__common__unBoolData(snd))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__find_key\", \"__helios__map__find_key\"));\n\tadd(new RawFunc(\"__helios__boolmap__find_key_safe\", \"__helios__map__find_key_safe\"));\n\tadd(new RawFunc(\"__helios__boolmap__find_value\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find(\n\t\t\t\t\t\tself, \n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t(result) -> {\n\t\t\t\t\t\t\t__helios__common__unBoolData(__core__sndPair(result))\n\t\t\t\t\t\t}\t\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__helios__common__unBoolData(__core__sndPair(pair)))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__find_value_safe\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__helios__common__find_safe(\n\t\t\t\t\t\tself, \n\t\t\t\t\t\tfn,\n\t\t\t\t\t\t(result) -> {\n\t\t\t\t\t\t\t__core__sndPair(result)\n\t\t\t\t\t\t}\t\n\t\t\t\t\t)\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\tfn(__helios__common__unBoolData(__core__sndPair(pair)))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__map\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__core__mapData(__helios__common__map(self, fn, __core__mkNilPairData(())))\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t(mapped_pair) -> {\n\t\t\t\t\t\t\tmapped_pair(\n\t\t\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t\t\t__core__mkPairData(key, value)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(fn(__core__fstPair(pair), __helios__common__unBoolData(__core__sndPair(pair))))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__map_to_bool\",\n\t`(self) -> {\n\t\t(self) -> {\n\t\t\t(fn) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\t__core__mapData(__helios__common__map(self, fn, __core__mkNilPairData(())))\n\t\t\t\t}(\n\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t(mapped_pair) -> {\n\t\t\t\t\t\t\tmapped_pair(\n\t\t\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t\t\t__core__mkPairData(key, __helios__common__boolData(value))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(fn(__core__fstPair(pair), __helios__common__unBoolData(__core__sndPair(pair))))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__fold\",\n\t`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__map__fold(self)(\n\t\t\t\t(prev, key, value) -> {\n\t\t\t\t\tfn(prev, key, __helios__common__unBoolData(value))\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__fold_lazy\",\n\t`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__map__fold_lazy(self)(\n\t\t\t\t(key, value, next) -> {\n\t\t\t\t\tfn(key, __helios__common__unBoolData(value), next)\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__for_each\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__map__for_each(self)(\n\t\t\t\t(key, value) -> {\n\t\t\t\t\tfn(key, __helios__common__unBoolData(value))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__set\", \n\t`(self) -> {\n\t\t(key, value) -> {\n\t\t\t__helios__map__set(self)(key, __helios__common__boolData(value))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__boolmap__sort\",\n\t`(self) -> {\n\t\t(comp) -> {\n\t\t\t(comp) -> {\n\t\t\t\t__helios__map__sort(self)(comp)\n\t\t\t}(\n\t\t\t\t(ak, av, bk, bv) -> {\n\t\t\t\t\tcomp(ak, __helios__common__unBoolData(av), bk, __helios__common__unBoolData(bv))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\n\n\t// Option[T] builtins\n\taddDataFuncs(\"__helios__option\");\n\tadd(new RawFunc(\"__helios__option__map\", \n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(pair) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__option__some__new(fn(__core__headList(__core__sndPair(pair))))\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__option__none__new()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}(__core__unConstrData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__option__map_to_bool\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__option__map(self)(fn)\n\t\t\t}(\n\t\t\t\t(data) -> {\n\t\t\t\t\t__helios__common__boolData(fn(data))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__option__unwrap\", \n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__field_0(self)\n\t\t}\n\t}`));\n\n\n\t// Option[T]::Some\n\taddEnumDataFuncs(\"__helios__option__some\");\n\tadd(new RawFunc(\"__helios__option__some__new\",\n\t`(data) -> {\n\t\t__core__constrData(0, __helios__common__list_1(data))\n\t}`));\n\tadd(new RawFunc(\"__helios__option__some__cast\",\n\t`(data) -> {\n\t\t__helios__common__assert_constr_index(data, 0)\n\t}`));\n\tadd(new RawFunc(\"__helios__option__some__some\", \"__helios__common__field_0\"));\n\t\n\n\t// Option[T]::None\n\taddEnumDataFuncs(\"__helios__option__none\");\n\tadd(new RawFunc(\"__helios__option__none__new\",\n\t`() -> {\n\t\t__core__constrData(1, __helios__common__list_0)\n\t}`));\n\tadd(new RawFunc(\"__helios__option__none__cast\",\n\t`(data) -> {\n\t\t__helios__common__assert_constr_index(data, 1)\n\t}`));\n\n\n\t// Option[Bool]\n\tadd(new RawFunc(\"__helios__booloption____eq\", \"__helios__option____eq\"));\n\tadd(new RawFunc(\"__helios__booloption____neq\", \"__helios__option____neq\"));\n\tadd(new RawFunc(\"__helios__booloption__serialize\", \"__helios__option__serialize\"));\n\tadd(new RawFunc(\"__helios__booloption__from_data\", \"__helios__option__from_data\"));\n\tadd(new RawFunc(\"__helios__booloption__unwrap\", `\n\t(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__unBoolData(__helios__common__field_0(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__booloption__map\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__option__map(self)(fn)\n\t\t\t}(\n\t\t\t\t(data) -> {\n\t\t\t\t\tfn(__helios__common__unBoolData(data))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__booloption__map_to_bool\",\n\t`(self) -> {\n\t\t(fn) -> {\n\t\t\t(fn) -> {\n\t\t\t\t__helios__option__map(self)(fn)\n\t\t\t}(\n\t\t\t\t(data) -> {\n\t\t\t\t\t__helios__common__boolData(fn(__helios__common__unBoolData(data)))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\n\t\n\t// Option[Bool]::Some\n\tadd(new RawFunc(\"__helios__booloption__some____eq\", \"__helios__option__some____eq\"));\n\tadd(new RawFunc(\"__helios__booloption__some____neq\", \"__helios__option__some____neq\"));\n\tadd(new RawFunc(\"__helios__booloption__some__serialize\", \"__helios__option__some__serialize\"));\n\tadd(new RawFunc(\"__helios__booloption__some__new\", \n\t`(b) -> {\n\t\t__helios__option__some__new(__helios__common__boolData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__booloption__some__cast\", \"__helios__option__some__cast\"));\n\tadd(new RawFunc(\"__helios__booloption__some__some\", \n\t`(self) -> {\n\t\t__helios__common__unBoolData(__helios__option__some__some(self))\n\t}`));\n\n\t\n\t// Option[Bool]::None\n\tadd(new RawFunc(\"__helios__booloption__none____eq\",      \"__helios__option__none____eq\"));\n\tadd(new RawFunc(\"__helios__booloption__none____neq\",     \"__helios__option__none____neq\"));\n\tadd(new RawFunc(\"__helios__booloption__none__serialize\", \"__helios__option__none__serialize\"));\n\tadd(new RawFunc(\"__helios__booloption__none__new\",       \"__helios__option__none__new\"));\n\tadd(new RawFunc(\"__helios__booloption__none__cast\",      \"__helios__option__none__cast\"));\n\n\t\n\t// Hash builtins\n\taddDataFuncs(\"__helios__hash\");\n\tadd(new RawFunc(\"__helios__hash____lt\", \"__helios__bytearray____lt\"));\n\tadd(new RawFunc(\"__helios__hash____leq\", \"__helios__bytearray____leq\"));\n\tadd(new RawFunc(\"__helios__hash____gt\", \"__helios__bytearray____gt\"));\n\tadd(new RawFunc(\"__helios__hash____geq\", \"__helios__bytearray____geq\"));\n\tadd(new RawFunc(\"__helios__hash__new\", `__helios__common__identity`));\n\tadd(new RawFunc(\"__helios__hash__show\", \"__helios__bytearray__show\"));\n\tadd(new RawFunc(\"__helios__hash__CURRENT\", \"__core__bData(#0000000000000000000000000000000000000000000000000000000000000000)\"));\n\tadd(new RawFunc(\"__helios__hash__from_script_hash\", \"__helios__common__identity\"));\n\n\t\n\t// ScriptHash builtin\n\taddDataFuncs(\"__helios__scripthash\");\n\n\n\t// PubKey builtin\n\taddDataFuncs(\"__helios__pubkey\");\n\tadd(new RawFunc(\"__helios__pubkey__new\", \"__helios__common__identity\"));\n\tadd(new RawFunc(\"__helios__pubkey__show\", \"__helios__bytearray__show\"));\n\tadd(new RawFunc(\"__helios__pubkey__verify\", \n\t`(self) -> {\n\t\t(message, signature) -> {\n\t\t\t__core__verifyEd25519Signature(__core__unBData(self), __core__unBData(message), __core__unBData(signature))\n\t\t}\n\t}`));\n\n\n\t// ScriptContext builtins\n\taddDataFuncs(\"__helios__scriptcontext\");\n\tadd(new RawFunc(\"__helios__scriptcontext__new_spending\",\n\t`(tx, output_id) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(1, __helios__common__list_1(output_id))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__new_minting\",\n\t`(tx, mph) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(0, __helios__common__list_1(mph))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__new_rewarding\",\n\t`(tx, cred) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(2, __helios__common__list_1(cred))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__new_certifying\",\n\t`(tx, dcert) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(3, __helios__common__list_1(dcert))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__tx\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__scriptcontext__purpose\", \"__helios__common__field_1\"));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_current_input\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(id) -> {\n\t\t\t\t__helios__list__find(__helios__tx__inputs(__helios__scriptcontext__tx(self)))(\n\t\t\t\t\t(input) -> {\n\t\t\t\t\t\t__core__equalsData(__helios__txinput__output_id(input), id)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(__helios__scriptcontext__get_spending_purpose_output_id(self)())\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_cont_outputs\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(vh) -> {\n\t\t\t\t(outputs) -> {\n\t\t\t\t\t__helios__list__filter(outputs)(\n\t\t\t\t\t\t(output) -> {\n\t\t\t\t\t\t\t(credential) -> {\n\t\t\t\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 0),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__equalsData(__core__headList(__core__sndPair(pair)), vh)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__unConstrData(credential))\n\t\t\t\t\t\t\t}(__helios__address__credential(__helios__txoutput__address(output)))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}(__helios__tx__outputs(__helios__scriptcontext__tx(self)))\n\t\t\t}(__helios__scriptcontext__get_current_validator_hash(self)())\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_spending_purpose_output_id\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__field_0(__helios__common__field_1(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_current_validator_hash\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__credential__validator__hash(\n\t\t\t\t__helios__credential__validator__cast(\n\t\t\t\t\t__helios__address__credential(\n\t\t\t\t\t\t__helios__txoutput__address(\n\t\t\t\t\t\t\t__helios__txinput__output(\n\t\t\t\t\t\t\t\t__helios__scriptcontext__get_current_input(self)()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_current_minting_policy_hash\", \"__helios__scriptcontext__get_spending_purpose_output_id\"));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_staking_purpose\", \n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__scriptcontext__purpose(self)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptcontext__get_script_purpose\", \n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__scriptcontext__purpose(self)\n\t\t}\n\t}`));\n\n\n\t// StakingPurpose builtins\n\taddDataFuncs(\"__helios__stakingpurpose\");\n\n\n\t// StakingPurpose::Rewarding builtins\n\taddEnumDataFuncs(\"__helios__stakingpurpose__rewarding\");\n\tadd(new RawFunc(\"__helios__stakingpurpose__rewarding__credential\", \"__helios__common__field_0\"));\n\n\t\n\t// StakingPurpose::Certifying builtins\n\taddEnumDataFuncs(\"__helios__stakingpurpose__certifying\");\n\tadd(new RawFunc(\"__helios__stakingpurpose__certifying__dcert\", \"__helios__common__field_0\"));\n\n\n\t// ScriptPurpose builtins\n\taddDataFuncs(\"__helios__scriptpurpose\");\n\tadd(new RawFunc(\"__helios__scriptpurpose__new_minting\",\n\t`(mintingPolicyHash) -> {\n\t\t__core__constrData(0, __helios__common__list_1(mintingPolicyHash))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptpurpose__new_spending\",\n\t`(output_id) -> {\n\t\t__core__constrData(1, __helios__common__list_1(output_id))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptpurpose__new_rewarding\",\n\t`(cred) -> {\n\t\t__core__constrData(2, __helios__common__list_1(cred))\n\t}`));\n\tadd(new RawFunc(\"__helios__scriptpurpose__new_certifying\",\n\t`(dcert) -> {\n\t\t__core__constrData(3, __helios__common__list_1(dcert))\n\t}`));\n\n\n\t// ScriptPurpose::Minting builtins\n\taddEnumDataFuncs(\"__helios__scriptpurpose__minting\");\n\tadd(new RawFunc(\"__helios__scriptpurpose__minting__policy_hash\", \"__helios__common__field_0\"));\n\n\t\n\t// ScriptPurpose::Spending builtins\n\taddEnumDataFuncs(\"__helios__scriptpurpose__spending\");\n\tadd(new RawFunc(\"__helios__scriptpurpose__spending__output_id\", \"__helios__common__field_0\"));\n\n\t\n\t// ScriptPurpose::Rewarding builtins\n\taddEnumDataFuncs(\"__helios__scriptpurpose__rewarding\");\n\tadd(new RawFunc(\"__helios__scriptpurpose__rewarding__credential\", \"__helios__common__field_0\"));\n\n\t\n\t// ScriptPurpose::Certifying builtins\n\taddEnumDataFuncs(\"__helios__scriptpurpose__certifying\");\n\tadd(new RawFunc(\"__helios__scriptpurpose__certifying__dcert\", \"__helios__common__field_0\"));\n\n\n\t// DCert builtins\n\taddDataFuncs(\"__helios__dcert\");\n\tadd(new RawFunc(\"__helios__dcert__new_register\",\n\t`(cred) -> {\n\t\t__core__constrData(0, __helios__common__list_1(cred))\n\t}`));\n\tadd(new RawFunc(\"__helios__dcert__new_deregister\",\n\t`(cred) -> {\n\t\t__core__constrData(1, __helios__common__list_1(cred))\n\t}`));\n\tadd(new RawFunc(\"__helios__dcert__new_delegate\",\n\t`(cred, pool_id) -> {\n\t\t__core__constrData(2, __helios__common__list_2(cred, pool_id))\n\t}`));\n\tadd(new RawFunc(\"__helios__dcert__new_register_pool\",\n\t`(id, vrf) -> {\n\t\t__core__constrData(3, __helios__common__list_2(id, vrf))\n\t}`));\n\tadd(new RawFunc(\"__helios__dcert__new_retire_pool\",\n\t`(id, epoch) -> {\n\t\t__core__constrData(4, __helios__common__list_2(id, epoch))\n\t}`));\n\n\n\t// DCert::Register builtins\n\taddEnumDataFuncs(\"__helios__dcert__register\");\n\tadd(new RawFunc(\"__helios__dcert__register__credential\", \"__helios__common__field_0\"));\n\n\n\t// DCert::Deregister builtins\n\taddEnumDataFuncs(\"__helios__dcert__deregister\");\n\tadd(new RawFunc(\"__helios__dcert__deregister__credential\", \"__helios__common__field_0\"));\n\n\n\t// DCert::Delegate builtins\n\taddEnumDataFuncs(\"__helios__dcert__delegate\");\n\tadd(new RawFunc(\"__helios__dcert__delegate__delegator\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__dcert__delegate__pool_id\", \"__helios__common__field_1\"));\n\n\n\t// DCert::RegisterPool builtins\n\taddEnumDataFuncs(\"__helios__dcert__registerpool\");\n\tadd(new RawFunc(\"__helios__dcert__registerpool__pool_id\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__dcert__registerpool__pool_vrf\", \"__helios__common__field_1\"));\n\n\n\t// DCert::RetirePool builtins\n\taddEnumDataFuncs(\"__helios__dcert__retirepool\");\n\tadd(new RawFunc(\"__helios__dcert__retirepool__pool_id\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__dcert__retirepool__epoch\", \"__helios__common__field_1\"));\n\n\n\t// Tx builtins\n\taddDataFuncs(\"__helios__tx\");\n\tadd(new RawFunc(\"__helios__tx__new\",\n\t`(inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t__core__constrData(0, __helios__common__list_12(\n\t\t\tinputs,\n\t\t\tref_inputs,\n\t\t\toutputs,\n\t\t\tfee,\n\t\t\tminted,\n\t\t\tdcerts,\n\t\t\twithdrawals,\n\t\t\tvalidity,\n\t\t\tsignatories,\n\t\t\tredeemers,\n\t\t\tdatums,\n\t\t\t__helios__txid__CURRENT\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__inputs\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__tx__ref_inputs\", \"__helios__common__field_1\"))\n\tadd(new RawFunc(\"__helios__tx__outputs\", \"__helios__common__field_2\"));\n\tadd(new RawFunc(\"__helios__tx__fee\", \"__helios__common__field_3\"));\n\tadd(new RawFunc(\"__helios__tx__minted\", \"__helios__common__field_4\"));\n\tadd(new RawFunc(\"__helios__tx__dcerts\", \"__helios__common__field_5\"));\n\tadd(new RawFunc(\"__helios__tx__withdrawals\", \"__helios__common__field_6\"));\n\tadd(new RawFunc(\"__helios__tx__time_range\", \"__helios__common__field_7\"));\n\tadd(new RawFunc(\"__helios__tx__signatories\", \"__helios__common__field_8\"));\n\tadd(new RawFunc(\"__helios__tx__redeemers\", \"__helios__common__field_9\"));\n\tadd(new RawFunc(\"__helios__tx__datums\", \"__helios__common__field_10\"));\n\tadd(new RawFunc(\"__helios__tx__id\", \"__helios__common__field_11\"));\n\tadd(new RawFunc(\"__helios__tx__find_datum_hash\",\n\t`(self) -> {\n\t\t(datum) -> {\n\t\t\t__core__fstPair(__helios__common__find(\n\t\t\t\t__core__unMapData(__helios__tx__datums(self)),\n\t\t\t\t(pair) -> {\n\t\t\t\t\t__core__equalsData(__core__sndPair(pair), datum)\n\t\t\t\t},\n\t\t\t\t__helios__common__identity\n\t\t\t))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__get_datum_data\",\n\t`(self) -> {\n\t\t(output) -> {\n\t\t\t(pair) -> {\n\t\t\t\t(idx) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(idx, 1),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__map__get(__helios__tx__datums(self))(__core__headList(__core__sndPair(pair)))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(idx, 2),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__headList(__core__sndPair(pair))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {error(\"output doesn't have a datum\")}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}(__core__fstPair(pair))\n\t\t\t}(__core__unConstrData(__helios__txoutput__datum(output)))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__filter_outputs\",\n\t`(self, fn) -> {\n\t\t__core__listData(\n\t\t\t__helios__common__filter_list(\n\t\t\t\t__core__unListData(__helios__tx__outputs(self)), \n\t\t\t\tfn\n\t\t\t)\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_sent_to\",\n\t`(self) -> {\n\t\t(pubKeyHash) -> {\n\t\t\t__helios__tx__filter_outputs(self, (output) -> {\n\t\t\t\t__helios__txoutput__is_sent_to(output)(pubKeyHash)\n\t\t\t})\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_sent_to_datum\",\n\t`(self) -> {\n\t\t(pubKeyHash, datum, isInline) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tisInline,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_sent_to_inline_datum(self, pubKeyHash, datum)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_sent_to_datum_hash(self, pubKeyHash, datum)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_sent_to_datum_hash\",\n\t`(self, pubKeyHash, datum) -> {\n\t\t(datumHash) -> {\n\t\t\t__helios__tx__filter_outputs(\n\t\t\t\tself, \n\t\t\t\t(output) -> {\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__txoutput__is_sent_to(output)(pubKeyHash)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__txoutput__has_datum_hash(output, datumHash)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)\n\t\t}(__helios__common__hash_datum_data(datum))\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_sent_to_inline_datum\",\n\t`(self, pubKeyHash, datum) -> {\n\t\t__helios__tx__filter_outputs(\n\t\t\tself, \n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_sent_to(output)(pubKeyHash)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_inline_datum(output, datum)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_locked_by\",\n\t`(self) -> {\n\t\t(validatorHash) -> {\n\t\t\t__helios__tx__filter_outputs(self, (output) -> {\n\t\t\t\t__helios__txoutput__is_locked_by(output)(validatorHash)\n\t\t\t})\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_locked_by_datum\",\n\t`(self) -> {\n\t\t(validatorHash, datum, isInline) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tisInline,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_locked_by_inline_datum(self, validatorHash, datum)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_locked_by_datum_hash(self, validatorHash, datum)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_locked_by_datum_hash\",\n\t`(self, validatorHash, datum) -> {\n\t\t(datumHash) -> {\n\t\t\t__helios__tx__filter_outputs(\n\t\t\t\tself, \n\t\t\t\t(output) -> {\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__txoutput__is_locked_by(output)(validatorHash)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__txoutput__has_datum_hash(output, datumHash)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)\n\t\t}(__helios__common__hash_datum_data(datum))\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__outputs_locked_by_inline_datum\",\n\t`(self, validatorHash, datum) -> {\n\t\t__helios__tx__filter_outputs(\n\t\t\tself, \n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_locked_by(output)(validatorHash)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_inline_datum(output, datum)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__value_sent_to\",\n\t`(self) -> {\n\t\t(pubKeyHash) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_sent_to(self)(pubKeyHash))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__value_sent_to_datum\",\n\t`(self) -> {\n\t\t(pubKeyHash, datum, isInline) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_sent_to_datum(self)(pubKeyHash, datum, isInline))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__value_locked_by\",\n\t`(self) -> {\n\t\t(validatorHash) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_locked_by(self)(validatorHash))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__value_locked_by_datum\",\n\t`(self) -> {\n\t\t(validatorHash, datum, isInline) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_locked_by_datum(self)(validatorHash, datum, isInline))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__tx__is_signed_by\",\n\t`(self) -> {\n\t\t(hash) -> {\n\t\t\t__helios__common__any(\n\t\t\t\t__core__unListData(__helios__tx__signatories(self)),\n\t\t\t\t(signatory) -> {\n\t\t\t\t\t__core__equalsData(signatory, hash)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\n\n\t// TxId builtins\n\taddDataFuncs(\"__helios__txid\");\n\tadd(new RawFunc(\"__helios__txid__bytes\",\n\t`(self) -> {\n\t\t__core__headList(__core__sndPair(__core__unConstrData(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__txid____lt\", \n\t`(a, b) -> {\n\t\t__helios__bytearray____lt(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__txid____leq\", \n\t`(a, b) -> {\n\t\t__helios__bytearray____leq(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__txid____gt\", \n\t`(a, b) -> {\n\t\t__helios__bytearray____gt(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__txid____geq\", \n\t`(a, b) -> {\n\t\t__helios__bytearray____geq(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__txid__new\",\n\t`(bytes) -> {\n\t\t__core__constrData(0, __helios__common__list_1(bytes)) \n\t}`));\n\tadd(new RawFunc(\"__helios__txid__CURRENT\", \"__helios__txid__new(__core__bData(#0000000000000000000000000000000000000000000000000000000000000000))\"));\n\tadd(new RawFunc(\"__helios__txid__show\",\n\t`(self) -> {\n\t\t__helios__bytearray__show(__helios__txid__bytes(self))\n\t}`));\n\n\n\t// TxInput builtins\n\taddDataFuncs(\"__helios__txinput\");\n\tadd(new RawFunc(\"__helios__txinput__new\",\n\t`(output_id, output) -> {\n\t\t__core__constrData(0, __helios__common__list_2(output_id, output))\n\t}`));\n\tadd(new RawFunc(\"__helios__txinput__output_id\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__txinput__output\", \"__helios__common__field_1\"));\n\t\n\n\t// TxOutput builtins\n\taddDataFuncs(\"__helios__txoutput\");\n\tadd(new RawFunc(\"__helios__txoutput__new\", \n\t`(address, value, datum) -> {\n\t\t__core__constrData(0, __helios__common__list_4(address, value, datum, __helios__option__none__new()))\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__address\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__txoutput__value\", \"__helios__common__field_1\"));\n\tadd(new RawFunc(\"__helios__txoutput__datum\", \"__helios__common__field_2\"));\n\tadd(new RawFunc(\"__helios__txoutput__ref_script_hash\", \"__helios__common__field_3\"));\n\tadd(new RawFunc(\"__helios__txoutput__get_datum_hash\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(pair) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 1),\n\t\t\t\t\t() -> {__core__headList(__core__sndPair(pair))},\n\t\t\t\t\t() -> {__core__bData(#)}\n\t\t\t\t)()\n\t\t\t}(__core__unConstrData(__helios__txoutput__datum(self)))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__has_datum_hash\",\n\t`(self, datumHash) -> {\n\t\t__core__equalsData(__helios__txoutput__get_datum_hash(self)(), datumHash)\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__has_inline_datum\",\n\t`(self, datum) -> {\n\t\t(pair) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 2),\n\t\t\t\t() -> {__core__equalsData(datum, __core__headList(__core__sndPair(pair)))},\n\t\t\t\t() -> {false}\n\t\t\t)()\n\t\t}(__core__unConstrData(__helios__txoutput__datum(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__is_locked_by\",\n\t`(self) -> {\n\t\t(hash) -> {\n\t\t\t(credential) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__helios__credential__is_validator(credential),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__equalsData(\n\t\t\t\t\t\t\thash, \n\t\t\t\t\t\t\t__helios__credential__validator__hash(\n\t\t\t\t\t\t\t\t__helios__credential__validator__cast(credential)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {false}\n\t\t\t\t)()\n\t\t\t}(__helios__address__credential(__helios__txoutput__address(self)))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__is_sent_to\",\n\t`(self) -> {\n\t\t(pkh) -> {\n\t\t\t(credential) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__helios__credential__is_pubkey(credential),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__equalsData(\n\t\t\t\t\t\t\tpkh, \n\t\t\t\t\t\t\t__helios__credential__pubkey__hash(\n\t\t\t\t\t\t\t\t__helios__credential__pubkey__cast(credential)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {false}\n\t\t\t\t)()\n\t\t\t}(__helios__address__credential(__helios__txoutput__address(self)))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutput__sum_values\",\n\t`(outputs) -> {\n\t\t__helios__list__fold(outputs)(\n\t\t\t(prev, txOutput) -> {\n\t\t\t\t__helios__value____add(\n\t\t\t\t\tprev,\n\t\t\t\t\t__helios__txoutput__value(txOutput)\n\t\t\t\t)\n\t\t\t}, \n\t\t\t__helios__value__ZERO\n\t\t)\t\n\t}`));\n\n\n\t// OutputDatum\n\taddDataFuncs(\"__helios__outputdatum\");\n\tadd(new RawFunc(\"__helios__outputdatum__new_none\",\n\t`() -> {\n\t\t__core__constrData(0, __helios__common__list_0)\n\t}`));\n\tadd(new RawFunc(\"__helios__outputdatum__new_hash\",\n\t`(hash) -> {\n\t\t__core__constrData(1, __helios__common__list_1(hash))\n\t}`));\n\tadd(new RawFunc(\"__helios__outputdatum__new_inline\",\n\t`(data) -> {\n\t\t__core__constrData(2, __helios__common__list_1(data))\n\t}`));\n\tadd(new RawFunc(\"__helios__outputdatum__new_inline_from_bool\",\n\t`(b) -> {\n\t\t__helios__outputdatum__new_inline(_helios__common__boolData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__outputdatum__get_inline_data\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(pair) -> {\n\t\t\t\t(index, fields) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(index, 2),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__headList(fields)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\terror(\"not an inline datum\")\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}(__core__fstPair(pair), __core__sndPair(pair))\n\t\t\t}(__core__unConstrData(self))\n\t\t}\n\t}`));\n\n\n\t// OutputDatum::None\n\taddEnumDataFuncs(\"__helios__outputdatum__none\");\n\t\n\n\t// OutputDatum::Hash\n\taddEnumDataFuncs(\"__helios__outputdatum__hash\");\n\tadd(new RawFunc(\"__helios__outputdatum__hash__hash\", \"__helios__common__field_0\"));\n\n\n\t// OutputDatum::Inline\n\taddEnumDataFuncs(\"__helios__outputdatum__inline\");\n\tadd(new RawFunc(\"__helios__outputdatum__inline__data\", \"__helios__common__field_0\"));\n\n\n\t// RawData\n\taddDataFuncs(\"__helios__data\");\n\tadd(new RawFunc(\"__helios__data__tag\", \n\t`(self) -> {\n\t\t__core__iData(__core__fstPair(__core__unConstrData(self)))\n\t}`));\n\n\n\t// TxOutputId\n\taddDataFuncs(\"__helios__txoutputid\");\n\tadd(new RawFunc(\"__helios__txoutputid__tx_id\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__txoutputid__index\", \"__helios__common__field_1\"));\n\tadd(new RawFunc(\"__helios__txoutputid__comp\", \n\t`(a, b, comp_txid, comp_index) -> {\n\t\t(a_txid, a_index) -> {\n\t\t\t(b_txid, b_index) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsData(a_txid, b_txid),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tcomp_index(a_index, b_index)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tcomp_txid(a_txid, b_txid)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}(__helios__txoutputid__tx_id(b), __helios__txoutputid__index(b))\n\t\t}(__helios__txoutputid__tx_id(a), __helios__txoutputid__index(a))\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutputid____lt\", \n\t`(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____lt, __helios__int____lt)\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutputid____leq\", \n\t`(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____leq, __helios__int____leq)\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutputid____gt\", \n\t`(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____gt, __helios__int____gt)\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutputid____geq\", \n\t`(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____geq, __helios__int____geq)\n\t}`));\n\tadd(new RawFunc(\"__helios__txoutputid__new\",\n\t`(tx_id, idx) -> {\n\t\t__core__constrData(0, __helios__common__list_2(tx_id, idx))\n\t}`));\n\n\n\t// Address\n\taddDataFuncs(\"__helios__address\");\n\tadd(new RawFunc(\"__helios__address__new\", \n\t`(cred, staking_cred) -> {\n\t\t__core__constrData(0, __helios__common__list_2(cred, staking_cred))\n\t}`));\n\tadd(new RawFunc(\"__helios__address__new_empty\",\n\t`() -> {\n\t\t__core__constrData(0, __helios__common__list_2(__helios__credential__new_pubkey(__core__bData(#)), __helios__option__none__new()))\n\t}`))\n\tadd(new RawFunc(\"__helios__address__credential\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__address__staking_credential\", \"__helios__common__field_1\"));\n\tadd(new RawFunc(\"__helios__address__is_staked\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(__helios__common__field_1(self))), 0)\n\t\t}\n\t}`));\n\n\n\t// Credential builtins\n\taddDataFuncs(\"__helios__credential\");\n\tadd(new RawFunc(\"__helios__credential__new_pubkey\",\n\t`(hash) -> {\n\t\t__core__constrData(0, __helios__common__list_1(hash))\n\t}`));\n\tadd(new RawFunc(\"__helios__credential__new_validator\",\n\t`(hash) -> {\n\t\t__core__constrData(1, __helios__common__list_1(hash))\n\t}`));\n\tadd(new RawFunc(\"__helios__credential__is_pubkey\",\n\t`(self) -> {\n\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(self)), 0)\n\t}`));\n\tadd(new RawFunc(\"__helios__credential__is_validator\",\n\t`(self) -> {\n\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(self)), 1)\n\t}`));\n\n\n\t// Credential::PubKey builtins\n\taddEnumDataFuncs(\"__helios__credential__pubkey\");\n\tadd(new RawFunc(\"__helios__credential__pubkey__cast\",\n\t`(data) -> {\n\t\t__helios__common__assert_constr_index(data, 0)\n\t}`));\n\tadd(new RawFunc(\"__helios__credential__pubkey__hash\", \"__helios__common__field_0\"));\n\n\n\t// Credential::Validator builtins\n\taddEnumDataFuncs(\"__helios__credential__validator\");\n\tadd(new RawFunc(\"__helios__credential__validator__cast\",\n\t`(data) -> {\n\t\t__helios__common__assert_constr_index(data, 1)\n\t}`));\n\tadd(new RawFunc(\"__helios__credential__validator__hash\", \"__helios__common__field_0\"));\n\n\n\t// StakingHash builtins\n\taddDataFuncs(\"__helios__stakinghash\");\n\tadd(new RawFunc(\"__helios__stakinghash__new_stakekey\", \"__helios__credential__new_pubkey\"));\n\tadd(new RawFunc(\"__helios__stakinghash__new_validator\", \"__helios__credential__new_validator\"));\n\tadd(new RawFunc(\"__helios__stakinghash__is_stakekey\", \"__helios__credential__is_stakekey\"));\n\tadd(new RawFunc(\"__helios__stakinghash__is_validator\", \"__helios__credential__is_validator\"));\n\n\n\t// StakingHash::StakeKey builtins\n\taddEnumDataFuncs(\"__helios__stakinghash__stakekey\");\n\tadd(new RawFunc(\"__helios__stakinghash__stakekey__cast\", \"__helios__credential__pubkey__cast\"));\n\tadd(new RawFunc(\"__helios__stakinghash__stakekey__hash\", \"__helios__credential__pubkey__hash\"));\n\n\n\t// StakingHash::Validator builtins\n\taddEnumDataFuncs(\"__helios__stakinghash__validator\");\n\tadd(new RawFunc(\"__helios__stakinghash__validator__cast\", \"__helios__credential__validator__cast\"));\n\tadd(new RawFunc(\"__helios__stakinghash__validator__hash\", \"__helios__credential__validator__hash\"));\n\n\n\t// StakingCredential builtins\n\taddDataFuncs(\"__helios__stakingcredential\");\n\tadd(new RawFunc(\"__helios__stakingcredential__new_hash\", \n\t`(cred) -> {\n\t\t__core__constrData(0, __helios__common__list_1(cred))\n\t}`));\n\tadd(new RawFunc(\"__helios__stakingcredential__new_ptr\", \n\t`(i, j, k) -> {\n\t\t__core__constrData(1, __helios__common__list_3(i, j, k))\n\t}`));\n\n\t\n\t// StakingCredential::Hash builtins\n\taddEnumDataFuncs(\"__helios__stakingcredential__hash\");\n\tadd(new RawFunc(\"__helios__stakingcredential__hash__hash\", \"__helios__common__field_0\"));\n\n\n\t// StakingCredential::Ptr builtins\n\taddEnumDataFuncs(\"__helios__stakingcredential__ptr\");\n\n\n\t// Time builtins\n\taddDataFuncs(\"__helios__time\");\n\tadd(new RawFunc(\"__helios__time__new\", `__helios__common__identity`));\n\tadd(new RawFunc(\"__helios__time____add\", `__helios__int____add`));\n\tadd(new RawFunc(\"__helios__time____sub\", `__helios__int____sub`));\n\tadd(new RawFunc(\"__helios__time____sub_alt\", `__helios__int____sub`));\n\tadd(new RawFunc(\"__helios__time____geq\", `__helios__int____geq`));\n\tadd(new RawFunc(\"__helios__time____gt\", `__helios__int____gt`));\n\tadd(new RawFunc(\"__helios__time____leq\", `__helios__int____leq`));\n\tadd(new RawFunc(\"__helios__time____lt\", `__helios__int____lt`));\n\tadd(new RawFunc(\"__helios__time__show\", `__helios__int__show`));\n\n\n\t// Duratin builtins\n\taddDataFuncs(\"__helios__duration\");\n\tadd(new RawFunc(\"__helios__duration__new\", `__helios__common__identity`));\n\tadd(new RawFunc(\"__helios__duration____add\", `__helios__int____add`));\n\tadd(new RawFunc(\"__helios__duration____sub\", `__helios__int____sub`));\n\tadd(new RawFunc(\"__helios__duration____mul\", `__helios__int____mul`));\n\tadd(new RawFunc(\"__helios__duration____div\", `__helios__int____div`));\n\tadd(new RawFunc(\"__helios__duration____div_alt\", `__helios__int____div`));\n\tadd(new RawFunc(\"__helios__duration____mod\", `__helios__int____mod`));\n\tadd(new RawFunc(\"__helios__duration____geq\", `__helios__int____geq`));\n\tadd(new RawFunc(\"__helios__duration____gt\", `__helios__int____gt`));\n\tadd(new RawFunc(\"__helios__duration____leq\", `__helios__int____leq`));\n\tadd(new RawFunc(\"__helios__duration____lt\", `__helios__int____lt`));\n\tadd(new RawFunc(\"__helios__duration__SECOND\", \"__core__iData(1000)\"));\n\tadd(new RawFunc(\"__helios__duration__MINUTE\", \"__core__iData(60000)\"));\n\tadd(new RawFunc(\"__helios__duration__HOUR\", \"__core__iData(3600000)\"));\n\tadd(new RawFunc(\"__helios__duration__DAY\", \"__core__iData(86400000)\"));\n\tadd(new RawFunc(\"__helios__duration__WEEK\", \"__core__iData(604800000)\"));\n\n\n\t// TimeRange builtins\n\taddDataFuncs(\"__helios__timerange\");\n\tadd(new RawFunc(\"__helios__timerange__new\", `\n\t(a, b) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(a)),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(b)),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__ALWAYS\", `\n\t__core__constrData(0, __helios__common__list_2(\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t__helios__common__boolData(true)\n\t\t)),\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t__helios__common__boolData(true)\n\t\t))\n\t))`));\n\tadd(new RawFunc(\"__helios__timerange__NEVER\", `\n\t__core__constrData(0, __helios__common__list_2(\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t__helios__common__boolData(true)\n\t\t)),\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t__helios__common__boolData(true)\n\t\t))\n\t))`));\n\tadd(new RawFunc(\"__helios__timerange__from\", `\n\t(a) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(a)),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__to\", `\n\t(b) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(b)),\n\t\t\t\t__helios__common__boolData(true)\n\t\t\t))\n\t\t))\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__is_before\", \n\t`(self) -> {\n\t\t(t) -> {\n\t\t\t(upper) -> {\n\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t(extType) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), __core__unIData(t))},\n\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), __core__unIData(t))}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(__core__fstPair(__core__unConstrData(extended)))\n\t\t\t\t}(__helios__common__field_0(upper), __helios__common__unBoolData(__helios__common__field_1(upper)))\n\t\t\t}(__helios__common__field_1(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__is_after\",\n\t`(self) -> {\n\t\t(t) -> {\n\t\t\t(lower) -> {\n\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t(extType) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(t), __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))},\n\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(t), __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(__core__fstPair(__core__unConstrData(extended)))\n\t\t\t\t}(__helios__common__field_0(lower), __helios__common__unBoolData(__helios__common__field_1(lower)))\n\t\t\t}(__helios__common__field_0(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__contains\",\n\t`(self) -> {\n\t\t(t) -> {\n\t\t\t(lower) -> {\n\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t(lowerExtType, checkUpper) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(lowerExtType, 2),\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(lowerExtType, 0),\n\t\t\t\t\t\t\t\t\t() -> {checkUpper()},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), __core__unIData(t))},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), __core__unIData(t))}\n\t\t\t\t\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t\t\t\t\t() -> {checkUpper()},\n\t\t\t\t\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(__core__fstPair(__core__unConstrData(extended)), () -> {\n\t\t\t\t\t\t(upper) -> {\n\t\t\t\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t\t\t\t(upperExtType) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(upperExtType, 0),\n\t\t\t\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(upperExtType, 2),\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(t), __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(t), __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__core__fstPair(__core__unConstrData(extended)))\n\t\t\t\t\t\t\t}(__helios__common__field_0(upper), __helios__common__unBoolData(__helios__common__field_1(upper)))\n\t\t\t\t\t\t}(__helios__common__field_1(self))\n\t\t\t\t\t})\n\t\t\t\t}(__helios__common__field_0(lower), __helios__common__unBoolData(__helios__common__field_1(lower)))\n\t\t\t}(__helios__common__field_0(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__start\",\n\t`(self) -> {\n\t\t__helios__common__field_0(__helios__common__field_0(__helios__common__field_0(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__end\",\n\t`(self) -> {\n\t\t__helios__common__field_0(__helios__common__field_0(__helios__common__field_1(self)))\n\t}`));\n\tadd(new RawFunc(\"__helios__timerange__show\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t(show_extended) -> {\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t(lower) -> {\n\t\t\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t() -> {__helios__common__stringData(\"[\")},\n\t\t\t\t\t\t\t\t\t() -> {__helios__common__stringData(\"(\")}\n\t\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t\tshow_extended(extended)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}(__helios__common__field_0(lower), __helios__common__unBoolData(__helios__common__field_1(lower)))\n\t\t\t\t\t}(__helios__common__field_0(self)),\n\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t__helios__common__stringData(\",\"),\n\t\t\t\t\t\t(upper) -> {\n\t\t\t\t\t\t\t(extended, closed) -> {\n\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\tshow_extended(extended),\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t() -> {__helios__common__stringData(\"]\")},\n\t\t\t\t\t\t\t\t\t\t() -> {__helios__common__stringData(\")\")}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}(__helios__common__field_0(upper), __helios__common__unBoolData(__helios__common__field_1(upper)))\n\t\t\t\t\t\t}(__helios__common__field_1(self))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}(\n\t\t\t\t(extended) -> {\n\t\t\t\t\t(extType) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t\t\t\t() -> {__helios__common__stringData(\"-inf\")},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t\t\t\t\t\t() -> {__helios__common__stringData(\"+inf\")},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(fields) -> {\n\t\t\t\t\t\t\t\t\t\t\t__helios__int__show(__core__headList(fields))()\n\t\t\t\t\t\t\t\t\t\t}(__core__sndPair(__core__unConstrData(extended)))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(__core__fstPair(__core__unConstrData(extended)))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`))\n\n\n\t// AssetClass builtins\n\taddDataFuncs(\"__helios__assetclass\");\n\tadd(new RawFunc(\"__helios__assetclass__ADA\", `__helios__assetclass__new(__core__bData(#), __core__bData(#))`));\n\tadd(new RawFunc(\"__helios__assetclass__new\",\n\t`(mph, token_name) -> {\n\t\t__core__constrData(0, __helios__common__list_2(mph, token_name))\n\t}`));\n\tadd(new RawFunc(\"__helios__assetclass__mph\", \"__helios__common__field_0\"));\n\tadd(new RawFunc(\"__helios__assetclass__token_name\", \"__helios__common__field_1\"));\n\n\n\t// Value builtins\n\tadd(new RawFunc(\"__helios__value__serialize\", \"__helios__common__serialize\"));\n\tadd(new RawFunc(\"__helios__value__from_data\", \"__helios__common__identity\"));\n\tadd(new RawFunc(\"__helios__value__ZERO\", `__core__mapData(__core__mkNilPairData(()))`));\n\tadd(new RawFunc(\"__helios__value__lovelace\",\n\t`(i) -> {\n\t\t__helios__value__new(__helios__assetclass__ADA, i)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__new\",\n\t`(assetClass, i) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(0, __core__unIData(i)),\n\t\t\t() -> {\n\t\t\t\t__helios__value__ZERO\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t(mintingPolicyHash, tokenName) -> {\n\t\t\t\t\t__core__mapData(\n\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t\tmintingPolicyHash, \n\t\t\t\t\t\t\t\t__core__mapData(\n\t\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t\t__core__mkPairData(tokenName, i), \n\t\t\t\t\t\t\t\t\t\t__core__mkNilPairData(())\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\t__core__mkNilPairData(())\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t}(__helios__common__field_0(assetClass), __helios__common__field_1(assetClass))\n\t\t\t}\n\t\t)()\n\t}`));\n\tadd(new RawFunc(\"__helios__value__from_map\", \"__helios__common__identity\"));\n\tadd(new RawFunc(\"__helios__value__to_map\", \n\t`(self) -> {\n\t\t() -> {\n\t\t\tself\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_map_keys\",\n\t`(map) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, map)\n\t\t}(\n\t\t\t(recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap, \n\t\t\t\t\t() -> {__helios__common__list_0}, \n\t\t\t\t\t() -> {__core__mkCons(__core__fstPair(__core__headList(map)), recurse(recurse, __core__tailList(map)))}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__merge_map_keys\",\n\t`(a, b) -> {\n\t\t(aKeys) -> {\n\t\t\t(recurse) -> {\n\t\t\t\t(uniqueBKeys) -> {\n\t\t\t\t\t__helios__common__concat(aKeys, uniqueBKeys)\n\t\t\t\t}(recurse(recurse, aKeys, b))\n\t\t\t}(\n\t\t\t\t(recurse, keys, map) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tmap, \n\t\t\t\t\t\t() -> {__helios__common__list_0}, \n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(key) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__helios__common__is_in_bytearray_list(aKeys, key), \n\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, keys, __core__tailList(map))},\n\t\t\t\t\t\t\t\t\t() -> {__core__mkCons(key, recurse(recurse, keys, __core__tailList(map)))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}(__core__fstPair(__core__headList(map)))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__helios__value__get_map_keys(a))\n\t}`));\n\n\tadd(new RawFunc(\"__helios__value__get_inner_map\",\n\t`(map, mph) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, map)\n\t\t}(\n\t\t\t(recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap, \n\t\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), mph), \n\t\t\t\t\t\t\t() -> {__core__unMapData(__core__sndPair(__core__headList(map)))},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_inner_map_int\",\n\t`(map, key) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, map, key)\n\t\t}(\n\t\t\t(recurse, map, key) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap, \n\t\t\t\t\t() -> {0}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), key), \n\t\t\t\t\t\t\t() -> {__core__unIData(__core__sndPair(__core__headList(map)))}, \n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(map), key)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__add_or_subtract_inner\",\n\t`(op) -> {\n\t\t(a, b) -> {\n\t\t\t(recurse) -> {\n\t\t\t\trecurse(recurse, __helios__value__merge_map_keys(a, b), __core__mkNilPairData(()))\n\t\t\t}(\n\t\t\t\t(recurse, keys, result) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tkeys, \n\t\t\t\t\t\t() -> {result}, \n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(key, tail) -> {\n\t\t\t\t\t\t\t\t(sum) -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(sum, 0), \n\t\t\t\t\t\t\t\t\t\t() -> {tail}, \n\t\t\t\t\t\t\t\t\t\t() -> {__core__mkCons(__core__mkPairData(key, __core__iData(sum)), tail)}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(op(__helios__value__get_inner_map_int(a, key), __helios__value__get_inner_map_int(b, key)))\n\t\t\t\t\t\t\t}(__core__headList(keys), recurse(recurse, __core__tailList(keys), result))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__add_or_subtract\",\n\t`(op, a, b) -> {\n\t\t(a, b) -> {\n\t\t\t(recurse) -> {\n\t\t\t\t__core__mapData(recurse(recurse, __helios__value__merge_map_keys(a, b), __core__mkNilPairData(())))\n\t\t\t}(\n\t\t\t\t(recurse, keys, result) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tkeys, \n\t\t\t\t\t\t() -> {result}, \n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(key, tail) -> {\n\t\t\t\t\t\t\t\t(item) -> {\n\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\titem, \n\t\t\t\t\t\t\t\t\t\t() -> {tail}, \n\t\t\t\t\t\t\t\t\t\t() -> {__core__mkCons(__core__mkPairData(key, __core__mapData(item)), tail)}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}(__helios__value__add_or_subtract_inner(op)(__helios__value__get_inner_map(a, key), __helios__value__get_inner_map(b, key)))\n\t\t\t\t\t\t\t}(__core__headList(keys), recurse(recurse, __core__tailList(keys), result))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__core__unMapData(a), __core__unMapData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__value__map_quantities\",\n\t`(self, op) -> {\n\t\t(self) -> {\n\t\t\t(recurseInner) -> {\n\t\t\t\t(recurseOuter) -> {\n\t\t\t\t\t__core__mapData(recurseOuter(recurseOuter, self))\n\t\t\t\t}(\n\t\t\t\t\t(recurseOuter, outer) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\touter,\n\t\t\t\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t\t\t\t\t__core__fstPair(head), \n\t\t\t\t\t\t\t\t\t\t\t__core__mapData(recurseInner(recurseInner, __core__unMapData(__core__sndPair(head))))\n\t\t\t\t\t\t\t\t\t\t),  \n\t\t\t\t\t\t\t\t\t\trecurseOuter(recurseOuter, __core__tailList(outer))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}(__core__headList(outer))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(\n\t\t\t\t(recurseInner, inner) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tinner,\n\t\t\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t\t\t\t__core__fstPair(head),\n\t\t\t\t\t\t\t\t\t\t__core__iData(op(__core__unIData(__core__sndPair(head))))\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\trecurseInner(recurseInner, __core__tailList(inner))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}(__core__headList(inner))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__core__unMapData(self))\n\t}`));\n\tadd(new RawFunc(\"__helios__value__compare_inner\",\n\t`(comp, a, b) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, __helios__value__merge_map_keys(a, b))\n\t\t}(\n\t\t\t(recurse, keys) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tkeys, \n\t\t\t\t\t() -> {true}, \n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(key) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__common__not(comp(__helios__value__get_inner_map_int(a, key), __helios__value__get_inner_map_int(b, key))), \n\t\t\t\t\t\t\t\t() -> {false}, \n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(keys))}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList(keys))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__compare\",\n\t`(comp, a, b) -> {\n\t\t(a, b) -> {\n\t\t\t(recurse) -> {\n\t\t\t\trecurse(recurse, __helios__value__merge_map_keys(a, b))\n\t\t\t}(\n\t\t\t\t(recurse, keys) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tkeys, \n\t\t\t\t\t\t() -> {true}, \n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t(key) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__helios__common__not(\n\t\t\t\t\t\t\t\t\t\t__helios__value__compare_inner(\n\t\t\t\t\t\t\t\t\t\t\tcomp, \n\t\t\t\t\t\t\t\t\t\t\t__helios__value__get_inner_map(a, key), \n\t\t\t\t\t\t\t\t\t\t\t__helios__value__get_inner_map(b, key)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\t\t\t() -> {false}, \n\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(keys))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}(__core__headList(keys))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}(__core__unMapData(a), __core__unMapData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__value____eq\",\n\t`(a, b) -> {\n\t\t__helios__value__compare(__core__equalsInteger, a, b)\n\t}`));\n\tadd(new RawFunc(\"__helios__value____neq\",\n\t`(a, b) -> {\n\t\t__helios__common__not(__helios__value____eq(a, b))\n\t}`));\n\tadd(new RawFunc(\"__helios__value____add\",\n\t`(a, b) -> {\n\t\t__helios__value__add_or_subtract(__core__addInteger, a, b)\n\t}`));\n\tadd(new RawFunc(\"__helios__value____sub\",\n\t`(a, b) -> {\n\t\t__helios__value__add_or_subtract(__core__subtractInteger, a, b)\n\t}`));\n\tadd(new RawFunc(\"__helios__value____mul\",\n\t`(a, b) -> {\n\t\t(scale) -> {\n\t\t\t__helios__value__map_quantities(a, (qty) -> {__core__multiplyInteger(qty, scale)})\n\t\t}(__core__unIData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__value____div\",\n\t`(a, b) -> {\n\t\t(den) -> {\n\t\t\t__helios__value__map_quantities(a, (qty) -> {__core__divideInteger(qty, den)})\n\t\t}(__core__unIData(b))\n\t}`));\n\tadd(new RawFunc(\"__helios__value____geq\",\n\t`(a, b) -> {\n\t\t__helios__value__compare((a_qty, b_qty) -> {__helios__common__not(__core__lessThanInteger(a_qty, b_qty))}, a, b)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__contains\", `\n\t(self) -> {\n\t\t(value) -> {\n\t\t\t__helios__value____geq(self, value)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value____gt\",\n\t`(a, b) -> {\n\t\t__helios__bool__and(\n\t\t\t() -> {\n\t\t\t\t__helios__common__not(\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t__helios__value__is_zero(a),\n\t\t\t\t\t\t__helios__value__is_zero(b)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__value__compare(\n\t\t\t\t\t(a_qty, b_qty) -> {\n\t\t\t\t\t\t__helios__common__not(__core__lessThanEqualsInteger(a_qty, b_qty))\n\t\t\t\t\t}, \n\t\t\t\t\ta, \n\t\t\t\t\tb\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value____leq\",\n\t`(a, b) -> {\n\t\t__helios__value__compare(__core__lessThanEqualsInteger, a, b)\n\t}`));\n\tadd(new RawFunc(\"__helios__value____lt\",\n\t`(a, b) -> {\n\t\t__helios__bool__and(\n\t\t\t() -> {\n\t\t\t\t__helios__common__not(\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t__helios__value__is_zero(a),\n\t\t\t\t\t\t__helios__value__is_zero(b)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__value__compare(\n\t\t\t\t\t(a_qty, b_qty) -> {\n\t\t\t\t\t\t__core__lessThanInteger(a_qty, b_qty)\n\t\t\t\t\t}, \n\t\t\t\t\ta, \n\t\t\t\t\tb\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`));\n\tadd(new RawFunc(\"__helios__value__is_zero\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__core__nullList(__core__unMapData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get\",\n\t`(self) -> {\n\t\t(assetClass) -> {\n\t\t\t(map, mintingPolicyHash, tokenName) -> {\n\t\t\t\t(outer, inner) -> {\n\t\t\t\t\touter(outer, inner, map)\n\t\t\t\t}(\n\t\t\t\t\t(outer, inner, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap, \n\t\t\t\t\t\t\t() -> {error(\"policy not found\")}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), mintingPolicyHash), \n\t\t\t\t\t\t\t\t\t() -> {inner(inner, __core__unMapData(__core__sndPair(__core__headList(map))))}, \n\t\t\t\t\t\t\t\t\t() -> {outer(outer, inner, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}, (inner, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap, \n\t\t\t\t\t\t\t() -> {error(\"tokenName not found\")}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), tokenName),\n\t\t\t\t\t\t\t\t\t() -> {__core__sndPair(__core__headList(map))},\n\t\t\t\t\t\t\t\t\t() -> {inner(inner, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(__core__unMapData(self), __helios__common__field_0(assetClass), __helios__common__field_1(assetClass))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_safe\",\n\t`(self) -> {\n\t\t(assetClass) -> {\n\t\t\t(map, mintingPolicyHash, tokenName) -> {\n\t\t\t\t(outer, inner) -> {\n\t\t\t\t\touter(outer, inner, map)\n\t\t\t\t}(\n\t\t\t\t\t(outer, inner, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap, \n\t\t\t\t\t\t\t() -> {__core__iData(0)}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), mintingPolicyHash), \n\t\t\t\t\t\t\t\t\t() -> {inner(inner, __core__unMapData(__core__sndPair(__core__headList(map))))}, \n\t\t\t\t\t\t\t\t\t() -> {outer(outer, inner, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}, (inner, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap, \n\t\t\t\t\t\t\t() -> {__core__iData(0)}, \n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), tokenName),\n\t\t\t\t\t\t\t\t\t() -> {__core__sndPair(__core__headList(map))},\n\t\t\t\t\t\t\t\t\t() -> {inner(inner, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(__core__unMapData(self), __helios__common__field_0(assetClass), __helios__common__field_1(assetClass))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_lovelace\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__value__get_safe(self)(__helios__assetclass__ADA)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_assets\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__map__filter(self)(\n\t\t\t\t(key, _) -> {\n\t\t\t\t\t__helios__common__not(__core__equalsByteString(__core__unBData(key), #))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__get_policy\", \n\t`(self) -> {\n\t\t(mph) -> {\n\t\t\t(map) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, map)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap,\n\t\t\t\t\t\t\t() -> {error(\"policy not found\")},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), mph),\n\t\t\t\t\t\t\t\t\t() -> {__core__sndPair(__core__headList(map))},\n\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(__core__unMapData(self))\n\t\t} \n\t}`));\n\tadd(new RawFunc(\"__helios__value__contains_policy\",\n\t`(self) -> {\n\t\t(mph) -> {\n\t\t\t(map) -> {\n\t\t\t\t(recurse) -> {\n\t\t\t\t\trecurse(recurse, map)\n\t\t\t\t}(\n\t\t\t\t\t(recurse, map) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tmap,\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList(map)), mph),\n\t\t\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList(map))}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(__core__unMapData(self))\n\t\t}\n\t}`));\n\tadd(new RawFunc(\"__helios__value__show\",\n\t`(self) -> {\n\t\t() -> {\n\t\t\t__helios__map__fold(self)(\n\t\t\t\t(prev, mph, tokens) -> {\n\t\t\t\t\t__helios__map__fold(tokens)(\n\t\t\t\t\t\t(prev, token_name, qty) -> {\n\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\tprev,\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__helios__bytearray____eq(mph, __core__bData(#)),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t__helios__common__stringData(\"lovelace: \"),\n\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__show(qty)(),\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__common__stringData(\"\\\\n\")\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t__helios__bytearray__show(mph)(),\n\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__common__stringData(\".\"),\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bytearray__show(token_name)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__common__stringData(\": \"),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__show(qty)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__common__stringData(\"\\\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprev\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t__helios__common__stringData(\"\")\n\t\t\t)\n\t\t}\n\t}`))\n\n\treturn db;\n}\n\n/**\n * @param {IR} ir \n * @returns {IR}\n * @package\n */\nfunction wrapWithRawFunctions(ir) {\n\tlet db = makeRawFunctions();\n\n\t// notify statistics of existence of builtin in correct order\n\tif (onNotifyRawUsage !== null) {\n\t\tfor (let [name, _] of db) {\n\t\t\tonNotifyRawUsage(name, 0);\n\t\t}\n\t}\n\n\tlet re = new RegExp(\"__helios[a-zA-Z0-9_]*\", \"g\");\n\n\tlet [src, _] = ir.generateSource();\n\n\t//console.log(src);\n\n\tlet matches = src.match(re);\n\n\tlet map = new Map();\n\n\tif (matches !== null) {\n\t\tfor (let match of matches) {\n\t\t\tif (!map.has(match)) {\n\t\t\t\tif (!db.has(match)) {\n\t\t\t\t\tthrow new Error(`builtin ${match} not found`);\n\t\t\t\t}\n\n\t\t\t\tlet builtin = assertDefined(db.get(match));\n\n\t\t\t\tbuiltin.load(db, map);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn IR.wrapWithDefinitions(ir, map);\n}\n\n\n\n/////////////////////////////////\n// Section 20: IR Context objects\n/////////////////////////////////\n\n/**\n * Scope for IR names.\n * Works like a stack of named values from which a Debruijn index can be derived\n * @package\n */\nclass IRScope {\n\t#parent;\n\t/** variable name (can be empty if no usable variable defined at this level) */\n\t#variable;\n\n\t/**\n\t * @param {?IRScope} parent \n\t * @param {?IRVariable} variable\n\t */\n\tconstructor(parent, variable) {\n\t\tthis.#parent = parent;\n\t\tthis.#variable = variable;\n\t}\n\n\t/**\n\t * Calculates the Debruijn index of a named value. Internal method\n\t * @param {Word | IRVariable} name \n\t * @param {number} index \n\t * @returns {[number, IRVariable]}\n\t */\n\tgetInternal(name, index) {\n\t\tif (this.#variable !== null && (name instanceof Word && this.#variable.toString() == name.toString()) || (name instanceof IRVariable && this.#variable == name)) {\n\t\t\treturn [index, this.#variable];\n\t\t} else if (this.#parent === null) {\n\t\t\tthrow name.referenceError(`variable ${name.toString()} not found`);\n\t\t} else {\n\t\t\treturn this.#parent.getInternal(name, index + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the Debruijn index.\n\t * @param {Word | IRVariable} name \n\t * @returns {[number, IRVariable]}\n\t */\n\tget(name) {\n\t\t// one-based\n\t\treturn this.getInternal(name, 1);\n\t}\n\n\t/**\n\t * Checks if a named builtin exists\n\t * @param {string} name \n\t * @param {boolean} strict - if true then throws an error if builtin doesn't exist\n\t * @returns {boolean}\n\t */\n\tstatic isBuiltin(name, strict = false) {\n\t\tif (name.startsWith(\"__core\")) {\n\t\t\tif (strict) {\n\t\t\t\tvoid this.findBuiltin(name); // assert that builtin exists\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns index of a named builtin\n\t * Throws an error if builtin doesn't exist\n\t * @param {string} name \n\t * @returns \n\t */\n\tstatic findBuiltin(name) {\n\t\tlet i = UPLC_BUILTINS.findIndex(info => { return \"__core__\" + info.name == name });\n\t\tassert(i != -1, `${name} is not a real builtin`);\n\t\treturn i;\n\t}\n}\n\n/**\n * IR class that represents function arguments\n * @package\n */\nclass IRVariable extends Token {\n\t#name;\n\n\t/**\n\t * @param {Word} name\n\t */\n\tconstructor(name) {\n\t\tsuper(name.site);\n\t\tthis.#name = name;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#name.toString();\n\t}\n\n\ttoString() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars \n\t * @returns {IRVariable}\n\t */\n\tcopy(newVars) {\n\t\tconst newVar = new IRVariable(this.#name);\n\n\t\tnewVars.set(this, newVar);\n\n\t\treturn newVar;\n\t}\n}\n\n/**\n * @package\n */\nclass IRValue {\n\tconstructor() {\n\t}\n\n\t/**\n\t * @param {IRValue[]} args \n\t * @returns {?IRValue}\n\t */\n\tcall(args) {\n\t\tthrow new Error(\"not a function\");\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget value() {\n\t\tthrow new Error(\"not a literal value\");\n\t}\n}\n\n/**\n * @package\n */\nclass IRFuncValue extends IRValue {\n\t#callback;\n\n\t/**\n\t * @param {(args: IRValue[]) => ?IRValue} callback\n\t */\n\tconstructor(callback) {\n\t\tsuper();\n\t\tthis.#callback = callback;\n\t}\n\n\t/**\n\t * @param {IRValue[]} args \n\t * @returns {?IRValue}\n\t */\n\tcall(args) {\n\t\treturn this.#callback(args);\n\t}\n}\n\n/**\n * @package\n */\nclass IRLiteralValue extends IRValue {\n\t#value;\n\n\t/**\n\t * @param {UplcValue} value \n\t */\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget value() {\n\t\treturn this.#value;\n\t}\n}\n\n/**\n * @package\n */\nclass IRDeferredValue extends IRValue {\n    #deferred;\n\n    /**\n     * @type {undefined | null | IRValue}\n     */\n    #cache;\n\n    /**\n     * @param {() => ?IRValue} deferred\n     */\n    constructor(deferred) {\n        super();\n        this.#deferred = deferred;\n        this.#cache = undefined;\n    }\n    /**\n     * @param {IRValue[]} args \n     * @returns {?IRValue}\n     */\n    call(args) {\n        if (this.#cache === undefined) {\n            this.#cache = this.#deferred();\n        }\n        \n        if (this.#cache != null) {\n            return this.#cache.call(args);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @type {UplcValue}\n     */\n    get value() {\n        if (this.#cache === undefined) {\n            this.#cache = this.#deferred();\n        }\n        \n        if (this.#cache != null) {\n            return this.#cache.value;\n        } else {\n            throw new Error(\"not a value\");\n        }\n    }\n\n}\n\n/**\n * @package\n */\nclass IRCallStack {\n\t#throwRTErrors;\n\t#parent;\n\t#variable;\n\t#value;\n\n\t/**\n\t * @param {boolean} throwRTErrors\n\t * @param {?IRCallStack} parent \n\t * @param {?IRVariable} variable \n\t * @param {?IRValue} value \n\t */\n\tconstructor(throwRTErrors, parent = null, variable = null, value = null) {\n\t\tthis.#throwRTErrors = throwRTErrors;\n\t\tthis.#parent = parent;\n\t\tthis.#variable = variable;\n\t\tthis.#value = value;\n\t}\n\n\tget throwRTErrors() {\n\t\treturn this.#throwRTErrors;\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @returns {?IRValue}\n\t */\n\tget(variable) {\n\t\tif (this.#variable !== null && this.#variable === variable) {\n\t\t\treturn this.#value;\n\t\t} else if (this.#parent !== null) {\n\t\t\treturn this.#parent.get(variable);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @param {IRValue} value \n\t * @returns {IRCallStack}\n\t */\n\tset(variable, value) {\n\t\treturn new IRCallStack(this.#throwRTErrors, this, variable, value);\n\t}\n}\n\n\n/////////////////////////////\n// Section 21: IR AST objects\n/////////////////////////////\n\n/**\n * @typedef {Map<IRVariable, IRLiteralExpr>} IRLiteralRegistry\n */\n\nclass IRNameExprRegistry {\n\t/**\n\t * @type {Map<IRVariable, Set<IRNameExpr>>}\n\t */\n\t#map;\n\n\t/**\n\t * @type {Set<IRVariable>}\n\t */\n\t#maybeInsideLoop;\n\n\t/**\n\t * Reset whenever recursion is detected.\n\t * @type {Set<IRVariable>}\n\t */\n\t#variables;\n\n\t/**\n\t * @param {Map<IRVariable, Set<IRNameExpr>>} map\n\t */\n\tconstructor(map = new Map(), maybeInsideLoop = new Set()) {\n\t\tthis.#map = map;\n\t\tthis.#maybeInsideLoop = maybeInsideLoop;\n\t\tthis.#variables = new Set();\n\t}\n\n\t/**\n\t * @param {IRNameExpr} nameExpr \n\t */\n\tregister(nameExpr) {\n\t\tif (!nameExpr.isCore()) {\n\t\t\tconst variable = nameExpr.variable;\n\n\t\t\tif (!this.#map.has(variable)) {\n\t\t\t\tthis.#map.set(variable, new Set([nameExpr]));\n\t\t\t} else {\n\t\t\t\tassertDefined(this.#map.get(variable)).add(nameExpr);\n\t\t\t}\n\n\t\t\t// add another reference in case of recursion\n\t\t\tif (!this.#variables.has(variable)) {\n\t\t\t\tthis.#maybeInsideLoop.add(variable);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Used to prevent inlining upon recursion\n\t * @param {IRVariable} variable\n\t */\n\tregisterVariable(variable) {\n\t\tthis.#variables.add(variable)\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @returns {number}\n\t */\n\tcountReferences(variable) {\n\t\tconst set = this.#map.get(variable);\n\n\t\tif (set == undefined) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn set.size;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @returns {boolean}\n\t */\n\tmaybeInsideLoop(variable) {\n\t\treturn this.#maybeInsideLoop.has(variable);\n\t}\n\n\t/**\n\t * Called whenever recursion is detected\n\t * @returns {IRNameExprRegistry}\n\t */\n\tresetVariables() {\n\t\treturn new IRNameExprRegistry(this.#map, this.#maybeInsideLoop);\n\t}\n}\n\nclass IRExprRegistry {\n\t#nameExprs;\n\n\t/**\n\t * @type {Map<IRVariable, IRExpr>}\n\t */\n\t#inline;\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs \n\t */\n\tconstructor(nameExprs) {\n\t\tthis.#nameExprs = nameExprs;\n\t\tthis.#inline = new Map();\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @returns {number}\n\t */\n\tcountReferences(variable) {\n\t\treturn this.#nameExprs.countReferences(variable);\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @returns {boolean}\n\t */\n\tmaybeInsideLoop(variable) {\n\t\treturn this.#nameExprs.maybeInsideLoop(variable);\n\t}\n\n\t/**\n\t * @param {IRVariable} variable\n\t * @returns {boolean}\n\t */\n\tisInlineable(variable) {\n\t\treturn this.#inline.has(variable);\n\t}\n\n\t/**\n\t * @param {IRVariable} variable\n\t * @returns {IRExpr}\n\t */\n\tgetInlineable(variable) {\n\t\treturn assertDefined(this.#inline.get(variable)).copy(new Map());\n\t}\n\n\t/**\n\t * @param {IRVariable} variable \n\t * @param {IRExpr} expr \n\t */\n\taddInlineable(variable, expr) {\n\t\tthis.#inline.set(variable, expr);\n\t}\n}\n\n/**\n * Base class of all Intermediate Representation expressions\n * @package\n */\nclass IRExpr extends Token {\n\t/**\n\t * @param {Site} site \n\t */\n\tconstructor(site) {\n\t\tsuper(site);\n\t}\n\n\t/**\n\t * For pretty printing the IR\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Link IRNameExprs to variables\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Turns all IRConstExpr istances into IRLiteralExpr instances\n\t * @param {IRCallStack} stack \n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Evaluates an expression to something (hopefully) literal\n\t * Returns null if it the result would be worse than the current expression\n\t * Doesn't return an IRLiteral because the resulting expression might still be an improvement, even if it isn't a literal\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Used to inline literals and to evaluate IRCoreCallExpr instances with only literal args.\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Used before simplifyTopology\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Used during inlining/expansion to make sure multiple inlines of IRNameExpr don't interfere when setting the Debruijn index\n\t * @param {Map<IRVariable, IRVariable>} newVars\n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Intermediate Representation variable reference expression\n * @package\n */\nclass IRNameExpr extends IRExpr {\n\t#name;\n\n\t/**\n\t * @type {?number} - cached debruijn index \n\t */\n\t#index;\n\n\t/**\n\t * @type {?IRVariable} - cached variable\n\t */\n\t#variable;\n\n\t/**\n\t * @type {?IRValue} - cached eval result (reused when eval is called within simplifyLiterals)\n\t */\n\t#value;\n\n\t/**\n\t * @param {Word} name \n\t * @param {?IRVariable} variable\n\t * @param {?IRValue} value\n\t */\n\tconstructor(name, variable = null, value = null) {\n\t\tsuper(name.site);\n\t\tassert(name.toString() != \"_\");\n\t\tassert(!name.toString().startsWith(\"undefined\"));\n\t\tthis.#name = name;\n\t\tthis.#index = null;\n\t\tthis.#variable = variable;\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#name.toString();\n\t}\n\n\t/**\n\t * isVariable() should be used to check if a IRNameExpr.variable is equal to a IRVariable (includes special handling of \"__core*\")\n\t * @type {IRVariable}\n\t */\n\tget variable() {\n\t\tif (this.#variable === null) {\n\t\t\tthrow new Error(`variable should be set (name: ${this.name})`);\n\t\t} else {\n\t\t\treturn this.#variable;\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @returns {boolean}\n\t */\n\tisCore() {\n\t\tconst name = this.name;\n\n\t\treturn name.startsWith(\"__core\");\n\t}\n\n\t/**\n\t * @param {IRVariable} ref \n\t * @returns {boolean}\n\t */\n\tisVariable(ref) {\n\t\tif (this.isCore()) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.variable === ref;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\treturn this.#name.toString();\n\t}\n\n\t/**\n\t * @param {IRScope} scope\n\t */\n\tresolveNames(scope) {\n\t\tif (!this.name.startsWith(\"__core\")) {\n\t\t\tif (this.#variable == null || this.name.startsWith(\"__PARAM\")) {\n\t\t\t\t[this.#index, this.#variable] = scope.get(this.#name);\n\t\t\t} else {\n\t\t\t\t[this.#index, this.#variable] = scope.get(this.#variable);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\tif (this.#variable != null) {\n\t\t\tthis.#value = stack.get(this.#variable);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\tif (this.isCore()) {\n\t\t\treturn new IRFuncValue((args) => {\n\t\t\t\treturn IRCoreCallExpr.evalValues(this.site, stack.throwRTErrors, this.#name.value.slice(\"__core__\".length), args);\n\t\t\t});\n\t\t} else if (this.#variable === null) {\n\t\t\tthrow new Error(\"variable should be set\");\n\t\t} else {\n\t\t\t// prefer result from stack, and use cached result as backup\n\t\t\tconst result = stack.get(this.#variable);\n\n\t\t\tif (result == null) {\n\t\t\t\treturn this.#value;\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\tif (this.#variable !== null && literals.has(this.#variable)) {\n\t\t\treturn assertDefined(literals.get(this.#variable));\n\t\t} else if (this.#value instanceof IRLiteralExpr) {\n\t\t\treturn this.#value;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tnameExprs.register(this);\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars\n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\tlet v = this.#variable;\n\n\t\tif (v != null) {\n\t\t\tconst maybeNewVar = newVars.get(v);\n\n\t\t\tif (maybeNewVar != undefined) {\n\t\t\t\tv = maybeNewVar;\n\t\t\t}\n\t\t}\n\n\t\treturn new IRNameExpr(this.#name, v, this.#value);\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tif (!this.isCore() && registry.isInlineable(this.variable)) {\n\t\t\treturn registry.getInlineable(this.variable);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/**\n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\tif (this.name.startsWith(\"__core\")) {\n\t\t\treturn IRCoreCallExpr.newUplcBuiltin(this.site, this.name);\n\t\t} else if (this.#index === null) {\n\t\t\t// use a dummy index (for size calculation)\n\t\t\treturn new UplcVariable(\n\t\t\t\tthis.site,\n\t\t\t\tnew UplcInt(this.site, BigInt(0), false),\n\t\t\t);\n\t\t} else {\n\t\t\treturn new UplcVariable(\n\t\t\t\tthis.site,\n\t\t\t\tnew UplcInt(this.site, BigInt(this.#index), false),\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * IR wrapper for UplcValues, representing literals\n * @package\n */\nclass IRLiteralExpr extends IRExpr {\n\t/**\n\t * @type {UplcValue}\n\t */\n\t#value;\n\n\t/**\n\t * @param {UplcValue} value \n\t */\n\tconstructor(value) {\n\t\tsuper(value.site);\n\n\t\tthis.#value = value;\n\t}\n\n\t/**\n\t * @type {UplcValue}\n\t */\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\treturn this.#value.toString();\n\t}\n\n\t/**\n\t * Linking doesn't do anything for literals\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t */\n\tevalConstants(stack) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\treturn new IRLiteralValue(this.value);\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars\n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\treturn new IRLiteralExpr(this.#value);\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {UplcConst}\n\t */\n\ttoUplc() {\n\t\treturn new UplcConst(this.#value);\n\t}\n}\n\n/**\n * The IRExpr simplify methods aren't implemented because any IRConstExpr instances should've been eliminated during evalConstants.\n * @package\n */\nclass IRConstExpr extends IRExpr {\n\t#expr;\n\n\t/**\n\t * @param {Site} site \n\t * @param {IRExpr} expr \n\t */\n\tconstructor(site, expr) {\n\t\tsuper(site);\n\t\tthis.#expr = expr;\n\t}\n\n\ttoString(indent = \"\") {\n\t\treturn `const(${this.#expr.toString(indent)})`;\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t\tthis.#expr.resolveNames(scope);\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\tconst result = this.#expr.eval(stack);\n\n\t\tif (result != null) {\n\t\t\treturn new IRLiteralExpr(result.value);\n\t\t} else {\n\t\t\tthrow new Error(\"unable to evaluate const\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\treturn this.#expr.eval(stack);\n\t}\n}\n\n/**\n * IR function expression with some args, that act as the header, and a body expression\n * @package\n */\nclass IRFuncExpr extends IRExpr {\n\t#args;\n\t#body;\n\n\t/**\n\t * @param {Site} site \n\t * @param {IRVariable[]} args \n\t * @param {IRExpr} body \n\t */\n\tconstructor(site, args, body) {\n\t\tsuper(site);\n\t\tthis.#args = args;\n\t\tthis.#body = assertDefined(body);\n\t}\n\n\tget args() {\n\t\treturn this.#args.slice();\n\t}\n\n\tget body() {\n\t\treturn this.#body;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\thasOptArgs() {\n\t\tconst b = this.#args.some(a => a.name.startsWith(\"__useopt__\"));\n\n\t\tif (b) {\n\t\t\treturn b;\n\t\t}\n\n\t\tif (this.#body instanceof IRFuncExpr) {\n\t\t\treturn this.#body.hasOptArgs();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\tlet innerIndent = (this.#body instanceof IRUserCallExpr && this.#body.argExprs.length == 1 && this.#body.fnExpr instanceof IRFuncExpr && this.#body.fnExpr.args[0].name.startsWith(\"__\")) ? indent : indent + TAB;\n\n\t\tlet s = \"(\" + this.#args.map(n => n.toString()).join(\", \") + \") -> {\\n\" + innerIndent;\n\t\ts += this.#body.toString(innerIndent);\n\t\ts += \"\\n\" + indent + \"}\";\n\n\t\treturn s;\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t\t// in the zero-arg case no Debruijn indices need to be added because we use Delay/Force\n\n\t\tfor (let arg of this.#args) {\n\t\t\tscope = new IRScope(scope, arg);\n\t\t}\n\n\t\tthis.#body.resolveNames(scope);\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t */\n\tevalConstants(stack) {\n\t\treturn new IRFuncExpr(this.site, this.args, this.#body.evalConstants(stack));\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\treturn new IRFuncValue((args) => {\n\t\t\tif (args.length != this.#args.length) {\n\t\t\t\tthrow this.site.syntaxError(`expected ${this.#args.length} arg(s), got ${args.length} arg(s)`);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tstack = stack.set(this.#args[i], args[i]);\n\t\t\t}\n\n\t\t\treturn this.#body.eval(stack);\n\t\t});\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals \n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\treturn new IRFuncExpr(this.site, this.args, this.#body.simplifyLiterals(literals));\n\t}\n\t\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tnameExprs = nameExprs.resetVariables();\n\n\t\tthis.#args.forEach(a => nameExprs.registerVariable(a));\n\n\t\tthis.#body.registerNameExprs(nameExprs);\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars\n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\treturn new IRFuncExpr(this.site, this.args.map(oldArg => oldArg.copy(newVars)), this.#body.copy(newVars));\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\treturn new IRFuncExpr(this.site, this.args, this.#body.simplifyTopology(registry));\n\t}\n\n\t/** \n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\tlet term = this.#body.toUplc();\n\n\t\tif (this.#args.length == 0) {\n\t\t\t// a zero-arg func is turned into a UplcDelay term\n\t\t\tterm = new UplcDelay(this.site, term);\n\t\t} else {\n\t\t\tfor (let i = this.#args.length - 1; i >= 0; i--) {\n\t\t\t\tterm = new UplcLambda(this.site, term, this.#args[i].toString());\n\t\t\t}\n\t\t}\n\n\t\treturn term;\n\t}\n}\n\n/**\n * Base class of IRUserCallExpr and IRCoreCallExpr\n * @package\n */\nclass IRCallExpr extends IRExpr {\n\t#argExprs;\n\t#parensSite;\n\n\t/**\n\t * @param {Site} site\n\t * @param {IRExpr[]} argExprs \n\t * @param {Site} parensSite \n\t */\n\tconstructor(site, argExprs, parensSite) {\n\t\tsuper(site);\n\t\tthis.#argExprs = argExprs;\n\t\tthis.#parensSite = parensSite;\n\t\t\n\t}\n\n\tget argExprs() {\n\t\treturn this.#argExprs.slice();\n\t}\n\n\tget parensSite() {\n\t\treturn this.#parensSite;\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\targsToString(indent = \"\") {\n\t\treturn this.#argExprs.map(argExpr => argExpr.toString(indent)).join(\", \")\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNamesInArgs(scope) {\n\t\tfor (let argExpr of this.#argExprs) {\n\t\t\targExpr.resolveNames(scope);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t * @returns {IRExpr[]}\n\t */\n\tevalConstantsInArgs(stack) {\n\t\treturn this.#argExprs.map(a => a.evalConstants(stack));\n\t}\n\n\t/** \n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue[]} \n\t */\n\tevalArgs(stack) {\n\t\t/**\n\t\t * @type {IRValue[]}\n\t\t */\n\t\tlet args = [];\n\n\t\tfor (let argExpr of this.argExprs) {\n\t\t\tlet argVal = argExpr.eval(stack);\n\t\t\tif (argVal !== null) {\n\t\t\t\targs.push(argVal);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr[]}\n\t */\n\tsimplifyLiteralsInArgs(literals) {\n\t\treturn this.#argExprs.map(a => a.simplifyLiterals(literals));\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs \n\t */\n\tregisterNameExprsInArgs(nameExprs) {\n\t\tthis.#argExprs.forEach(a => a.registerNameExprs(nameExprs));\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr[]}\n\t */\n\tsimplifyTopologyInArgs(registry) {\n\t\treturn this.#argExprs.map(a => a.simplifyTopology(registry));\n\t}\n\n\t/**\n\t * @param {UplcTerm} term\n\t * @returns {UplcTerm}\n\t */\n\ttoUplcCall(term) {\n\t\tif (this.#argExprs.length == 0) {\n\t\t\t// assuming underlying zero-arg function has been converted into a UplcDelay term\n\t\t\tterm = new UplcForce(this.site, term);\n\t\t} else {\n\t\t\tfor (let argExpr of this.#argExprs) {\n\t\t\t\tterm = new UplcCall(this.site, term, argExpr.toUplc());\n\t\t\t}\n\t\t}\n\n\t\treturn term;\n\t}\n}\n\n/**\n * IR function call of core functions\n * @package\n */\nclass IRCoreCallExpr extends IRCallExpr {\n\t#name;\n\n\t/**\n\t * @param {Word} name \n\t * @param {IRExpr[]} argExprs \n\t * @param {Site} parensSite \n\t */\n\tconstructor(name, argExprs, parensSite) {\n\t\tsuper(name.site, argExprs, parensSite);\n\t\tassert(name.value !== \"\" && name.value !== \"error\");\n\t\tthis.#name = name;\n\n\t\tassert(this.builtinName !== \"\", name.value);\n\t}\n\n\tget builtinName() {\n\t\treturn this.#name.toString().slice(8);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisCast() {\n\t\tlet name = this.builtinName;\n\n\t\treturn name == \"iData\" || name == \"bData\" || name == \"unIData\" || name == \"unBData\" || name == \"mapData\" || name == \"unMapData\" || name == \"listData\" || name == \"unListData\";\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\tif (this.builtinName == \"ifThenElse\") {\n\t\t\treturn `${this.#name.toString()}(\\n${indent}${TAB}${this.argExprs[0].toString(indent + TAB)},\\n${indent}${TAB}${this.argExprs[1].toString(indent + TAB)},\\n${indent}${TAB}${this.argExprs[2].toString(indent+TAB)}\\n${indent})`;\n\t\t} else {\n\t\t\treturn `${this.#name.toString()}(${this.argsToString(indent)})`;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t\tthis.resolveNamesInArgs(scope);\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {boolean} throwRTErrors\n\t * @param {string} builtinName\n\t * @param {IRValue[]} args \n\t * @returns {?IRValue}\n\t */\n\tstatic evalValues(site, throwRTErrors, builtinName, args) {\n\t\tif (builtinName == \"ifThenElse\") {\n\t\t\tlet cond = args[0].value;\n\t\t\tif (cond !== null && cond instanceof UplcBool) {\n\t\t\t\tif (cond.bool) {\n\t\t\t\t\treturn args[1];\n\t\t\t\t} else {\n\t\t\t\t\treturn args[2];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (builtinName == \"chooseList\") {\n\t\t\tconst lst = args[0].value;\n\n\t\t\tif (lst !== null && lst instanceof UplcList) {\n\t\t\t\tif (lst.length == 0) {\n\t\t\t\t\treturn args[1];\n\t\t\t\t} else {\n\t\t\t\t\treturn args[2];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (builtinName == \"trace\") {\n\t\t\treturn args[1];\n\t\t} else {\n\t\t\t/**\n\t\t\t * @type {UplcValue[]}\n\t\t\t */\n\t\t\tlet argValues = [];\n\n\t\t\tfor (let arg of args) {\n\t\t\t\tif (arg.value !== null) {\n\t\t\t\t\targValues.push(arg.value);\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tlet result = UplcBuiltin.evalStatic(new Word(Site.dummy(), builtinName), argValues);\n\n\t\t\t\treturn new IRLiteralValue(result);\n\t\t\t} catch(e) {\n\t\t\t\t// runtime errors like division by zero are allowed if throwRTErrors is false\n\t\t\t\tif (e instanceof RuntimeError) {\n\t\t\t\t\tif (!throwRTErrors) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e.addTraceSite(site);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\treturn new IRCoreCallExpr(this.#name, this.evalConstantsInArgs(stack), this.parensSite);\n\t}\n\t\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\tlet args = this.evalArgs(stack);\n\n\t\tif (args !== null) {\n\t\t\treturn IRCoreCallExpr.evalValues(this.site, stack.throwRTErrors, this.builtinName, args);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\tconst args = this.simplifyLiteralsInArgs(literals);\n\n\t\tif (args.length > 0 && args.every(a => a instanceof IRLiteralExpr)) {\n\t\t\ttry {\n\t\t\t\tconst res = IRCoreCallExpr.evalValues(\n\t\t\t\t\tthis.site,\n\t\t\t\t\tfalse,\n\t\t\t\t\tthis.builtinName,\n\t\t\t\t\targs.map(a => new IRLiteralValue(assertClass(a, IRLiteralExpr).value))\n\t\t\t\t);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn new IRLiteralExpr(res.value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t}\n\t\t}\n\n\t\tswitch(this.builtinName) {\n\t\t\tcase \"addInteger\": {\n\t\t\t\t\t// check if first or second arg evaluates to 0\n\t\t\t\t\tconst [a, b] = args;\n\n\t\t\t\t\tif (a instanceof IRLiteralExpr && a.value instanceof UplcInt && a.value.int == 0n) {\n\t\t\t\t\t\treturn b;\n\t\t\t\t\t} else if (b instanceof IRLiteralExpr && b.value instanceof UplcInt && b.value.int == 0n) {\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"appendByteString\": {\n\t\t\t\t\t// check if either 1st or 2nd arg is the empty bytearray\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (a instanceof IRLiteralExpr && a.value instanceof UplcByteArray && a.value.bytes.length == 0) {\n\t\t\t\t\t\treturn b;\n\t\t\t\t\t} else if (b instanceof IRLiteralExpr && b.value instanceof UplcByteArray && b.value.bytes.length == 0) {\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"appendString\": {\n\t\t\t\t\t// check if either 1st or 2nd arg is the empty string\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (a instanceof IRLiteralExpr && a.value instanceof UplcString && a.value.string.length == 0) {\n\t\t\t\t\t\treturn b;\n\t\t\t\t\t} else if (b instanceof IRLiteralExpr && b.value instanceof UplcString && b.value.string.length == 0) {\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"divideInteger\": {\n\t\t\t\t\t// check if second arg is 1\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (b instanceof IRLiteralExpr && b.value instanceof UplcInt) {\n\t\t\t\t\t\tif (b.value.int == 1n) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t} else if (b.value.int == 0n) {\n\t\t\t\t\t\t\treturn new IRCoreCallExpr(this.#name, args, this.parensSite);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ifThenElse\": {\n\t\t\t\t\tconst [cond, a, b] = args;\n\n\t\t\t\t\tif (cond instanceof IRLiteralExpr && cond.value instanceof UplcBool) {\n\t\t\t\t\t\t// if the condition is a literal, one the branches can be returned\n\t\t\t\t\t\tif (cond.value.bool) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn b;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (a instanceof IRLiteralExpr && a.value instanceof UplcBool && b instanceof IRLiteralExpr && b.value instanceof UplcBool) {\n\t\t\t\t\t\tif (a.value.bool && !b.value.bool) {\n\t\t\t\t\t\t\treturn cond;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!a.value.bool && \n\t\t\t\t\t\t\tb.value.bool && \n\t\t\t\t\t\t\tcond instanceof IRUserCallExpr && \n\t\t\t\t\t\t\tcond.fnExpr instanceof IRNameExpr && \n\t\t\t\t\t\t\tcond.fnExpr.name === \"__helios__common__not\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn cond.argExprs[0];\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"modInteger\": {\n\t\t\t\t\t// check if second arg is 1\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (b instanceof IRLiteralExpr && b.value instanceof UplcInt && b.value.int == 1n) {\n\t\t\t\t\t\treturn new IRLiteralExpr(new UplcInt(this.site, 0n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"multiplyInteger\": {\n\t\t\t\t\t// check if first arg is 0 or 1\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (a instanceof IRLiteralExpr && a.value instanceof UplcInt) {\n\t\t\t\t\t\tif (a.value.int == 0n) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t} else if (a.value.int == 1n) {\n\t\t\t\t\t\t\treturn b;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (b instanceof IRLiteralExpr && b.value instanceof UplcInt) {\n\t\t\t\t\t\tif (b.value.int == 0n) {\n\t\t\t\t\t\t\treturn b;\n\t\t\t\t\t\t} else if (b.value.int == 1n) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"subtractInteger\": {\n\t\t\t\t\t// check if second arg evaluates to 0\n\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\tif (b instanceof IRLiteralExpr && b.value instanceof UplcInt && b.value.int == 0n) {\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (args.every(a => a instanceof IRLiteralExpr)) {\n\t\t\treturn new IRLiteralExpr(\n\t\t\t\tUplcBuiltin.evalStatic(\n\t\t\t\t\tnew Word(this.#name.site, this.builtinName),\n\t\t\t\t\targs.map(a => assertClass(a, IRLiteralExpr).value)\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\treturn new IRCoreCallExpr(this.#name, args, this.parensSite);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tthis.registerNameExprsInArgs(nameExprs);\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars\n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\treturn new IRCoreCallExpr(this.#name, this.argExprs.map(a => a.copy(newVars)), this.parensSite);\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tconst args = this.simplifyTopologyInArgs(registry);\n\n\t\tswitch(this.builtinName) {\n\t\t\tcase \"encodeUtf8\":\n\t\t\t\t// we can't eliminate a call to decodeUtf8, as it might throw some errors\n\t\t\t\tbreak;\n\t\t\tcase \"decodeUtf8\": {\n\t\t\t\t// check if arg is a call to encodeUtf8\n\t\t\t\tconst [arg] = args;\n\t\t\t\tif (arg instanceof IRCoreCallExpr && arg.builtinName == \"encodeUtf8\") {\n\t\t\t\t\treturn arg.argExprs[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\t\t\n\t\t\tcase \"equalsData\": {\n\t\t\t\tconst [a, b] = args;\n\n\t\t\t\tif (a instanceof IRCoreCallExpr && b instanceof IRCoreCallExpr) {\n\t\t\t\t\tif (a.builtinName === \"iData\" && b.builtinName === \"iData\") {\n\t\t\t\t\t\treturn new IRCoreCallExpr(new Word(this.site, \"__core__equalsInteger\"), [a.argExprs[0], b.argExprs[0]], this.parensSite);\t\n\t\t\t\t\t} else if (a.builtinName === \"bData\" && b.builtinName === \"bData\") {\n\t\t\t\t\t\treturn new IRCoreCallExpr(new Word(this.site, \"__core__equalsByteString\"), [a.argExprs[0], b.argExprs[0]], this.parensSite);\t\n\t\t\t\t\t} else if (a.builtinName === \"decodeUtf8\" && b.builtinName === \"decodeUtf8\") {\n\t\t\t\t\t\treturn new IRCoreCallExpr(new Word(this.site, \"__core__equalsString\"), [a.argExprs[0], b.argExprs[0]], this.parensSite);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"ifThenElse\": {\n\t\t\t\tconst [cond, a, b] = args;\n\n\t\t\t\tif (cond instanceof IRCoreCallExpr && cond.builtinName === \"nullList\") {\n\t\t\t\t\treturn new IRCoreCallExpr(new Word(this.site, \"__core__chooseList\"), [cond.argExprs[0], a, b], this.parensSite);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"trace\":\n\t\t\t\treturn args[1];\n\t\t\tcase \"unIData\": {\n\t\t\t\t// check if arg is a call to iData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"iData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"iData\": {\n\t\t\t\t// check if arg is a call to unIData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"unIData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"unBData\": {\n\t\t\t\t// check if arg is a call to bData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"bData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"bData\": {\n\t\t\t\t// check if arg is a call to unBData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"unBData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"unMapData\": {\n\t\t\t\t// check if arg is call to mapData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"mapData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"mapData\": {\n\t\t\t\t// check if arg is call to unMapData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"unMapData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"listData\": {\n\t\t\t\t// check if arg is call to unListData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"unListData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"unListData\": {\n\t\t\t\t// check if arg is call to listData\n\t\t\t\tconst a = args[0];\n\t\t\t\tif (a instanceof IRCoreCallExpr && a.builtinName == \"listData\") {\n\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\t\t\n\t\t}\n\n\t\treturn new IRCoreCallExpr(this.#name, args, this.parensSite);\n\t}\n\n\t/**\n\t * @param {Site} site\n\t * @param {string} name - full name of builtin, including prefix\n\t * @returns {UplcTerm}\n\t */\n\tstatic newUplcBuiltin(site, name) {\n\t\tlet builtinName = name.slice(\"__core__\".length);\n\t\tassert(!builtinName.startsWith(\"__core__\"));\n\n\t\t/**\n\t\t * @type {UplcTerm}\n\t\t */\n\t\tlet term = new UplcBuiltin(site, builtinName);\n\n\t\tlet nForce = UPLC_BUILTINS[IRScope.findBuiltin(name)].forceCount;\n \n\t\tfor (let i = 0; i < nForce; i++) {\n\t\t\tterm = new UplcForce(site, term);\n\t\t}\n \n\t\treturn term;\n\t}\n\n\t/**\n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\tlet term = IRCoreCallExpr.newUplcBuiltin(this.site, this.#name.value);\n\n\t\treturn this.toUplcCall(term);\n\t}\n}\n\n/**\n * IR function call of non-core function\n * @package\n */\nclass IRUserCallExpr extends IRCallExpr {\n\t#fnExpr;\n\n\t/**\n\t * @param {IRExpr} fnExpr \n\t * @param {IRExpr[]} argExprs \n\t * @param {Site} parensSite \n\t */\n\tconstructor(fnExpr, argExprs, parensSite) {\n\t\tsuper(fnExpr.site, argExprs, parensSite);\n\n\t\tthis.#fnExpr = fnExpr;\n\t}\n\n\t/**\n\t * @param {IRExpr} fnExpr \n\t * @param {IRExpr[]} argExprs \n\t * @param {Site} parensSite \n\t * @returns {IRUserCallExpr}\n\t */\n\tstatic new(fnExpr, argExprs, parensSite) {\n\t\tif (fnExpr instanceof IRAnonCallExpr) {\n\t\t\treturn new IRNestedAnonCallExpr(fnExpr, argExprs, parensSite);\n\t\t} else if (fnExpr instanceof IRFuncExpr) {\n\t\t\tif (argExprs.length == 1 && argExprs[0] instanceof IRFuncExpr) {\n\t\t\t\tconst argExpr = argExprs[0];\n\n\t\t\t\tif (argExpr instanceof IRFuncExpr) {\n\t\t\t\t\treturn new IRFuncDefExpr(fnExpr, argExpr, parensSite);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new IRAnonCallExpr(fnExpr, argExprs, parensSite);\n\t\t} else {\n\t\t\treturn new IRUserCallExpr(fnExpr, argExprs, parensSite);\n\t\t}\n\t}\n\n\tget fnExpr() {\n\t\treturn this.#fnExpr;\n\t}\n\n\t/**\n\t * @param {string} indent\n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\tlet comment = (this.#fnExpr instanceof IRFuncExpr && this.#fnExpr.args.length == 1 && this.#fnExpr.args[0].name.startsWith(\"__\")) ? `/*${this.#fnExpr.args[0].name}*/` : \"\";\n\n\t\treturn `${this.#fnExpr.toString(indent)}(${comment}${this.argsToString(indent)})`;\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t\tthis.#fnExpr.resolveNames(scope);\n\n\t\tsuper.resolveNamesInArgs(scope);\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\treturn IRUserCallExpr.new(\n\t\t\tthis.#fnExpr.evalConstants(stack),\n\t\t\tthis.evalConstantsInArgs(stack),\n\t\t\tthis.parensSite\n\t\t);\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack \n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\tlet args = this.evalArgs(stack);\n\n\t\tif (args === null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tlet fn = this.#fnExpr.eval(stack);\n\n\t\t\tif (fn === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\treturn fn.call(args);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof RuntimeError) {\n\t\t\t\t\t\tif (!stack.throwRTErrors) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e.addTraceSite(this.site);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {(IRExpr[] | IRLiteralExpr)}\n\t */\n\tsimplifyLiteralsInArgsAndTryEval(literals) {\n\t\tconst args = this.simplifyLiteralsInArgs(literals);\n\n\t\tif (args.length > 0 && args.every(a => ((a instanceof IRLiteralExpr) || (a instanceof IRFuncExpr)))) {\n\t\t\ttry {\n\t\t\t\tconst fn = this.#fnExpr.eval(new IRCallStack(false));\n\n\t\t\t\tif (fn != null) {\n\t\t\t\t\tconst res = fn.call(\n\t\t\t\t\t\targs.map(a => {\n\t\t\t\t\t\t\tconst v = a.eval(new IRCallStack(false));\n\n\t\t\t\t\t\t\tif (v == null) {\n\t\t\t\t\t\t\t\t// caught by outer catch\n\t\t\t\t\t\t\t\tthrow new Error(\"null eval sub-result\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\n\t\t\t\t\tif (res != null) {\n\t\t\t\t\t\treturn new IRLiteralExpr(res.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\tconst argsOrLiteral = this.simplifyLiteralsInArgsAndTryEval(literals);\n\n\t\tif (argsOrLiteral instanceof IRLiteralExpr) {\n\t\t\treturn argsOrLiteral;\n\t\t} else {\n\t\t\tconst args = argsOrLiteral;\n\n\t\t\treturn IRUserCallExpr.new(\n\t\t\t\tthis.#fnExpr.simplifyLiterals(literals),\n\t\t\t\targs, \n\t\t\t\tthis.parensSite\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs \n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tthis.registerNameExprsInArgs(nameExprs);\n\t\t\n\t\tthis.#fnExpr.registerNameExprs(nameExprs);\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars \n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\treturn new IRUserCallExpr(this.#fnExpr.copy(newVars), this.argExprs.map(a => a.copy(newVars)), this.parensSite);\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tconst args = this.simplifyTopologyInArgs(registry);\n\n\t\tif (this.#fnExpr instanceof IRNameExpr) {\n\t\t\tif (this.#fnExpr.isCore()) {\n\t\t\t\treturn new IRCoreCallExpr(new Word(this.#fnExpr.site, this.#fnExpr.name), args, this.parensSite);\n\t\t\t} else {\n\t\t\t\tswitch (this.#fnExpr.name) {\n\t\t\t\t\tcase \"__helios__common__boolData\": {\n\t\t\t\t\t\t\t// check if arg is a call to __helios__common__unBoolData\n\t\t\t\t\t\t\tconst a = args[0];\n\t\t\t\t\t\t\tif (a instanceof IRUserCallExpr && a.fnExpr instanceof IRNameExpr && a.fnExpr.name == \"__helios__common__unBoolData\") {\n\t\t\t\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"__helios__common__unBoolData\": {\n\t\t\t\t\t\t\t// check if arg is a call to __helios__common__boolData\n\t\t\t\t\t\t\tconst a = args[0];\n\t\t\t\t\t\t\tif (a instanceof IRUserCallExpr && a.fnExpr instanceof IRNameExpr && a.fnExpr.name == \"__helios__common__boolData\") {\n\t\t\t\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"__helios__common__not\": {\n\t\t\t\t\t\t\tconst a = args[0];\n\t\t\t\t\t\t\tif (a instanceof IRUserCallExpr && a.fnExpr instanceof IRNameExpr && a.fnExpr.name == \"__helios__common__not\") {\n\t\t\t\t\t\t\t\treturn a.argExprs[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"__helios__common__concat\": {\n\t\t\t\t\t\t\t// check if either 1st or 2nd arg is the empty list\n\t\t\t\t\t\t\tconst [a, b] = args;\n\t\t\t\t\t\t\tif (a instanceof IRLiteralExpr && a.value instanceof UplcList && a.value.length == 0) {\n\t\t\t\t\t\t\t\treturn b;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (b instanceof IRLiteralExpr && b.value instanceof UplcList && b.value.length == 0) {\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn IRUserCallExpr.new(\n\t\t\tthis.#fnExpr.simplifyTopology(registry),\n\t\t\targs,\n\t\t\tthis.parensSite\n\t\t);\n\t}\n\n\t/**\n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\treturn super.toUplcCall(this.#fnExpr.toUplc());\n\t}\n}\n\nclass IRAnonCallExpr extends IRUserCallExpr {\n\t#anon;\n\n\t/**\n\t * @param {IRFuncExpr} fnExpr \n\t * @param {IRExpr[]} argExprs \n\t * @param {Site} parensSite \n\t */\n\tconstructor(fnExpr, argExprs, parensSite) {\n\t\tsuper(fnExpr, argExprs, parensSite)\n\n\t\tthis.#anon = fnExpr;\n\t}\n\n\t/**\n\t * Internal function\n\t * @type {IRFuncExpr}\n\t */\n\tget anon() {\n\t\treturn this.#anon;\n\t}\n\n\t/**\n\t * @type {IRVariable[]}\n\t */\n\tget argVariables() {\n\t\treturn this.#anon.args;\n\t}\n\n\t/**\n\t * Add args to the stack as IRDeferredValue instances\n\t * @param {IRCallStack} stack\n\t */\n\tevalConstants(stack) {\n\t\tconst argExprs = this.evalConstantsInArgs(stack);\n\n\t\tconst parentStack = stack;\n\n\t\targExprs.forEach((argExpr, i) => {\n\t\t\tstack = stack.set(this.argVariables[i], new IRDeferredValue(() => argExpr.eval(parentStack)));\n\t\t});\n\n\t\tconst anonBody = this.#anon.body.evalConstants(stack);\n\n\t\tif (anonBody instanceof IRLiteralExpr) {\n\t\t\treturn anonBody;\n\t\t} else {\n\t\t\treturn IRUserCallExpr.new(\n\t\t\t\tnew IRFuncExpr(\n\t\t\t\t\tthis.#anon.site,\n\t\t\t\t\tthis.#anon.args,\n\t\t\t\t\tanonBody\n\t\t\t\t),\n\t\t\t\targExprs,\n\t\t\t\tthis.parensSite\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Add literal args to the map\n\t * @param {IRLiteralRegistry} literals\n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\tconst argsOrLiteral = super.simplifyLiteralsInArgsAndTryEval(literals);\n\n\t\tif (argsOrLiteral instanceof IRLiteralExpr) {\n\t\t\treturn argsOrLiteral;\n\t\t} else {\n\t\t\tconst args = argsOrLiteral;\n\n\t\t\targs.forEach((arg, i) => {\n\t\t\t\tif (arg instanceof IRLiteralExpr) {\n\t\t\t\t\tliterals.set(this.argVariables[i], arg);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst anonBody = this.#anon.body.simplifyLiterals(literals);\n\n\t\t\tif (anonBody instanceof IRLiteralExpr) {\n\t\t\t\treturn anonBody;\n\t\t\t} else {\n\t\t\t\treturn new IRAnonCallExpr(\n\t\t\t\t\tnew IRFuncExpr(\n\t\t\t\t\t\tthis.#anon.site,\n\t\t\t\t\t\tthis.#anon.args,\n\t\t\t\t\t\tanonBody\n\t\t\t\t\t),\n\t\t\t\t\targs,\n\t\t\t\t\tthis.parensSite\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs \n\t */\n\tregisterNameExprs(nameExprs) {\n\t\tthis.registerNameExprsInArgs(nameExprs);\n\n\t\tthis.argVariables.forEach(a => nameExprs.registerVariable(a));\n\n\t\tthis.#anon.body.registerNameExprs(nameExprs);\n\t}\n\t\n\t/**\n\t * @param {IRExprRegistry} registry \n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tconst args = this.simplifyTopologyInArgs(registry);\n\n\t\t// remove unused args, inline args that are only referenced once, inline all IRNameExprs, inline function with default args \n\t\tconst remainingIds = this.argVariables.map((variable, i) => {\n\t\t\tconst n = registry.countReferences(variable);\n\n\t\t\tconst arg = args[i];\n\n\t\t\tif (\n\t\t\t\tn == 0 \n\t\t\t\t|| (n == 1 && (!registry.maybeInsideLoop(variable) || arg instanceof IRFuncExpr)) \n\t\t\t\t|| arg instanceof IRNameExpr \n\t\t\t\t|| (arg instanceof IRFuncExpr && arg.hasOptArgs())\n\t\t\t) {\n\t\t\t\tif (n > 0) {\n\t\t\t\t\t// inline\n\t\t\t\t\tregistry.addInlineable(variable, arg);\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}).filter(i => i != -1);\n\n\t\tconst remainingVars = remainingIds.map(i => this.argVariables[i]);\n\t\tconst remainingExprs = remainingIds.map(i => args[i]);\n\n\t\tconst anonBody = this.#anon.body.simplifyTopology(registry);\n\n\t\tif (anonBody instanceof IRLiteralExpr || remainingExprs.length == 0) {\n\t\t\treturn anonBody;\n\t\t} else {\n\t\t\treturn new IRAnonCallExpr(\n\t\t\t\tnew IRFuncExpr(\n\t\t\t\t\tthis.#anon.site,\n\t\t\t\t\tremainingVars,\n\t\t\t\t\tanonBody\n\t\t\t\t),\n\t\t\t\tremainingExprs,\n\t\t\t\tthis.parensSite\n\t\t\t);\n\t\t}\n\t}\n}\n\nclass IRNestedAnonCallExpr extends IRUserCallExpr {\n\t#anon;\n\n\t/**\n\t * @param {IRAnonCallExpr} anon\n\t * @param {IRExpr[]} outerArgExprs\n\t * @param {Site} parensSite\n\t */\n\tconstructor(anon, outerArgExprs, parensSite) {\n\t\tsuper(anon, outerArgExprs, parensSite);\n\n\t\tthis.#anon = anon;\n\t}\n\n\t/**\n\t * Flattens consecutive nested calls\n\t * @param {IRExprRegistry} registry\n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\tconst anon = this.#anon.simplifyTopology(registry);\n\n\t\tconst args = this.simplifyTopologyInArgs(registry);\n\n\t\tif (anon instanceof IRAnonCallExpr && anon.anon.body instanceof IRFuncExpr) {\n\t\t\t// flatten\n\t\t\tconst allArgs = anon.argExprs.slice().concat(args);\n\t\t\tconst allVars = anon.argVariables.slice().concat(anon.anon.body.args.slice());\n\n\t\t\tassert(allArgs.length == allVars.length);\n\n\t\t\treturn IRUserCallExpr.new(\n\t\t\t\tnew IRFuncExpr(\n\t\t\t\t\tanon.anon.body.site,\n\t\t\t\t\tallVars,\n\t\t\t\t\tanon.anon.body.body\n\t\t\t\t),\n\t\t\t\tallArgs,\n\t\t\t\tthis.parensSite\n\t\t\t);\n\t\t} else {\n\t\t\treturn IRUserCallExpr.new(\n\t\t\t\tanon,\n\t\t\t\targs,\n\t\t\t\tthis.parensSite\n\t\t\t);\n\t\t}\n\t}\n}\n\nclass IRFuncDefExpr extends IRAnonCallExpr {\n\t#def;\n\n\t/**\n\t * @param {IRFuncExpr} fnExpr \n\t * @param {IRFuncExpr} defExpr \n\t * @param {Site} parensSite\n\t */\n\tconstructor(fnExpr, defExpr, parensSite) {\n\t\tsuper(fnExpr, [defExpr], parensSite);\n\n\t\tthis.#def = defExpr;\n\t}\n}\n\n/**\n * Intermediate Representation error call (with optional literal error message)\n * @package\n */\nclass IRErrorCallExpr extends IRExpr {\n\t#msg;\n\n\t/**\n\t * @param {Site} site \n\t * @param {string} msg \n\t */\n\tconstructor(site, msg = \"\") {\n\t\tsuper(site);\n\t\tthis.#msg = msg;\n\t}\n\n\t/**\n\t * @param {string} indent \n\t * @returns {string}\n\t */\n\ttoString(indent = \"\") {\n\t\treturn \"error()\";\n\t}\n\n\t/**\n\t * @param {IRScope} scope \n\t */\n\tresolveNames(scope) {\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {IRExpr}\n\t */\n\tevalConstants(stack) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {IRCallStack} stack\n\t * @returns {?IRValue}\n\t */\n\teval(stack) {\n\t\tif (stack.throwRTErrors) {\n\t\t\tthrow this.site.runtimeError(this.#msg);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IRLiteralRegistry} literals \n\t * @returns {IRExpr}\n\t */\n\tsimplifyLiterals(literals) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {IRNameExprRegistry} nameExprs\n\t */\n\tregisterNameExprs(nameExprs) {\n\t}\n\n\t/**\n\t * @param {Map<IRVariable, IRVariable>} newVars \n\t * @returns {IRExpr}\n\t */\n\tcopy(newVars) {\n\t\treturn new IRErrorCallExpr(this.site, this.#msg);\n\t}\n\n\t/**\n\t * @param {IRExprRegistry} registry\n\t * @returns {IRExpr}\n\t */\n\tsimplifyTopology(registry) {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {UplcTerm}\n\t */\n\ttoUplc() {\n\t\treturn new UplcError(this.site, this.#msg);\n\t}\n}\n\n\n/////////////////////////////////////\n// Section 22: IR AST build functions\n/////////////////////////////////////\n\n/**\n * Build an Intermediate Representation expression\n * @param {Token[]} ts \n * @returns {IRExpr}\n * @package\n */\nfunction buildIRExpr(ts) {\n\t/** @type {?IRExpr} */\n\tlet expr = null;\n\n\twhile (ts.length > 0) {\n\t\tlet t = ts.shift();\n\n\t\tif (t === undefined) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\t\t\tif (t.isGroup(\"(\") && ts.length > 0 && ts[0].isSymbol(\"->\")) {\n\t\t\t\tassert(expr === null);\n\n\t\t\t\tts.unshift(t);\n\n\t\t\t\texpr = buildIRFuncExpr(ts);\n\t\t\t} else if (t.isGroup(\"(\")) {\n\t\t\t\tlet group = t.assertGroup();\n\n\t\t\t\tif (expr === null) {\n\t\t\t\t\tif (group.fields.length == 1) {\n\t\t\t\t\t\texpr = buildIRExpr(group.fields[0])\n\t\t\t\t\t} else if (group.fields.length == 0) {\n\t\t\t\t\t\texpr = new IRLiteralExpr(new UplcUnit(t.site));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup.syntaxError(\"unexpected parentheses with multiple fields\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet args = [];\n\t\t\t\t\tfor (let f of group.fields) {\n\t\t\t\t\t\targs.push(buildIRExpr(f));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (expr instanceof IRNameExpr && expr.name.startsWith(\"__core\")) {\n\t\t\t\t\t\tif (!IRScope.isBuiltin(expr.name)) {\n\t\t\t\t\t\t\tthrow expr.site.referenceError(`builtin '${expr.name}' undefined`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpr = new IRCoreCallExpr(new Word(expr.site, expr.name), args, t.site);\n\t\t\t\t\t} else {\n\t\t\t\t\t\texpr = IRUserCallExpr.new(expr, args, t.site);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (t.isSymbol(\"-\")) {\n\t\t\t\t// only makes sense next to IntegerLiterals\n\t\t\t\tlet int = assertDefined(ts.shift());\n\t\t\t\tif (int instanceof IntLiteral) {\n\t\t\t\t\texpr = new IRLiteralExpr(new UplcInt(int.site, int.value * (-1n)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow int.site.typeError(`expected literal int, got ${int}`);\n\t\t\t\t}\n\t\t\t} else if (t instanceof BoolLiteral) {\n\t\t\t\tassert(expr === null);\n\t\t\t\texpr = new IRLiteralExpr(new UplcBool(t.site, t.value));\n\t\t\t} else if (t instanceof IntLiteral) {\n\t\t\t\tassert(expr === null);\n\t\t\t\texpr = new IRLiteralExpr(new UplcInt(t.site, t.value));\n\t\t\t} else if (t instanceof ByteArrayLiteral) {\n\t\t\t\tassert(expr === null);\n\t\t\t\tif (t.bytes.length == 0 && ts[0] != undefined && ts[0] instanceof ByteArrayLiteral) {\n\t\t\t\t\t// literal data is ##<...>\n\t\t\t\t\tconst next = assertDefined(ts.shift());\n\n\t\t\t\t\tif (next instanceof ByteArrayLiteral) {\n\t\t\t\t\t\texpr = new IRLiteralExpr(new UplcDataValue(next.site, UplcData.fromCbor(next.bytes)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texpr = new IRLiteralExpr(new UplcByteArray(t.site, t.bytes));\n\t\t\t\t}\n\t\t\t} else if (t instanceof StringLiteral) {\n\t\t\t\tassert(expr === null);\n\t\t\t\texpr = new IRLiteralExpr(new UplcString(t.site, t.value));\n\t\t\t} else if (t.isWord(\"const\")) {\n\t\t\t\tassert(expr === null);\n\n\t\t\t\tlet maybeGroup = ts.shift();\n\t\t\t\tif (maybeGroup === undefined) {\n\t\t\t\t\tthrow t.site.syntaxError(\"expected parens after const\");\n\t\t\t\t} else {\n\t\t\t\t\tlet parens = maybeGroup.assertGroup(\"(\", 1);\n\t\t\t\t\tlet pts = parens.fields[0];\n\n\t\t\t\t\texpr = new IRConstExpr(t.site, buildIRExpr(pts));\n\t\t\t\t}\n\t\t\t} else if (t.isWord(\"error\")) {\n\t\t\t\tassert(expr === null);\n\n\t\t\t\tlet maybeGroup = ts.shift();\n\t\t\t\tif (maybeGroup === undefined) {\n\t\t\t\t\tthrow t.site.syntaxError(\"expected parens after error\");\n\t\t\t\t} else {\n\t\t\t\t\tlet parens = maybeGroup.assertGroup(\"(\", 1);\n\t\t\t\t\tlet pts = parens.fields[0];\n\n\t\t\t\t\tif (pts.length != 1) {\n\t\t\t\t\t\tthrow parens.syntaxError(\"error call expects a single literal string msg arg\");\n\t\t\t\t\t}\n\n\t\t\t\t\tlet msg = pts[0];\n\t\t\t\t\tif (!(msg instanceof StringLiteral)) {\n\t\t\t\t\t\tthrow msg.syntaxError(\"error call expects literal string msg arg\");\n\t\t\t\t\t}\n\t\t\t\t\texpr = new IRErrorCallExpr(t.site, msg.value);\n\t\t\t\t}\n\t\t\t} else if (t.isWord()) {\n\t\t\t\tassert(expr === null);\n\t\t\t\texpr = new IRNameExpr(t.assertWord());\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unhandled untyped token \" + t.toString());\n\t\t\t}\n\t\t}\n\t}\n\n\tif (expr === null) {\n\t\tthrow new Error(\"expr is null\");\n\t} else {\n\t\treturn expr;\n\t}\n}\n\n/**\n * Build an IR function expression\n * @param {Token[]} ts \n * @returns {IRFuncExpr}\n */\nfunction buildIRFuncExpr(ts) {\n\tlet maybeParens = ts.shift();\n\tif (maybeParens === undefined) {\n\t\tthrow new Error(\"empty func expr\");\n\t} else {\n\t\tlet parens = maybeParens.assertGroup(\"(\");\n\n\t\tassertDefined(ts.shift()).assertSymbol(\"->\");\n\t\tlet braces = assertDefined(ts.shift()).assertGroup(\"{\");\n\n\t\t/**\n\t\t * @type {Word[]}\n\t\t */\n\t\tlet argNames = [];\n\n\t\tfor (let f of parens.fields) {\n\t\t\tassert(f.length == 1, \"expected single word per arg\");\n\t\t\targNames.push(f[0].assertWord());\n\t\t}\n\n\t\tif (braces.fields.length > 1) {\n\t\t\tthrow braces.syntaxError(\"unexpected comma in function body\")\n\t\t} else if (braces.fields.length == 0) {\n\t\t\tthrow braces.syntaxError(\"empty function body\")\n\t\t}\n\n\t\tlet bodyExpr = buildIRExpr(braces.fields[0]);\n\n\t\treturn new IRFuncExpr(parens.site, argNames.map(a => new IRVariable(a)), bodyExpr)\n\t}\n}\n\n\n/////////////////////////\n// Section 23: IR Program\n/////////////////////////\n\n\n/**\n * Wrapper for IRFuncExpr, IRCallExpr or IRLiteralExpr\n * @package\n */\nclass IRProgram {\n\t#expr;\n\t#purpose;\n\n\t/**\n\t * @param {IRFuncExpr | IRCallExpr | IRLiteralExpr} expr\n\t * @param {?number} purpose\n\t */\n\tconstructor(expr, purpose) {\n\t\tthis.#expr = expr;\n\t\tthis.#purpose = purpose;\n\t}\n\n\t/**\n\t * @param {IRExpr} expr \n\t * @returns {IRFuncExpr | IRCallExpr | IRLiteralExpr}\n\t */\n\tstatic assertValidRoot(expr) {\n\t\tif (expr instanceof IRFuncExpr || expr instanceof IRCallExpr || expr instanceof IRLiteralExpr) {\n\t\t\treturn expr;\n\t\t} else {\n\t\t\tthrow new Error(\"invalid IRExpr type for IRProgram\");\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {IR} ir \n\t * @param {?number} purpose\n\t * @param {boolean} simplify\n\t * @param {boolean} throwSimplifyRTErrors - if true -> throw RuntimErrors caught during evaluation steps\n\t * @param {IRScope} scope\n\t * @returns {IRProgram}\n\t */\n\tstatic new(ir, purpose, simplify = false, throwSimplifyRTErrors = false, scope = new IRScope(null, null)) {\n\t\tlet [irSrc, codeMap] = ir.generateSource();\n\n\t\tlet irTokens = tokenizeIR(irSrc, codeMap);\n\n\t\tlet expr = buildIRExpr(irTokens);\n\t\n\t\texpr.resolveNames(scope);\n\n\t\texpr = expr.evalConstants(new IRCallStack(throwSimplifyRTErrors));\n\n\t\tif (simplify) {\n\t\t\t// inline literals and evaluate core expressions with only literal args (some can be evaluated with only partial literal args)\n\t\t\texpr = this.simplify(expr);\n\n\t\t\t// make sure the debruijn indices are correct\n\t\t\texpr.resolveNames(scope);\n\t\t}\n\n\t\tconst program = new IRProgram(IRProgram.assertValidRoot(expr), purpose);\n\n\t\treturn program;\n\t}\n\n\t/**\n\t * @param {IRExpr} expr\n\t * @returns {IRExpr}\n\t */\n\tstatic simplify(expr) {\n\t\tlet dirty = true;\n\t\tlet oldState = expr.toString();\n\n\t\twhile (dirty) {\n\t\t\tdirty = false;\n\n\t\t\texpr = expr.simplifyLiterals(new Map());\n\n\t\t\tconst nameExprs = new IRNameExprRegistry();\n\n\t\t\texpr.registerNameExprs(nameExprs);\n\n\t\t\texpr = expr.simplifyTopology(new IRExprRegistry(nameExprs));\n\n\t\t\tconst newState = expr.toString();\n\n\t\t\tif (newState != oldState) {\n\t\t\t\tdirty = true;\n\t\t\t\toldState = newState;\n\t\t\t}\n\t\t}\n\n\t\treturn expr;\n\t}\n\n\t/**\n\t * @package\n\t * @type {IRFuncExpr | IRCallExpr | IRLiteralExpr}\n\t */\n\tget expr() {\n\t\treturn this.#expr;\n\t}\n\n\t/**\n\t * @package\n\t * @type {?number}\n\t */\n\tget purpose() {\n\t\treturn this.#purpose;\n\t}\n\n\t/**\n\t * @package\n\t * @type {Site}\n\t */\n\tget site() {\n\t\treturn this.#expr.site;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\tif (this.#expr instanceof IRLiteralExpr) {\n\t\t\tlet v = this.#expr.value;\n\n\t\t\treturn v.data;\n\t\t} else {\n\t\t\tconsole.log(this.#expr.toString());\n\t\t\tthrow new Error(\"expected data literal\");\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.#expr.toString();\n\t}\n\n\t/**\n\t * @returns {UplcProgram}\n\t */\n\ttoUplc() {\n\t\treturn new UplcProgram(this.#expr.toUplc(), this.#purpose);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tcalcSize() {\n\t\treturn this.toUplc().calcSize();\n\t}\n}\n\nclass IRParametricProgram {\n\t#irProgram;\n\t#parameters;\n\n\t/**\n\t * @param {IRProgram} irProgram\n\t * @param {string[]} parameters\n\t */\n\tconstructor(irProgram, parameters) {\n\t\tthis.#irProgram = irProgram;\n\t\tthis.#parameters = parameters;\n\t}\n\n\t/**\n\t * @package\n\t * @param {IR} ir \n\t * @param {?number} purpose\n\t * @param {string[]} parameters\n\t * @param {boolean} simplify\n\t * @returns {IRParametricProgram}\n\t */\n\tstatic new(ir, purpose, parameters, simplify = false) {\n\t\tlet scope = new IRScope(null, null);\n\n\t\tparameters.forEach((p, i) => {\n\t\t\tconst internalName = `__PARAM_${i}`;\n\n\t\t\tscope = new IRScope(scope, new IRVariable(new Word(Site.dummy(), internalName)));\n\t\t});\n\n\t\tconst irProgram = IRProgram.new(ir, purpose, simplify, false, scope);\n\n\t\treturn new IRParametricProgram(irProgram, parameters);\n\t}\n\n\t/**\n\t * @returns {UplcProgram}\n\t */\n\ttoUplc() {\n\t\tlet exprUplc = this.#irProgram.expr.toUplc();\n\n\t\tthis.#parameters.forEach(p => {\n\t\t\texprUplc = new UplcLambda(Site.dummy(), exprUplc, p);\n\t\t});\n\n\t\treturn new UplcProgram(exprUplc, this.#irProgram.purpose);\n\t}\n}\n\n\n\n/////////////////////////////\n// Section 24: Helios program\n/////////////////////////////\n\n/**\n * A Module is a collection of statements\n */\nclass Module {\n\t#name;\n\t#statements;\n\n\t/**\n\t * @param {Word} name \n\t * @param {Statement[]} statements\n\t */\n\tconstructor(name, statements) {\n\t\tthis.#name = name;\n\t\tthis.#statements = statements;\n\n\t\tthis.#statements.forEach(s => s.setBasePath(`__module__${this.#name.toString()}`));\n\t}\n\n\t/**\n\t * @param {string} rawSrc\n\t * @param {?number} fileIndex - a unique optional index passed in from outside that makes it possible to associate a UserError with a specific file\n\t * @returns {Module}\n\t */\n\tstatic new(rawSrc, fileIndex = null) {\n\t\tconst src = new Source(rawSrc, fileIndex);\n\n\t\tconst ts = tokenize(src);\n\n\t\tsrc.throwErrors();\n\n\t\tif (ts === null) {\n\t\t\tthrow new Error(\"should've been thrown above\");\n\t\t}\n\n\t\tif (ts.length == 0) {\n\t\t\tthrow UserError.syntaxError(src, 0, 1, \"empty script\");\n\t\t}\n\n\t\tconst [purpose, name, statements, mainIdx] = buildScript(ts, ScriptPurpose.Module);\n\n\t\tsrc.throwErrors();\n\n\t\tif (name !== null) {\n\t\t\treturn new Module(name, statements);\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected\"); // should've been caught by calling src.throwErrors() above\n\t\t}\n\t}\n\n\t/**\n\t * @type {Word}\n\t */\n\tget name() {\n\t\treturn this.#name;\n\t}\n\n\t/**\n\t * @type {Statement[]}\n\t */\n\tget statements() {\n\t\treturn this.#statements.slice();\n\t}\n\n\ttoString() {\n\t\treturn this.#statements.map(s => s.toString()).join(\"\\n\");\n\t}\n\n\t/**\n\t * @param {ModuleScope} scope \n\t */\n\tevalTypes(scope) {\n\t\tfor (let s of this.statements) {\n\t\t\ts.eval(scope);\n\t\t}\n\t}\n\n\t/**\n\t * Cleans the program by removing everything that is unecessary for the smart contract (easier to audit)\n\t * @returns {string}\n\t */\n\tcleanSource() {\n\t\tlet raw = this.name.site.src.raw;\n\t\tlet n = raw.length;\n\n\t\tlet mask = new Uint8Array(n);\n\n\t\tmask.fill(1); // hide the unused parts by setting to 0\n\n\t\tfor (let s of this.#statements) {\n\t\t\ts.hideUnused(mask);\n\t\t}\n\n\t\t/** @type {string[]} */\n\t\tlet chars = [];\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet c = raw.charAt(i);\n\n\t\t\tif (c == '\\n' || c == ' ') {\n\t\t\t\tchars.push(c);\n\t\t\t} else if (mask[i] == 1) {\n\t\t\t\tchars.push(c);\n\t\t\t} else {\n\t\t\t\tchars.push(' ');\n\t\t\t}\n\t\t}\n\n\t\tlet lines = chars.join(\"\").split(\"\\n\").map(l => {\n\t\t\tif (l.trim().length == 0) {\n\t\t\t\treturn \"\";\n\t\t\t} else {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t});\n\n\t\t// remove more than one consecutive empty line\n\n\t\t/**\n\t\t * @type {string[]}\n\t\t */\n\t\tlet parts = [];\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tif (!(i > 0 && lines[i-1].length == 0 && lines[i].length == 0)) {\n\t\t\t\tparts.push(lines[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn parts.join(\"\\n\");\n\t}\n\n\t/**\n\t * This module can depend on other modules\n\t * TODO: detect circular dependencies\n\t * @param {Module[]} modules \n\t * @param {Module[]} stack\n\t * @returns {Module[]}\n\t */\n\tfilterDependencies(modules, stack = []) {\n\t\t/**\n\t\t * @type {Module[]}\n\t\t */\n\t\tlet deps = [];\n\n\t\t/** @type {Module[]} */\n\t\tlet newStack = [this];\n\t\tnewStack = newStack.concat(stack);\n\n\t\tfor (let s of this.#statements) {\n\t\t\tif (s instanceof ImportStatement) {\n\t\t\t\tlet mn = s.moduleName.value;\n\n\t\t\t\tif (mn == this.name.value) {\n\t\t\t\t\tthrow s.syntaxError(\"can't import self\");\n\t\t\t\t} else if (stack.some(d => d.name.value == mn)) {\n\t\t\t\t\tthrow s.syntaxError(\"circular import detected\");\n\t\t\t\t}\n\n\t\t\t\t// if already in deps, then don't add (because it will have been added before along with all its dependencies)\n\t\t\t\tif (!deps.some(d => d.name.value == mn)) {\n\t\t\t\t\tlet m = modules.find(m => m.name.value == mn);\n\n\t\t\t\t\tif (m === undefined) {\n\t\t\t\t\t\tthrow s.referenceError(`module '${mn}' not found`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// only add deps that weren't added before\n\t\t\t\t\t\tlet newDeps = m.filterDependencies(modules, newStack).concat([m]).filter(d => !deps.some(d_ => d_.name.value == d.name.value));\n\n\t\t\t\t\t\tdeps = deps.concat(newDeps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deps;\n\t}\n}\n\n/**\n * The entrypoint module\n */\nclass MainModule extends Module {\n\t/**\n\t * @param {Word} name \n\t * @param {Statement[]} statements \n\t */\n\tconstructor(name, statements) {\n\t\tsuper(name, statements);\n\t}\n\n\t/**\n\t * @type {FuncStatement}\n\t */\n\tget mainFunc() {\n\t\tfor (let s of this.statements) {\n\t\t\tif (s.name.value == \"main\") {\n\t\t\t\tif (!(s instanceof FuncStatement)) {\t\n\t\t\t\t\tthrow s.typeError(\"'main' isn't a function statement\");\n\t\t\t\t} else {\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(\"'main' not found (is a module being used as an entrypoint?)\");\n\t}\n}\n\n/**\n * @typedef {Object.<string, HeliosDataClass<HeliosData>>} UserTypes\n */\n\n/**\n * Helios root object\n */\n class Program {\n\t#purpose;\n\t#modules;\n\n\t/** @type {UserTypes} */\n\t#types;\n\n\t/**\n\t * Cache of const values\n\t * @type {Object.<string, HeliosData>}\n\t */\n\t#parameters;\n\t\n\t/**\n\t * @param {number} purpose\n\t * @param {Module[]} modules\n\t */\n\tconstructor(purpose, modules) {\n\t\tthis.#purpose = purpose;\n\t\tthis.#modules = modules;\n\t\tthis.#types = {};\n\t\tthis.#parameters = {};\n\t}\n\n\t/**\n\t * @param {string} rawSrc \n\t * @returns {[purpose, Module[]]}\n\t */\n\tstatic parseMain(rawSrc) {\n\t\tconst src = new Source(rawSrc, 0);\n\n\t\tconst ts = tokenize(src);\n\n\t\tsrc.throwErrors();\n\n\t\tif (ts === null) {\n\t\t\tthrow new Error(\"should've been thrown above\");\n\t\t}\n\n\t\tif (ts.length == 0) {\n\t\t\tthrow UserError.syntaxError(src, 0, 1, \"empty script\");\n\t\t}\n\n\t\tconst [purpose, name, statements, mainIdx] = buildScript(ts);\n\n\t\tsrc.throwErrors();\n\n\t\tif (purpose !== null && name !== null) {\n\t\t\t/**\n\t\t\t * @type {Module[]}\n\t\t\t */\n\t\t\tconst modules = [new MainModule(name, statements.slice(0, mainIdx+1))];\n\n\t\t\tif (mainIdx < statements.length - 1) {\n\t\t\t\tmodules.push(new Module(name, statements.slice(mainIdx+1)));\n\t\t\t}\n\n\t\t\treturn [purpose, modules];\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected\"); // should've been caught by calling src.throwErrors() above\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {string} mainName \n\t * @param {string[]} moduleSrcs\n\t * @returns {Module[]}\n\t */\n\tstatic parseImports(mainName, moduleSrcs = []) {\n\t\tlet imports = moduleSrcs.map((src, i) => Module.new(src, i+1));\n\n\t\t/**\n\t\t * @type {Set<string>}\n\t\t */\n\t\tlet names = new Set();\n\n\t\tnames.add(mainName);\n\n\t\tfor (let m of imports) {\n\t\t\tif (names.has(m.name.value)) {\n\t\t\t\tthrow m.name.syntaxError(`non-unique module name '${m.name.value}'`);\n\t\t\t}\n\n\t\t\tnames.add(m.name.value);\n\t\t}\n\n\t\treturn imports;\n\t}\n\n\t/**\n\t * Creates  a new program.\n\t * @param {string} mainSrc \n\t * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports\n\t * @returns {Program}\n\t */\n\tstatic new(mainSrc, moduleSrcs = []) {\n\t\tlet [purpose, modules] = Program.parseMain(mainSrc);\n\n\t\tlet site = modules[0].name.site;\n\n\t\tlet imports = Program.parseImports(modules[0].name.value, moduleSrcs);\n\t\t\n\t\tlet mainImports = modules[0].filterDependencies(imports);\n\n\t\t/** @type {Module[]} */\n\t\tlet postImports = [];\n\n\t\tif (modules.length > 1) {\n\t\t\tpostImports = modules[modules.length - 1].filterDependencies(imports).filter(m => !mainImports.some(d => d.name.value == m.name.value));\n\t\t}\n\n\t\t// create the final order of all the modules (this is the order in which statements will be added to the IR)\n\t\tmodules = mainImports.concat([modules[0]]).concat(postImports).concat(modules.slice(1));\n\t\n\t\t/**\n\t\t * @type {Program}\n\t\t */\n\t\tlet program;\n\n\t\tswitch (purpose) {\n\t\t\tcase ScriptPurpose.Testing:\n\t\t\t\tprogram = new TestingProgram(modules);\n\t\t\t\tbreak;\n\t\t\tcase ScriptPurpose.Spending:\n\t\t\t\tprogram = new SpendingProgram(modules);\n\t\t\t\tbreak;\n\t\t\tcase ScriptPurpose.Minting:\n\t\t\t\tprogram = new MintingProgram(modules);\n\t\t\t\tbreak\n\t\t\tcase ScriptPurpose.Staking:\n\t\t\t\tprogram = new StakingProgram(modules);\n\t\t\t\tbreak\n\t\t\tcase ScriptPurpose.Module:\n\t\t\t\tthrow site.syntaxError(\"can't use module for main\");\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"unhandled script purpose\");\n\t\t}\n\n\t\tconst topScope = program.evalTypes();\n\n\t\tprogram.fillTypes(topScope);\n\n\t\treturn program;\n\t}\n\n\t/** \n\t * @type {Module[]} \n\t */\n\tget mainImportedModules() {\n\t\t/** @type {Module[]} */\n\t\tlet ms = [];\n\n\t\tfor (let m of this.#modules) {\n\t\t\tif (m instanceof MainModule) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tms.push(m);\n\t\t\t}\n\t\t}\n\n\t\treturn ms;\n\t}\n\n\t/**\n\t * @type {MainModule}\n\t */\n\tget mainModule() {\n\t\tfor (let m of this.#modules) {\n\t\t\tif (m instanceof MainModule) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(\"MainModule not found\");\n\t}\n\n\t/**\n\t * @type {?Module}\n\t */\n\tget postModule() {\n\t\tlet m = this.#modules[this.#modules.length - 1];\n\n\t\tif (m instanceof MainModule) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn m;\n\t\t}\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.mainModule.name.value;\n\t}\n\n\t/**\n\t * @type {FuncStatement}\n\t */\n\tget mainFunc() {\n\t\treturn this.mainModule.mainFunc;\n\t}\n\n\t/**\n\t * @type {string}\n\t */\n\tget mainPath() {\n\t\treturn this.mainFunc.path;\n\t}\n\n\t/**\n\t * @type {Statement[]}\n\t */\n\tget mainStatements() {\n\t\treturn this.mainModule.statements;\n\t}\n\n\t/**\n\t * Needed to list the paramTypes, and to call changeParam\n\t * @type {Statement[]}\n\t */\n\tget mainAndPostStatements() {\n\t\tlet statements = this.mainModule.statements;\n\n\t\tif (this.postModule != null) {\n\t\t\tstatements = statements.concat(this.postModule.statements);\n\t\t}\n\n\t\treturn statements;\n\t}\n\n\t/**\n\t * @type {[Statement, boolean][]} - boolean value marks if statement is import or not\n\t */\n\tget allStatements() {\n\t\t/**\n\t\t * @type {[Statement, boolean][]}\n\t\t */\n\t\tlet statements = [];\n\n\t\tfor (let i = 0; i < this.#modules.length; i++) {\n\t\t\tlet m = this.#modules[i];\n\n\t\t\tlet isImport = !(m instanceof MainModule || (i == this.#modules.length - 1));\n\n\t\t\tstatements = statements.concat(m.statements.map(s => [s, isImport]));\n\t\t}\n\n\t\treturn statements;\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn this.#modules.map(m => m.toString()).join(\"\\n\");\n\t}\n\n\t/**\n\t * @returns {[string[], string]}\n\t */\n\tcleanSource() {\n\t\treturn [this.mainImportedModules.map(m => m.cleanSource()), this.mainModule.cleanSource()];\n\t}\n\n\t/**\n\t * @param {GlobalScope} globalScope\n\t * @returns {TopScope}\n\t */\n\tevalTypesInternal(globalScope) {\n\t\tconst topScope = new TopScope(globalScope);\n\n\t\t// loop through the modules\n\n\t\tfor (let i = 0; i < this.#modules.length; i++) {\n\t\t\tconst m = this.#modules[i];\n\n\t\t\t// reuse main ModuleScope for post module\n\t\t\tconst moduleScope = (m ===  this.postModule) ? topScope.getModuleScope(this.mainModule.name) : new ModuleScope(topScope);\n\n\t\t\tm.evalTypes(moduleScope);\n\n\t\t\tif (m instanceof MainModule) {\n\t\t\t\tglobalScope.allowMacros();\n\t\t\t\ttopScope.setStrict(false);\n\t\t\t}\n\n\t\t\tif (m !== this.postModule) {\n\t\t\t\ttopScope.set(m.name, moduleScope);\n\t\t\t}\n\t\t}\n\n\t\tthis.mainFunc.use();\n\t\t\n\t\treturn topScope;\n\t}\n\n\t/**\n\t * @returns {TopScope}\n\t */\n\tevalTypes() {\n\t\tthrow new Error(\"not yet implemeneted\");\n\t}\n\n\t/**\n\t * @type {UserTypes}\n\t */\n\tget types() {\n\t\treturn this.#types;\n\t}\n\n\t/**\n\t * Fill #types with convenient javascript equivalents of Int, ByteArray etc.\n\t * @param {TopScope} topScope\n\t */\n\tfillTypes(topScope) {\n\t\tconst mainModuleScope = topScope.getModuleScope(this.mainModule.name);\n\n\t\tmainModuleScope.loopTypes((name, type) => {\n\t\t\tif (type instanceof StructStatementType || type instanceof EnumStatementType) {\n\t\t\t\tif (name in this.#types) {\n\t\t\t\t\tthrow new Error(`unexpected duplicate type name ${name} in main program scope`);\n\t\t\t\t}\n\n\t\t\t\tthis.#types[name] = type.userType;;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @type {Object.<string, Type>}\n\t */\n\tget paramTypes() {\n\t\t/**\n\t\t * @type {Object.<string, Type>}\n\t\t */\n\t\tlet res = {};\n\n\t\tfor (let s of this.mainAndPostStatements) {\n\t\t\tif (s instanceof ConstStatement) {\n\t\t\t\tres[s.name.value] = s.type;\n\t\t\t} else if (s instanceof ImportStatement && s.origStatement instanceof ConstStatement) {\n\t\t\t\tres[s.name.value] = s.origStatement.type;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Change the literal value of a const statements  \n\t * @param {string} name \n\t * @param {string | UplcValue} value \n\t * @returns {Program} - returns 'this' so that changeParam calls can be chained\n\t */\n\tchangeParam(name, value) {\n\t\tdeprecationWarning(\"program.changeParam\", \"0.14.0\", \"use program.parameters instead\", \"https://www.hyperion-bt.org/helios-book/api/reference/program.html#parameters-1\");\n\n\t\tfor (let s of this.mainAndPostStatements) {\n\t\t\tif (s instanceof ConstStatement && s.name.value == name) {\n\t\t\t\ts.changeValue(value);\n\t\t\t\treturn this;\n\t\t\t} else if (s instanceof ImportStatement && s.name.value == name && s.origStatement instanceof ConstStatement) {\n\t\t\t\ts.origStatement.changeValue(value);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tthrow this.mainFunc.referenceError(`param '${name}' not found`);\n\t}\n\n\t/**\n\t * Change the literal value of a const statements  \n\t * @package\n\t * @param {string} name \n\t * @param {UplcData} data\n\t */\n\tchangeParamSafe(name, data) {\n\t\tfor (let s of this.mainAndPostStatements) {\n\t\t\tif (s instanceof ConstStatement && s.name.value == name) {\n\t\t\t\ts.changeValueSafe(data);\n\t\t\t\treturn this;\n\t\t\t} else if (s instanceof ImportStatement && s.name.value == name && s.origStatement instanceof ConstStatement) {\n\t\t\t\ts.origStatement.changeValueSafe(data);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tthrow this.mainFunc.referenceError(`param '${name}' not found`);\n\t}\n\n\t/**\n\t * Doesn't use wrapEntryPoint\n\t * @param {string} name \n\t * @returns {UplcValue}\n\t */\n\tevalParam(name) {\n\t\t/**\n\t\t * @type {Map<string, IR>}\n\t\t */\n\t\tlet map = new Map();\n\n\t\t/** @type {?ConstStatement} */\n\t\tlet constStatement = null;\n\n\t\tfor (let s of this.mainAndPostStatements) {\n\t\t\tif (s instanceof ImportStatement && s.name.value == name && s.origStatement instanceof ConstStatement) {\n\t\t\t\tconstStatement = s.origStatement;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let [s, isImport] of this.allStatements) {\n\t\t\ts.toIR(map);\n\t\t\tif (s instanceof ConstStatement && ((s.name.value == name && !isImport) || s === constStatement)) {\n\t\t\t\tconstStatement = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (constStatement === null) {\n\t\t\tthrow new Error(`param '${name}' not found`);\n\t\t} else {\n\t\t\tlet path = constStatement.path;\n\n\t\t\tlet ir = assertDefined(map.get(path));\n\n\t\t\tmap.delete(path);\n\n\t\t\tir = wrapWithRawFunctions(IR.wrapWithDefinitions(ir, map));\n\n\t\t\tlet irProgram = IRProgram.new(ir, this.#purpose, true, true);\n\n\t\t\treturn new UplcDataValue(irProgram.site, irProgram.data);\n\t\t}\n\t}\n\t\n\t/**\n\t * Alternative way to get the parameters as HeliosData instances\n\t * @returns {Object.<string, HeliosData>}\n\t */\n\tget parameters() {\n\t\tconst that = this;\n\n\t\t// not expensive, so doesn't need to be evaluated on-demand\n\t\tconst types = this.paramTypes;\n\n\t\tconst handler = {\n\t\t\t/**\n\t\t\t * Return from this.#parameters if available, or calculate\n\t\t\t * @param {Object.<string, HeliosData>} target \n\t\t\t * @param {string} name\n\t\t\t * @returns \n\t\t\t */\n\t\t\tget(target, name) {\n\t\t\t\tif (name in target) {\n\t\t\t\t\treturn target[name];\n\t\t\t\t} else {\n\t\t\t\t\tconst type = assertDefined(types[name], `invalid param name '${name}'`);\n\t\t\t\t\t\n\t\t\t\t\tconst uplcValue = that.evalParam(name);\n\n\t\t\t\t\tconst value = (uplcValue instanceof UplcBool) ? new Bool(uplcValue.bool) : type.userType.fromUplcData(uplcValue.data);\n\t\t\t\t\t\t\n\t\t\t\t\ttarget[name] = value;\n\n\t\t\t\t\t// TODO: return Proxy instead?\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\treturn new Proxy(this.#parameters, handler);\n\t}\n\n\t/**\n\t * @param {Object.<string, HeliosData | any>} values\n\t */\n\tset parameters(values) {\n\t\tconst types = this.paramTypes;\n\n\t\tfor (let name in values) {\n\t\t\tconst rawValue = values[name];\n\n\t\t\tconst UserType = assertDefined(types[name], `invalid param name '${name}'`).userType;\n\n\t\t\tconst value = rawValue instanceof UserType ? rawValue : new UserType(rawValue);\n\n\t\t\tthis.#parameters[name] = value;\n\n\t\t\tthis.changeParamSafe(name, value._toUplcData());\n\t\t}\n\t}\n\n\t/**\n\t * @package\n\t * @param {IR} ir\n\t * @param {string[]} parameters\n\t * @returns {IR}\n\t */\n\twrapEntryPoint(ir, parameters) {\n\t\t// find the constStatements associated with the parameters\n\t\t/**\n\t\t * @type {(ConstStatement | null)[]}\n\t\t */\n\t\tconst parameterStatements = new Array(parameters.length).fill(null);\n\n\t\tif (parameters.length > 0) {\n\t\t\tfor (let statement of this.mainStatements) {\n\t\t\t\tif (statement instanceof ConstStatement) {\n\t\t\t\t\tconst i = parameters.findIndex(p => statement.name.value == p);\n\n\t\t\t\t\tif (i != -1) {\n\t\t\t\t\t\tparameterStatements[i] = statement;\n\t\t\t\t\t}\n\t\t\t\t} else if (statement instanceof ImportStatement && statement.origStatement instanceof ConstStatement) {\n\t\t\t\t\tconst i = parameters.findIndex(p => statement.name.value == p);\n\n\t\t\t\t\tif (i != -1) {\n\t\t\t\t\t\tparameterStatements[i] = statement.origStatement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparameters.forEach((p, i) => {\n\t\t\t\tif (parameterStatements[i] == null) {\n\t\t\t\t\tthrow new Error(`parameter ${p} not found (hint: must come before main)`);\n\t\t\t\t}\n\t\t\t});\n\t\t}\t\t\n\n\t\t/**\n\t\t * @type {Map<string, IR>}\n\t\t */\n\t\tconst map = new Map();\n\n\t\tfor (let [statement, _] of this.allStatements) {\n\t\t\tif (parameters.length > 0 && statement instanceof ConstStatement) {\n\t\t\t\tconst i = parameterStatements.findIndex(cs => cs === statement);\n\n\t\t\t\tif (i != -1) {\n\t\t\t\t\tlet ir = new IR(`__PARAM_${i}`);\n\n\t\t\t\t\tif (statement.type instanceof BoolType) {\n\t\t\t\t\t\tir = new IR([\n\t\t\t\t\t\t\tnew IR(\"__helios__common__unBoolData(\"),\n\t\t\t\t\t\t\tir,\n\t\t\t\t\t\t\tnew IR(\")\")\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.set(statement.path, ir); \n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatement.toIR(map);\n\n\t\t\tif (statement.name.value == \"main\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n \n\t\t// builtin functions are added when the IR program is built\n\t\t// also replace all tabs with four spaces\n\t\treturn wrapWithRawFunctions(IR.wrapWithDefinitions(ir, map));\n\t}\n\n\t/**\n\t * @package\n\t * @param {string[]}  parameters\n\t * @returns {IR}\n\t */\n\ttoIR(parameters = []) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\tprettyIR(simplify = false) {\n\t\tconst ir = this.toIR([]);\n\n\t\tconst irProgram = IRProgram.new(ir, this.#purpose, simplify);\n\n\t\treturn new Source(irProgram.toString()).pretty();\n\t}\n\n\t/**\n\t * @param {boolean} simplify \n\t * @returns {UplcProgram}\n\t */\n\tcompile(simplify = false) {\n\t\tconst ir = this.toIR([]);\n\n\t\tconst irProgram = IRProgram.new(ir, this.#purpose, simplify);\n\t\t\n\t\t//console.log(new Source(irProgram.toString()).pretty());\n\t\t\n\t\treturn irProgram.toUplc();\n\t}\n\n\t/**\n\t * Compile a special Uplc\n\t * @param {string[]} parameters\n\t * @param {boolean} simplify\n\t * @returns {UplcProgram}\n\t */\n\tcompileParametric(parameters, simplify = false) {\n\t\tassert(parameters.length > 0, \"expected at least 1 parameter (hint: use program.compile() instead)\");\n\n\t\tconst ir = this.toIR(parameters);\n\n\t\tconst irProgram = IRParametricProgram.new(ir, this.#purpose, parameters, simplify);\n\n\t\t// TODO: UplcParametricProgram\n\t\treturn irProgram.toUplc();\n\t}\n}\n\nclass RedeemerProgram extends Program {\n\t/**\n\t * @param {number} purpose\n\t * @param {Module[]} modules \n\t */\n\tconstructor(purpose, modules) {\n\t\tsuper(purpose, modules);\n\t}\n\n\t/**\n\t * @package\n\t * @param {GlobalScope} scope\n\t * @returns {TopScope}\n\t */\n\tevalTypesInternal(scope) {\n\t\tconst topScope = super.evalTypesInternal(scope);\n\n\t\t// check the 'main' function\n\n\t\tlet main = this.mainFunc;\n\t\tlet argTypeNames = main.argTypeNames;\n\t\tlet retTypes = main.retTypes;\n\t\tlet haveRedeemer = false;\n\t\tlet haveScriptContext = false;\n\t\tlet haveUnderscores = argTypeNames.some(name => name ==\"\");\n\n\t\tif (argTypeNames.length > 2) {\n\t\t\tthrow main.typeError(\"too many arguments for main\");\n\t\t} else if (haveUnderscores) {\n\t\t\t// empty type name comes from an underscore\n\t\t\tassert(argTypeNames.length == 2, \"expected 2 arguments\");\n\t\t} else if (argTypeNames.length != 2) {\n\t\t\tdeprecationWarning(\"main with variable arguments\", \"0.14.0\", \"use underscores instead\", \"https://www.hyperion-bt.org/helios-book/lang/script-structure.html#main-function-4\");\n\t\t}\n\n\t\tfor (let i = 0; i < argTypeNames.length; i++) {\n\t\t\tconst t = argTypeNames[i];\n\n\t\t\tif (t == \"\") {\n\t\t\t\tcontinue\n\t\t\t} else if (t == \"Redeemer\") {\n\t\t\t\tif (haveUnderscores && i != 0) {\n\t\t\t\t\tthrow main.typeError(`unexpected Redeemer type for arg ${i} of main`);\n\t\t\t\t}\n\n\t\t\t\tif (haveRedeemer) {\n\t\t\t\t\tthrow main.typeError(`duplicate 'Redeemer' argument`);\n\t\t\t\t} else if (haveScriptContext) {\n\t\t\t\t\tthrow main.typeError(`'Redeemer' must come before 'ScriptContext'`);\n\t\t\t\t} else {\n\t\t\t\t\thaveRedeemer = true;\n\t\t\t\t}\n\t\t\t} else if (t == \"ScriptContext\") {\n\t\t\t\tif (haveUnderscores && i != 1) {\n\t\t\t\t\tthrow main.typeError(`unexpected ScriptContext type for arg ${i} of main`);\n\t\t\t\t}\n\n\t\t\t\tif (haveScriptContext) {\n\t\t\t\t\tthrow main.typeError(`duplicate 'ScriptContext' argument`);\n\t\t\t\t} else {\n\t\t\t\t\thaveScriptContext = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow main.typeError(`illegal argument type, must be 'Redeemer' or 'ScriptContext', got '${t}'`);\n\t\t\t}\n\t\t}\n\n\t\tif (retTypes.length !== 1) {\n\t\t\tthrow main.typeError(`illegal number of return values for main, expected 1, got ${retTypes.length}`);\n\t\t} else if (!(retTypes[0] instanceof BoolType)) {\n\t\t\tthrow main.typeError(`illegal return type for main, expected 'Bool', got '${retTypes[0].toString()}'`);\n\t\t}\n\n\t\treturn topScope;\n\t}\n\n\t/**\n\t * @package\n\t * @param {string[]} parameters\n\t * @returns {IR} \n\t */\n\ttoIR(parameters = []) {\n\t\t/** @type {IR[]} */\n\t\tconst outerArgs = [];\n\n\t\t/** @type {IR[]} */\n\t\tconst innerArgs = [];\n\n\t\tfor (let t of this.mainFunc.argTypeNames) {\n\t\t\tif (t == \"Redeemer\") {\n\t\t\t\tinnerArgs.push(new IR(\"redeemer\"));\n\t\t\t\touterArgs.push(new IR(\"redeemer\"));\n\t\t\t} else if (t == \"ScriptContext\") {\n\t\t\t\tinnerArgs.push(new IR(\"ctx\"));\n\t\t\t\tif (outerArgs.length == 0) {\n\t\t\t\t\touterArgs.push(new IR(\"_\"));\n\t\t\t\t}\n\t\t\t\touterArgs.push(new IR(\"ctx\"));\n\t\t\t} else if (t == \"\") {\n\t\t\t\tinnerArgs.push(new IR(\"0\")); // use a literal to make life easier for the optimizer\n\t\t\t\touterArgs.push(new IR(\"_\"));\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t}\n\t\t}\n\n\t\twhile(outerArgs.length < 2) {\n\t\t\touterArgs.push(new IR(\"_\"));\n\t\t}\n\n\t\tconst ir = new IR([\n\t\t\tnew IR(`${TAB}/*entry point*/\\n${TAB}(`),\n\t\t\tnew IR(outerArgs).join(\", \"),\n\t\t\tnew IR(`) -> {\\n${TAB}${TAB}`),\n\t\t\tnew IR(`__core__ifThenElse(\\n${TAB}${TAB}${TAB}${this.mainPath}(`),\n\t\t\tnew IR(innerArgs).join(\", \"),\n\t\t\tnew IR(`),\\n${TAB}${TAB}${TAB}() -> {()},\\n${TAB}${TAB}${TAB}() -> {error(\"transaction rejected\")}\\n${TAB}${TAB})()`),\n\t\t\tnew IR(`\\n${TAB}}`),\n\t\t]);\n\n\t\treturn this.wrapEntryPoint(ir, parameters);\n\t}\n}\n\nclass DatumRedeemerProgram extends Program {\n\t/**\n\t * @param {number} purpose\n\t * @param {Module[]} modules\n\t */\n\tconstructor(purpose, modules) {\n\t\tsuper(purpose, modules);\n\t}\n\n\t/**\n\t * @package\n\t * @param {GlobalScope} scope \n\t * @returns {TopScope}\n\t */\n\tevalTypesInternal(scope) {\n\t\tconst topScope = super.evalTypesInternal(scope);\n\n\t\t// check the 'main' function\n\n\t\tconst main = this.mainFunc;\n\t\tconst argTypeNames = main.argTypeNames;\n\t\tconst retTypes = main.retTypes;\n\t\tconst haveUnderscores = argTypeNames.some(name => name == \"\");\n\t\tlet haveDatum = false;\n\t\tlet haveRedeemer = false;\n\t\tlet haveScriptContext = false;\n\n\t\tif (argTypeNames.length > 3) {\n\t\t\tthrow main.typeError(\"too many arguments for main\");\n\t\t} else if (haveUnderscores) {\n\t\t\tassert(argTypeNames.length == 3, \"expected 3 args\");\n\t\t} else if (argTypeNames.length != 3) {\n\t\t\tdeprecationWarning(\"main with variable arguments\", \"0.14.0\", \"use underscores instead\", \"https://www.hyperion-bt.org/helios-book/lang/script-structure.html#main-function-4\");\n\t\t}\n\n\t\tfor (let i = 0; i < argTypeNames.length; i++) {\n\t\t\tconst t = argTypeNames[i];\n\n\t\t\tif (t == \"\") {\n\t\t\t\tcontinue;\n\t\t\t} else if (t == \"Datum\") {\n\t\t\t\tif (haveUnderscores && i != 0) {\n\t\t\t\t\tthrow main.typeError(`unexpected Datum type for arg ${i} of main`);\n\t\t\t\t}\n\n\t\t\t\tif (haveDatum) {\n\t\t\t\t\tthrow main.typeError(\"duplicate 'Datum' argument\");\n\t\t\t\t} else if (haveRedeemer) {\n\t\t\t\t\tthrow main.typeError(\"'Datum' must come before 'Redeemer'\");\n\t\t\t\t} else if (haveScriptContext) {\n\t\t\t\t\tthrow main.typeError(\"'Datum' must come before 'ScriptContext'\");\n\t\t\t\t} else {\n\t\t\t\t\thaveDatum = true;\n\t\t\t\t}\n\t\t\t} else if (t == \"Redeemer\") {\n\t\t\t\tif (haveUnderscores && i != 1) {\n\t\t\t\t\tthrow main.typeError(`unexpected Redeemer type for arg ${i} of main`);\n\t\t\t\t}\n\n\t\t\t\tif (haveRedeemer) {\n\t\t\t\t\tthrow main.typeError(\"duplicate 'Redeemer' argument\");\n\t\t\t\t} else if (haveScriptContext) {\n\t\t\t\t\tthrow main.typeError(\"'Redeemer' must come before 'ScriptContext'\");\n\t\t\t\t} else {\n\t\t\t\t\thaveRedeemer = true;\n\t\t\t\t}\n\t\t\t} else if (t == \"ScriptContext\") {\n\t\t\t\tif (haveUnderscores && i != 2) {\n\t\t\t\t\tthrow main.typeError(`unexpected ScriptContext type for arg ${i} of main`);\n\t\t\t\t}\n\n\t\t\t\tif (haveScriptContext) {\n\t\t\t\t\tthrow main.typeError(\"duplicate 'ScriptContext' argument\");\n\t\t\t\t} else {\n\t\t\t\t\thaveScriptContext = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow main.typeError(`illegal argument type, must be 'Datum', 'Redeemer' or 'ScriptContext', got '${t}'`);\n\t\t\t}\n\t\t}\n\n\t\tif (retTypes.length !== 1) {\n\t\t\tthrow main.typeError(`illegal number of return values for main, expected 1, got ${retTypes.length}`);\n\t\t} else if (!(retTypes[0] instanceof BoolType)) {\n\t\t\tthrow main.typeError(`illegal return type for main, expected 'Bool', got '${retTypes[0].toString()}'`);\n\t\t}\n\n\t\treturn topScope;\n\t}\n\n\t/**\n\t * @package\n\t * @param {string[]} parameters\n\t * @returns {IR}\n\t */\n\ttoIR(parameters = []) {\n\t\t/** @type {IR[]} */\n\t\tconst outerArgs = [];\n\n\t\t/** @type {IR[]} */\n\t\tconst innerArgs = [];\n\n\t\tfor (let t of this.mainFunc.argTypeNames) {\n\t\t\tif (t == \"Datum\") {\n\t\t\t\tinnerArgs.push(new IR(\"datum\"));\n\t\t\t\touterArgs.push(new IR(\"datum\"));\n\t\t\t} else if (t == \"Redeemer\") {\n\t\t\t\tinnerArgs.push(new IR(\"redeemer\"));\n\t\t\t\tif (outerArgs.length == 0) {\n\t\t\t\t\touterArgs.push(new IR(\"_\"));\n\t\t\t\t}\n\t\t\t\touterArgs.push(new IR(\"redeemer\"));\n\t\t\t} else if (t == \"ScriptContext\") {\n\t\t\t\tinnerArgs.push(new IR(\"ctx\"));\n\t\t\t\twhile (outerArgs.length < 2) {\n\t\t\t\t\touterArgs.push(new IR(\"_\"));\n\t\t\t\t}\n\t\t\t\touterArgs.push(new IR(\"ctx\"));\n\t\t\t} else if (t == \"\") {\n\t\t\t\tinnerArgs.push(new IR(\"0\")); // use a literal to make life easier for the optimizer\n\t\t\t\touterArgs.push(new IR(\"_\"));\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t}\n\t\t}\n\n\t\twhile(outerArgs.length < 3) {\n\t\t\touterArgs.push(new IR(\"_\"));\n\t\t}\n\n\t\tconst ir = new IR([\n\t\t\tnew IR(`${TAB}/*entry point*/\\n${TAB}(`),\n\t\t\tnew IR(outerArgs).join(\", \"),\n\t\t\tnew IR(`) -> {\\n${TAB}${TAB}`),\n\t\t\tnew IR(`__core__ifThenElse(\\n${TAB}${TAB}${TAB}${this.mainPath}(`),\n\t\t\tnew IR(innerArgs).join(\", \"),\n\t\t\tnew IR(`),\\n${TAB}${TAB}${TAB}() -> {()},\\n${TAB}${TAB}${TAB}() -> {error(\"transaction rejected\")}\\n${TAB}${TAB})()`),\n\t\t\tnew IR(`\\n${TAB}}`),\n\t\t]);\n\n\t\treturn this.wrapEntryPoint(ir, parameters);\n\t}\n}\n\nclass TestingProgram extends Program {\n\t/**\n\t * @param {Module[]} modules \n\t */\n\tconstructor(modules) {\n\t\tsuper(ScriptPurpose.Testing, modules);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `testing ${this.name}\\n${super.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @returns {TopScope}\n\t */\n\tevalTypes() {\n\t\tconst scope = GlobalScope.new(ScriptPurpose.Testing);\n\n\t\tconst topScope = this.evalTypesInternal(scope);\n\n\t\t// main can have any arg types, and any return type \n\n\t\tif (this.mainFunc.retTypes.length > 1) {\n\t\t\tthrow this.mainFunc.typeError(\"program entry-point can only return one value\");\n\t\t}\n\n\t\treturn topScope;\n\t}\n\n\t/**\n\t * @package\n\t * @param {string[]} parameters\n\t * @returns {IR}\n\t */\n\ttoIR(parameters = []) {\n\t\tconst innerArgs = this.mainFunc.argTypes.map((t, i) => {\n\t\t\tif (t instanceof BoolType) {\n\t\t\t\treturn new IR(`__helios__common__unBoolData(arg${i})`);\n\t\t\t} else {\n\t\t\t\treturn new IR(`arg${i}`);\n\t\t\t}\n\t\t});\n\n\t\tlet ir = new IR([\n\t\t\tnew IR(`${this.mainPath}(`),\n\t\t\tnew IR(innerArgs).join(\", \"),\n\t\t\tnew IR(\")\"),\n\t\t]);\n\n\t\tif (this.mainFunc.retTypes[0] instanceof BoolType) {\n\t\t\tir = new IR([\n\t\t\t\tnew IR(\"__helios__common__boolData(\"),\n\t\t\t\tir,\n\t\t\t\tnew IR(\")\")\n\t\t\t]);\n\t\t}\n\n\t\tconst outerArgs = this.mainFunc.argTypes.map((_, i) => new IR(`arg${i}`));\n\n\t\tir = new IR([\n\t\t\tnew IR(`${TAB}/*entry point*/\\n${TAB}(`),\n\t\t\tnew IR(outerArgs).join(\", \"),\n\t\t\tnew IR(`) -> {\\n${TAB}${TAB}`),\n\t\t\tir,\n\t\t\tnew IR(`\\n${TAB}}`),\n\t\t]);\n\n\t\treturn this.wrapEntryPoint(ir, parameters);\n\t}\n}\n\nclass SpendingProgram extends DatumRedeemerProgram {\n\t/**\n\t * @param {Module[]} modules\n\t */\n\tconstructor(modules) {\n\t\tsuper(ScriptPurpose.Spending, modules);\n\t}\n\n\ttoString() {\n\t\treturn `spending ${this.name}\\n${super.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @returns {TopScope}\n\t */\n\tevalTypes() {\n\t\tconst scope = GlobalScope.new(ScriptPurpose.Spending);\n\n\t\treturn this.evalTypesInternal(scope);\t\n\t}\n}\n\nclass MintingProgram extends RedeemerProgram {\n\t/**\n\t * @param {Module[]} modules \n\t */\n\tconstructor(modules) {\n\t\tsuper(ScriptPurpose.Minting, modules);\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `minting ${this.name}\\n${super.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @returns {TopScope}\n\t */\n\tevalTypes() {\n\t\tconst scope = GlobalScope.new(ScriptPurpose.Minting);\n\n\t\treturn this.evalTypesInternal(scope);\t\n\t}\n}\n\nclass StakingProgram extends RedeemerProgram {\n\t/**\n\t * @param {Module[]} modules \n\t */\n\tconstructor(modules) {\n\t\tsuper(ScriptPurpose.Staking, modules);\n\t}\n\n\ttoString() {\n\t\treturn `staking ${this.name}\\n${super.toString()}`;\n\t}\n\n\t/**\n\t * @package\n\t * @returns {TopScope}\n\t */\n\tevalTypes() {\n\t\tconst scope = GlobalScope.new(ScriptPurpose.Staking);\n\n\t\treturn this.evalTypesInternal(scope);\t\n\t}\n}\n\n\n///////////////////////\n// Section 25: Tx types\n///////////////////////\n\nclass Tx extends CborData {\n\t/**\n\t * @type {TxBody}\n\t */\n\t#body;\n\n\t/**\n\t * @type {TxWitnesses}\n\t */\n\t#witnesses;\n\n\t/**\n\t * @type {boolean}\n\t */\n\t#valid;\n\n\t/** \n\t * @type {?TxMetadata} \n\t */\n\t#metadata;\n\n\t// the following field(s) aren't used by the serialization (only for building)\n\t/**\n\t * Upon finalization the slot is calculated and stored in the body\n\t * @type {?Date} \n\t */\n\t#validTo;\n\n\t/**\n\t * Upon finalization the slot is calculated and stored in the body \n\t *  @type {?Date} \n\t */\n\t#validFrom;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.#body = new TxBody();\n\t\tthis.#witnesses = new TxWitnesses();\n\t\tthis.#valid = false; // building is only possible if valid==false\n\t\tthis.#metadata = null;\n\t\tthis.#validTo = null;\n\t\tthis.#validFrom = null;\n\t}\n\n\t/**\n\t * @type {TxBody}\n\t */\n\tget body() {\n\t\treturn this.#body;\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget bodyHash() {\n\t\treturn Crypto.blake2b(this.#body.toCbor());\n\t}\n\n\t/**\n\t * @type {TxWitnesses}\n\t */\n\tget witnesses() {\n\t\treturn this.#witnesses;\n\t}\n\n\t/**\n\t * Used by emulator to check if tx is valid.\n\t * @param {bigint} slot\n\t * @returns {boolean}\n\t */\n\tisValid(slot) {\n\t\tif (!this.#valid) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.#body.isValid(slot);\n\t\t}\n\t}\n\n\t/** \n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tthis.#body.toCbor(),\n\t\t\tthis.#witnesses.toCbor(),\n\t\t\tCborData.encodeBool(this.#valid),\n\t\t\tthis.#metadata === null ? CborData.encodeNull() : this.#metadata.toCbor(),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {Tx}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tbytes = bytes.slice();\n\n\t\tlet tx = new Tx();\n\n\t\tlet n = CborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttx.#body = TxBody.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttx.#witnesses = TxWitnesses.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttx.#valid = CborData.decodeBool(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (CborData.isNull(fieldBytes)) {\n\t\t\t\t\t\tCborData.decodeNull(fieldBytes);\n\n\t\t\t\t\t\ttx.#metadata = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttx.#metadata = TxMetadata.fromCbor(fieldBytes);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"bad tuple size\");\n\t\t\t}\n\t\t});\n\n\t\tassert(n == 4);\n\t\tassert(bytes.length == 0);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tbody: this.#body.dump(),\n\t\t\twitnesses: this.#witnesses.dump(),\n\t\t\tvalid: this.#valid,\n\t\t\tmetadata: this.#metadata !== null ? this.#metadata.dump() : null\n\t\t};\n\t}\n\n\t/**\n\t * @param {Date} t\n\t * @returns {Tx}\n\t */\n\tvalidFrom(t) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#validFrom = t;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {Date} t\n\t * @returns {Tx}\n\t */\n\tvalidTo(t) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#validTo = t;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Throws error if assets of given mph are already being minted in this transaction\n\t * @param {MintingPolicyHash} mph \n\t * @param {[number[] | string, bigint][]} tokens - list of pairs of [tokenName, quantity], tokenName can be list of bytes or hex-string\n\t * @param {UplcDataValue | UplcData} redeemer\n\t * @returns {Tx}\n\t */\n\tmintTokens(mph, tokens, redeemer) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#body.addMint(mph, tokens.map(([name, amount]) => {\n\t\t\tif (typeof name == \"string\" ) {\n\t\t\t\treturn [hexToBytes(name), amount];\n\t\t\t} else {\n\t\t\t\treturn [name, amount];\n\t\t\t}\n\t\t}));\n\n\t\tthis.#witnesses.addMintingRedeemer(mph, UplcDataValue.unwrap(redeemer));\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {UTxO} input\n\t * @param {?(UplcDataValue | UplcData)} redeemer\n\t * @returns {Tx}\n\t */\n\taddInput(input, redeemer = null) {\n\t\tassert(!this.#valid);\n\n\t\tif (input.origOutput === null) {\n\t\t\tthrow new Error(\"TxInput.origOutput must be set when building transaction\");\n\t\t} else {\n\t\t\tvoid this.#body.addInput(input.asTxInput);\n\n\t\t\tif (redeemer !== null) {\n\t\t\t\tassert(input.origOutput.address.validatorHash !== null, \"input isn't locked by a script\");\n\n\t\t\t\tthis.#witnesses.addSpendingRedeemer(input.asTxInput, UplcDataValue.unwrap(redeemer));\n\n\t\t\t\tif (input.origOutput.datum === null) {\n\t\t\t\t\tthrow new Error(\"expected non-null datum\");\n\t\t\t\t} else {\n\t\t\t\t\tlet datum = input.origOutput.datum;\n\n\t\t\t\t\tif (datum instanceof HashedDatum) {\n\t\t\t\t\t\tlet datumData = datum.data;\n\t\t\t\t\t\tif (datumData === null) {\n\t\t\t\t\t\t\tthrow new Error(\"expected non-null datum data\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.#witnesses.addDatumData(datumData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert(input.origOutput.address.pubKeyHash !== null, \"input is locked by a script, but redeemer isn't specified\");\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {UTxO[]} inputs\n\t * @param {?(UplcDataValue | UplcData)} redeemer\n\t * @returns {Tx}\n\t */\n\taddInputs(inputs, redeemer = null) {\n\t\tfor (let input of inputs) {\n\t\t\tthis.addInput(input, redeemer);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {TxRefInput} input\n\t * @param {?UplcProgram} refScript\n\t * @returns {Tx}\n\t */\n\taddRefInput(input, refScript = null) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#body.addRefInput(input);\n\n\t\tif (refScript !== null) {\n\t\t\tthis.#witnesses.attachScript(refScript, true);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {TxRefInput[]} inputs\n\t * @returns {Tx}\n\t */\n\taddRefInputs(inputs) {\n\t\tfor (let input of inputs) {\n\t\t\tthis.addRefInput(input);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {TxOutput} output \n\t * @returns {Tx}\n\t */\n\taddOutput(output) {\n\t\tassert(!this.#valid);\n\t\t\n\t\t// min lovelace is checked during build, because \n\t\tthis.#body.addOutput(output);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {TxOutput[]} outputs \n\t * @returns {Tx}\n\t */\n\taddOutputs(outputs) {\n\t\tfor (let output of outputs) {\n\t\t\tthis.addOutput(output);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {PubKeyHash} hash\n\t * @returns {Tx}\n\t */\n\taddSigner(hash) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#body.addSigner(hash);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unused scripts are detected during finalize(), in which case an error is thrown\n\t * Throws error if script was already added before\n\t * @param {UplcProgram} program\n\t * @returns {Tx}\n\t */\n\tattachScript(program) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#witnesses.attachScript(program);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Usually adding only one collateral input is enough\n\t * Must be less than the limit in networkParams (eg. 3), or else an error is thrown during finalization\n\t * @param {UTxO} input \n\t * @returns {Tx}\n\t */\n\taddCollateral(input) {\n\t\tassert(!this.#valid);\n\n\t\tthis.#body.addCollateral(input.asTxInput);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates tx fee (including script execution)\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams\n\t * @returns {bigint}\n\t */\n\testimateFee(networkParams) {\n\t\tlet [a, b] = networkParams.txFeeParams;\n\n\t\tif (!this.#valid) {\n\t\t\t// add dummy signatures\n\t\t\tlet nUniquePubKeyHashes = this.#body.countUniqueSigners();\n\t\t\t\n\t\t\tthis.#witnesses.addDummySignatures(nUniquePubKeyHashes);\n\t\t}\n\n\t\tlet size = this.toCbor().length;\n\n\t\tif (!this.#valid) {\n\t\t\t// clean up the dummy signatures\n\t\t\tthis.#witnesses.removeDummySignatures();\n\t\t}\n\n\t\tlet sizeFee = BigInt(a) + BigInt(size)*BigInt(b);\n\n\t\tlet exFee = this.#witnesses.estimateFee(networkParams);\n\n\t\treturn sizeFee + exFee;\n\t}\n\n\t/**\n\t * Iterates until fee is exact\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams\n\t * @param {bigint} fee\n\t * @returns {bigint}\n\t */\n\tsetFee(networkParams, fee) {\n\t\tlet oldFee = this.#body.fee;\n\n\t\twhile (oldFee != fee) {\n\t\t\tthis.#body.setFee(fee);\n\n\t\t\toldFee = fee;\n\n\t\t\tfee = this.estimateFee(networkParams);\n\t\t}\n\n\t\treturn fee;\n\t}\n\n\t/**\n\t * Checks that all necessary scripts are included, and that all included scripts are used\n\t * Shouldn't be used directly\n\t */\n\tcheckScripts() {\n\t\tlet scripts = this.#witnesses.scripts;\n\n\t\t/**\n\t\t * @type {Set<string>}\n\t\t */\n\t\tconst currentScripts = new Set();\n\t\tscripts.forEach(script => {\n\t\t\tcurrentScripts.add(bytesToHex(script.hash()))\n\t\t})\n\n\t\t/** \n\t\t * @type {Map<string, number>} \n\t\t */\n\t\tlet wantedScripts = new Map();\n\n\t\tthis.#body.collectScriptHashes(wantedScripts);\n\n\t\tif (wantedScripts.size < scripts.length) {\n\t\t\tthrow new Error(\"too many scripts included\");\n\t\t} else if (wantedScripts.size > scripts.length) {\n\t\t\twantedScripts.forEach((value, key) => {\n\t\t\t\tif (!currentScripts.has(key)) {\n\t\t\t\t\tif (value >= 0) {\n\t\t\t\t\t\tthrow new Error(`missing script for input ${value}`);\n\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\tthrow new Error(`missing script for minting policy ${-value-1}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tcurrentScripts.forEach((key) => {\n\t\t\tif (!wantedScripts.has(key)) {\n\t\t\t\tconsole.log(wantedScripts, currentScripts)\n\t\t\t\tthrow new Error(\"unused script\");\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams \n\t * @param {Address} changeAddress\n\t * @returns {Promise<void>}\n\t */\n\tasync executeRedeemers(networkParams, changeAddress) {\n\t\tawait this.#witnesses.executeRedeemers(networkParams, this.#body, changeAddress);\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams \n\t * @returns {Promise<void>}\n\t */\n\tasync checkExecutionBudgets(networkParams) {\n\t\tawait this.#witnesses.checkExecutionBudgets(networkParams, this.#body);\n\t}\n\n\t/**\n\t * @param {Address} changeAddress \n\t */\n\tbalanceAssets(changeAddress) {\n\t\tconst inputAssets = this.#body.sumInputAndMintedAssets();\n\n\t\tconst outputAssets = this.#body.sumOutputAssets();\n\n\t\tif (inputAssets.eq(outputAssets)) {\n\t\t\treturn;\n\t\t} else if (outputAssets.ge(inputAssets)) {\n\t\t\tthrow new Error(\"not enough input assets\");\n\t\t} else {\n\t\t\tconst diff = inputAssets.sub(outputAssets);\n\n\t\t\tconst changeOutput = new TxOutput(changeAddress, new Value(0n, diff));\n\n\t\t\tthis.#body.addOutput(changeOutput);\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the base fee which will be multiplied by the required min collateral percentage \n\t * @param {NetworkParams} networkParams \n\t * @param {Address} changeAddress \n\t * @param {UTxO[]} spareUtxos \n\t */\n\testimateCollateralBaseFee(networkParams, changeAddress, spareUtxos) {\n\t\tassert(config.N_DUMMY_INPUTS == 1 || config.N_DUMMY_INPUTS == 2, \"expected N_DUMMY_INPUTs == 1 or N_DUMMY_INPUTS == 2\");\n\n\t\t// create the collateral return output (might not actually be added if there isn't enough lovelace)\n\t\tconst dummyOutput = new TxOutput(changeAddress, new Value(0n));\n\t\tdummyOutput.correctLovelace(networkParams);\n\n\t\t// some dummy UTxOs on to be able to correctly calculate the collateral (assuming it uses full body fee)\n\t\tconst dummyCollateral = spareUtxos.map(spare => spare.asTxInput).concat(this.#body.inputs).slice(0, 3);\n\t\tdummyCollateral.forEach(input => {\n\t\t\tthis.#body.collateral.push(input);\n\t\t});\n\n\t\tconst dummyInputs = dummyCollateral.slice(0, config.N_DUMMY_INPUTS);\n\n\t\tthis.#body.setCollateralReturn(dummyOutput);\n\t\tdummyInputs.forEach(dummyInput => this.#body.addInput(dummyInput, false));\n\t\tthis.#body.addOutput(dummyOutput);\n\n\t\tconst baseFee = this.estimateFee(networkParams);\n\n\t\t// remove the dummy inputs and outputs\n\t\twhile(this.#body.collateral.length) {\n\t\t\tthis.#body.collateral.pop();\n\t\t}\n\t\tthis.#body.setCollateralReturn(null);\n\t\tdummyInputs.forEach(dummyInput => this.#body.removeInput(dummyInput));\n\t\tthis.#body.removeOutput(dummyOutput);\n\n\t\treturn baseFee;\n\t}\n\t\n\t/**\n\t * @param {NetworkParams} networkParams\n\t * @param {Address} changeAddress\n\t * @param {UTxO[]} spareUtxos\n\t */\n\tbalanceCollateral(networkParams, changeAddress, spareUtxos) {\n\t\t// don't do this step if collateral was already added explicitly\n\t\tif (this.#body.collateral.length > 0 || !this.isSmart()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst baseFee = this.estimateCollateralBaseFee(networkParams, changeAddress, spareUtxos);\n\n\t\tconst minCollateral = ((baseFee*BigInt(networkParams.minCollateralPct)) + 100n)/100n; // integer division that rounds up\n\n\t\tlet collateral = 0n;\n\t\t/**\n\t\t * @type {TxInput[]}\n\t\t */\n\t\tconst collateralInputs = [];\n\n\t\t/**\n\t\t * @param {TxInput[]} inputs \n\t\t */\n\t\tfunction addCollateralInputs(inputs) {\n\t\t\t// first try using the UTxOs that already form the inputs\n\t\t\tconst cleanInputs = inputs.filter(utxo => utxo.value.assets.isZero()).sort((a, b) => Number(a.value.lovelace - b.value.lovelace));\n\n\t\t\tfor (let input of cleanInputs) {\n\t\t\t\tif (collateral > minCollateral) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\twhile (collateralInputs.length >= networkParams.maxCollateralInputs) {\n\t\t\t\t\tcollateralInputs.shift();\n\t\t\t\t}\n\t\n\t\t\t\tcollateralInputs.push(input);\n\t\t\t\tcollateral += input.value.lovelace;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddCollateralInputs(this.#body.inputs.slice());\n\n\t\taddCollateralInputs(spareUtxos.map(utxo => utxo.asTxInput));\n\n\t\t// create the collateral return output if there is enough lovelace\n\t\tconst changeOutput = new TxOutput(changeAddress, new Value(0n));\n\t\tchangeOutput.correctLovelace(networkParams);\n\n\t\tif (collateral < minCollateral) {\n\t\t\tthrow new Error(\"unable to find enough collateral input\");\n\t\t} else {\n\t\t\tif (collateral > minCollateral + changeOutput.value.lovelace) {\n\t\t\t\tchangeOutput.setValue(new Value(0n));\n\n\t\t\t\tchangeOutput.correctLovelace(networkParams);\n\n\t\t\t\tif (collateral > minCollateral + changeOutput.value.lovelace) {\n\t\t\t\t\tchangeOutput.setValue(new Value(collateral - minCollateral));\n\t\t\t\t\tthis.#body.setCollateralReturn(changeOutput);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(`not setting collateral return: collateral input too low (${collateral})`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcollateralInputs.forEach(utxo => {\n\t\t\tthis.#body.addCollateral(utxo);\n\t\t});\n\t}\n\n\t/**\n\t * Calculates fee and balances transaction by sending an output back to changeAddress\n\t * First assumes that change output isn't needed, and if that assumption doesn't result in a balanced transaction the change output is created.\n\t * Iteratively increments the fee because the fee increase the tx size which in turn increases the fee (always converges within two steps though).\n\t * Throws error if transaction can't be balanced.\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams \n\t * @param {Address} changeAddress\n\t * @param {UTxO[]} spareUtxos - used when there are yet enough inputs to cover everything (eg. due to min output lovelace requirements, or fees)\n\t */\n\tbalanceLovelace(networkParams, changeAddress, spareUtxos) {\n\t\t// don't include the changeOutput in this value\n\t\tlet nonChangeOutputValue = this.#body.sumOutputValue();\n\n\t\t// assume a change output is always needed\n\t\tconst changeOutput = new TxOutput(changeAddress, new Value(0n));\n\n\t\tchangeOutput.correctLovelace(networkParams);\n\n\t\tthis.#body.addOutput(changeOutput);\n\t\t\n\t\tconst minLovelace = changeOutput.value.lovelace;\n\n\t\tlet fee = this.setFee(networkParams, this.estimateFee(networkParams));\n\t\t\n\t\tlet inputValue = this.#body.sumInputAndMintedValue();\n\n\t\tlet feeValue = new Value(fee);\n\n\t\tnonChangeOutputValue = feeValue.add(nonChangeOutputValue);\n\n\t\tspareUtxos = spareUtxos.filter(utxo => utxo.value.assets.isZero());\n\t\t\n\t\t// use some spareUtxos if the inputValue doesn't cover the outputs and fees\n\n\t\twhile (!inputValue.ge(nonChangeOutputValue.add(changeOutput.value))) {\n\t\t\tlet spare = spareUtxos.pop();\n\n\t\t\tif (spare === undefined) {\n\t\t\t\tthrow new Error(\"transaction doesn't have enough inputs to cover the outputs + fees + minLovelace\");\n\t\t\t} else {\n\t\t\t\tthis.#body.addInput(spare.asTxInput);\n\n\t\t\t\tinputValue = inputValue.add(spare.value);\n\t\t\t}\n\t\t}\n\n\t\t// use to the exact diff, which is >= minLovelace\n\t\tlet diff = inputValue.sub(nonChangeOutputValue);\n\n\t\tassert(diff.assets.isZero(), \"unexpected unbalanced assets\");\n\t\tassert(diff.lovelace >= minLovelace);\n\n\t\tchangeOutput.setValue(diff);\n\n\t\t// we can mutate the lovelace value of 'changeOutput' until we have a balanced transaction with precisely the right fee\n\n\t\tlet oldFee = fee;\n\t\tfee = this.estimateFee(networkParams);\n\n\t\twhile (fee != oldFee) {\n\t\t\tthis.#body.setFee(fee);\n\n\t\t\tlet diffFee = fee - oldFee;\n\n\t\t\t// use some more spareUtxos\n\t\t\twhile (diffFee  > (changeOutput.value.lovelace - minLovelace)) {\n\t\t\t\tlet spare = spareUtxos.pop();\n\n\t\t\t\tif (spare === undefined) {\n\t\t\t\t\tthrow new Error(\"not enough clean inputs to cover fees\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.#body.addInput(spare.asTxInput);\n\n\t\t\t\t\tinputValue = inputValue.add(spare.value);\n\n\t\t\t\t\tdiff = diff.add(spare.value);\n\n\t\t\t\t\tchangeOutput.setValue(diff);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchangeOutput.value.setLovelace(changeOutput.value.lovelace - diffFee);\n\n\t\t\t// changeOutput.value.lovelace should still be >= minLovelace at this point\n\n\t\t\toldFee = fee;\n\n\t\t\tfee = this.estimateFee(networkParams);\n\t\t}\n\t}\n\n\t/**\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams\n\t */\n\tsyncScriptDataHash(networkParams) {\n\t\tconst hash = this.#witnesses.calcScriptDataHash(networkParams);\n\n\t\tthis.#body.setScriptDataHash(hash);\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisSmart() {\n\t\treturn this.#witnesses.scripts.length > 0;\n\t}\n\n\t/**\n\t * Throws an error if there isn't enough collateral\n\t * Also throws an error if the script doesn't require collateral, but collateral was actually included\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams \n\t */\n\tcheckCollateral(networkParams) {\n\t\tif (this.isSmart()) {\n\t\t\tlet minCollateralPct = networkParams.minCollateralPct;\n\n\t\t\t// only use the exBudget \n\n\t\t\tconst fee = this.#body.fee;\n\n\t\t\tthis.#body.checkCollateral(networkParams, BigInt(Math.ceil(minCollateralPct*Number(fee)/100.0)));\n\t\t} else {\n\t\t\tthis.#body.checkCollateral(networkParams, null);\n\t\t}\n\t}\n\n\t/**\n\t * Throws error if tx is too big\n\t * Shouldn't be used directly\n\t * @param {NetworkParams} networkParams \n\t */\n\tcheckSize(networkParams) {\n\t\tlet size = this.toCbor().length;\n\n\t\tif (size > networkParams.maxTxSize) {\n\t\t\tthrow new Error(\"tx too big\");\n\t\t}\n\t}\n\n\t/**\n\t * Final check that fee is big enough\n\t * @param {NetworkParams} networkParams \n\t */\n\tcheckFee(networkParams) {\n\t\tassert(this.estimateFee(networkParams) <= this.#body.fee, \"fee too small\");\n\t}\n\n\t/**\n\t * Assumes transaction hasn't yet been signed by anyone (i.e. witnesses.signatures is empty)\n\t * Mutates 'this'\n\t * Note: this is an async function so that a debugger can optionally be attached in the future\n\t * @param {NetworkParams} networkParams\n\t * @param {Address}       changeAddress\n\t * @param {UTxO[]}        spareUtxos - might be used during balancing if there currently aren't enough inputs\n\t * @returns {Promise<Tx>}\n\t */\n\tasync finalize(networkParams, changeAddress, spareUtxos = []) {\n\t\tassert(!this.#valid);\n\n\t\tif (this.#metadata !== null) {\n\t\t\t// Calculate the Metadata hash and add to the TxBody\n\t\t\tthis.#body.setMetadataHash(\n\t\t\t\tnew Hash(Crypto.blake2b(this.#metadata.toCbor()))\n\t\t\t);\n\t\t}\n\n\t\tif (this.#validTo !== null) {\n\t\t\tthis.#body.validTo(\n\t\t\t\tnetworkParams.timeToSlot(BigInt(this.#validTo.getTime()))\n\t\t\t);\n\t\t}\n\n\t\tif (this.#validFrom !== null) {\n\t\t\tthis.#body.validFrom(networkParams.timeToSlot(BigInt(this.#validFrom.getTime())));\n\t\t}\n\n\t\t// inputs, minted assets, and withdrawals must all be in a particular order\n\t\tthis.#body.sort();\n\n\t\t// after inputs etc. have been sorted we can calculate the indices of the redeemers referring to those inputs\n\t\tthis.#witnesses.updateRedeemerIndices(this.#body);\n\n\t\tthis.checkScripts();\n\n\t\t// balance the non-ada assets\n\t\tthis.balanceAssets(changeAddress)\n\n\t\t// make sure that each output contains the necessary minimum amount of lovelace\t\n\t\tthis.#body.correctOutputs(networkParams);\n\n\t\t// the scripts executed at this point will not see the correct txHash nor the correct fee\n\t\tawait this.executeRedeemers(networkParams, changeAddress);\n\n\t\t// balance collateral (if collateral wasn't already set manually)\n\t\tthis.balanceCollateral(networkParams, changeAddress, spareUtxos.slice());\n\n\t\t// balance the lovelace\n\t\tthis.balanceLovelace(networkParams, changeAddress, spareUtxos.slice());\n\n\t\t// run updateRedeemerIndices again because new inputs may have been added and sorted\n\t\tthis.#witnesses.updateRedeemerIndices(this.#body);\n\n\t\t// we can only sync scriptDataHash after the redeemer execution costs have been estimated, and final redeemer indices have been determined\n\t\tthis.syncScriptDataHash(networkParams);\n\n\t\t// a bunch of checks\n\t\tthis.#body.checkOutputs(networkParams);\n\n\t\tthis.checkCollateral(networkParams);\n\n\t\tawait this.checkExecutionBudgets(networkParams);\n\n\t\tthis.#witnesses.checkExecutionBudgetLimits(networkParams);\n\n\t\tthis.checkSize(networkParams);\n\n\t\tthis.checkFee(networkParams);\n\n\t\tthis.#valid = true;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Throws an error if verify==true and signature is invalid \n\t * Adding many signatures might be a bit slow\n\t * @param {Signature} signature \n\t * @param {boolean} verify\n\t * @returns {Tx}\n\t */\n\taddSignature(signature, verify = true) {\n\t\tassert(this.#valid);\n\n\t\tif (verify) {\n\t\t\tsignature.verify(this.bodyHash);\n\t\t}\n\n\t\tthis.#witnesses.addSignature(signature);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Throws an error if verify==true and any of the signatures is invalid\n\t * Adding many signatures might be a bit slow\n\t * @param {Signature[]} signatures \n\t * @param {boolean} verify \n\t * @returns {Tx}\n\t */\n\taddSignatures(signatures, verify = true) {\n\t\tfor (let s of signatures) {\n\t\t\tthis.addSignature(s, verify);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {number} tag\n\t * @param {Metadata} data\n\t * @returns {Tx}\n\t */\n\taddMetadata(tag, data) {\n\t\tif (this.#metadata === null) {\n\t\t\tthis.#metadata = new TxMetadata();\n\t\t}\n\n\t\tthis.#metadata.add(tag, data);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {TxId}\n\t */\n\tid() {\n\t\tassert(this.#valid, \"can't get TxId of unfinalized Tx\");\n\t\treturn new TxId(this.bodyHash);\n\t}\n}\n\n/**\n * inputs, minted assets, and withdrawals need to be sorted in order to form a valid transaction\n */\nclass TxBody extends CborData {\n\t/**\n\t * Inputs must be sorted before submitting (first by TxId, then by utxoIndex)\n\t * Spending redeemers must point to the sorted inputs\n\t * @type {TxInput[]} \n\t */\n\t#inputs;\n\n\t/** @type {TxOutput[]} */\n\t#outputs;\n\n\t/** @type {bigint} in lovelace */\n\t#fee;\n\n\t/** @type {?bigint} */\n\t#lastValidSlot;\n\n\t/** @type {DCert[]} */\n\t#certs;\n\n\t/**\n\t * Withdrawals must be sorted by address\n\t * Stake rewarding redeemers must point to the sorted withdrawals\n\t * @type {Map<Address, bigint>} \n\t */\n\t#withdrawals;\n\n\t/** @type {?bigint} */\n\t#firstValidSlot;\n\n\t/**\n\t * Internally the assets must be sorted by mintingpolicyhash\n\t * Minting redeemers must point to the sorted minted assets\n\t * @type {Assets} \n\t */\n\t#minted;\n\n\t/** @type {?Hash} */\n\t#scriptDataHash;\n\n\t/** @type {TxInput[]} */\n\t#collateral;\n\n\t/** @type {PubKeyHash[]} */\n\t#signers;\n\n\t/** @type {?TxOutput} */\n\t#collateralReturn;\n\n\t/** @type {bigint} */\n\t#totalCollateral;\n\n\t/** @type {TxInput[]} */\n\t#refInputs;\n\n\t/** @type {?Hash} */\n\t#metadataHash;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.#inputs = [];\n\t\tthis.#outputs = [];\n\t\tthis.#fee = 0n;\n\t\tthis.#lastValidSlot = null;\n\t\tthis.#certs = [];\n\t\tthis.#withdrawals = new Map();\n\t\tthis.#firstValidSlot = null;\n\t\tthis.#minted = new Assets(); // starts as zero value (i.e. empty map)\n\t\tthis.#scriptDataHash = new Hash((new Array(32)).fill(0)); // initially dummy for more correct body size, (re)calculated upon finalization\n\t\tthis.#collateral = [];\n\t\tthis.#signers = [];\n\t\tthis.#collateralReturn = null;\n\t\tthis.#totalCollateral = 0n; // doesn't seem to be used anymore\n\t\tthis.#refInputs = [];\n\t\tthis.#metadataHash = null;\n\t}\n\n\t/**\n\t * @type {TxInput[]}\n\t */\n\tget inputs() {\n\t\treturn this.#inputs;\n\t}\n\n\t/**\n\t * @type {TxOutput[]}\n\t */\n\tget outputs() {\n\t\treturn this.#outputs;\n\t}\n\n\tget fee() {\n\t\treturn this.#fee;\n\t}\n\n\t/**\n\t * @param {bigint} fee\n\t */\n\tsetFee(fee) {\n\t\tthis.#fee = fee;\n\t}\n\n\t/**\n\t * @type {Assets}\n\t */\n\tget minted() {\n\t\treturn this.#minted;\n\t}\n\n\t/**\n\t * @type {TxInput[]}\n\t */\n\tget collateral() {\n\t\treturn this.#collateral;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\t/**\n\t\t * @type {Map<number, number[]>}\n\t\t */\n\t\tlet object = new Map();\n\n\t\tobject.set(0, CborData.encodeDefList(this.#inputs));\n\t\tobject.set(1, CborData.encodeDefList(this.#outputs));\n\t\tobject.set(2, CborData.encodeInteger(this.#fee));\n\t\t\n\t\tif (this.#lastValidSlot !== null) {\n\t\t\tobject.set(3, CborData.encodeInteger(this.#lastValidSlot));\n\t\t}\n\n\t\tif (this.#certs.length != 0) {\n\t\t\tobject.set(4, CborData.encodeDefList(this.#certs));\n\t\t}\n\n\t\tif (this.#withdrawals.size != 0) {\n\t\t\tthrow new Error(\"not yet implemented\");\n\t\t}\n\n\t\tif (this.#metadataHash !== null) {\n\t\t\tobject.set(7, this.#metadataHash.toCbor());\n\t\t}\n\n\t\tif (this.#firstValidSlot !== null) {\n\t\t\tobject.set(8, CborData.encodeInteger(this.#firstValidSlot));\n\t\t}\n\n\t\tif (!this.#minted.isZero()) {\n\t\t\tobject.set(9, this.#minted.toCbor());\n\t\t}\n\n\t\tif (this.#scriptDataHash !== null) {\n\t\t\tobject.set(11, this.#scriptDataHash.toCbor());\n\t\t}\n\n\t\tif (this.#collateral.length != 0) {\n\t\t\tobject.set(13, CborData.encodeDefList(this.#collateral));\n\t\t}\n\n\t\tif (this.#signers.length != 0) {\n\t\t\tobject.set(14, CborData.encodeDefList(this.#signers));\n\t\t}\n\n\t\t// what is NetworkId used for?\n\t\t//object.set(15, CborData.encodeInteger(2n));\n\n\t\tif (this.#collateralReturn !== null) {\n\t\t\tobject.set(16, this.#collateralReturn.toCbor());\n\t\t}\n\n\t\tif (this.#totalCollateral > 0n) {\n\t\t\tobject.set(17, CborData.encodeInteger(this.#totalCollateral));\n\t\t}\n\n\t\tif (this.#refInputs.length != 0) {\n\t\t\tobject.set(18, CborData.encodeDefList(this.#refInputs));\n\t\t}\n\n\t\treturn CborData.encodeObject(object);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {TxBody}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tlet txBody = new TxBody();\n\n\t\tlet done = CborData.decodeObject(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxBody.#inputs.push(TxInput.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxBody.#outputs.push(TxOutput.fromCbor(itemBytes));\n\t\t\t\t\t})\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttxBody.#fee = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\ttxBody.#lastValidSlot = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxBody.#certs.push(DCert.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tthrow new Error(\"not yet implemented\");\n\t\t\t\tcase 6:\n\t\t\t\t\tthrow new Error(\"not yet implemented\");\n\t\t\t\tcase 7:\n\t\t\t\t\ttxBody.#metadataHash = Hash.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\ttxBody.#firstValidSlot = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\ttxBody.#minted = Assets.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tthrow new Error(\"unhandled field\");\n\t\t\t\tcase 11:\n\t\t\t\t\ttxBody.#scriptDataHash = Hash.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tthrow new Error(\"unhandled field\");\n\t\t\t\tcase 13:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxBody.#collateral.push(TxInput.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxBody.#signers.push(PubKeyHash.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 15:\n\t\t\t\t\tassert(CborData.decodeInteger(fieldBytes) == 2n);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\ttxBody.#collateralReturn = TxOutput.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 17:\n\t\t\t\t\ttxBody.#totalCollateral = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\t\tCborData.decodeList(fieldBytes, itemBytes => {\n\t\t\t\t\t\ttxBody.#refInputs.push(TxInput.fromCbor(fieldBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\tassert(done.has(0) && done.has(1) && done.has(2));\n\n\t\treturn txBody;\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tinputs: this.#inputs.map(input => input.dump()),\n\t\t\toutputs: this.#outputs.map(output => output.dump()),\n\t\t\tfee: this.#fee.toString(),\n\t\t\tlastValidSlot: this.#lastValidSlot === null ? null : this.#lastValidSlot.toString(),\n\t\t\tfirstValidSlot: this.#firstValidSlot === null ? null : this.#firstValidSlot.toString(),\n\t\t\tminted: this.#minted.isZero() ? null : this.#minted.dump(),\n\t\t\tmetadataHash: this.#metadataHash === null ? null : this.#metadataHash.dump(),\n\t\t\tscriptDataHash: this.#scriptDataHash === null ? null : this.#scriptDataHash.dump(),\n\t\t\tcollateral: this.#collateral.length == 0 ? null : this.#collateral.map(c => c.dump()),\n\t\t\tsigners: this.#signers.length == 0 ? null : this.#signers.map(rs => rs.dump()),\n\t\t\tcollateralReturn: this.#collateralReturn === null ? null : this.#collateralReturn.dump(),\n\t\t\t//totalCollateral: this.#totalCollateral.toString(), // doesn't seem to be used anymore\n\t\t\trefInputs: this.#refInputs.map(ri => ri.dump()),\n\t\t};\n\t}\n\n\t/**\n\t * For now simply returns minus infinity to plus infinity (WiP)\n\t * @param {NetworkParams} networkParams\n\t * @returns {ConstrData}\n\t */\n\ttoValidTimeRangeData(networkParams) {\n\t\treturn new ConstrData(0, [\n\t\t\tnew ConstrData(0, [ // LowerBound\n\t\t\t\tthis.#firstValidSlot === null ? new ConstrData(0, []) : new ConstrData(1, [new IntData(networkParams.slotToTime(this.#firstValidSlot))]), // NegInf\n\t\t\t\tnew ConstrData(1, []), // true\n\t\t\t]),\n\t\t\tnew ConstrData(0, [ // UpperBound\n\t\t\t\tthis.#lastValidSlot === null ? new ConstrData(2, []) : new ConstrData(1, [new IntData(networkParams.slotToTime(this.#lastValidSlot))]), // PosInf\n\t\t\t\tnew ConstrData(1, []), // true\n\t\t\t]),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams\n\t * @param {Redeemer[]} redeemers\n\t * @param {ListData} datums \n\t * @param {TxId} txId\n\t * @returns {ConstrData}\n\t */\n\ttoTxData(networkParams, redeemers, datums, txId) {\n\t\treturn new ConstrData(0, [\n\t\t\tnew ListData(this.#inputs.map(input => input.toData())),\n\t\t\tnew ListData(this.#refInputs.map(input => input.toData())),\n\t\t\tnew ListData(this.#outputs.map(output => output.toData())),\n\t\t\t(new Value(this.#fee))._toUplcData(),\n\t\t\t// NOTE: all other Value instances in ScriptContext contain some lovelace, but #minted can never contain any lovelace, yet cardano-node always prepends 0 lovelace to the #minted MapData\n\t\t\t(new Value(0n, this.#minted))._toUplcData(true), \n\t\t\tnew ListData(this.#certs.map(cert => cert.toData())),\n\t\t\tnew MapData(Array.from(this.#withdrawals.entries()).map(w => [w[0].toStakingData(), new IntData(w[1])])),\n\t\t\tthis.toValidTimeRangeData(networkParams),\n\t\t\tnew ListData(this.#signers.map(rs => new ByteArrayData(rs.bytes))),\n\t\t\tnew MapData(redeemers.map(r => [r.toScriptPurposeData(this), r.data])),\n\t\t\tnew MapData(datums.list.map(d => [\n\t\t\t\tnew ByteArrayData(Crypto.blake2b(d.toCbor())), \n\t\t\t\td\n\t\t\t])),\n\t\t\tnew ConstrData(0, [new ByteArrayData(txId.bytes)])\n\t\t]);\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams \n\t * @param {Redeemer[]} redeemers\n\t * @param {ListData} datums\n\t * @param {number} redeemerIdx\n\t * @returns {UplcData}\n\t */\n\ttoScriptContextData(networkParams, redeemers, datums, redeemerIdx) {\t\t\n\t\treturn new ConstrData(0, [\n\t\t\t// tx (we can't know the txId right now, because we don't know the execution costs yet, but a dummy txId should be fine)\n\t\t\tthis.toTxData(networkParams, redeemers, datums, TxId.dummy()),\n\t\t\tredeemers[redeemerIdx].toScriptPurposeData(this),\n\t\t]);\n\t}\n\n\t/**\n\t * @returns {Value}\n\t */\n\tsumInputValue() {\n\t\tlet sum = new Value();\n\n\t\tfor (let input of this.#inputs) {\n\t\t\tif (input.origOutput !== null) {\n\t\t\t\tsum = sum.add(input.origOutput.value);\n\t\t\t}\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Throws error if any part of the sum is negative (i.e. more is burned than input)\n\t * @returns {Value}\n\t */\n\tsumInputAndMintedValue() {\n\t\treturn this.sumInputValue().add(new Value(0n, this.#minted)).assertAllPositive();\n\t}\n\n\t/**\n\t * @returns {Assets}\n\t */\n\tsumInputAndMintedAssets() {\n\t\treturn this.sumInputAndMintedValue().assets;\n\t}\n\n\t/**\n\t * @returns {Value}\n\t */\n\tsumOutputValue() {\n\t\tlet sum = new Value();\n\n\t\tfor (let output of this.#outputs) {\n\t\t\tsum = sum.add(output.value);\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t/**\n\t * @returns {Assets}\n\t */\n\tsumOutputAssets() {\n\t\treturn this.sumOutputValue().assets;\n\t}\n\n\t/**\n\t * @param {bigint} slot\n\t */\n\tvalidFrom(slot) {\n\t\tthis.#firstValidSlot = slot;\n\t}\n\n\t/**\n\t * @param {bigint} slot\n\t */\n\tvalidTo(slot) {\n\t\tthis.#lastValidSlot = slot;\n\t}\n\n\t/**\n\t * Throws error if this.#minted already contains mph\n\t * @param {MintingPolicyHash} mph - minting policy hash\n\t * @param {[number[], bigint][]} tokens\n\t */\n\taddMint(mph, tokens) {\n\t\tthis.#minted.addTokens(mph, tokens);\n\t}\n\n\t/**\n\t * @param {TxInput} input \n\t * @param {boolean} checkUniqueness\n\t */\n\taddInput(input, checkUniqueness = true) {\n\t\tif (input.origOutput === null) {\n\t\t\tthrow new Error(\"TxInput.origOutput must be set when building transaction\");\n\t\t}\n\n\t\tinput.origOutput.value.assertAllPositive();\n\n\t\tif (checkUniqueness) {\n\t\t\tassert(this.#inputs.every(prevInput => {\n\t\t\t\treturn  !prevInput.txId.eq(input.txId) || prevInput.utxoIdx != input.utxoIdx\n\t\t\t}), \"input already added before\");\n\t\t}\n\n\t\t// push, then sort immediately\n\t\tthis.#inputs.push(input);\n\t\tthis.#inputs.sort(TxInput.comp);\n\t}\n\n\t/**\n\t * Used to remove dummy inputs\n\t * Dummy inputs are needed to be able to correctly estimate fees\n\t * Throws an error if input doesn't exist in list of inputs\n\t * Internal use only!\n\t * @param {TxInput} input\n\t */\n\tremoveInput(input) {\n\t\tlet idx = -1;\n\n\t\t// search from end, so removal is exact inverse of addition\n\t\tfor (let i = this.#inputs.length - 1; i >= 0; i--) {\n\t\t\tif (this.#inputs[i] == input) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst n = this.#inputs.length;\n\n\t\tassert(idx != -1, \"input not found\");\n\n\t\tthis.#inputs = this.#inputs.filter((_, i) => i != idx);\n\n\t\tassert(this.#inputs.length == n - 1, \"input not removed\");\n\t}\n\n\t/**\n\t * @param {TxInput} input \n\t */\n\taddRefInput(input) {\n\t\tthis.#refInputs.push(input);\n\t}\n\n\t/**\n\t * @param {TxOutput} output\n\t */\n\taddOutput(output) {\n\t\toutput.value.assertAllPositive();\n\n\t\tthis.#outputs.push(output);\n\t}\n\n\t/**\n\t * Used to remove dummy outputs\n\t * Dummy outputs are needed to be able to correctly estimate fees\n\t * Throws an error if the output doesn't exist in list of outputs\n\t * Internal use only!\n\t * @param {TxOutput} output \n\t */\n\tremoveOutput(output) {\n\t\tlet idx = -1;\n\n\t\t// search from end, so removal is exact inverse of addition\n\t\tfor (let i = this.#outputs.length - 1; i >= 0; i--) {\n\t\t\tif (this.#outputs[i] == output) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst n = this.#outputs.length;\n\n\t\tassert(idx != -1, \"output not found\");\n\n\t\tthis.#outputs = this.#outputs.filter((_, i) => i != idx);\n\n\t\tassert(this.#outputs.length == n - 1, \"output not removed\");\n\t}\n\n\t/**\n\t * @param {PubKeyHash} hash \n\t */\n\taddSigner(hash) {\n\t\tthis.#signers.push(hash);\n\t}\n\n\t/**\n\t * @param {TxInput} input \n\t */\n\taddCollateral(input) {\n\t\tthis.#collateral.push(input);\n\t}\n\t\n\t/**\n\t * @param {Hash | null} scriptDataHash\n\t */\n\tsetScriptDataHash(scriptDataHash) {\n\t\tthis.#scriptDataHash = scriptDataHash;\n\t}\n\n\t/**\n\t * @param {Hash} metadataHash\n\t */\n\tsetMetadataHash(metadataHash) {\n\t\tthis.#metadataHash = metadataHash;\n\t}\n\n\t/**\n\t * @param {TxOutput | null} output \n\t */\n\tsetCollateralReturn(output) {\n\t\tthis.#collateralReturn = output;\n\t}\n\n\t/**\n\t * Calculates the number of dummy signatures needed to get precisely the right tx size\n\t * @returns {number}\n\t */\n\tcountUniqueSigners() {\n\t\t/** @type {Set<PubKeyHash>} */\n\t\tlet set = new Set();\n\n\t\tconst inputs = this.#inputs.concat(this.#collateral);\n\n\t\tfor (let input of inputs) {\n\t\t\tlet origOutput = input.origOutput;\n\n\t\t\tif (origOutput !== null) {\n\t\t\t\tlet pubKeyHash = origOutput.address.pubKeyHash;\n\n\t\t\t\tif (pubKeyHash !== null) {\n\t\t\t\t\tset.add(pubKeyHash);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let rs of this.#signers) {\n\t\t\tset.add(rs);\n\t\t}\n\n\t\treturn set.size;\n\t}\n\n\t/**\n\t * Script hashes are found in addresses of TxInputs and hashes of the minted MultiAsset\n\t * @param {Map<string, number>} set - hashes in hex format\n\t */\n\tcollectScriptHashes(set) {\n\t\tfor (let i = 0; i < this.#inputs.length; i++) {\n\t\t\tconst input = this.#inputs[i];\n\n\t\t\tif (input.origOutput !== null) {\n\t\t\t\tlet scriptHash = input.origOutput.address.validatorHash;\n\n\t\t\t\tif (scriptHash !== null) {\n\t\t\t\t\tconst hash = bytesToHex(scriptHash.bytes);\n\n\t\t\t\t\tif (!set.has(hash)) { \n\t\t\t\t\t\tset.set(hash, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet mphs = this.#minted.mintingPolicies;\n\n\t\tfor (let i = 0; i < mphs.length; i++) {\n\t\t\tconst mph = mphs[i];\n\n\t\t\tconst hash = bytesToHex(mph.bytes);\n\n\t\t\tif (!set.has(hash)) {\n\t\t\t\tset.set(hash, -i-1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes sure each output contains the necessary min lovelace\n\t * @param {NetworkParams} networkParams\n\t */\n\tcorrectOutputs(networkParams) {\n\t\tfor (let output of this.#outputs) {\n\t\t\toutput.correctLovelace(networkParams);\n\t\t}\n\t}\n\n\t/**\n\t * Checks that each output contains enough lovelace\n\t * @param {NetworkParams} networkParams\n\t */\n\tcheckOutputs(networkParams) {\n\t\tfor (let output of this.#outputs) {\n\t\t\tlet minLovelace = output.calcMinLovelace(networkParams);\n\n\t\t\tassert(minLovelace <= output.value.lovelace, `not enough lovelace in output (expected at least ${minLovelace.toString()}, got ${output.value.lovelace})`);\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {NetworkParams} networkParams\n\t * @param {?bigint} minCollateral \n\t */\n\tcheckCollateral(networkParams, minCollateral) {\n\t\tassert(this.#collateral.length <= networkParams.maxCollateralInputs);\n\n\t\tif (minCollateral === null) {\n\t\t\tassert(this.#collateral.length == 0, \"unnecessary collateral included\");\n\t\t} else {\n\t\t\tlet sum = new Value();\n\n\t\t\tfor (let col of this.#collateral) {\n\t\t\t\tif (col.origOutput === null) {\n\t\t\t\t\tthrow new Error(\"expected collateral TxInput.origOutput to be set\");\n\t\t\t\t} else if (!col.origOutput.value.assets.isZero()) {\n\t\t\t\t\tthrow new Error(\"collateral can only contain lovelace\");\n\t\t\t\t} else {\n\t\t\t\t\tsum = sum.add(col.origOutput.value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.#collateralReturn != null) {\n\t\t\t\tsum = sum.sub(this.#collateralReturn.value);\n\t\t\t}\n\n\t\t\tassert(sum.lovelace >= minCollateral, \"not enough collateral\");\n\n\t\t\tif (sum.lovelace > minCollateral*5n){\n\t\t\t\tconsole.error(\"Warning: way too much collateral\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes sore inputs, withdrawals, and minted assets are in correct order\n\t * Mutates\n\t */\n\tsort() {\n\t\t// inputs should've been added in sorted manner, so this is just a check\n\t\tthis.#inputs.forEach((input, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tconst prev = this.#inputs[i-1];\n\n\t\t\t\t// can be less than -1 if utxoIds aren't consecutive\n\t\t\t\tassert(TxInput.comp(prev, input) <= -1, \"inputs not sorted\");\n\t\t\t}\n\t\t});\n\n\t\t// TODO: also add withdrawals in sorted manner\n\t\tthis.#withdrawals = new Map(Array.from(this.#withdrawals.entries()).sort((a, b) => {\n\t\t\treturn Address.compStakingHashes(a[0], b[0]);\n\t\t}));\n\n\t\t// minted assets should've been added in sorted manner, so this is just a check\n\t\tthis.#minted.assertSorted();\n\t}\n\n\t/**\n\t * Used by (indirectly) by emulator to check if slot range is valid.\n\t * @param {bigint} slot\n\t */\n\tisValid(slot) {\n\t\tif (this.#lastValidSlot != null) {\n\t\t\tif (slot > this.#lastValidSlot) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.#firstValidSlot != null) {\n\t\t\tif (slot < this.#firstValidSlot) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nclass TxWitnesses extends CborData {\n\t/** @type {Signature[]} */\n\t#signatures;\n\n\t/** @type {ListData} */\n\t#datums;\n\n\t/** @type {Redeemer[]} */\n\t#redeemers;\n\n\t/** @type {UplcProgram[]} */\n\t#scripts;\n\n\t/** @type {UplcProgram[]} */\n\t#refScripts;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.#signatures = [];\n\t\tthis.#datums = new ListData([]);\n\t\tthis.#redeemers = [];\n\t\tthis.#scripts = [];\n\t\tthis.#refScripts = [];\n\t}\n\n\t/**\n\t * @type {Signature[]}\n\t */\n\tget signatures() {\n\t\treturn this.#signatures;\n\t}\n\n\t/**\n\t * Returns all the scripts, including the reference scripts\n\t * @type {UplcProgram[]}\n\t */\n\tget scripts() {\n\t\treturn this.#scripts.slice().concat(this.#refScripts.slice());\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\t/**\n\t\t * @type {Map<number, number[]>}\n\t\t */\n\t\tlet object = new Map();\n\n\t\tif (this.#signatures.length != 0) {\n\t\t\tobject.set(0, CborData.encodeDefList(this.#signatures));\n\t\t}\n\n\t\tif (this.#datums.list.length != 0) {\n\t\t\tobject.set(4, this.#datums.toCbor());\n\t\t}\n\n\t\tif (this.#redeemers.length != 0) {\n\t\t\tobject.set(5, CborData.encodeDefList(this.#redeemers));\n\t\t}\n\n\t\tif (this.#scripts.length != 0) {\n\t\t\t/**\n\t\t\t * @type {number[][]}\n\t\t\t */\n\t\t\tlet scriptBytes = this.#scripts.map(s => s.toCbor());\n\n\t\t\tobject.set(6, CborData.encodeDefList(scriptBytes));\n\t\t}\n\n\t\treturn CborData.encodeObject(object);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {TxWitnesses}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tlet txWitnesses = new TxWitnesses();\n\n\t\tCborData.decodeObject(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxWitnesses.#signatures.push(Signature.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tthrow new Error(\"unhandled field\");\n\t\t\t\tcase 4:\n\t\t\t\t\ttxWitnesses.#datums = ListData.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxWitnesses.#redeemers.push(Redeemer.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tCborData.decodeList(fieldBytes, (_, itemBytes) => {\n\t\t\t\t\t\ttxWitnesses.#scripts.push(UplcProgram.fromCbor(itemBytes));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\treturn txWitnesses;\n\t}\n\n\t/**\n\t * Throws error if signatures are incorrect\n\t * @param {number[]} bodyBytes \n\t */\n\tverifySignatures(bodyBytes) {\n\t\tfor (let signature of this.#signatures) {\n\t\t\tsignature.verify(Crypto.blake2b(bodyBytes));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tsignatures: this.#signatures.map(pkw => pkw.dump()),\n\t\t\tdatums: this.#datums.list.map(datum => datum.toString()),\n\t\t\tredeemers: this.#redeemers.map(redeemer => redeemer.dump()),\n\t\t\tscripts: this.#scripts.map(script => bytesToHex(script.toCbor())),\n\t\t\trefScripts: this.#refScripts.map(script => bytesToHex(script.toCbor())),\n\t\t};\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams\n\t * @returns {bigint}\n\t */\n\testimateFee(networkParams) {\n\t\tlet sum = 0n;\n\n\t\tfor (let redeemer of this.#redeemers) {\n\t\t\tsum += redeemer.estimateFee(networkParams);\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\t/**\n\t * @param {Signature} signature \n\t */\n\taddSignature(signature) {\n\t\tthis.#signatures.push(signature);\n\t}\n\n\t/**\n\t * @param {number} n\n\t */\n\taddDummySignatures(n) {\n\t\tfor (let i = 0 ; i < n; i++) {\n\t\t\tthis.#signatures.push(Signature.dummy());\n\t\t}\n\t}\n\n\tremoveDummySignatures() {\n\t\tthis.#signatures = this.#signatures.filter(pkw => !pkw.isDummy());\n\t}\n\n\t/**\n\t * Index is calculated later\n\t * @param {TxInput} input\n\t * @param {UplcData} redeemerData \n\t */\n\taddSpendingRedeemer(input, redeemerData) {\n\t\tthis.#redeemers.push(new SpendingRedeemer(input, -1, redeemerData)); // actual input index is determined later\n\t}\n\n\t/**\n\t * @param {MintingPolicyHash} mph\n\t * @param {UplcData} redeemerData\n\t */\n\taddMintingRedeemer(mph, redeemerData) {\n\t\tthis.#redeemers.push(new MintingRedeemer(mph, -1, redeemerData));\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t */\n\taddDatumData(data) {\n\t\t// check that it hasn't already been included\n\t\tfor (let prev of this.#datums.list) {\n\t\t\tif (eq(prev.toCbor(), data.toCbor())) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tlet lst = this.#datums.list;\n\t\tlst.push(data);\n\n\t\tthis.#datums = new ListData(lst);\n\t}\n\n\t/**\n\t * Throws error if script was already added before\n\t * @param {UplcProgram} program \n\t * @param {boolean} isRef\n\t */\n\tattachScript(program, isRef = false) {\n\t\tlet h = program.hash();\n\n\t\tassert(this.#scripts.every(s => !eq(s.hash(), h)));\n\t\tassert(this.#refScripts.every(s => !eq(s.hash(), h)));\n\n\t\tif (isRef) {\n\t\t\tthis.#refScripts.push(program);\n\t\t} else {\n\t\t\tthis.#scripts.push(program);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves either a regular script or a reference script\n\t * @param {Hash} scriptHash - can be ValidatorHash or MintingPolicyHash\n\t * @returns {UplcProgram}\n\t */\n\tgetScript(scriptHash) {\n\t\treturn assertDefined(this.scripts.find(s => eq(s.hash(), scriptHash.bytes)));\n\t}\n\n\t/**\n\t * @param {TxBody} body\n\t */\n\tupdateRedeemerIndices(body) {\n\t\tfor (let redeemer of this.#redeemers) {\n\t\t\tredeemer.updateIndex(body);\n\t\t}\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams \n\t * @returns {Hash | null} - returns null if there are no redeemers\n\t */\n\tcalcScriptDataHash(networkParams) {\n\t\tif (this.#redeemers.length > 0) {\n\t\t\tlet bytes = CborData.encodeDefList(this.#redeemers);\n\n\t\t\tif (this.#datums.list.length > 0) {\n\t\t\t\tbytes = bytes.concat(this.#datums.toCbor());\n\t\t\t}\n\n\t\t\t// language view encodings?\n\t\t\tlet sortedCostParams = networkParams.sortedCostParams;\n\n\t\t\tbytes = bytes.concat(CborData.encodeMap([[\n\t\t\t\tCborData.encodeInteger(1n), \n\t\t\t\tCborData.encodeDefList(sortedCostParams.map(cp => CborData.encodeInteger(BigInt(cp)))),\n\t\t\t]]));\n\n\t\t\treturn new Hash(Crypto.blake2b(bytes));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @param {NetworkParams} networkParams \n\t * @param {TxBody} body\n\t * @param {Redeemer} redeemer \n\t * @param {UplcData} scriptContext\n\t * @returns {Promise<Cost>} \n\t */\n\tasync executeRedeemer(networkParams, body, redeemer, scriptContext) {\n\t\tif (redeemer instanceof SpendingRedeemer) {\n\t\t\tconst idx = redeemer.inputIndex;\n\n\t\t\tconst origOutput = body.inputs[idx].origOutput;\n\n\t\t\tif (origOutput === null) {\n\t\t\t\tthrow new Error(\"expected origOutput to be non-null\");\n\t\t\t} else {\n\t\t\t\tconst datumData = origOutput.getDatumData();\n\n\t\t\t\tconst validatorHash = origOutput.address.validatorHash;\n\n\t\t\t\tif (validatorHash === null || validatorHash === undefined) {\n\t\t\t\t\tthrow new Error(\"expected validatorHash to be non-null\");\n\t\t\t\t} else {\n\t\t\t\t\tconst script = this.getScript(validatorHash);\n\n\t\t\t\t\tconst args = [\n\t\t\t\t\t\tnew UplcDataValue(Site.dummy(), datumData), \n\t\t\t\t\t\tnew UplcDataValue(Site.dummy(), redeemer.data), \n\t\t\t\t\t\tnew UplcDataValue(Site.dummy(), scriptContext),\n\t\t\t\t\t];\n\n\t\t\t\t\tconst profile = await script.profile(args, networkParams);\n\n\t\t\t\t\tprofile.messages.forEach(m => console.log(m));\n\n\t\t\t\t\tif (profile.result instanceof UserError) {\t\n\t\t\t\t\t\tthrow profile.result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {mem: profile.mem, cpu: profile.cpu};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (redeemer instanceof MintingRedeemer) {\n\t\t\tconst mph = body.minted.mintingPolicies[redeemer.mphIndex];\n\n\t\t\tconst script = this.getScript(mph);\n\n\t\t\tconst args = [\n\t\t\t\tnew UplcDataValue(Site.dummy(), redeemer.data),\n\t\t\t\tnew UplcDataValue(Site.dummy(), scriptContext),\n\t\t\t];\n\n\t\t\tconst profile = await script.profile(args, networkParams);\n\n\t\t\tprofile.messages.forEach(m => console.log(m));\n\n\t\t\tif (profile.result instanceof UserError) {\t\n\t\t\t\tthrow profile.result;\n\t\t\t} else {\n\t\t\t\treturn {mem: profile.mem, cpu: profile.cpu};\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"unhandled redeemer type\");\n\t\t}\n\t}\n\n\t/**\n\t * Executes the redeemers in order to calculate the necessary ex units\n\t * @param {NetworkParams} networkParams \n\t * @param {TxBody} body - needed in order to create correct ScriptContexts\n\t * @param {Address} changeAddress - needed for dummy input and dummy output\n\t * @returns {Promise<void>}\n\t */\n\tasync executeRedeemers(networkParams, body, changeAddress) {\n\t\tassert(config.N_DUMMY_INPUTS == 1 || config.N_DUMMY_INPUTS == 2, \"expected N_DUMMY_INPUTS==1 or N_DUMMY_INPUTS==2\");\n\t\tconst twoDummyInputs = config.N_DUMMY_INPUTS == 2;\n\n\t\tconst fee = networkParams.maxTxFee;\n\n\t\t// Additional 2 dummy inputs and 1 dummy output to compensate for balancing inputs and outputs that might be added later\n\t\t// The reason for needing 2 dummy inputs is that one needs to be at the beginning of the body.inputs list (TxId 0000...), and the other needs TxId ffffff (at the end of the list)\n\t\t// TxId ffffff overestimates the cost of printing the TxIds, and the dummy TxId 00000 overestimates iterating over body.inputs\n\t\t// We can't just prepend a dummy input with TxId ffffff, because some scripts might be relying on the order of the inputs (eg. counting votes in DAOs)\n\n\t\t// 1000 ADA should be enough as a dummy input/output\n\t\tconst dummyInput1 = new TxInput(\n\t\t\tTxId.dummy(0),\n\t\t\t0n,\n\t\t\tnew TxOutput(\n\t\t\t\tchangeAddress,\n\t\t\t\tnew Value(fee + 1000_000_000n)\n\t\t\t)\n\t\t);\n\t\t\n\t\tconst dummyInput2 = new TxInput(\n\t\t\tTxId.dummy(255),\n\t\t\t999n,\n\t\t\tnew TxOutput(\n\t\t\t\tchangeAddress,\n\t\t\t\tnew Value(1000_000_000n)\n\t\t\t)\n\t\t);\n\n\t\tconst dummyOutput = new TxOutput(\n\t\t\tchangeAddress,\n\t\t\tnew Value(twoDummyInputs ? 2000_000_000n : 1000_000_000n)\n\t\t);\n\n\t\tbody.setFee(fee);\n\t\tbody.addInput(dummyInput1, false);\n\t\tif (twoDummyInputs) {\n\t\t\tbody.addInput(dummyInput2, false);\n\t\t}\n\t\tbody.addOutput(dummyOutput);\n\n\t\tthis.updateRedeemerIndices(body);\n\n\t\tfor (let i = 0; i < this.#redeemers.length; i++) {\n\t\t\tconst redeemer = this.#redeemers[i];\n\n\t\t\tconst scriptContext = body.toScriptContextData(networkParams, this.#redeemers, this.#datums, i);\n\n\t\t\tconst cost = await this.executeRedeemer(networkParams, body, redeemer, scriptContext);\n\n\t\t\tredeemer.setCost(cost);\n\t\t}\n\n\t\tbody.removeInput(dummyInput1);\n\t\tif (twoDummyInputs) {\n\t\t\tbody.removeInput(dummyInput2);\n\t\t}\n\t\tbody.removeOutput(dummyOutput);\n\n\t\tthis.updateRedeemerIndices(body);\n\t}\n\n\t/**\n\t * Reruns all the redeemers to make sure the ex budgets are still correct (can change due to outputs added during rebalancing)\n\t * @param {NetworkParams} networkParams \n\t * @param {TxBody} body \n\t */\n\tasync checkExecutionBudgets(networkParams, body) {\n\t\tfor (let i = 0; i < this.#redeemers.length; i++) {\n\t\t\tconst redeemer = this.#redeemers[i];\n\n\t\t\tconst scriptContext = body.toScriptContextData(networkParams, this.#redeemers, this.#datums, i);\n\n\t\t\tconst cost = await this.executeRedeemer(networkParams, body, redeemer, scriptContext);\n\n\t\t\tif (redeemer.memCost < cost.mem) {\n\t\t\t\tthrow new Error(\"internal finalization error, redeemer mem budget too low\");\n\t\t\t} else if (redeemer.cpuCost < cost.cpu) {\n\t\t\t\tthrow new Error(\"internal finalization error, redeemer cpu budget too low\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Throws error if execution budget is exceeded\n\t * @param {NetworkParams} networkParams\n\t */\n\tcheckExecutionBudgetLimits(networkParams) {\n\t\tlet totalMem = 0n;\n\t\tlet totalCpu = 0n;\n\n\t\tfor (let redeemer of this.#redeemers) {\n\t\t\ttotalMem += redeemer.memCost;\n\t\t\ttotalCpu += redeemer.cpuCost;\n\t\t}\n\n\t\tlet [maxMem, maxCpu] = networkParams.maxTxExecutionBudget;\n\n\t\tif (totalMem >= BigInt(maxMem)) {\n\t\t\tthrow new Error(\"execution budget exceeded for mem\");\n\t\t}\n\n\t\tif (totalCpu >= BigInt(maxCpu)) {\n\t\t\tthrow new Error(\"execution budget exceeded for cpu\");\n\t\t}\n\t}\n}\n\n/**\n * @package\n */\nclass TxInput extends CborData {\n\t/** @type {TxId} */\n\t#txId;\n\n\t/** @type {bigint} */\n\t#utxoIdx;\n\n\t/** @type {?TxOutput} */\n\t#origOutput;\n\n\t/**\n\t * @param {TxId} txId \n\t * @param {bigint} utxoIdx \n\t * @param {?TxOutput} origOutput - used during building, not part of serialization\n\t */\n\tconstructor(txId, utxoIdx, origOutput = null) {\n\t\tsuper();\n\t\tthis.#txId = txId;\n\t\tthis.#utxoIdx = utxoIdx;\n\t\tthis.#origOutput = origOutput;\n\t}\n\t\n\t/**\n\t * @type {TxId}\n\t */\n\tget txId() {\n\t\treturn this.#txId;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget utxoIdx() {\n\t\treturn this.#utxoIdx;\n\t}\n\n\t/**\n\t * @type {TxOutput}\n\t */\n\tget origOutput() {\n\t\tif (this.#origOutput === null) {\n\t\t\tthrow new Error(\"origOutput not set\");\n\t\t} else {\n\t\t\treturn this.#origOutput;\n\t\t}\n\t}\n\n\t/**\n\t * Shortcut\n\t * @type {Value}\n\t */\n\tget value() {\n\t\treturn this.origOutput.value;\n\t}\n\n\t/**\n\t * Shortcut\n\t * @type {Address}\n\t */\n\tget address() {\n\t\treturn this.origOutput.address;\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoOutputIdData() {\n\t\treturn new ConstrData(0, [\n\t\t\tnew ConstrData(0, [new ByteArrayData(this.#txId.bytes)]),\n\t\t\tnew IntData(this.#utxoIdx),\n\t\t]);\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\tif (this.#origOutput === null) {\n\t\t\tthrow new Error(\"expected to be non-null\");\n\t\t} else {\n\t\t\treturn new ConstrData(0, [\n\t\t\t\tthis.toOutputIdData(),\n\t\t\t\tthis.#origOutput.toData(),\n\t\t\t]);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tthis.#txId.toCbor(),\n\t\t\tCborData.encodeInteger(this.#utxoIdx),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {TxInput}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?TxId} */\n\t\tlet txId = null;\n\n\t\t/** @type {?bigint} */\n\t\tlet utxoIdx = null;\n\n\t\tCborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttxId = TxId.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tutxoIdx = CborData.decodeInteger(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\tif (txId === null || utxoIdx === null) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\t\t\treturn new TxInput(txId, utxoIdx);\n\t\t}\n\t}\n\n\t/**\n\t * Tx inputs must be ordered. \n\t * The following function can be used directly by a js array sort\n\t * @param {TxInput} a\n\t * @param {TxInput} b\n\t * @returns {number}\n\t */\n\tstatic comp(a, b) {\n\t\tlet res = ByteArrayData.comp(a.#txId.bytes, b.#txId.bytes);\n\n\t\tif (res == 0) {\n\t\t\treturn Number(a.#utxoIdx - b.#utxoIdx);\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t} \n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\ttxId: this.#txId.dump(),\n\t\t\tutxoIdx: this.#utxoIdx.toString(),\n\t\t\torigOutput: this.#origOutput !== null ? this.#origOutput.dump() : null,\n\t\t};\n\t}\n}\n\n/**\n * UTxO wraps TxInput\n */\nclass UTxO {\n\t#input;\n\n\t/**\n\t * @param {TxId} txId \n\t * @param {bigint} utxoIdx \n\t * @param {TxOutput} origOutput\n\t */\n\tconstructor(txId, utxoIdx, origOutput) {\n\t\tthis.#input = new TxInput(txId, utxoIdx, origOutput);\n\t}\n\n\t/**\n\t * @type {TxId}\n\t */\n\tget txId() {\n\t\treturn this.#input.txId;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget utxoIdx() {\n\t\treturn this.#input.utxoIdx;\n\t}\n\n\t/**\n\t * @type {TxInput}\n\t */\n\tget asTxInput() {\n\t\treturn this.#input;\n\t}\n\n\t/**\n\t * @type {Value}\n\t */\n\tget value() {\n\t\treturn this.#input.value;\n\t}\n\n\t/**\n\t * @type {TxOutput}\n\t */\n\tget origOutput() {\n\t\treturn this.#input.origOutput;\n\t}\n\n\t/**\n\t * Deserializes UTxO format used by wallet connector\n\t * @param {number[]} bytes\n\t * @returns {UTxO}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?TxInput} */\n\t\tlet maybeTxInput = null;\n\n\t\t/** @type {?TxOutput} */\n\t\tlet origOutput = null;\n\n\t\tCborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tmaybeTxInput = TxInput.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\torigOutput = TxOutput.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\tif (maybeTxInput !== null && origOutput !== null) {\n            /** @type {TxInput} */\n            const txInput = maybeTxInput;\n            \n\t\t\treturn new UTxO(txInput.txId, txInput.utxoIdx, origOutput);\n\t\t} else {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tthis.#input.toCbor(),\n\t\t\tthis.#input.origOutput.toCbor()\n\t\t]);\n\t}\n\n\t/**\n\t * @param {UTxO[]} utxos\n\t * @returns {Value}\n\t */\n\tstatic sumValue(utxos) {\n\t\tlet sum = new Value();\n\n\t\tfor (let utxo of utxos) {\n\t\t\tsum = sum.add(utxo.value);\n\t\t}\n\n\t\treturn sum;\n\t}\n}\n\nclass TxRefInput extends TxInput {\n\t/**\n\t * @param {TxId} txId \n\t * @param {bigint} utxoId\n\t * @param {TxOutput} origOutput\n\t */\n\tconstructor(txId, utxoId, origOutput) {\n\t\tsuper(txId, utxoId, origOutput);\n\t}\n}\n\nclass TxOutput extends CborData {\n\t/** @type {Address} */\n\t#address;\n\n\t/** @type {Value} */\n\t#value;\n\n\t/** @type {?Datum} */\n\t#datum;\n\n\t/** @type {?UplcProgram} */\n\t#refScript;\n\n\t/**\n\t * @param {Address} address \n\t * @param {Value} value \n\t * @param {?Datum} datum \n\t * @param {?UplcProgram} refScript \n\t */\n\tconstructor(address, value, datum = null, refScript = null) {\n\t\tassert(datum === null || datum instanceof Datum); // check this explicitely because caller might be using this constructor without proper type-checking\n\t\tsuper();\n\t\tthis.#address = address;\n\t\tthis.#value = value;\n\t\tthis.#datum = datum;\n\t\tthis.#refScript = refScript;\n\t}\n\n\tget address() {\n\t\treturn this.#address;\n\t}\n\n\t/**\n\t * Mutation is handy when correctin the quantity of lovelace in a utxo\n\t * @param {Address} addr\n\t */\n\tsetAddress(addr) {\n\t\tthis.#address = addr;\n\t}\n\n\tget value() {\n\t\treturn this.#value;\n\t}\n\n\t/**\n\t * Mutation is handy when correcting the quantity of lovelace in a utxo\n\t * @param {Value} val\n\t */\n\tsetValue(val) {\n\t\tthis.#value = val;\n\t}\n\n\tget datum() {\n\t\treturn this.#datum;\n\t}\n\n\t/**\n\t * Mutation is handy when correctin the quantity of lovelace in a utxo \n\t * @param {Datum} datum \n\t */\n\tsetDatum(datum) {\n\t\tthis.#datum = datum;\n\t}\n\n\t/**\n\t * @returns {UplcData}\n\t */\n\tgetDatumData() {\n\t\tif (this.#datum === null) {\n\t\t\tthrow new Error(\"no datum data available\");\n\t\t} else {\n\t\t\tlet data = this.#datum.data;\n\t\t\tif (data === null) {\n\t\t\t\tthrow new Error(\"no datum data available\");\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\tif ((this.#datum === null || this.#datum instanceof HashedDatum) && this.#refScript === null && !config.STRICT_BABBAGE) {\n\t\t\t// this is needed to match eternl wallet (de)serialization (annoyingly eternl deserializes the tx and then signs its own serialization)\n\t\t\t// hopefully cardano-cli signs whatever serialization we choose (so we use the eternl variant in order to be compatible with both)\n\n\t\t\tlet fields = [\n\t\t\t\tthis.#address.toCbor(),\n\t\t\t\tthis.#value.toCbor()\n\t\t\t];\n\n\t\t\tif (this.#datum !== null) {\n\t\t\t\tif (this.#datum instanceof HashedDatum) {\n\t\t\t\t\tfields.push(this.#datum.hash.toCbor());\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn CborData.encodeTuple(fields);\n\t\t} else {\n\t\t\t/** @type {Map<number, number[]>} */\n\t\t\tlet object = new Map();\n\n\t\t\tobject.set(0, this.#address.toCbor());\n\t\t\tobject.set(1, this.#value.toCbor());\n\n\t\t\tif (this.#datum !== null) {\n\t\t\t\tobject.set(2, this.#datum.toCbor());\n\t\t\t}\n\n\t\t\tif (this.#refScript !== null) {\n\t\t\t\tobject.set(3, CborData.encodeTag(24n).concat(CborData.encodeBytes(\n\t\t\t\t\tCborData.encodeTuple([\n\t\t\t\t\t\tCborData.encodeInteger(BigInt(this.#refScript.versionTag())),\n\t\t\t\t\t\tthis.#refScript.toCbor()\n\t\t\t\t\t])\n\t\t\t\t)));\n\t\t\t}\n\n\t\t\treturn CborData.encodeObject(object);\n\t\t}\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {TxOutput}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?Address} */\n\t\tlet address = null;\n\n\t\t/** @type {?Value} */\n\t\tlet value = null;\n\n\t\t/** @type {?Datum} */\n\t\tlet outputDatum = null;\n\n\t\t/** @type {?UplcProgram} */\n\t\tlet refScript = null;\n\n\t\tif (CborData.isObject(bytes)) {\n\t\t\tCborData.decodeObject(bytes, (i, fieldBytes) => {\n\t\t\t\tswitch(i) { \n\t\t\t\t\tcase 0:\n\t\t\t\t\t\taddress = Address.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tvalue = Value.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutputDatum = Datum.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tassert(CborData.decodeTag(fieldBytes) == 24n);\n\n\t\t\t\t\t\tlet tupleBytes = CborData.decodeBytes(fieldBytes);\n\n\t\t\t\t\t\tCborData.decodeTuple(tupleBytes, (tupleIdx, innerTupleBytes) => {\n\t\t\t\t\t\t\tassert(refScript === null);\n\n\t\t\t\t\t\t\tswitch(tupleIdx) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tthrow new Error(\"native refScript unhandled\");\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tthrow new Error(\"plutuScriptV1 as refScript unhandled\");\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\trefScript = UplcProgram.fromCbor(innerTupleBytes);\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tthrow new Error(\"unhandled script type for refScript\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (CborData.isTuple(bytes)) {\n\t\t\t// this is the pre-vasil format, which is still sometimes returned by wallet connector functions\n\t\t\tCborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\t\tswitch(i) { \n\t\t\t\t\tcase 0:\n\t\t\t\t\t\taddress = Address.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tvalue = Value.fromCbor(fieldBytes);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutputDatum = new HashedDatum(DatumHash.fromCbor(fieldBytes));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error(\"expected object or tuple for TxOutput\");\n\t\t}\n\n\t\tif (address === null || value === null) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\t\t\treturn new TxOutput(address, value, outputDatum, refScript);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\taddress: this.#address.dump(),\n\t\t\tvalue: this.#value.dump(),\n\t\t\tdatum: this.#datum === null ? null : this.#datum.dump(),\n\t\t\trefScript: this.#refScript === null ? null : bytesToHex(this.#refScript.toCbor()),\n\t\t};\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\tlet datum = new ConstrData(0, []); // none\n\t\tif (this.#datum !== null) {\n\t\t\tdatum = this.#datum.toData();\n\t\t}\n\n\t\treturn new ConstrData(0, [\n\t\t\tthis.#address._toUplcData(),\n\t\t\tthis.#value._toUplcData(),\n\t\t\tdatum,\n\t\t\tnew ConstrData(1, []), // TODO: how to include the ref script\n\t\t]);\n\t}\n\n\t/**\n\t * Each UTxO must contain some minimum quantity of lovelace to avoid that the blockchain is used for data storage\n\t * @param {NetworkParams} networkParams\n\t * @returns {bigint}\n\t */\n\tcalcMinLovelace(networkParams) {\n\t\tlet lovelacePerByte = networkParams.lovelacePerUTXOByte;\n\n\t\tlet correctedSize = this.toCbor().length + 160; // 160 accounts for some database overhead?\n\n\t\treturn BigInt(correctedSize)*BigInt(lovelacePerByte);\n\t}\n\n\t/**\n\t * Mutates. Makes sure the output contains at least the minimum quantity of lovelace.\n\t * Other parts of the output can optionally also be mutated\n\t * @param {NetworkParams} networkParams \n\t * @param {?((output: TxOutput) => void)} updater\n\t */\n\tcorrectLovelace(networkParams, updater = null) {\n\t\tlet minLovelace = this.calcMinLovelace(networkParams);\n\n\t\twhile (this.#value.lovelace < minLovelace) {\n\t\t\tthis.#value.setLovelace(minLovelace);\n\n\t\t\tif (updater != null) {\n\t\t\t\tupdater(this);\n\t\t\t}\n\n\t\t\tminLovelace = this.calcMinLovelace(networkParams);\n\t\t}\n\t}\n}\n\n// TODO: enum members\nclass DCert extends CborData {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {DCert}\n\t */\n\tstatic fromCbor(bytes) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Convenience address that is used to query all assets controlled by a given StakeHash (can be scriptHash or regular stakeHash)\n */\nclass StakeAddress {\n\t#bytes;\n\n\t/**\n\t * @param {number[]} bytes \n\t */\n\tconstructor(bytes) {\n\t\tassert(bytes.length == 29);\n\n\t\tthis.#bytes = bytes;\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget bytes() {\n\t\treturn this.#bytes;\n\t}\n\n\t/**\n\t * @param {StakeAddress} sa\n\t * @returns {boolean}\n\t */\n\tstatic isForTestnet(sa) {\n\t\treturn Address.isForTestnet(new Address(sa.bytes));\n\t}\n\n\t/**\n\t * Convert regular Address into StakeAddress.\n\t * Throws an error if the given Address doesn't have a staking part.\n\t * @param {Address} addr \n\t * @returns {StakeAddress}\n\t */\n\tstatic fromAddress(addr) {\n\t\tconst sh = addr.stakingHash;\n\n\t\tif (sh === null) {\n\t\t\tthrow new Error(\"address doesn't have a staking part\");\n\t\t} else {\n\t\t\treturn StakeAddress.fromHash(Address.isForTestnet(addr), sh);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeBytes(this.#bytes);\n\t}\n\n\t/**\n\t * @param {number[]} bytes\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromCbor(bytes) {\n\t\treturn new StakeAddress(CborData.decodeBytes(bytes));\n\t}\n\n\t/**\n\t * @returns {string}\n\t */\n\ttoBech32() {\n\t\treturn Crypto.encodeBech32(\n\t\t\tStakeAddress.isForTestnet(this) ? \"stake_test\" : \"stake\",\n\t\t\tthis.bytes\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} str\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromBech32(str) {\n\t\tlet [prefix, bytes] = Crypto.decodeBech32(str);\n\n\t\tlet result = new StakeAddress(bytes);\n\n\t\tassert(prefix == (StakeAddress.isForTestnet(result) ? \"stake_test\" : \"stake\"), \"invalid StakeAddress prefix\");\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the raw StakeAddress bytes as a hex encoded string\n\t * @returns {string}\n\t */\n\ttoHex() {\n\t\treturn bytesToHex(this.#bytes);\n\t}\n\n\t/**\n\t * Doesn't check validity\n\t * @param {string} hex\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromHex(hex) {\n\t\treturn new StakeAddress(hexToBytes(hex));\n\t}\n\n\t/**\n\t * Address with only staking part (regular StakeKeyHash)\n\t * @param {boolean} isTestnet\n\t * @param {StakeKeyHash} hash\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromStakeKeyHash(isTestnet, hash) {\n\t\treturn new StakeAddress(\n\t\t\t[isTestnet ? 0xe0 : 0xe1].concat(hash.bytes)\n\t\t);\n\t}\n\n\t/**\n\t * Address with only staking part (script StakingValidatorHash)\n\t * @param {boolean} isTestnet\n\t * @param {StakingValidatorHash} hash\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromStakingValidatorHash(isTestnet, hash) {\n\t\treturn new StakeAddress(\n\t\t\t[isTestnet ? 0xf0 : 0xf1].concat(hash.bytes)\n\t\t);\n\t}\n\n\t/**\n\t * @param {boolean} isTestnet\n\t * @param {StakeKeyHash | StakingValidatorHash} hash\n\t * @returns {StakeAddress}\n\t */\n\tstatic fromHash(isTestnet, hash) {\n\t\tif (hash instanceof StakeKeyHash) {\n\t\t\treturn StakeAddress.fromStakeKeyHash(isTestnet, hash);\n\t\t} else {\n\t\t\treturn StakeAddress.fromStakingValidatorHash(isTestnet, hash);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {StakeKeyHash | StakingValidatorHash}\n\t */\n\tget stakingHash() {\n\t\tconst type = this.bytes[0];\n\n\t\tif (type == 0xe0 || type == 0xe1) {\n\t\t\treturn new StakeKeyHash(this.bytes.slice(1));\n\t\t} else if (type == 0xf0 || type == 0xf1) {\n\t\t\treturn new StakingValidatorHash(this.bytes.slice(1));\n\t\t} else {\n\t\t\tthrow new Error(\"bad StakeAddress header\");\n\t\t}\n\t}\n}\n\nclass Signature extends CborData {\n\t/** @type {number[]} */\n\t#pubKey;\n\n\t/** @type {number[]} */\n\t#signature;\n\n\t/**\n\t * @param {number[]} pubKey \n\t * @param {number[]} signature \n\t */\n\tconstructor(pubKey, signature) {\n\t\tsuper();\n\t\tthis.#pubKey = pubKey;\n\t\tthis.#signature = signature;\n\t}\n\n\t/**\n\t * @returns {Signature}\n\t */\n\tstatic dummy() {\n\t\treturn new Signature((new Array(32)).fill(0), (new Array(64)).fill(0));\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisDummy() {\n\t\treturn this.#pubKey.every(b => b == 0) && this.#signature.every(b => b == 0);\n\t}\n\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tCborData.encodeBytes(this.#pubKey),\n\t\t\tCborData.encodeBytes(this.#signature),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {Signature}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?number[]} */\n\t\tlet pubKey = null;\n\n\t\t/** @type {?number[]} */\n\t\tlet signature = null;\n\n\t\tlet n = CborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpubKey = CborData.decodeBytes(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tsignature = CborData.decodeBytes(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\tassert(n == 2);\n\n\t\tif (pubKey === null || signature === null) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\t\t\treturn new Signature(pubKey, signature);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tpubKey: bytesToHex(this.#pubKey),\n\t\t\tpubKeyHash: bytesToHex(Crypto.blake2b(this.#pubKey, 28)),\n\t\t\tsignature: bytesToHex(this.#signature),\n\t\t};\n\t}\n\n\t/**\n\t * Throws error if incorrect\n\t * @param {number[]} msg\n\t */\n\tverify(msg) {\n\t\tif (this.#signature === null) {\n\t\t\tthrow new Error(\"signature can't be null\");\n\t\t} else {\n\t\t\tif (this.#pubKey === null) {\n\t\t\t\tthrow new Error(\"pubKey can't be null\");\n\t\t\t} else {\n\t\t\t\tif (!Crypto.Ed25519.verify(this.#signature, msg, this.#pubKey)) {\n\t\t\t\t\tthrow new Error(\"incorrect signature\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Redeemer extends CborData {\n\t/** @type {UplcData} */\n\t#data;\n\n\t/** @type {Cost} */\n\t#exUnits;\n\n\t/**\n\t * @param {UplcData} data \n\t * @param {Cost} exUnits \n\t */\n\tconstructor(data, exUnits = {mem: 0n, cpu: 0n}) {\n\t\tsuper();\n\t\tthis.#data = data;\n\t\tthis.#exUnits = exUnits;\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget memCost() {\n\t\treturn this.#exUnits.mem;\n\t}\n\n\t/**\n\t * @type {bigint}\n\t */\n\tget cpuCost() {\n\t\treturn this.#exUnits.cpu;\n\t}\n\n\t/**\n\t * type:\n\t *   0 -> spending\n\t *   1 -> minting \n\t *   2 -> certifying\n\t *   3 -> rewarding\n\t * @param {number} type \n\t * @param {number} index \n\t * @returns {number[]}\n\t */\n\ttoCborInternal(type, index) {\n\t\treturn CborData.encodeTuple([\n\t\t\tCborData.encodeInteger(BigInt(type)),\n\t\t\tCborData.encodeInteger(BigInt(index)),\n\t\t\tthis.#data.toCbor(),\n\t\t\tCborData.encodeTuple([\n\t\t\t\tCborData.encodeInteger(this.#exUnits.mem),\n\t\t\t\tCborData.encodeInteger(this.#exUnits.cpu),\n\t\t\t]),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {Redeemer}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?number} */\n\t\tlet type = null;\n\n\t\t/** @type {?number} */\n\t\tlet index = null;\n\n\t\t/** @type {?UplcData} */\n\t\tlet data = null;\n\n\t\t/** @type {?Cost} */\n\t\tlet cost = null;\n\n\t\tlet n = CborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttype = Number(CborData.decodeInteger(fieldBytes));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tindex = Number(CborData.decodeInteger(fieldBytes));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tdata = UplcData.fromCbor(fieldBytes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3: \n\t\t\t\t\t/** @type {?bigint} */\n\t\t\t\t\tlet mem = null;\n\n\t\t\t\t\t/** @type {?bigint} */\n\t\t\t\t\tlet cpu = null;\n\n\t\t\t\t\tlet m = CborData.decodeTuple(fieldBytes, (j, subFieldBytes) => {\n\t\t\t\t\t\tswitch (j) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tmem = CborData.decodeInteger(subFieldBytes);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tcpu = CborData.decodeInteger(subFieldBytes);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tassert(m == 2);\n\n\t\t\t\t\tif (mem === null || cpu === null) {\n\t\t\t\t\t\tthrow new Error(\"unexpected\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcost = {mem: mem, cpu: cpu};\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field\");\n\t\t\t}\n\t\t});\n\n\t\tassert(n == 4);\n\n\t\tif (type === null || index === null || data === null || cost === null) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\n\t\t\tswitch(type) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn new SpendingRedeemer(null, index, data, cost);\n\t\t\t\tcase 1:\n\t\t\t\t\treturn new MintingRedeemer(null, index, data, cost);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unhandled redeemer type (Todo)\");\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdumpInternal() {\n\t\treturn {\n\t\t\tdata: this.#data.toString(),\n\t\t\texUnits: {\n\t\t\t\tmem: this.#exUnits.mem.toString(),\n\t\t\t\tcpu: this.#exUnits.cpu.toString(),\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {TxBody} body \n\t * @returns {ConstrData}\n\t */\n\ttoScriptPurposeData(body) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {TxBody} body \n\t */\n\tupdateIndex(body) {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @param {Cost} cost \n\t */\n\tsetCost(cost) {\n\t\tthis.#exUnits = cost;\n\t}\n\n\t/**\n\t * @param {NetworkParams} networkParams \n\t * @returns {bigint}\n\t */\n\testimateFee(networkParams) {\n\t\t// this.#exUnits.mem and this.#exUnits can be 0 if we are estimating the fee for an initial balance\n\t\t\n\t\tlet [memFee, cpuFee] = networkParams.exFeeParams;\n\n\t\treturn BigInt(Math.ceil(Number(this.#exUnits.mem)*memFee + Number(this.#exUnits.cpu)*cpuFee));\n\t}\n}\n\nclass SpendingRedeemer extends Redeemer {\n\t#input;\n\t#inputIndex;\n\n\t/**\n\t * @param {?TxInput} input\n\t * @param {number} inputIndex\n\t * @param {UplcData} data \n\t * @param {Cost} exUnits \n\t */\n\tconstructor(input, inputIndex, data, exUnits = {mem: 0n, cpu: 0n}) {\n\t\tsuper(data, exUnits);\n\n\t\tthis.#input = input\n\t\tthis.#inputIndex = inputIndex;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget inputIndex() {\n\t\treturn this.#inputIndex;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn this.toCborInternal(0, this.#inputIndex);\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tlet obj = super.dumpInternal();\n\n\t\tobj[\"type\"] = 0;\n\t\tobj[\"typeName\"] = \"spending\";\n\t\tobj[\"inputIndex\"] = this.#inputIndex;\n\n\t\treturn obj;\n\t}\n\n\t/**\n\t * @param {TxBody} body \n\t * @returns {ConstrData}\n\t */\n\ttoScriptPurposeData(body) {\n\t\treturn new ConstrData(1, [\n\t\t\tbody.inputs[this.#inputIndex].toOutputIdData(),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {TxBody} body\n\t */\n\tupdateIndex(body) {\n\t\tif (this.#input == null) {\n\t\t\tthrow new Error(\"input can't be null\");\n\t\t} else {\n\t\t\tthis.#inputIndex = body.inputs.findIndex(i => {\n\t\t\t\treturn i.txId.eq(assertDefined(this.#input).txId) && (i.utxoIdx == assertDefined(this.#input).utxoIdx)\n\t\t\t});\n\n\t\t\tassert(this.#inputIndex != -1);\n\t\t}\n\t}\n}\n\nclass MintingRedeemer extends Redeemer {\n\t#mph;\n\t#mphIndex;\n\n\t/**\n\t * @param {?MintingPolicyHash} mph\n\t * @param {number} mphIndex\n\t * @param {UplcData} data\n\t * @param {Cost} exUnits\n\t */\n\tconstructor(mph, mphIndex, data, exUnits = {mem: 0n, cpu: 0n}) {\n\t\tsuper(data, exUnits);\n\n\t\tthis.#mph = mph;\n\t\tthis.#mphIndex = mphIndex;\n\t}\n\n\t/**\n\t * @type {number}\n\t */\n\tget mphIndex() {\n\t\treturn this.#mphIndex;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn this.toCborInternal(1, this.#mphIndex);\n\t}\n\n\t/** \n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tlet obj = super.dumpInternal();\n\n\t\tobj[\"type\"] = 1;\n\t\tobj[\"typeName\"] = \"minting\";\n\t\tobj[\"mphIndex\"] = this.#mphIndex;\n\n\t\treturn obj;\n\t}\n\n\t/**\n\t * @param {TxBody} body \n\t * @returns {ConstrData}\n\t */\n\ttoScriptPurposeData(body) {\n\t\tlet mph = body.minted.mintingPolicies[this.#mphIndex];\n\n\t\treturn new ConstrData(0, [\n\t\t\tnew ByteArrayData(mph.bytes),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {TxBody} body \n\t */\n\tupdateIndex(body) {\n\t\tif (this.#mph === null) {\n\t\t\tthrow new Error(\"can't have null mph at this point\");\n\t\t} else {\n\t\t\tthis.#mphIndex = body.minted.mintingPolicies.findIndex(mph => mph.eq(assertDefined(this.#mph)));\n\n\t\t\tassert(this.#mphIndex != -1);\n\t\t}\n\t}\n}\n\n/**\n * Inside helios this type is named OutputDatum in order to distinguish it from the user defined Datum,\n * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum\n */\nclass Datum extends CborData {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param {number[]} bytes \n\t * @returns {Datum}\n\t */\n\tstatic fromCbor(bytes) {\n\t\t/** @type {?number} */\n\t\tlet type = null;\n\n\t\t/** @type {?Datum} */\n\t\tlet res = null;\n\n\t\tlet n = CborData.decodeTuple(bytes, (i, fieldBytes) => {\n\t\t\tswitch(i) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttype = Number(CborData.decodeInteger(fieldBytes));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (type == 0) {\n\t\t\t\t\t\tres = new HashedDatum(DatumHash.fromCbor(fieldBytes));\n\t\t\t\t\t} else if (type == 1) {\n\t\t\t\t\t\tassert(CborData.decodeTag(fieldBytes) == 24n);\n\n\t\t\t\t\t\tlet dataBytes = CborData.decodeBytes(fieldBytes);\n\t\t\t\t\t\tlet data = UplcData.fromCbor(dataBytes);\n\n\t\t\t\t\t\tres = new InlineDatum(data);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"unrecognized field label\");\n\t\t\t}\n\t\t});\n\n\t\tassert(n == 2);\n\n\t\tif (type === null || res === null) {\n\t\t\tthrow new Error(\"unexpected\");\n\t\t} else {\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/**\n\t * @param {UplcDataValue | UplcData | HeliosData} data\n\t * @returns {HashedDatum}\n\t */\n\tstatic hashed(data) {\n\t\tif (data instanceof HeliosData) {\n\t\t\treturn HashedDatum.fromData(data._toUplcData());\n\t\t} else {\n\t\t\treturn HashedDatum.fromData(UplcDataValue.unwrap(data));\n\t\t}\n\t}\n\n\t/**\n\t * @param {UplcDataValue | UplcData | HeliosData} data\n\t * @returns {InlineDatum}\n\t */\n\tstatic inline(data) {\n\t\tif (data instanceof HeliosData) {\n\t\t\treturn new InlineDatum(data._toUplcData());\n\t\t} else {\n\t\t\treturn new InlineDatum(UplcDataValue.unwrap(data));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisInline() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisHashed() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @type {DatumHash}\n\t */\n\tget hash() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @type {?UplcData}\n\t */\n\tget data() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n\n\t/**\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\tthrow new Error(\"not yet implemented\");\n\t}\n}\n\n/**\n * Inside helios this type is named OutputDatum::Hash in order to distinguish it from the user defined Datum,\n * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum\n */\nclass HashedDatum extends Datum {\n\t/** @type {DatumHash} */\n\t#hash;\n\n\t/** @type {?UplcData} */\n\t#origData;\n\n\t/**\n\t * @param {DatumHash} hash \n\t * @param {?UplcData} origData\n\t */\n\tconstructor(hash, origData = null) {\n\t\tsuper();\n\t\tthis.#hash = hash;\n\t\tthis.#origData = origData;\n\n\t\tif (this.#origData !== null) {\n\t\t\tassert(eq(this.#hash.bytes, Crypto.blake2b(this.#origData.toCbor())));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisInline() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisHashed() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @type {DatumHash}\n\t */\n\tget hash() {\n\t\treturn this.#hash;\n\t}\n\n\t/**\n\t * @type {?UplcData}\n\t */\n\tget data() {\n\t\treturn this.#origData;\n\t}\n\n\t/**\n\t * Used by script context emulation\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\treturn new ConstrData(1, [new ByteArrayData(this.#hash.bytes)]);\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tCborData.encodeInteger(0n),\n\t\t\tthis.#hash.toCbor(),\n\t\t]);\n\t}\n\n\t/**\n\t * @param {UplcData} data \n\t * @returns {HashedDatum}\n\t */\n\tstatic fromData(data) {\n\t\treturn new HashedDatum(new Hash(Crypto.blake2b(data.toCbor())), data);\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\thash: this.#hash.dump(),\n\t\t\tcbor: this.#origData === null ? null : bytesToHex(this.#origData.toCbor()),\n\t\t\tschema: this.#origData === null ? null : JSON.parse(this.#origData.toSchemaJson())\n\t\t};\n\t}\n}\n\n/**\n * Inside helios this type is named OutputDatum::Inline in order to distinguish it from the user defined Datum,\n * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum\n */\nclass InlineDatum extends Datum {\n\t/** @type {UplcData} */\n\t#data;\n\n\t/**\n\t * @param {UplcData} data\n\t */\n\tconstructor(data) {\n\t\tsuper();\n\t\tthis.#data = data;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisInline() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {boolean}\n\t */\n\tisHashed() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @type {DatumHash}\n\t */\n\tget hash() {\n\t\treturn new DatumHash(Crypto.blake2b(this.#data.toCbor()));\n\t}\n\n\t/**\n\t * @type {UplcData}\n\t */\n\tget data() {\n\t\treturn this.#data;\n\t}\n\n\t/**\n\t * Used by script context emulation\n\t * @returns {ConstrData}\n\t */\n\ttoData() {\n\t\treturn new ConstrData(2, [this.#data]);\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\treturn CborData.encodeTuple([\n\t\t\tCborData.encodeInteger(1n),\n\t\t\tCborData.encodeTag(24n).concat(CborData.encodeBytes(this.#data.toCbor()))\n\t\t]);\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\treturn {\n\t\t\tinlineCbor: bytesToHex(this.#data.toCbor()),\n\t\t\tinlineSchema: JSON.parse(this.#data.toSchemaJson())\n\t\t};\n\t}\n}\n\n/**\n * The inner 'any' is also Metadata, but jsdoc doesn't allow declaring recursive types\n * Metadata is essentially a JSON schema object\n * @typedef {{map: [any, any][]} | any[] | string | number} Metadata\n */\n\n/**\n * @param {Metadata} metadata \n * @returns {number[]}\n */\nfunction encodeMetadata(metadata) {\n\tif (typeof metadata === 'string') {\n\t\treturn CborData.encodeUtf8(metadata, true);\n\t} else if (typeof metadata === 'number') {\n\t\tassert(metadata % 1.0 == 0.0);\n\n\t\treturn CborData.encodeInteger(BigInt(metadata));\n\t} else if (Array.isArray(metadata)) {\n\t\treturn CborData.encodeDefList(metadata.map(item => encodeMetadata(item)));\n\t} else if (metadata instanceof Object && \"map\" in metadata && Object.keys(metadata).length == 1) {\n\t\tlet pairs = metadata[\"map\"];\n\n\t\tif (Array.isArray(pairs)) {\n\t\t\treturn CborData.encodeMap(pairs.map(pair => {\n\t\t\t\tif (Array.isArray(pair) && pair.length == 2) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tencodeMetadata(pair[0]),\n\t\t\t\t\t\tencodeMetadata(pair[1])\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"invalid metadata schema\");\t\t\n\t\t\t\t}\n\t\t\t}));\n\t\t} else {\n\t\t\tthrow new Error(\"invalid metadata schema\");\n\t\t}\n\t} else {\n\t\tthrow new Error(\"invalid metadata schema\");\n\t}\n}\n\n/**\n * Shifts bytes to next Cbor element\n * @param {number[]} bytes \n * @returns {Metadata}\n */\nfunction decodeMetadata(bytes) {\n\tif (CborData.isUtf8(bytes)) {\n\t\treturn CborData.decodeUtf8(bytes);\n\t} else if (CborData.isList(bytes)) {\n\t\t/**\n\t\t * @type {Metadata[]}\n\t\t */\n\t\tlet items = [];\n\n\t\tCborData.decodeList(bytes, (_, itemBytes) => {\n\t\t\titems.push(decodeMetadata(itemBytes));\n\t\t});\n\n\t\treturn items;\n\t} else if (CborData.isMap(bytes)) {\n\t\t/**\n\t\t * @type {[Metadata, Metadata][]}\n\t\t */\n\t\tlet pairs = [];\n\n\t\tCborData.decodeMap(bytes, (_, pairBytes) => {\n\t\t\tpairs.push([\n\t\t\t\tdecodeMetadata(pairBytes),\n\t\t\t\tdecodeMetadata(pairBytes)\n\t\t\t]);\n\t\t});\n\n\t\treturn {\"map\": pairs};\n\t} else {\n\t\treturn Number(CborData.decodeInteger(bytes));\n\t}\n}\n\nclass TxMetadata {\n\t/**\n\t * @type {Object.<number, Metadata>} \n\t */\n\t#metadata;\n\n\tconstructor() {\n\t\tthis.#metadata = {};\n\t}\n\n\t/**\n\t *\n\t * @param {number} tag\n\t * @param {Metadata} data\n\t */\n\tadd(tag, data) {\n\t\tthis.#metadata[tag] = data;\n\t}\n\n\t/**\n\t * @type {number[]}\n\t */\n\tget keys() {\n\t\treturn Object.keys(this.#metadata).map(key => parseInt(key)).sort();\n\t}\n\n\t/**\n\t * @returns {Object}\n\t */\n\tdump() {\n\t\tlet obj = {};\n\n\t\tfor (let key of this.keys) {\n\t\t\tobj[key] =this.#metadata[key];\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\t/**\n\t * @returns {number[]}\n\t */\n\ttoCbor() {\n\t\t/**\n\t\t * @type {[number[], number[]][]}\n\t\t */\n\t\tconst pairs = this.keys.map(key => [\n\t\t\tCborData.encodeInteger(BigInt(key)),\n\t\t\tencodeMetadata(this.#metadata[key])\n\t\t]);\n\t\t\n\t\treturn CborData.encodeMap(pairs);\n\t}\n\n\t/**\n\t* Decodes a TxMetadata instance from Cbor\n\t* @param {number[]} data\n\t* @returns {TxMetadata}\n\t*/\n\tstatic fromCbor(data) {\n\t\tconst txMetadata = new TxMetadata();\n\n\t\tCborData.decodeMap(data, (_, pairBytes) => {\n\t\t\ttxMetadata.add(\n\t\t\t\tNumber(CborData.decodeInteger(pairBytes)), \n\t\t\t\tdecodeMetadata(pairBytes)\n\t\t\t);\n\t\t});\n\n\t\treturn txMetadata;\n\t}\n}\n\n\n\n////////////////////////////////////\n// Section 26: Highlighting function\n////////////////////////////////////\n\n/**\n * Categories for syntax highlighting\n */\nconst SyntaxCategory = {\n\tNormal:     0,\n\tComment:    1,\n\tLiteral:    2,\n\tSymbol:     3,\n\tType:       4,\n\tKeyword:    5,\n\tError:      6,\n};\n\n/**\n * Applies syntax highlighting by returning a list of char categories.\n * Not part of Tokeizer because it needs to be very fast and can't throw errors.\n * Doesn't depend on any other functions so it can easily be ported to other languages.\n * @param {string} src\n * @returns {Uint8Array}\n */\nfunction highlight(src) {\n\tlet n = src.length;\n\n\tconst SyntaxState = {\n\t\tNormal:        0,\n\t\tSLComment:     1,\n\t\tMLComment:     2,\n\t\tString:        3,\n\t\tNumberStart:   4,\n\t\tHexNumber:     5,\n\t\tBinaryNumber:  6,\n\t\tOctalNumber:   7,\n\t\tDecimalNumber: 8,\n\t\tByteArray:     9,\n\t};\n\n\t// array of categories\n\tlet data = new Uint8Array(n);\n\n\tlet j = 0; // position in data\n\tlet state = SyntaxState.Normal;\n\n\t/** @type {SymbolToken[]} */\n\tlet groupStack = [];\n\t\n\tfor (let i = 0; i < n; i++) {\n\t\tlet c = src[i];\n\t\tlet isLast = i == n - 1;\n\n\t\tswitch (state) {\n\t\t\tcase SyntaxState.Normal:\n\t\t\t\tif (c == \"/\") {\n\t\t\t\t\t// maybe comment\n\t\t\t\t\tif (!isLast && src[i+1] == \"/\") {\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\t\t\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tstate = SyntaxState.SLComment;\n\t\t\t\t\t} else if (!isLast && src[i+1] == \"*\") {\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tstate = SyntaxState.MLComment;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t}\n\t\t\t\t} else if (c == \"[\" || c == \"]\" || c == \"{\" || c == \"}\" || c == \"(\" || c == \")\") {\n\t\t\t\t\tlet s = new SymbolToken(new Site(new Source(src), i), c);\n\n\t\t\t\t\tif (Group.isOpenSymbol(s)) {\n\t\t\t\t\t\tgroupStack.push(s);\n\t\t\t\t\t\tdata[j++] = SyntaxCategory.Normal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet prevGroup = groupStack.pop();\n\n\t\t\t\t\t\tif (prevGroup === undefined) {\n\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Error;\n\t\t\t\t\t\t} else if (c == Group.matchSymbol(prevGroup)) {\n\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Normal;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[prevGroup.site.startPos] = SyntaxCategory.Error;\n\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (c == \"%\" || c == \"!\" || c == \"&\" || c == \"*\" || c == \"+\" || c == \"-\" || c == \"<\" || c == \"=\" || c == \">\" || c == \"|\") {\n\t\t\t\t\t// symbol\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase \"&\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \"&\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Normal;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"|\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \"|\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Normal;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"!\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \"=\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"=\":\n\t\t\t\t\t\t\tif (!isLast && (src[i+1] == \"=\" || src[i+1] == \">\")) {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \">\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \"=\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \"=\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\t\tif (!isLast && src[i+1] == \">\") {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdata[j++] = SyntaxCategory.Symbol;\n\t\t\t\t\t}\n\t\t\t\t} else if (c == \"\\\"\") {\n\t\t\t\t\t// literal string\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.String;\n\t\t\t\t} else if (c == \"0\") {\n\t\t\t\t\t// literal number\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.NumberStart;\n\t\t\t\t} else if (c >= \"1\" && c <= \"9\") {\n\t\t\t\t\t// literal decimal number\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.DecimalNumber;\n\t\t\t\t} else if (c == \"#\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.ByteArray;\n\t\t\t\t} else if ((c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\") || c == \"_\") {\n\t\t\t\t\t// maybe keyword, builtin type, or boolean\n\t\t\t\t\tlet i0 = i;\n\t\t\t\t\tlet chars = [c];\n\t\t\t\t\t// move i to the last word char\n\t\t\t\t\twhile (i + 1 < n) {\n\t\t\t\t\t\tlet d = src[i+1];\n\n\t\t\t\t\t\tif ((d >= \"a\" && d <= \"z\") || (d >= \"A\" && d <= \"Z\") || d == \"_\" || (d >= \"0\" && d <= \"9\")) {\n\t\t\t\t\t\t\tchars.push(d);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet word = chars.join(\"\");\n\t\t\t\t\t/** @type {number} */\n\t\t\t\t\tlet type;\n\t\t\t\t\tswitch (word) {\n\t\t\t\t\t\tcase \"true\":\n\t\t\t\t\t\tcase \"false\":\n\t\t\t\t\t\t\ttype = SyntaxCategory.Literal;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Bool\":\n\t\t\t\t\t\tcase \"Int\":\n\t\t\t\t\t\tcase \"ByteArray\":\n\t\t\t\t\t\tcase \"String\":\n\t\t\t\t\t\tcase \"Option\":\n\t\t\t\t\t\t\ttype = SyntaxCategory.Type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"if\":\n\t\t\t\t\t\tcase \"else\":\n\t\t\t\t\t\tcase \"switch\":\n\t\t\t\t\t\tcase \"func\":\n\t\t\t\t\t\tcase \"const\":\n\t\t\t\t\t\tcase \"struct\":\n\t\t\t\t\t\tcase \"enum\":\n\t\t\t\t\t\tcase \"import\":\n\t\t\t\t\t\tcase \"print\":\n\t\t\t\t\t\tcase \"error\":\n\t\t\t\t\t\tcase \"self\":\n\t\t\t\t\t\t\ttype = SyntaxCategory.Keyword;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"testing\":\n\t\t\t\t\t\tcase \"spending\":\n\t\t\t\t\t\tcase \"staking\":\n\t\t\t\t\t\tcase \"minting\":\n\t\t\t\t\t\tcase \"module\":\n\t\t\t\t\t\t\tif (i0 == 0) {\n\t\t\t\t\t\t\t\ttype = SyntaxCategory.Keyword;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttype = SyntaxCategory.Normal;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = SyntaxCategory.Normal;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let ii = i0; ii < i0 + chars.length; ii++) {\n\t\t\t\t\t\tdata[j++] = type;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.SLComment:\n\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\t\t\t\tif (c == \"\\n\") {\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.MLComment:\n\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\n\t\t\t\tif (c == \"*\" && !isLast && src[i+1] == \"/\") {\n\t\t\t\t\ti++;\n\t\t\t\t\tdata[j++] = SyntaxCategory.Comment;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.String:\n\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\n\t\t\t\tif (c == \"\\\"\") {\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.NumberStart:\n\t\t\t\tif (c == \"x\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.HexNumber;\n\t\t\t\t} else if (c == \"o\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.OctalNumber;\n\t\t\t\t} else if (c == \"b\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.BinaryNumber;\n\t\t\t\t} else if (c >= \"0\" && c <= \"9\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t\tstate = SyntaxState.DecimalNumber;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.DecimalNumber:\n\t\t\t\tif (c >= \"0\" && c <= \"9\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.HexNumber:\n\t\t\tcase SyntaxState.ByteArray:\n\t\t\t\tif ((c >= \"a\" && c <= \"f\") || (c >= \"0\" && c <= \"9\")) {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.OctalNumber:\n\t\t\t\tif (c >= \"0\" && c <= \"7\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SyntaxState.BinaryNumber:\n\t\t\t\tif (c == \"0\" || c == \"1\") {\n\t\t\t\t\tdata[j++] = SyntaxCategory.Literal;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tstate = SyntaxState.Normal;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"unhandled SyntaxState\");\n\t\t}\t\t\n\t}\n\n\tfor (let s of groupStack) {\n\t\tdata[s.site.startPos] = SyntaxCategory.Error;\n\t}\n\n\treturn data;\n}\n\n\n//////////////////////////////////////\n// Section 27: Fuzzy testing framework\n//////////////////////////////////////\n\n/**\n * @typedef {() => UplcData} ValueGenerator\n */\n\n/**\n * @typedef {(args: UplcValue[], res: (UplcValue | UserError)) => (boolean | Object.<string, boolean>)} PropertyTest\n */\n\n/**\n * Creates generators and runs script tests\n */\nclass FuzzyTest {\n\t/**\n\t * @type {NumberGenerator} - seed generator\n\t */\n\t#rand;\n\n\t#runsPerTest;\n\n\t#simplify;\n\n\t/**\n\t * @param {number} seed\n\t * @param {number} runsPerTest\n\t * @param {boolean} simplify - if true then also test the simplified program\n\t */\n\tconstructor(seed = 0, runsPerTest = 100, simplify = false) {\n\t\tconsole.log(\"starting fuzzy testing  with seed\", seed);\n\n\t\tthis.#rand = Crypto.rand(seed);\n\t\tthis.#runsPerTest = runsPerTest;\n\t\tthis.#simplify = simplify;\n\t}\n\n\t/**\n\t * @returns {NumberGenerator}\n\t */\n\tnewRand() {\n\t\tlet seed = this.#rand()*1000000;\n\n\t\treturn Crypto.rand(seed);\n\t}\n\n\t/**\n\t * Returns a gernator for whole numbers between min and max\n\t * @param {number} min\n\t * @param {number} max\n\t * @returns {() => bigint}\n\t */\n\trawInt(min = -10000000, max = 10000000) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\treturn BigInt(Math.floor(rand()*(max - min)) + min);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for whole numbers between min and max, wrapped with IntData\n\t * @param {number} min\n\t * @param {number} max\n\t * @returns {ValueGenerator}\n\t */\n\tint(min = -10000000, max = 10000000) {\t\t\n\t\tlet rand = this.rawInt(min, max);\n\n\t\treturn function() {\n\t\t\treturn new IntData(rand());\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for strings containing any utf-8 character\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tstring(minLength = 0, maxLength = 64) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\tlet chars = [];\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tchars.push(String.fromCodePoint(Math.round(rand()*1112064)));\n\t\t\t}\n\t\t\t\n\t\t\treturn ByteArrayData.fromString(chars.join(\"\"));\n\t\t}\n\t}\n\n\t/** \n\t * Returns a generator for strings with ascii characters from 32 (space) to 126 (tilde)\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tascii(minLength = 0, maxLength = 64) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\tlet chars = [];\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tchars.push(String.fromCharCode(Math.round(rand()*94 + 32)));\n\t\t\t}\n\t\t\t\n\t\t\treturn ByteArrayData.fromString(chars.join(\"\"));\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for bytearrays containing only valid ascii characters\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tasciiBytes(minLength = 0, maxLength = 64) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\tlet bytes = [];\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tbytes.push(Math.floor(rand()*94 + 32));\n\t\t\t}\n\n\t\t\treturn new ByteArrayData(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for bytearrays the are also valid utf8 strings\n\t * @param {number} minLength - length of the string, not of the bytearray!\n\t * @param {number} maxLength - length of the string, not of the bytearray!\n\t * @returns {ValueGenerator}\n\t */\n\tutf8Bytes(minLength = 0, maxLength = 64) {\n\t\treturn this.string(minLength, maxLength);\n\t}\n\n\t/**\n\t * Returns a generator for number[]\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {() => number[]}\n\t */\n\trawBytes(minLength = 0, maxLength = 64) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\tlet bytes = [];\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tbytes.push(Math.floor(rand()*256));\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for bytearrays \n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tbytes(minLength = 0, maxLength = 64) {\n\t\tlet rand = this.rawBytes(minLength, maxLength);\n\n\t\treturn function() {\n\t\t\tlet bytes = rand();\n\n\t\t\treturn new ByteArrayData(bytes);\n\t\t}\n\t}\n\t/**\n\t * Returns a generator for booleans,\n\t * @returns {() => boolean}\n\t */\n\trawBool() {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet x = rand();\n\n\t\t\treturn x >= 0.5;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for booleans, wrapped with ConstrData\n\t * @returns {ValueGenerator}\n\t */\n\tbool() {\n\t\tlet rand = this.rawBool();\n\n\t\treturn function() {\n\t\t\treturn new ConstrData(rand() ? 1 : 0, []);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for options\n\t * @param {ValueGenerator} someGenerator\n\t * @param {number} noneProbability\n\t * @returns {ValueGenerator}\n\t */\n\toption(someGenerator, noneProbability = 0.5) {\n\t\tlet rand = this.newRand();\n\n\t\treturn function() {\n\t\t\tlet x = rand();\n\n\t\t\tif (x < noneProbability) {\n\t\t\t\treturn new ConstrData(1, []);\n\t\t\t} else {\n\t\t\t\treturn new ConstrData(0, [someGenerator()]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for lists\n\t * @param {ValueGenerator} itemGenerator\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tlist(itemGenerator, minLength = 0, maxLength = 10) {\n\t\tlet rand = this.newRand();\n\n\t\tif (minLength < 0) {\n\t\t\tminLength = 0;\n\t\t}\n\n\t\tif (maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {UplcData[]}\n\t\t\t */\n\t\t\tlet items = [];\n\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\titems.push(itemGenerator());\n\t\t\t}\n\n\t\t\treturn new ListData(items);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for maps\n\t * @param {ValueGenerator} keyGenerator\n\t * @param {ValueGenerator} valueGenerator\n\t * @param {number} minLength\n\t * @param {number} maxLength\n\t * @returns {ValueGenerator}\n\t */\n\tmap(keyGenerator, valueGenerator, minLength = 0, maxLength = 10) {\n\t\tlet rand = this.newRand();\n\n\t\tif (minLength < 0) {\n\t\t\tminLength = 0;\n\t\t}\n\n\t\tif (maxLength < 0) {\n\t\t\tmaxLength = 0;\n\t\t}\n\n\t\treturn function() {\n\t\t\tlet n = Math.round(rand()*(maxLength - minLength)) + minLength;\n\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {[UplcData, UplcData][]}\n\t\t\t */\n\t\t\tlet pairs = [];\n\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tpairs.push([keyGenerator(), valueGenerator()]);\n\t\t\t}\n\n\t\t\treturn new MapData(pairs);\n\t\t};\n\t}\n\n\t/**\n\t * Returns a generator for objects\n\t * @param {...ValueGenerator} itemGenerators\n\t * @returns {ValueGenerator}\n\t */\n\tobject(...itemGenerators) {\n\t\treturn function() {\n\t\t\tlet items = itemGenerators.map(g => g());\n\n\t\t\treturn new ConstrData(0, items);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a generator for tagged constr\n\t * @param {number | NumberGenerator} tag\n\t * @param {...ValueGenerator} fieldGenerators\n\t * @returns {ValueGenerator}\n\t */\n\tconstr(tag, ...fieldGenerators) {\n\t\treturn function() {\n\t\t\tconst fields = fieldGenerators.map(g => g());\n\n\t\t\tconst finalTag = (typeof tag == \"number\") ? tag : Math.round(tag()*100);\n\t\t\t\n\t\t\treturn new ConstrData(finalTag, fields);\n\t\t}\n\t}\n\n\t/**\n\t * Run a test\n\t * @param {ValueGenerator[]} argGens\n\t * @param {string} src\n\t * @param {PropertyTest} propTest\n\t * @param {number} nRuns\n\t * @param {boolean} simplify\n\t * @returns {Promise<void>} - throws an error if any of the property tests fail\n\t */\n\tasync test(argGens, src, propTest, nRuns = this.#runsPerTest, simplify = false) {\n\t\t// compilation errors here aren't caught\n\n\t\tlet purposeName = extractScriptPurposeAndName(src);\n\n\t\tif (purposeName === null) {\n\t\t\tthrow new Error(\"failed to get script purpose and name\");\n\t\t} else {\n\t\t\tlet [_, testName] = purposeName;\n\n\t\t\tlet program = Program.new(src).compile(simplify);\n\n\t\t\tfor (let it = 0; it < nRuns; it++) {\n\t\t\t\tlet args = argGens.map(gen => new UplcDataValue(Site.dummy(), gen()));\n\t\t\t\n\t\t\t\tlet result = await program.run(args);\n\n\t\t\t\tlet obj = propTest(args, result);\n\n\t\t\t\tif (typeof obj == \"boolean\") {\n\t\t\t\t\tif (!obj) {\n\t\t\t\t\t\tthrow new Error(`property test '${testName}' failed (info: (${args.map(a => a.toString()).join(', ')}) => ${result.toString()})`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// check for failures\n\t\t\t\t\tfor (let key in obj) {\n\t\t\t\t\t\tif (!obj[key]) {\n\t\t\t\t\t\t\tthrow new Error(`property test '${testName}:${key}' failed (info: (${args.map(a => a.toString()).join(', ')}) => ${result.toString()})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(`property tests for '${testName}' succeeded${simplify ? \" (simplified)\":\"\"} (${program.calcSize()} bytes)`);\n\t\t}\n\n\t\tif (!simplify && this.#simplify) {\n\t\t\tawait this.test(argGens, src, propTest, nRuns, true);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Object.<string, ValueGenerator>} paramGenerators\n\t * @param {string[]} paramArgs\n\t * @param {string} src\n\t * @param {PropertyTest} propTest\n\t * @param {number} nRuns\n\t * @param {boolean} simplify\n\t * @returns {Promise<void>}\n\t */\n\tasync testParams(paramGenerators, paramArgs, src, propTest, nRuns = this.#runsPerTest, simplify = false) {\n\t\tlet program = Program.new(src);\n\n\t\tlet purposeName = extractScriptPurposeAndName(src);\n\n\t\tif (purposeName === null) {\n\t\t\tthrow new Error(\"failed to get script purpose and name\");\n\t\t} else {\n\t\t\tlet [_, testName] = purposeName;\n\n\t\t\tfor (let it = 0; it < nRuns; it++) {\n\n\t\t\t\tfor (let key in paramGenerators) {\n\t\t\t\t\tprogram.changeParamSafe(key, paramGenerators[key]())\n\t\t\t\t}\n\n\t\t\t\tlet args = paramArgs.map(paramArg => program.evalParam(paramArg));\n\t\t\t\n\t\t\t\tlet coreProgram = Program.new(src).compile(simplify);\n\n\t\t\t\tlet result = await coreProgram.run(args);\n\n\t\t\t\tlet obj = propTest(args, result);\n\n\t\t\t\tif (typeof obj == \"boolean\") {\n\t\t\t\t\tif (!obj) {\n\t\t\t\t\t\tthrow new Error(`property test '${testName}' failed (info: (${args.map(a => a.toString()).join(', ')}) => ${result.toString()})`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// check for failures\n\t\t\t\t\tfor (let key in obj) {\n\t\t\t\t\t\tif (!obj[key]) {\n\t\t\t\t\t\t\tthrow new Error(`property test '${testName}:${key}' failed (info: (${args.map(a => a.toString()).join(', ')}) => ${result.toString()})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(`property tests for '${testName}' succeeded${simplify ? \" (simplified)\":\"\"}`);\n\t\t}\n\n\t\tif (!simplify && this.#simplify) {\n\t\t\tawait this.testParams(paramGenerators, paramArgs, src, propTest, nRuns, true);\n\t\t}\n\t}\n}\n\n\n////////////////////////////\n// Section 28: CoinSelection\n////////////////////////////\n\n\n\n/**\n * Collection of coin selection algorithms\n */\nclass CoinSelection {\n    /**\n     * @param {UTxO[]} utxos \n     * @param {Value} amount \n     * @param {boolean} largestFirst\n     * @returns {[UTxO[], UTxO[]]} - [picked, not picked that can be used as spares]\n     */\n    static selectExtremumFirst(utxos, amount, largestFirst) {\n        let sum = new Value();\n\n        /** @type {UTxO[]} */\n        let notSelected = utxos.slice();\n\n        /** @type {UTxO[]} */\n        const selected = [];\n\n        /**\n         * Selects smallest utxos until 'needed' is reached\n         * @param {bigint} neededQuantity\n         * @param {(utxo: UTxO) => bigint} getQuantity\n         */\n        function select(neededQuantity, getQuantity) {\n            // first sort notYetPicked in ascending order when picking smallest first,\n            // and in descending order when picking largest first\n            // sort UTxOs that contain more assets last\n            notSelected.sort((a, b) => {\n                const qa = getQuantity(a);\n                const qb = getQuantity(b);\n\n                const sign = largestFirst ? -1 : 1;\n\n                if (qa != 0n && qb == 0n) {\n                    return sign;\n                } else if (qa == 0n && qb != 0n) {\n                    return -sign;\n                } else if (qa == 0n && qb == 0n) {\n                    return 0;\n                } else {\n                    const na = a.value.assets.nTokenTypes;\n                    const nb = b.value.assets.nTokenTypes;\n\n                    if (na == nb) {\n                        return Number(qa - qb)*sign;\n                    } else if (na < nb) {\n                        return sign;\n                    } else {\n                        return -sign\n                    }\n                }\n            });\n\n            let count = 0n;\n            const remaining = [];\n\n            while (count < neededQuantity || count == 0n) { // must select at least one utxo if neededQuantity == 0n\n                const utxo = notSelected.shift();\n\n                if (utxo === undefined) {\n                    throw new Error(\"not enough utxos to cover amount\");\n                } else {\n                    const qty = getQuantity(utxo);\n\n                    if (qty > 0n) {\n                        count += qty;\n                        selected.push(utxo);\n                        sum = sum.add(utxo.value);\n                    } else {\n                        remaining.push(utxo)\n                    }\n                }\n            }\n\n            notSelected = notSelected.concat(remaining);\n        }\n\n        /**\n         * Select UTxOs while looping through (MintingPolicyHash,TokenName) entries\n         */\n        const mphs = amount.assets.mintingPolicies;\n\n        for (const mph of mphs) {\n            const tokenNames = amount.assets.getTokenNames(mph);\n\n            for (const tokenName of tokenNames) {\n                const need = amount.assets.get(mph, tokenName);\n                const have = sum.assets.get(mph, tokenName);\n\n                if (have < need) {\n                    const diff = need - have;\n\n                    select(diff, (utxo) => utxo.value.assets.get(mph, tokenName));\n                }\n            }\n        }\n\n        // now use the same strategy for lovelace\n        const need = amount.lovelace;\n        const have = sum.lovelace;\n\n        if (have < need) {\n            const diff = need - have;\n\n            select(diff, (utxo) => utxo.value.lovelace);\n        }\n\n        assert(selected.length + notSelected.length == utxos.length, \"internal error: select algorithm doesn't conserve utxos\");\n\n        return [selected, notSelected];\n    }\n\n    /**\n     * @param {UTxO[]} utxos \n     * @param {Value} amount \n     * @returns {[UTxO[], UTxO[]]} - [selected, not selected]\n     */\n    static selectSmallestFirst(utxos, amount) {\n        return CoinSelection.selectExtremumFirst(utxos, amount, false);\n    }\n\n    /**\n     * @param {UTxO[]} utxos \n     * @param {Value} amount \n     * @returns {[UTxO[], UTxO[]]} - [selected, not selected]\n     */\n    static selectLargestFirst(utxos, amount) {\n        return CoinSelection.selectExtremumFirst(utxos, amount, true);\n    }\n}\n\n\n//////////////////////\n// Section 29: Wallets\n//////////////////////\n\n\n/**\n * @typedef {{\n *     isMainnet(): Promise<boolean>,\n *     usedAddresses: Promise<Address[]>,\n *     unusedAddresses: Promise<Address[]>,\n *     utxos: Promise<UTxO[]>,\n *     signTx(tx: Tx): Promise<Signature[]>,\n *     submitTx(tx: Tx): Promise<TxId>\n * }} Wallet\n */\n\n/**\n * @typedef {{\n *     getNetworkId(): Promise<number>,\n *     getUsedAddresses(): Promise<string[]>,\n *     getUnusedAddresses(): Promise<string[]>,\n *     getUtxos(): Promise<string[]>,\n *     signTx(txHex: string, partialSign: boolean): Promise<string>,\n *     submitTx(txHex: string): Promise<string>\n * }} Cip30Handle\n */\n\n/**\n * @implements {Wallet}\n */\nclass Cip30Wallet {\n    #handle;\n\n    /**\n     * @param {Cip30Handle} handle \n     */\n    constructor(handle) {\n        this.#handle = handle;\n    }\n\n    /**\n     * @returns {Promise<boolean>}\n     */\n    async isMainnet() {\n        return (await this.#handle.getNetworkId()) == 1;\n    }\n\n    /**\n     * @type {Promise<Address[]>}\n     */\n    get usedAddresses() {\n        return this.#handle.getUsedAddresses().then(addresses => addresses.map(a => new Address(a)));\n    }\n\n    /**\n     * @type {Promise<Address[]>}\n     */\n    get unusedAddresses() {\n        return this.#handle.getUnusedAddresses().then(addresses => addresses.map(a => new Address(a)));\n    }\n\n    /**\n     * @type {Promise<UTxO[]>}\n     */\n    get utxos() {\n        return this.#handle.getUtxos().then(utxos => utxos.map(u => UTxO.fromCbor(hexToBytes(u))));\n    }\n\n    /**\n     * @param {Tx} tx \n     * @returns {Promise<Signature[]>}\n     */\n    async signTx(tx) {\n        const res = await this.#handle.signTx(bytesToHex(tx.toCbor()), true);\n        \n        return TxWitnesses.fromCbor(hexToBytes(res)).signatures;\n    }\n\n    /**\n     * @param {Tx} tx \n     * @returns {Promise<TxId>}\n     */\n    async submitTx(tx) {\n        const responseText = await this.#handle.submitTx(bytesToHex(tx.toCbor()));\n\n        return new TxId(responseText);\n    }\n}\n\nclass WalletHelper {\n    #wallet;\n\n    /**\n     * @param {Wallet} wallet \n     */\n    constructor(wallet) {\n        this.#wallet = wallet;\n    }\n\n    /**\n     * @type {Promise<Address[]>}\n     */\n    get allAddresses() {\n        return this.#wallet.usedAddresses.then(usedAddress => this.#wallet.unusedAddresses.then(unusedAddresses => usedAddress.concat(unusedAddresses)));\n    }\n\n    /**\n     * @returns {Promise<Value>}\n     */\n    async calcBalance() {\n        let sum = new Value();\n\n        const utxos = await this.#wallet.utxos;\n\n        for (const utxo of utxos) {\n            sum = sum.add(utxo.value);\n        }\n\n        return sum;\n    }\n\n    /**\n     * @type {Promise<Address>}\n     */\n    get baseAddress() {\n        return this.allAddresses.then(addresses => assertDefined(addresses[0]));\n    }\n\n    /**\n     * @type {Promise<Address>}\n     */\n    get changeAddress() {\n        return this.#wallet.unusedAddresses.then(addresses => {\n            if (addresses.length == 0) {\n                return this.#wallet.usedAddresses.then(addresses => {\n                    if (addresses.length == 0) {\n                        throw new Error(\"no addresses found\")\n                    } else {\n                        return addresses[addresses.length-1];\n                    }\n                })\n            } else {\n                return addresses[0];\n            }\n        });\n    }\n\n    /**\n     * Returns the first UTxO, so the caller can check precisely which network the user is connected to (eg. preview or preprod)\n     * @type {Promise<?UTxO>}\n     */\n    get refUtxo() {\n        return this.#wallet.utxos.then(utxos => {\n            if(utxos.length == 0) {\n                return null;\n            } else {\n                return assertDefined(utxos[0])\n            }\n        });\n    }\n\n    /**\n     * @param {Value} amount \n     * @param {(allUtxos: UTxO[], anount: Value) => [UTxO[], UTxO[]]} algorithm\n     * @returns {Promise<[UTxO[], UTxO[]]>} - [picked, not picked that can be used as spares]\n     */ \n    async pickUtxos(amount, algorithm = CoinSelection.selectSmallestFirst) {\n        return algorithm(await this.#wallet.utxos, amount);\n    }\n\n    /**\n     * Returned collateral can't contain an native assets (pure lovelace)\n     * TODO: combine UTxOs if a single UTxO isn't enough\n     * @param {bigint} amount - 2 Ada should cover most things\n     * @returns {Promise<UTxO>}\n     */\n    async pickCollateral(amount = 2000000n) {\n        const pureUtxos = (await this.#wallet.utxos).filter(utxo => utxo.value.assets.isZero());\n\n        if (pureUtxos.length == 0) {\n            throw new Error(\"no pure UTxOs in wallet (needed for collateral)\");\n        }\n\n        const bigEnough = pureUtxos.filter(utxo => utxo.value.lovelace >= amount);\n\n        if (bigEnough.length == 0) {\n            throw new Error(\"no UTxO in wallet that is big enough to cover collateral\");\n        }\n\n        bigEnough.sort((a,b) => Number(a.value.lovelace - b.value.lovelace));\n\n        return bigEnough[0];\n    }\n\n    /**\n     * @param {Address} addr\n     * @returns {Promise<boolean>}\n     */\n    async isOwnAddress(addr) {\n        const pkh = addr.pubKeyHash;\n\n        if (pkh === null) {\n            return false;\n        } else {\n            return this.isOwnPubKeyHash(pkh);\n        }\n    }\n\n        /**\n     * @param {PubKeyHash} pkh\n     * @returns {Promise<boolean>}\n     */\n    async isOwnPubKeyHash(pkh) {\n        const addresses = await this.allAddresses;\n\n        for (const addr of addresses) {\n            const aPkh = addr.pubKeyHash;\n\n            if (aPkh !== null && aPkh.eq(pkh)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\n\n//////////////////////\n// Section 30: Network\n//////////////////////\n\n/**\n * @typedef {{\n *     getUtxos(address: Address): Promise<UTxO[]>,\n *     submitTx(tx: Tx): Promise<TxId>\n * }} Network\n */\n\n/**\n * @implements {Network}\n */\nclass BlockfrostV0 {\n    #networkName;\n    #projectId;\n\n    /**\n     * @param {string} networkName - \"preview\", \"preprod\" or \"mainnet\"\n     * @param {string} projectId\n     */\n    constructor(networkName, projectId) {\n        this.#networkName = networkName;\n        this.#projectId = projectId\n    }\n\n    /**\n     * Determine the network which the wallet is connected to.\n     * @param {Wallet} wallet \n     * @param {{\n     *     preview?: string,\n     *     preprod?: string,\n     *     mainnet?: string\n     * }} projectIds \n     * @returns {Promise<BlockfrostV0>}\n     */\n    static async resolve(wallet, projectIds) {\n        if (await wallet.isMainnet()) {\n            return new BlockfrostV0(\"mainnet\", assertDefined(projectIds[\"mainnet\"]));\n        } else {\n            const helper = new WalletHelper(wallet);\n\n            const refUtxo = await helper.refUtxo;\n\n            if (refUtxo === null) {\n                throw new Error(\"empty wallet, can't determine which testnet you are connecting to\");\n            } else {\n                const preprodProjectId = projectIds[\"preprod\"];\n                const previewProjectId = projectIds[\"preview\"];\n\n                if (preprodProjectId !== undefined) {\n                    const preprodNetwork = new BlockfrostV0(\"preprod\", preprodProjectId);\n\n                    if (await preprodNetwork.hasUtxo(refUtxo)) {\n                        return preprodNetwork;\n                    }\n                } \n                \n                if (previewProjectId !== undefined) {\n                    const previewNetwork = new BlockfrostV0(\"preview\", previewProjectId);\n\n                    if (!(await previewNetwork.hasUtxo(refUtxo))) {\n                        throw new Error(\"not preview network (hint: provide project id for preprod\");\n                    } else {\n                        return previewNetwork;\n                    }\n                } else {\n                    if (preprodProjectId === undefined) {\n                        throw new Error(\"no project ids for testnets\");\n                    } else {\n                        throw new Error(\"no project id for preview testnet\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {any} obj \n     * @returns \n     */\n    static parseValue(obj) {\n        let value = new Value();\n\n        for (let item of obj) {\n            let qty = BigInt(item.quantity);\n\n            if (item.unit == \"lovelace\") {\n                value = value.add(new Value(qty));\n            } else {\n                let policyID = item.unit.substring(0, 56);\n                let mph = MintingPolicyHash.fromHex(policyID);\n\n                let token = hexToBytes(item.unit.substring(56));\n\n                value = value.add(new Value(0n, new Assets([\n                    [mph, [\n                        [token, qty]\n                    ]]\n                ])));\n            }\n        }\n\n        return value;\n    }\n\n    /**\n     * Used by BlockfrostV0.resolve()\n     * @param {UTxO} utxo\n     * @returns {Promise<boolean>}\n     */\n    async hasUtxo(utxo) {\n        const txId = utxo.txId;\n\n        const url = `https://cardano-${this.#networkName}.blockfrost.io/api/v0/txs/${txId.hex}/utxos`;\n\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers: {\n                \"project_id\": this.#projectId\n            }\n        });\n\n        return response.ok;\n    }\n\n    /**\n     * Returns oldest UTxOs first, newest last.\n     * TODO: pagination\n     * @param {Address} address \n     * @returns {Promise<UTxO[]>}\n     */\n    async getUtxos(address) {\n        const url = `https://cardano-${this.#networkName}.blockfrost.io/api/v0/addresses/${address.toBech32()}/utxos?order=asc`;\n\n        const response = await fetch(url, {\n            headers: {\n                \"project_id\": this.#projectId\n            }\n        });\n\n        /** \n         * @type {any} \n         */\n        let all = await response.json();\n\n        if (all?.status_code >= 300) {\n            all = []; \n        }\n\n        return all.map(obj => {\n            return new UTxO(\n                TxId.fromHex(obj.tx_hash),\n                BigInt(obj.output_index),\n                new TxOutput(\n                    address,\n                    BlockfrostV0.parseValue(obj.amount),\n                    Datum.inline(ConstrData.fromCbor(hexToBytes(obj.inline_datum)))\n                )\n            );\n        });\n    }  \n\n    /** \n     * @param {Tx} tx \n     * @returns {Promise<TxId>}\n     */\n    async submitTx(tx) {\n        const data = new Uint8Array(tx.toCbor());\n        const url = `https://cardano-${this.#networkName}.blockfrost.io/api/v0/tx/submit`;\n\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"content-type\": \"application/cbor\",\n                \"project_id\": this.#projectId\n            },\n            body: data\n        }).catch(e => {\n            console.error(e);\n            throw e;\n        });\n\n        const responseText = await response.text();\n\n        if (response.status != 200) {\n            throw new Error(responseText);\n        } else {\n            return new TxId(JSON.parse(responseText));  \n        }\n    }   \n}\n\n\n///////////////////////\n// Section 31: Emulator\n///////////////////////\n/**\n * Single address wallet emulator.\n * @implements {Wallet}\n */\nclass WalletEmulator {\n    #network;\n    #privateKey;\n    #publicKey;\n\n    /** \n     * @param {Network} network\n     * @param {NumberGenerator} random - used to generate the private key\n     */\n    constructor(network, random) {\n        this.#network = network;\n        this.#privateKey = WalletEmulator.genPrivateKey(random);\n        this.#publicKey = Crypto.Ed25519.derivePublicKey(this.#privateKey);\n\n        // TODO: staking credentials\n    }\n\n    /**\n     * Generate a private key from a random number generator (not cryptographically secure!)\n     * @param {NumberGenerator} random \n     * @returns {number[]} - Ed25519 private key is 32 bytes long\n     */\n    static genPrivateKey(random) {\n        const key = [];\n\n        for (let i = 0; i < 32; i++) {\n            key.push(Math.floor(random()*256)%256);\n        }\n\n        return key;\n    }\n\n    /**\n     * @type {PubKeyHash}\n     */\n    get pubKeyHash() {\n        return new PubKeyHash(Crypto.blake2b(this.#publicKey, 28));\n    }\n\n    get address() {\n        return Address.fromPubKeyHash(this.pubKeyHash);\n    }\n\n    /**\n     * @returns {Promise<boolean>}\n     */\n    async isMainnet() {\n        return false;\n    }\n\n    /**\n     * Assumed wallet was initiated with at least 1 UTxO at the pubkeyhash address.\n     * @returns {Promise<Address[]>}\n     */\n    get usedAddresses() {\n        return new Promise((resolve, _) => {\n            resolve([this.address])\n        });\n    }\n\n    get unusedAddresses() {\n        return new Promise((resolve, _) => {\n            resolve([])\n        });\n    }\n\n    get utxos() {\n        return new Promise((resolve, _) => {\n            resolve(this.#network.getUtxos(this.address));\n        });\n    }\n\n    /**\n     * Simply assumed the tx needs to by signed by this wallet without checking.\n     * @param {Tx} tx\n     * @returns {Promise<Signature[]>}\n     */\n    async signTx(tx) {\n        return [\n            new Signature(\n                this.#publicKey,\n                Crypto.Ed25519.sign(tx.bodyHash, this.#privateKey)\n            )\n        ];\n    }\n\n    /**\n     * @param {Tx} tx \n     * @returns {Promise<TxId>}\n     */\n    async submitTx(tx) {\n        return await this.#network.submitTx(tx);\n    }\n}\n\n/**\n * collectUtxos removes tx inputs from the list, and appends txoutputs sent to the address to the end.\n * @typedef {{\n *     id(): TxId,\n *     consumes(txId: TxId, utxoIdx: bigint): boolean,\n *     collectUtxos(address: Address, utxos: UTxO[]): UTxO[]\n * }} EmulatorTx\n */\n\n/**\n * @implements {EmulatorTx}\n */\nclass GenesisTx {\n    #id;\n    #address;\n    #lovelace;\n    #assets;\n\n    /**\n     * @param {number} id\n     * @param {Address} address \n     * @param {bigint} lovelace\n     * @param {Assets} assets \n     */\n    constructor(id, address, lovelace, assets) {\n        this.#id = id;\n        this.#address = address;\n        this.#lovelace = lovelace;\n        this.#assets = assets;\n    }\n\n    /**\n     * Simple incremental txId for genesis transactions.\n     * It's very unlikely that regular transactions have the same hash.\n     * @return {TxId}\n     */\n    id() {\n        let bytes = bigIntToBytes(BigInt(this.#id));\n\n        if (bytes.length < 32) {\n            bytes = (new Array(32 - bytes.length)).fill(0).concat(bytes);\n        }\n\n        return new TxId(bytes);\n    }\n\n    /**\n     * @param {TxId} txId \n     * @param {bigint} utxoIdx \n     * @returns \n     */\n    consumes(txId, utxoIdx) {\n        return false;\n    }\n\n    /**\n     * @param {Address} address\n     * @param {UTxO[]} utxos\n     * @returns {UTxO[]}\n     */\n    collectUtxos(address, utxos) {\n        if (eq(this.#address.bytes, address.bytes)) {\n            utxos = utxos.slice();\n\n            utxos.push(new UTxO(\n                this.id(),\n                0n,\n                new TxOutput(\n                    this.#address,\n                    new Value(this.#lovelace, this.#assets)\n                )\n            ));\n\n            return utxos;\n        } else {\n            return utxos;\n        }\n    }\n}\n\n/**\n * @implements {EmulatorTx}\n */\nclass RegularTx {\n    #tx;\n\n    /**\n     * @param {Tx} tx \n     */\n    constructor(tx) {\n        this.#tx = tx;\n    }\n\n    /**\n     * @returns {TxId}\n     */\n    id() {\n        return this.#tx.id();\n    }\n\n    /**\n     * @param {TxId} txId\n     * @param {bigint} utxoIdx\n     * @returns {boolean}\n     */\n    consumes(txId, utxoIdx) {\n        const txInputs = this.#tx.body.inputs;\n\n        return txInputs.some(txInput => {\n            return txInput.txId.hex == txId.hex && txInput.utxoIdx == utxoIdx;\n        });\n    }\n\n    /**\n     * @param {Address} address \n     * @param {UTxO[]} utxos \n     * @returns {UTxO[]}\n     */\n    collectUtxos(address, utxos) {\n        utxos = utxos.filter(utxo => !this.consumes(utxo.txId, utxo.utxoIdx));\n\n        const txOutputs = this.#tx.body.outputs;\n\n        txOutputs.forEach((txOutput, utxoId) => {\n            if (eq(txOutput.address.bytes, address.bytes)) {\n                utxos.push(new UTxO(\n                    this.id(),\n                    BigInt(utxoId),\n                    txOutput\n                ));\n            }\n        });\n\n        return utxos;\n    }\n}\n\n/**\n * @implements {Network}\n */\nclass NetworkEmulator {\n    /**\n     * @type {bigint}\n     */\n    #slot;\n\n    /**\n     * @type {NumberGenerator}\n     */\n    #random;\n\n    /**\n     * @type {GenesisTx[]}\n     */\n    #genesis;\n\n    /**\n     * @type {EmulatorTx[]}\n     */\n    #mempool;\n\n    /**\n     * @type {EmulatorTx[][]}\n     */\n    #blocks;\n\n    /**\n     * @param {number} seed \n     */\n    constructor(seed = 0) {\n        this.#slot = 0n;\n        this.#random = Crypto.mulberry32(seed);\n        this.#genesis = [];\n        this.#mempool = [];\n        this.#blocks = [];\n    }\n\n    /**\n     * Creates a WalletEmulator and adds a block with a single fake unbalanced Tx\n     * @param {bigint} lovelace\n     * @param {Assets} assets\n     * @returns {WalletEmulator}\n     */\n    createWallet(lovelace = 0n, assets = new Assets([])) {\n        const wallet = new WalletEmulator(this, this.#random);\n\n        this.createUtxo(wallet, lovelace, assets);\n\n        return wallet;\n    }\n\n    /**\n     * Creates a UTxO using a GenesisTx.\n     * @param {WalletEmulator} wallet \n     * @param {bigint} lovelace \n     * @param {Assets} assets \n     */\n    createUtxo(wallet, lovelace, assets = new Assets([])) {\n        if (lovelace != 0n || !assets.isZero()) {\n            const tx = new GenesisTx(\n                this.#genesis.length,\n                wallet.address,\n                lovelace,\n                assets\n            );\n\n            this.#genesis.push(tx);\n            this.#mempool.push(tx);\n        }\n    }\n\n    /**\n     * Mint a block with the current mempool, and advance the slot.\n     * @param {bigint} nSlots \n     */\n    tick(nSlots) {\n        if (this.#mempool.length > 0) {\n            this.#blocks.push(this.#mempool);\n\n            this.#mempool = [];\n        }\n\n        this.#slot += nSlots;\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise<UTxO[]>}\n     */\n    async getUtxos(address) {\n        /**\n         * @type {UTxO[]}\n         */\n        let utxos = [];\n\n        for (let block of this.#blocks) {\n            for (let tx of block) {\n                utxos = tx.collectUtxos(address, utxos);\n            }\n        }\n\n        return utxos;\n    }\n\n    /**\n     * @param {TxId} txId \n     * @param {bigint} utxoIdx \n     * @returns {boolean}\n     */\n    isConsumed(txId, utxoIdx) {\n        return this.#blocks.some(b => {\n            return b.some(tx => {\n                return tx.consumes(txId, utxoIdx)\n            })\n        }) || this.#mempool.some(tx => {\n            return tx.consumes(txId, utxoIdx);\n        })\n    }\n\n    /**\n     * @param {Tx} tx \n     * @returns {Promise<TxId>}\n     */\n    async submitTx(tx) {\n        assert(tx.isValid(this.#slot), \"tx invalid (not finalized or slot out of range)\");\n\n        // make sure that none of the inputs have been consumed before\n        assert(tx.body.inputs.every(input => !this.isConsumed(input.txId, input.utxoIdx)), \"input already consumed before\");\n\n        this.#mempool.push(new RegularTx(tx));\n\n        return tx.id();\n    }\n}\n\n/**\n * The following functions are used for some tests in ./test/, and aren't\n * intended to be used by regular users of this library.\n */\nconst exportedForTesting = {\n\tassert: assert,\n\tassertClass: assertClass,\n\tbigIntToBytes: bigIntToBytes,\n\tbytesToBigInt: bytesToBigInt,\n\tsetRawUsageNotifier: setRawUsageNotifier,\n\tsetBlake2bDigestSize: setBlake2bDigestSize,\n\tdumpCostModels: dumpCostModels,\n\tSite: Site,\n\tSource: Source,\n\tCrypto: Crypto,\n\tMapData: MapData,\n\tUplcData: UplcData,\n\tCborData: CborData,\n\tConstrData: ConstrData,\n\tIntData: IntData,\n\tByteArrayData: ByteArrayData,\n\tListData: ListData,\n\tUplcBool: UplcBool,\n\tUplcValue: UplcValue,\n\tUplcDataValue: UplcDataValue,\n\tScriptPurpose: ScriptPurpose,\n\tUplcTerm: UplcTerm,\n\tUplcProgram: UplcProgram,\n\tUplcLambda: UplcLambda,\n\tUplcCall: UplcCall,\n\tUplcBuiltin: UplcBuiltin,\n\tUplcVariable: UplcVariable,\n\tUplcConst: UplcConst,\n\tUplcInt: UplcInt,\n\tIRProgram: IRProgram,\n\tTx: Tx,\n\tTxInput: TxInput,\n\tTxBody: TxBody\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGh5cGVyaW9uYnQvaGVsaW9zL2hlbGlvcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdB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QTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDBDQUEwQyxTQUFTOztBQUVuRDtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCwwQ0FBMEMsU0FBUzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUIsV0FBVyxtQkFBbUI7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtB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QWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFD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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUZBQXlGLGFBQWEsUUFBUSxXQUFXO0FBQ3pIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLDZJQUE2SSxZQUFZO0FBQzdKO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Es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bEIsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxN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O0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRkFBZ0Y7QUFDOUYsY0FBYztBQUNkO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2QsVUFBVTtBQUNWO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2YsVUFBVTtBQUNWO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtB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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFLFNBQVMsdUJBQXVCO0FBQ2xGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BELFlBQVk7QUFDWjtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQW1FO0FBQzlFLFdBQVc7QUFDWDtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWTtBQUNaO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWjtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnSUFBZ0k7QUFDbEosa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnSUFBZ0k7QUFDbEosa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNJQUFzSTtBQUN6SixtQkFBbUI7QUFDbkI7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0lBQXNJO0FBQzVKLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixPQUFPO0FBQ1AsTUFBTTtBQUNOLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBa0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBOEM7QUFDOUQsZ0JBQWdCO0FBQ2hCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsY0FBYywwREFBMEQ7QUFDeEUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3REFBd0Q7QUFDdEUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlO0FBQ2Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0NBQW9DO0FBQ3BGLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRixHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSw4Q0FBOEMsNkRBQTZEO0FBQzNHLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdFQUF3RTtBQUN4RixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQXdFO0FBQ3hGLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlDQUF5QyxpQkFBaUI7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDO0FBQ25GLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxjQUFjO0FBQzFCLFlBQVksYUFBYTtBQUN6QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxTQUFTO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFTztBQUNQO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksWUFBWTtBQUN4QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGFBQWE7QUFDekIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEU7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUIsY0FBYyxhQUFhO0FBQzFGOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQixLQUFLLE9BQU8sRUFBRSxJQUFJLEVBQUUsd0NBQXdDLEtBQUssT0FBTyxFQUFFLElBQUksRUFBRSx3Q0FBd0MsS0FBSyxPQUFPLEVBQUUsSUFBSSxFQUFFLHNDQUFzQyxJQUFJLE9BQU87QUFDaE8sSUFBSTtBQUNKLGFBQWEsc0JBQXNCLEdBQUcsMEJBQTBCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksUUFBUTtBQUNwQixZQUFZLFdBQVc7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsMklBQTJJLDBCQUEwQjs7QUFFckssWUFBWSw4QkFBOEIsR0FBRyxRQUFRLEVBQUUsMEJBQTBCO0FBQ2pGOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELElBQUk7QUFDL0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCLFlBQVksU0FBUztBQUNyQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxTQUFTO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsRUFBRTs7QUFFckM7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxzQkFBc0I7QUFDakY7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0MsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQVE7QUFDUjtBQUNBOztBQUVBLFlBQVksV0FBVztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSixrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTtBQUN6QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLEtBQUs7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLEtBQUs7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEMsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvRUFBb0UsS0FBSztBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNFQUFzRSxLQUFLOztBQUUzRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQixZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLEVBQUU7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhEQUE4RCxHQUFHO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1FQUFtRSxHQUFHO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCwrRkFBK0YsRUFBRTtBQUNqRztBQUNBOztBQUVBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRyxJQUFJO0FBQ0osK0VBQStFLHVCQUF1QjtBQUN0Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUEsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLElBQUksbUJBQW1CLElBQUk7QUFDeEM7QUFDQSxpQkFBaUIsSUFBSSxJQUFJLEVBQUUsSUFBSTtBQUMvQixrQ0FBa0MsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsY0FBYztBQUNsRTtBQUNBLGlCQUFpQixJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLE9BQU8sOEJBQThCLElBQUksSUFBSSxFQUFFLElBQUk7QUFDbkgsZUFBZSxLQUFLO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhEQUE4RCxHQUFHO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1FQUFtRSxHQUFHO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTCx3R0FBd0csRUFBRTtBQUMxRztBQUNBOztBQUVBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRyxJQUFJO0FBQ0osK0VBQStFLHVCQUF1QjtBQUN0Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUEsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsSUFBSSxtQkFBbUIsSUFBSTtBQUN4QztBQUNBLGlCQUFpQixJQUFJLElBQUksRUFBRSxJQUFJO0FBQy9CLGtDQUFrQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxjQUFjO0FBQ2xFO0FBQ0EsaUJBQWlCLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxPQUFPLEdBQUcsS0FBSyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksT0FBTyw4QkFBOEIsSUFBSSxJQUFJLEVBQUUsSUFBSTtBQUNuSCxlQUFlLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixVQUFVLElBQUksaUJBQWlCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQsS0FBSztBQUNMLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFLEVBQUU7O0FBRXhFO0FBQ0EsYUFBYSxJQUFJLG1CQUFtQixJQUFJO0FBQ3hDO0FBQ0EsaUJBQWlCLElBQUksSUFBSSxFQUFFLElBQUk7QUFDL0I7QUFDQSxlQUFlLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVSxJQUFJLGlCQUFpQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsSUFBSSxpQkFBaUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsVUFBVSxJQUFJLGlCQUFpQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLCtCQUErQjtBQUMzQyxZQUFZLDBCQUEwQjtBQUN0QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLGNBQWM7QUFDMUIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksWUFBWTtBQUN4QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksTUFBTTtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksWUFBWTtBQUN4QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksVUFBVTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksVUFBVTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQSxhQUFhLDJGQUEyRjtBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQ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QUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGh5cGVyaW9uYnQvaGVsaW9zL2hlbGlvcy5qcz9lZTgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vQHRzLWNoZWNrXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgICAgSGVsaW9zICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gQXV0aG9yOiAgICAgICAgQ2hyaXN0aWFuIFNjaG1pdHpcbi8vIEVtYWlsOiAgICAgICAgIGNzY2htaXR6Mzk4QGdtYWlsLmNvbVxuLy8gV2Vic2l0ZTogICAgICAgaHR0cHM6Ly93d3cuaHlwZXJpb24tYnQub3JnXG4vLyBSZXBvc2l0b3J5OiAgICBodHRwczovL2dpdGh1Yi5jb20vaHlwZXJpb24tYnQvaGVsaW9zXG4vLyBWZXJzaW9uOiAgICAgICAwLjEzLjI4XG4vLyBMYXN0IHVwZGF0ZTogICBBcHJpbCAyMDIzXG4vLyBMaWNlbnNlIHR5cGU6ICBCU0QtMy1DbGF1c2Vcbi8vXG4vL1xuLy8gQWJvdXQ6IEhlbGlvcyBpcyBhIHNtYXJ0IGNvbnRyYWN0IERTTCBmb3IgQ2FyZGFuby5cbi8vICAgICBUaGlzIEphdmFzY3JpcHQgbGlicmFyeSBjb250YWlucyBmdW5jdGlvbnMgdG8gY29tcGlsZSBIZWxpb3Mgc291cmNlcyBpbnRvIFBsdXR1cy1jb3JlLlxuLy8gICAgIFRyYW5zYWN0aW9ucyBjYW4gYWxzbyBiZSBidWlsdCB1c2luZyBIZWxpb3MuXG4vL1xuLy9cbi8vIERlcGVuZGVuY2llczogbm9uZVxuLy9cbi8vXG4vLyBEaXNjbGFpbWVyOiBJIG1hZGUgSGVsaW9zIGF2YWlsYWJsZSBhcyBGT1NTIHNvIHRoYXQgdGhlIENhcmRhbm8gY29tbXVuaXR5IGNhbiB0ZXN0IGl0IFxuLy8gICAgIGV4dGVuc2l2ZWx5LiBJIGRvbid0IGd1YXJhbnRlZSB0aGUgbGlicmFyeSBpcyBidWctZnJlZSwgbm9yIGRvIEkgZ3VhcmFudGVlXG4vLyAgICAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGZ1dHVyZSB2ZXJzaW9ucy5cbi8vXG4vL1xuLy8gRXhhbXBsZSB1c2FnZTpcbi8vICAgICA+IGltcG9ydCAqIGFzIGhlbGlvcyBmcm9tIFwiaGVsaW9zLmpzXCI7XG4vLyAgICAgPiBjb25zb2xlLmxvZyhoZWxpb3MuUHJvZ3JhbS5uZXcoXCJzcGVuZGluZyBteV92YWxpZGF0b3IgLi4uXCIpLmNvbXBpbGUoKS5zZXJpYWxpemUoKSk7XG4vLyAgICAgXG4vL1xuLy8gRG9jdW1lbnRhdGlvbjogaHR0cHM6Ly93d3cuaHlwZXJpb24tYnQub3JnL2hlbGlvcy1ib29rXG4vL1xuLy9cbi8vIE5vdGU6IEkgcmVjb21tZW5kIGtlZXBpbmcgdGhlIEhlbGlvcyBsaWJyYXJ5IGFzIGEgc2luZ2xlIHVubWluaWZpZWQgZmlsZSBmb3Igb3B0aW1hbCBcbi8vICAgICBhdWRpdGFiaWxpdHkuXG4vL1xuLy8gXG4vLyBMaWNlbnNlIHRleHQ6XG4vLyAgICAgQ29weXJpZ2h0IDIwMjMgQ2hyaXN0aWFuIFNjaG1pdHpcbi8vICAgICBcbi8vICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgXG4vLyAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyAgICAgXG4vLyAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIFxuLy8gICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gICAgIFxuLy8gICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgXG4vLyAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbi8vICAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAgICBcbi8vICAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBcbi8vICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBcbi8vICAgICBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyAgICAgXG4vLyAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyDigJxBUyBJU+KAnSBcbi8vICAgICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIFxuLy8gICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbi8vICAgICBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIFxuLy8gICAgIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIFxuLy8gICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFxuLy8gICAgIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIFxuLy8gICAgIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIFxuLy8gICAgIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIFxuLy8gICAgIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAgICAgXG4vL1xuLy9cbi8vIE92ZXJ2aWV3IG9mIGludGVybmFsczpcbi8vICAgICBTZWN0aW9uIDE6IENvbmZpZyAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04sIFRBQiwgY29uZmlnXG4vL1xuLy8gICAgIFNlY3Rpb24gMjogVXRpbGl0aWVzICAgICAgICAgICAgICAgICAgYXNzZXJ0LCBhc3NlcnREZWZpbmVkLCBhc3NlcnRDbGFzcywgYXNzZXJ0TnVtYmVyLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZU51bGwsIHJlZHVjZU51bGxQYWlycywgZXEsIGFzc2VydEVxLCBpZGl2LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwb3cyLCBpbWFzaywgaW1vZDgsIGJpZ0ludFRvQnl0ZXMsIGJ5dGVzVG9CaWdJbnQsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkWmVyb2VzLCBieXRlVG9CaXRTdHJpbmcsIGhleFRvQnl0ZXMsIGJ5dGVzVG9IZXgsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRvQnl0ZXMsIGJ5dGVzVG9UZXh0LCByZXBsYWNlVGFicywgQml0UmVhZGVyLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJpdFdyaXRlciwgU291cmNlLCBobCwgZGVwcmVjYXRpb25XYXJuaW5nXG4vL1xuLy8gICAgIFNlY3Rpb24gMzogVG9rZW5zICAgICAgICAgICAgICAgICAgICAgU2l0ZSwgUnVudGltZUVycm9yLCBUb2tlbiwgYXNzZXJ0VG9rZW4sIFdvcmQsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3ltYm9sVG9rZW4sIEdyb3VwLCBQcmltaXRpdmVMaXRlcmFsLCBJbnRMaXRlcmFsLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJvb2xMaXRlcmFsLCBCeXRlQXJyYXlMaXRlcmFsLCBTdHJpbmdMaXRlcmFsXG4vL1xuLy8gICAgIFNlY3Rpb24gNDogQ3J5cHRvZ3JhcGh5IGZ1bmN0aW9ucyAgICAgQkxBS0UyQl9ESUdFU1RfU0laRSwgc2V0Qmxha2UyYkRpZ2VzdFNpemUsIGltb2QzMiwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcm90ciwgcG9zTW9kLCBVSW50NjQsIENyeXB0b1xuLy9cbi8vICAgICBTZWN0aW9uIDU6IENib3IgZW5jb2Rlci9kZWNvZGVyICAgICAgIENib3JEYXRhXG4vL1xuLy8gICAgIFNlY3Rpb24gNjogVXBsYyBkYXRhIHR5cGVzICAgICAgICAgICAgVVBMQ19EQVRBX05PREVfTUVNX1NJWkUsIFVwbGNEYXRhLCBJbnREYXRhLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVBcnJheURhdGEsIExpc3REYXRhLCBNYXBEYXRhLCBDb25zdHJEYXRhXG4vL1xuLy8gICAgIFNlY3Rpb24gNzogSGVsaW9zIGRhdGEgb2JqZWN0cyAgICAgICAgSGVsaW9zRGF0YSwgSEludCwgVGltZSwgRHVyYXRpb24sIEJvb2wsIEhTdHJpbmcsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUFycmF5LCBITGlzdCwgSE1hcCwgT3B0aW9uLCBIYXNoLCBEYXR1bUhhc2gsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViS2V5SGFzaCwgU2NyaXB0SGFzaCwgTWludGluZ1BvbGljeUhhc2gsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3Rha2VLZXlIYXNoLCBTdGFraW5nVmFsaWRhdG9ySGFzaCwgVmFsaWRhdG9ySGFzaCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUeElkLCBUeE91dHB1dElkLCBBZGRyZXNzLCBBc3NldENsYXNzLCBBc3NldHMsIFZhbHVlXG4vL1xuLy8gICAgIFNlY3Rpb24gODogVXBsYyBjb3N0LW1vZGVscyAgICAgICAgICAgTmV0d29ya1BhcmFtcywgQ29zdE1vZGVsLCBDb25zdENvc3QsIExpbmVhckNvc3QsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnU2l6ZUNvc3QsIEFyZzBTaXplQ29zdCwgQXJnMVNpemVDb3N0LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZzJTaXplQ29zdCwgTWluQXJnU2l6ZUNvc3QsIE1heEFyZ1NpemVDb3N0LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1bUFyZ1NpemVzQ29zdCwgQXJnU2l6ZURpZmZDb3N0LCBBcmdTaXplUHJvZENvc3QsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnU2l6ZURpYWdDb3N0XG4vL1xuLy8gICAgIFNlY3Rpb24gOTogVXBsYyBidWlsdC1pbiBmdW5jdGlvbnMgICAgVVBMQ19CVUlMVElOUywgZHVtcENvc3RNb2RlbHMsIGZpbmRVcGxjQnVpbHRpbiwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VwbGNCdWlsdGluXG4vL1xuLy8gICAgIFNlY3Rpb24gMTA6IFVwbGMgQVNUICAgICAgICAgICAgICAgICAgU2NyaXB0UHVycG9zZSwgZ2V0UHVycG9zZU5hbWUsIFVwbGNWYWx1ZSwgVXBsY1R5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9VUExDX1JURV9DQUxMQkFDS1MsIFVwbGNSdGUsIFVwbGNTdGFjaywgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGxjQW5vbiwgVXBsY0RlbGF5ZWRWYWx1ZSwgVXBsY0ludCwgVXBsY0J5dGVBcnJheSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGxjU3RyaW5nLCBVcGxjVW5pdCwgVXBsY0Jvb2wsIFVwbGNQYWlyLCBVcGxjTGlzdCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGxjRGF0YVZhbHVlLCBVcGxjVGVybSwgVXBsY1ZhcmlhYmxlLCBVcGxjRGVsYXksIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBsY0xhbWJkYSwgVXBsY0NhbGwsIFVwbGNDb25zdCwgVXBsY0ZvcmNlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwbGNFcnJvciwgVXBsY0J1aWx0aW5cbi8vXG4vLyAgICAgU2VjdGlvbiAxMTogVXBsYyBwcm9ncmFtICAgICAgICAgICAgICBVUExDX1ZFUlNJT05fQ09NUE9ORU5UUywgVVBMQ19WRVJTSU9OLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBMVVRVU19TQ1JJUFRfVkVSU0lPTiwgZGVzZXJpYWxpemVVcGxjQnl0ZXMsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemVVcGxjXG4vL1xuLy8gICAgIFNlY3Rpb24gMTI6IFRva2VuaXphdGlvbiAgICAgICAgICAgICAgVG9rZW5pemVyLCB0b2tlbml6ZSwgdG9rZW5pemVJUlxuLy9cbi8vICAgICBTZWN0aW9uIDEzOiBIZWxpb3MgZXZhbCBlbnRpdGllcyAgICAgIEV2YWxFbnRpdHksIFR5cGUsIEFueVR5cGUsIERhdGFUeXBlLCBBbnlEYXRhVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdWlsdGluVHlwZSwgQnVpbHRpbkVudW1NZW1iZXIsIFN0YXRlbWVudFR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RydWN0U3RhdGVtZW50VHlwZSwgRW51bVN0YXRlbWVudFR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW51bU1lbWJlclN0YXRlbWVudFR5cGUsIEFyZ1R5cGUsIEZ1bmNUeXBlLCBOb3RUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluc3RhbmNlLCBEYXRhSW5zdGFuY2UsIENvbnN0U3RhdGVtZW50SW5zdGFuY2UsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnVuY0luc3RhbmNlLCBGdW5jU3RhdGVtZW50SW5zdGFuY2UsIE11bHRpSW5zdGFuY2UsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVm9pZEluc3RhbmNlLCBFcnJvckluc3RhbmNlLCBCdWlsdGluRnVuY0luc3RhbmNlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByaW50RnVuYywgVm9pZFR5cGUsIEVycm9yVHlwZSwgSW50VHlwZSwgQm9vbFR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVHlwZSwgQnl0ZUFycmF5VHlwZSwgUGFyYW1UeXBlLCBQYXJhbUZ1bmNWYWx1ZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0VHlwZSwgTWFwVHlwZSwgT3B0aW9uVHlwZSwgT3B0aW9uU29tZVR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uTm9uZVR5cGUsIEhhc2hUeXBlLCBQdWJLZXlIYXNoVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFrZUtleUhhc2hUeXBlLCBQdWJLZXlUeXBlLCBTY3JpcHRIYXNoVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWxpZGF0b3JIYXNoVHlwZSwgTWludGluZ1BvbGljeUhhc2hUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YWtpbmdWYWxpZGF0b3JIYXNoVHlwZSwgRGF0dW1IYXNoVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY3JpcHRDb250ZXh0VHlwZSwgU2NyaXB0UHVycG9zZVR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWludGluZ1NjcmlwdFB1cnBvc2VUeXBlLCBTcGVuZGluZ1NjcmlwdFB1cnBvc2VUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJld2FyZGluZ1NjcmlwdFB1cnBvc2VUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENlcnRpZnlpbmdTY3JpcHRQdXJwb3NlVHlwZSwgU3Rha2luZ1B1cnBvc2VUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YWtpbmdSZXdhcmRpbmdQdXJwb3NlVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFraW5nQ2VydGlmeWluZ1B1cnBvc2VUeXBlLCBEQ2VydFR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVnaXN0ZXJEQ2VydFR5cGUsIERlcmVnaXN0ZXJEQ2VydFR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZWdhdGVEQ2VydFR5cGUsIFJlZ2lzdGVyUG9vbERDZXJ0VHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXRpcmVQb29sRENlcnRUeXBlLCBUeFR5cGUsIFR4SWRUeXBlLCBUeElucHV0VHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUeE91dHB1dFR5cGUsIE91dHB1dERhdHVtVHlwZSwgTm9PdXRwdXREYXR1bVR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGFzaGVkT3V0cHV0RGF0dW1UeXBlLCBJbmxpbmVPdXRwdXREYXR1bVR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmF3RGF0YVR5cGUsIFR4T3V0cHV0SWRUeXBlLCBBZGRyZXNzVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDcmVkZW50aWFsVHlwZSwgQ3JlZGVudGlhbFB1YktleVR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JlZGVudGlhbFZhbGlkYXRvclR5cGUsIFN0YWtpbmdIYXNoVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFraW5nSGFzaFN0YWtlS2V5VHlwZSwgU3Rha2luZ0hhc2hWYWxpZGF0b3JUeXBlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YWtpbmdDcmVkZW50aWFsVHlwZSwgU3Rha2luZ0hhc2hDcmVkZW50aWFsVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdGFraW5nUHRyQ3JlZGVudGlhbFR5cGUsIFRpbWVUeXBlLCBEdXJhdGlvblR5cGUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGltZVJhbmdlVHlwZSwgQXNzZXRDbGFzc1R5cGUsIFZhbHVlVHlwZVxuLy9cbi8vICAgICBTZWN0aW9uIDE0OiBTY29wZXMgICAgICAgICAgICAgICAgICAgIEdsb2JhbFNjb3BlLCBTY29wZSwgVG9wU2NvcGUsIE1vZHVsZVNjb3BlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZ1bmNTdGF0ZW1lbnRTY29wZVxuLy9cbi8vICAgICBTZWN0aW9uIDE1OiBIZWxpb3MgQVNUIGV4cHJlc3Npb25zICAgIEV4cHIsIFR5cGVFeHByLCBUeXBlUmVmRXhwciwgVHlwZVBhdGhFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RUeXBlRXhwciwgTWFwVHlwZUV4cHIsIE9wdGlvblR5cGVFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZvaWRUeXBlRXhwciwgRnVuY0FyZ1R5cGVFeHByLCBGdW5jVHlwZUV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWVFeHByLCBBc3NpZ25FeHByLCBQcmludEV4cHIsIFZvaWRFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYWluRXhwciwgUHJpbWl0aXZlTGl0ZXJhbEV4cHIsIExpdGVyYWxEYXRhRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJ1Y3RMaXRlcmFsRmllbGQsIFN0cnVjdExpdGVyYWxFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RMaXRlcmFsRXhwciwgTWFwTGl0ZXJhbEV4cHIsIE5hbWVUeXBlUGFpciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGdW5jQXJnLCBGdW5jTGl0ZXJhbEV4cHIsIFZhbHVlUmVmRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVBhdGhFeHByLCBVbmFyeUV4cHIsIEJpbmFyeUV4cHIsIFBhcmVuc0V4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbEFyZ0V4cHIsIENhbGxFeHByLCBNZW1iZXJFeHByLCBJZkVsc2VFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlc3RydWN0RXhwciwgU3dpdGNoQ2FzZSwgVW5jb25zdHJEYXRhU3dpdGNoQ2FzZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTd2l0Y2hEZWZhdWx0LCBTd2l0Y2hFeHByLCBFbnVtU3dpdGNoRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhU3dpdGNoRXhwclxuLy9cbi8vICAgICBTZWN0aW9uIDE2OiBMaXRlcmFsIGZ1bmN0aW9ucyAgICAgICAgIGJ1aWxkTGl0ZXJhbEV4cHJGcm9tSnNvbiwgYnVpbGRMaXRlcmFsRXhwckZyb21WYWx1ZVxuLy9cbi8vICAgICBTZWN0aW9uIDE3OiBIZWxpb3MgQVNUIHN0YXRlbWVudHMgICAgIFN0YXRlbWVudCwgSW1wb3J0U3RhdGVtZW50LCBDb25zdFN0YXRlbWVudCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhRmllbGQsIERhdGFEZWZpbml0aW9uLCBTdHJ1Y3RTdGF0ZW1lbnQsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnVuY1N0YXRlbWVudCwgRW51bU1lbWJlciwgRW51bVN0YXRlbWVudCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbXBsRGVmaW5pdGlvblxuLy9cbi8vICAgICBTZWN0aW9uIDE4OiBIZWxpb3MgQVNUIGJ1aWxkaW5nICAgICAgIEFVVE9NQVRJQ19NRVRIT0RTLCBpbXBvcnRQYXRoVHJhbnNsYXRvciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbXBvcnRQYXRoVHJhbnNsYXRvciwgYnVpbGRQcm9ncmFtU3RhdGVtZW50cywgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFNjcmlwdFB1cnBvc2UsIGJ1aWxkU2NyaXB0LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RTY3JpcHRQdXJwb3NlQW5kTmFtZSwgYnVpbGRDb25zdFN0YXRlbWVudCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdERhdGFJbXBsLCBidWlsZFN0cnVjdFN0YXRlbWVudCwgYnVpbGREYXRhRmllbGRzLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkRnVuY1N0YXRlbWVudCwgYnVpbGRGdW5jTGl0ZXJhbEV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRGdW5jQXJncywgYnVpbGRFbnVtU3RhdGVtZW50LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkSW1wb3J0U3RhdGVtZW50cywgYnVpbGRFbnVtTWVtYmVyLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkSW1wbERlZmluaXRpb24sIGJ1aWxkSW1wbE1lbWJlcnMsIGJ1aWxkVHlwZUV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRMaXN0VHlwZUV4cHIsIGJ1aWxkTWFwVHlwZUV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRPcHRpb25UeXBlRXhwciwgYnVpbGRGdW5jVHlwZUV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRGdW5jQXJnVHlwZUV4cHIsIGJ1aWxkRnVuY1JldFR5cGVFeHBycywgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFR5cGVQYXRoRXhwciwgYnVpbGRUeXBlUmVmRXhwciwgYnVpbGRWYWx1ZUV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRNYXliZUFzc2lnbk9yUHJpbnRFeHByLCBidWlsZERlc3RydWN0RXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZERlc3RydWN0RXhwcnMsIGJ1aWxkQXNzaWduTGhzLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VCaW5hcnlFeHByQnVpbGRlciwgbWFrZVVuYXJ5RXhwckJ1aWxkZXIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRDaGFpbmVkVmFsdWVFeHByLCBidWlsZENhbGxFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ2hhaW5TdGFydFZhbHVlRXhwciwgYnVpbGRQYXJlbnNFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ2FsbEFyZ3MsIGJ1aWxkQ2FsbEFyZ0V4cHIsIGJ1aWxkSWZFbHNlRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFN3aXRjaEV4cHIsIGJ1aWxkU3dpdGNoQ2FzZU5hbWUsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRTd2l0Y2hDYXNlLCBidWlsZFN3aXRjaENhc2VOYW1lVHlwZSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZE11bHRpQXJnU3dpdGNoQ2FzZSwgYnVpbGRTaW5nbGVBcmdTd2l0Y2hDYXNlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkU3dpdGNoQ2FzZUJvZHksIGJ1aWxkU3dpdGNoRGVmYXVsdCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZExpc3RMaXRlcmFsRXhwciwgYnVpbGRNYXBMaXRlcmFsRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFN0cnVjdExpdGVyYWxFeHByLCBidWlsZFN0cnVjdExpdGVyYWxGaWVsZCwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFN0cnVjdExpdGVyYWxOYW1lZEZpZWxkLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkU3RydWN0TGl0ZXJhbFVubmFtZWRGaWVsZCwgYnVpbGRWYWx1ZVBhdGhFeHByXG4vL1xuLy8gICAgIFNlY3Rpb24gMTk6IElSIGRlZmluaXRpb25zICAgICAgICAgICAgb25Ob3RpZnlSYXdVc2FnZSwgc2V0UmF3VXNhZ2VOb3RpZmllciwgUmF3RnVuYywgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmF3RnVuY3Rpb25zLCB3cmFwV2l0aFJhd0Z1bmN0aW9uc1xuLy9cbi8vICAgICBTZWN0aW9uIDIwOiBJUiBDb250ZXh0IG9iamVjdHMgICAgICAgIElSU2NvcGUsIElSVmFyaWFibGUsIElSVmFsdWUsIElSRnVuY1ZhbHVlLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElSTGl0ZXJhbFZhbHVlLCBJUkRlZmVycmVkVmFsdWUsIElSQ2FsbFN0YWNrXG4vL1xuLy8gICAgIFNlY3Rpb24gMjE6IElSIEFTVCBvYmplY3RzICAgICAgICAgICAgSVJOYW1lRXhwclJlZ2lzdHJ5LCBJUkV4cHJSZWdpc3RyeSwgSVJFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElSTmFtZUV4cHIsIElSTGl0ZXJhbEV4cHIsIElSQ29uc3RFeHByLCBJUkZ1bmNFeHByLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElSQ2FsbEV4cHIsIElSQ29yZUNhbGxFeHByLCBJUlVzZXJDYWxsRXhwciwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJUkFub25DYWxsRXhwciwgSVJOZXN0ZWRBbm9uQ2FsbEV4cHIsIElSRnVuY0RlZkV4cHIsIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVJFcnJvckNhbGxFeHByXG4vL1xuLy8gICAgIFNlY3Rpb24gMjI6IElSIEFTVCBidWlsZCBmdW5jdGlvbnMgICAgYnVpbGRJUkV4cHIsIGJ1aWxkSVJGdW5jRXhwclxuLy9cbi8vICAgICBTZWN0aW9uIDIzOiBJUiBQcm9ncmFtICAgICAgICAgICAgICAgIElSUHJvZ3JhbSwgSVJQYXJhbWV0cmljUHJvZ3JhbVxuLy9cbi8vICAgICBTZWN0aW9uIDI0OiBIZWxpb3MgcHJvZ3JhbSAgICAgICAgICAgIE1vZHVsZSwgTWFpbk1vZHVsZSwgUmVkZWVtZXJQcm9ncmFtLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdHVtUmVkZWVtZXJQcm9ncmFtLCBUZXN0aW5nUHJvZ3JhbSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGVuZGluZ1Byb2dyYW0sIE1pbnRpbmdQcm9ncmFtLCBTdGFraW5nUHJvZ3JhbVxuLy9cbi8vICAgICBTZWN0aW9uIDI1OiBUeCB0eXBlcyAgICAgICAgICAgICAgICAgIFR4LCBUeEJvZHksIFR4V2l0bmVzc2VzLCBUeElucHV0LCBVVHhPLCBUeFJlZklucHV0LCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFR4T3V0cHV0LCBEQ2VydCwgU3Rha2VBZGRyZXNzLCBTaWduYXR1cmUsIFJlZGVlbWVyLCBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwZW5kaW5nUmVkZWVtZXIsIE1pbnRpbmdSZWRlZW1lciwgRGF0dW0sIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGFzaGVkRGF0dW0sIElubGluZURhdHVtLCBlbmNvZGVNZXRhZGF0YSwgXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVNZXRhZGF0YSwgVHhNZXRhZGF0YVxuLy9cbi8vICAgICBTZWN0aW9uIDI2OiBIaWdobGlnaHRpbmcgZnVuY3Rpb24gICAgIFN5bnRheENhdGVnb3J5LCBoaWdobGlnaHRcbi8vXG4vLyAgICAgU2VjdGlvbiAyNzogRnV6enkgdGVzdGluZyBmcmFtZXdvcmsgICBGdXp6eVRlc3Rcbi8vXG4vLyAgICAgU2VjdGlvbiAyODogQ29pblNlbGVjdGlvbiAgICAgICAgICAgICBDb2luU2VsZWN0aW9uXG4vL1xuLy8gICAgIFNlY3Rpb24gMjk6IFdhbGxldHMgICAgICAgICAgICAgICAgICAgQ2lwMzBXYWxsZXQsIFdhbGxldEhlbHBlclxuLy9cbi8vICAgICBTZWN0aW9uIDMwOiBOZXR3b3JrICAgICAgICAgICAgICAgICAgIEJsb2NrZnJvc3RWMFxuLy9cbi8vICAgICBTZWN0aW9uIDMxOiBFbXVsYXRvciAgICAgICAgICAgICAgICAgIFdhbGxldEVtdWxhdG9yLCBHZW5lc2lzVHgsIFJlZ3VsYXJUeCwgTmV0d29ya0VtdWxhdG9yXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAxOiBDb25maWdcbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogVmVyc2lvbiBvZiB0aGUgSGVsaW9zIGxpYnJhcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gXCIwLjEzLjI4XCI7XG5cbi8qKlxuICogQSB0YWIgdXNlZCBmb3IgaW5kZW50aW5nIG9mIHRoZSBJUi5cbiAqIDIgc3BhY2VzLlxuICogQHBhY2thZ2VcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFRBQiA9IFwiICBcIjtcblxuLyoqXG4gKiBNb2RpZmlhYmxlIGNvbmZpZyB2YXJzXG4gKiBAdHlwZSB7e1xuICogICBERUJVRzogYm9vbGVhbixcbiAqICAgU1RSSUNUX0JBQkJBR0U6IGJvb2xlYW4sXG4gKiAgIElTX1RFU1RORVQ6IGJvb2xlYW4sXG4gKiAgIE5fRFVNTVlfSU5QVVRTOiBudW1iZXJcbiAqIH19XG4gKi9cbmV4cG9ydCBjb25zdCBjb25maWcgPSB7XG4gICAgLyoqXG4gICAgICogR2xvYmFsIGRlYnVnIGZsYWcuIE5vdCBjdXJyZW50bHkgdXNlZCBmb3IgYW55dGhpbmcgdGhvdWdoLlxuICAgICAqL1xuICAgIERFQlVHOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHRyYW5zYWN0aW9ucyBzZXJpYWxpemVkIHVzaW5nIHRoZSBzdHJpY3QgYmFiYmFnZSBjZGRsIGZvcm1hdFxuICAgICAqL1xuICAgIFNUUklDVF9CQUJCQUdFOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byBmYWxzZSBpZiB1c2luZyB0aGUgbGlicmFyeSBmb3IgbWFpbm5ldCAoaW1wYWN0cyBBZGRyZXNzZXMpXG4gICAgICovXG4gICAgSVNfVEVTVE5FVDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0aW5nIHRoZSBleGVjdXRpb24gYnVkZ2V0IGR1cmluZyB0eCBidWlsZGluZyByZXF1aXJlcyBrbm93aW5nIGFsbCB0aGUgaW5wdXRzIGJlZm9yZWhhbmQsXG4gICAgICogICB3aGljaCBpcyB2ZXJ5IGRpZmZpY3VsdCBiZWNhdXNlIGJhbGFuY2luZyBpcyBkb25lIGFmdGVyIHRoZSBidWRnZXQgaXMgY2FsY3VsYXRlZC5cbiAgICAgKiBJbnN0ZWFkIHdlIHVzZSBhdCBsZWFzdCAxIGR1bW15IGlucHV0LCB3aGljaCBzaG91bGQgYWN0IGFzIGEgcmVwcmVzZW50YXRpdmUgYmFsYW5jaW5nIGlucHV0LlxuICAgICAqIEZvciBpbmNyZWFzZWQgcm9idXN0bmVzcyB3ZSB1c2UgMiBkdW1teSBpbnB1dHMsIG9uZSB3aXRoIFR4aWQgMCBhbmQgb3RoZXIgd2l0aCBUeElkIGZmZmYuLi4sXG4gICAgICogICBiZWNhdXNlIGVnLiB0aGVyZSBhcmUgY2FzZSB3aGVyZSB0aGUgVHhJZCBpcyBiZWluZyBwcmludGVkLCBhbmQgYSBUeGlkIG9mIGZmZmYuLi4gd291bGQgb3ZlcmVzdGltYXRlIHRoZSBmZWVcbiAgICAgKiBUaGlzIHZhbHVlIG11c3QgYmUgJzEnIG9yICcyJ1xuICAgICAqL1xuICAgIE5fRFVNTVlfSU5QVVRTOiAyXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAyOiBVdGlsaXRpZXNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgJ2NvbmQnIGlzIGZhbHNlLlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZCBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cgPSBcInVuZXhwZWN0ZWRcIikge1xuXHRpZiAoIWNvbmQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0fVxufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiAnb2JqJyBpcyB1bmRlZmluZWQuIFJldHVybnMgJ29iaicgaXRzZWxmIChmb3IgY2hhaW5lZCBhcHBsaWNhdGlvbikuXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VCB8IHVuZGVmaW5lZCB8IG51bGx9IG9iaiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZChvYmosIG1zZyA9IFwidW5leHBlY3RlZCB1bmRlZmluZWQgdmFsdWVcIikge1xuXHRpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsICkge1xuXHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHR9XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIFRpbiwgVG91dFxuICogQHBhcmFtIHtUaW59IG9ialxuICogQHBhcmFtIHt7bmV3KC4uLmFueSk6IFRvdXR9fSBDXG4gKiBAcmV0dXJucyB7VG91dH1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Q2xhc3Mob2JqLCBDLCBtc2cgPSBcInVuZXhwZWN0ZWQgY2xhc3NcIikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQykge1xuXHRcdHJldHVybiBvYmo7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHthbnl9IG9iaiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBhc3NlcnROdW1iZXIob2JqLCBtc2cgPSBcImV4cGVjdGVkIGEgbnVtYmVyXCIpIHtcblx0aWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBvYmo7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KFQgfCBudWxsKVtdfSBsc3RcbiAqIEByZXR1cm5zIHtudWxsIHwgKFRbXSl9XG4gKi9cbmZ1bmN0aW9uIHJlZHVjZU51bGwobHN0KSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VFtdfVxuXHQgKi9cblx0Y29uc3Qgbm9uTnVsbExzdCA9IFtdO1xuXG5cdGxldCBzb21lTnVsbCA9IGZhbHNlO1xuXG5cdGxzdC5mb3JFYWNoKGl0ZW0gPT4ge1xuXHRcdGlmIChpdGVtICE9PSBudWxsICYmICFzb21lTnVsbCkge1xuXHRcdFx0bm9uTnVsbExzdC5wdXNoKGl0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzb21lTnVsbCA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoc29tZU51bGwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbm9uTnVsbExzdDtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUYVxuICogQHRlbXBsYXRlIFRiXG4gKiBAcGFyYW0ge1tUYSB8IG51bGwsIFRiIHwgbnVsbF1bXX0gcGFpcnNcbiAqIEByZXR1cm5zIHtudWxsIHwgW1RhLCBUYl1bXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZU51bGxQYWlycyhwYWlycykge1xuXHQvKipcblx0ICogQHR5cGUge1tUYSwgVGJdW119XG5cdCAqL1xuXHRjb25zdCBub25OdWxsUGFpcnMgPSBbXTtcblxuXHRsZXQgc29tZU51bGwgPSBmYWxzZTtcblxuXHRwYWlycy5mb3JFYWNoKChbYSwgYl0pID0+IHtcblx0XHRpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG5cdFx0XHRzb21lTnVsbCA9IHRydWU7XG5cdFx0fSBlbHNlIGlmICghc29tZU51bGwpIHtcblx0XHRcdG5vbk51bGxQYWlycy5wdXNoKFthLCBiXSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoc29tZU51bGwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbm9uTnVsbFBhaXJzO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIG9iamVjdHMgKGRlZXAgcmVjdXJzaXZlIGNvbXBhcmlzb24pXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gYSBcbiAqIEBwYXJhbSB7VH0gYiBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlcShhLCBiKSB7XG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwib25lIG9mIHRoZSBhcmdzIGlzIHVuZGVmaW5lZFwiKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBhID09PSBiO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBhID09IFwiYm9vbGVhblwiKSB7XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJiaWdpbnRcIikge1xuXHRcdHJldHVybiBhID09PSBiO1xuXHR9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBiIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghZXEoYVtpXSwgYltpXSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImVxIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoZXNlIHR5cGVzXCIpO1xuXHR9XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHR3byBvYmplY3QgYXJlbid0IGVxdWFsIChkZWVwIGNvbXBhcmlzb24pLlxuICogVXNlZCBieSB1bml0IHRlc3RzIHRoYXQgYXJlIGF1dG9nZW5lcmF0ZWQgZnJvbSBKU0RvYyBpbmxpbmUgZXhhbXBsZXMuXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEVxKGEsIGIsIG1zZykge1xuXHRpZiAoIWVxKGEsIGIpKSB7XG5cdFx0Y29uc29sZS5sb2coYSk7XG5cdFx0Y29uc29sZS5sb2coYik7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byBpbnRlZ2Vycy4gQXNzdW1lcyBhIGFuZCBiIGFyZSB3aG9sZSBudW1iZXJzLiBSb3VuZHMgZG93biB0aGUgcmVzdWx0LlxuICogQGV4YW1wbGVcbiAqIGlkaXYoMzU1LCAxMTMpID0+IDNcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgXG4gKi9cbmZ1bmN0aW9uIGlkaXYoYSwgYikge1xuXHRyZXR1cm4gTWF0aC5mbG9vcihhIC8gYik7XG5cdC8vIGFsdGVybmF0aXZlbHk6IChhIC0gYSViKS9iXG59XG5cbi8qKlxuICogMiB0byB0aGUgcG93ZXIgJ3AnIGZvciBiaWdpbnQuXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtiaWdpbnR9IHBcbiAqIEByZXR1cm5zIHtiaWdpbnR9XG4gKi9cbmZ1bmN0aW9uIGlwb3cyKHApIHtcblx0cmV0dXJuIChwIDw9IDBuKSA/IDFuIDogMm4gPDwgKHAgLSAxbik7XG59XG5cbi8qKlxuICogTWFza3MgYml0cyBvZiAnYicgYnkgc2V0dGluZyBiaXRzIG91dHNpZGUgdGhlIHJhbmdlIFsnaTAnLCAnaTEnKSB0byAwLiBcbiAqICdiJyBpcyBhbiA4IGJpdCBpbnRlZ2VyIChpLmUuIG51bWJlciBiZXR3ZWVuIDAgYW5kIDI1NSkuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFsc28gYW4gOCBiaXQgaW50ZWdlciwgc2hpZnQgcmlnaHQgYnkgJ2kxJy5cbiBcbiAqIEBleGFtcGxlXG4gKiBpbWFzaygwYjExMTExMTExLCAxLCA0KSA9PiAwYjAxMTEgLy8gKGkuZS4gNylcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gYiBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpMCBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpMSBcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGltYXNrKGIsIGkwLCBpMSkge1xuXHRhc3NlcnQoaTAgPCBpMSk7XG5cblx0Y29uc3QgbWFza19iaXRzID0gW1xuXHRcdDBiMTExMTExMTEsXG5cdFx0MGIwMTExMTExMSxcblx0XHQwYjAwMTExMTExLFxuXHRcdDBiMDAwMTExMTEsXG5cdFx0MGIwMDAwMTExMSxcblx0XHQwYjAwMDAwMTExLFxuXHRcdDBiMDAwMDAwMTEsXG5cdFx0MGIwMDAwMDAwMSxcblx0XTtcblxuXHRyZXR1cm4gKGIgJiBtYXNrX2JpdHNbaTBdKSA+PiAoOCAtIGkxKTtcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgcmVzdWx0aW5nIG51bWJlciBmaXRzIGluIHVpbnQ4XG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqL1xuZnVuY3Rpb24gaW1vZDgoeCkge1xuXHRyZXR1cm4geCAmIDB4ZmY7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gdW5ib3VuZGVkIGludGVnZXIgaW50byBhIGxpc3Qgb2YgdWludDggbnVtYmVycyAoYmlnIGVuZGlhbilcbiAqIFVzZWQgYnkgdGhlIENCT1IgZW5jb2Rpbmcgb2YgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgYnkgRWQyNTUxOVxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7YmlnaW50fSB4XG4gKiBAcmV0dXJucyB7bnVtYmVyW119XG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnl0ZXMoeCkge1xuXHRpZiAoeCA9PSAwbikge1xuXHRcdHJldHVybiBbMF07XG5cdH0gZWxzZSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge251bWJlcltdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IHJlcyA9IFtdO1xuXG5cdFx0d2hpbGUgKHggPiAwbikge1xuXHRcdFx0cmVzLnVuc2hpZnQoTnVtYmVyKHglMjU2bikpO1xuXG5cdFx0XHR4ID0geC8yNTZuO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgdWludDggbnVtYmVycyBpbnRvIGFuIHVuYm91bmRlZCBpbnQgKGJpZyBlbmRpYW4pXG4gKiBVc2VkIGJ5IHRoZSBDQk9SIGRlY29kaW5nIG9mIGRhdGEgc3RydWN0dXJlcy5cbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge251bWJlcltdfSBiXG4gKiBAcmV0dXJuIHtiaWdpbnR9XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CaWdJbnQoYikge1xuXHRsZXQgcyA9IDFuO1xuXHRsZXQgdG90YWwgPSAwbjtcblxuXHR3aGlsZSAoYi5sZW5ndGggPiAwKSB7XG5cdFx0dG90YWwgKz0gQmlnSW50KGFzc2VydERlZmluZWQoYi5wb3AoKSkpKnM7XG5cblx0XHRzICo9IDI1Nm47XG5cdH1cblxuXHRyZXR1cm4gdG90YWw7XG59XG5cbi8qKlxuICogUHJlcGVuZHMgemVyb2VzIHRvIGEgYml0LXN0cmluZyBzbyB0aGF0ICdyZXN1bHQubGVuZ3RoID09IG4nLlxuICogQGV4YW1wbGVcbiAqIHBhZFplcm9lcyhcIjExMTFcIiwgOCkgPT4gXCIwMDAwMTExMVwiXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtzdHJpbmd9IGJpdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcGFkWmVyb2VzKGJpdHMsIG4pIHtcblx0Ly8gcGFkZGVkIHRvIG11bHRpcGxlIG9mIG5cblx0aWYgKGJpdHMubGVuZ3RoICUgbiAhPSAwKSB7XG5cdFx0Y29uc3QgblBhZCA9IG4gLSBiaXRzLmxlbmd0aCAlIG47XG5cblx0XHRiaXRzID0gKG5ldyBBcnJheShuUGFkKSkuZmlsbCgnMCcpLmpvaW4oJycpICsgYml0cztcblx0fVxuXG5cdHJldHVybiBiaXRzO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgOCBiaXQgaW50ZWdlciBudW1iZXIgaW50byBhIGJpdCBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBcIjBiXCIgcHJlZml4LlxuICogVGhlIHJlc3VsdCBpcyBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm9lcyB0byBiZWNvbWUgJ24nIGNoYXJzIGxvbmcgKCcyICsgbicgY2hhcnMgbG9uZyBpZiB5b3UgY291bnQgdGhlIFwiMGJcIiBwcmVmaXgpLiBcbiAqIEBleGFtcGxlXG4gKiBieXRlVG9CaXRTdHJpbmcoNykgPT4gXCIwYjAwMDAwMTExXCJcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gYiBcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHByZWZpeFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnl0ZVRvQml0U3RyaW5nKGIsIG4gPSA4LCBwcmVmaXggPSB0cnVlKSB7XG5cdGNvbnN0IHMgPSBwYWRaZXJvZXMoYi50b1N0cmluZygyKSwgbik7XG5cblx0aWYgKHByZWZpeCkge1xuXHRcdHJldHVybiBcIjBiXCIgKyBzO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzO1xuXHR9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBieXRlcyBpbnRvIGFuIGFjdHVhbCBsaXN0IG9mIHVpbnQ4IGJ5dGVzLlxuICogQGV4YW1wbGVcbiAqIGhleFRvQnl0ZXMoXCIwMGZmMzRcIikgPT4gWzAsIDI1NSwgNTJdIFxuICogQHBhcmFtIHtzdHJpbmd9IGhleCBcbiAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG5cdGhleCA9IGhleC50cmltKCk7XG5cdFxuXHRjb25zdCBieXRlcyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0Ynl0ZXMucHVzaChwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNikpO1xuXHR9XG5cblx0cmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiB1aW50OCBieXRlcyBpbnRvIGl0cyBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAZXhhbXBsZVxuICogYnl0ZXNUb0hleChbMCwgMjU1LCA1Ml0pID0+IFwiMDBmZjM0XCJcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuXHRjb25zdCBwYXJ0cyA9IFtdO1xuXG5cdGZvciAobGV0IGIgb2YgYnl0ZXMpIHtcblx0XHRwYXJ0cy5wdXNoKHBhZFplcm9lcyhiLnRvU3RyaW5nKDE2KSwgMikpO1xuXHR9XG5cblx0cmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdWludDggYnl0ZXMgdXNpbmcgVVRGLTggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZVxuICogdGV4dFRvQnl0ZXMoXCJoZWxsbyB3b3JsZFwiKSA9PiBbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgXG4gKiBAcmV0dXJucyB7bnVtYmVyW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0VG9CeXRlcyhzdHIpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUoc3RyKSk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGxpc3Qgb2YgdWludDggYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyBVVEYtOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlXG4gKiBieXRlc1RvVGV4dChbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pID0+IFwiaGVsbG8gd29ybGRcIlxuICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1RleHQoYnl0ZXMpIHtcblx0cmV0dXJuIChuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7ZmF0YWw6IHRydWV9KSkuZGVjb2RlKChuZXcgVWludDhBcnJheShieXRlcykpLmJ1ZmZlcik7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIHRhYiBjaGFyYWN0ZXJzIG9mIGEgc3RyaW5nIHdpdGggc3BhY2VzLlxuICogVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhIHByZXR0aWVyIElSICh3aGljaCBpcyBidWlsdC11cCBmcm9tIG1hbnkgdGVtcGxhdGUganMgc3RyaW5ncyBpbiB0aGlzIGZpbGUsIHdoaWNoIG1pZ2h0IGNvbnRhaW4gdGFicyBkZXBlbmRpbmcgb24gdGhlIGVkaXRvciB1c2VkKVxuICogQGV4YW1wbGVcbiAqIHJlcGxhY2VUYWJzKFwiXFx0XFx0XFx0XCIpID0+IFtUQUIsIFRBQiwgVEFCXS5qb2luKFwiXCIpXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VUYWJzKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcdFwiLCBcImdcIiksIFRBQik7XG59XG5cbi8qKlxuICogUmVhZCBub24tYnl0ZSBhbGlnbmVkIG51bWJlcnNcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEJpdFJlYWRlciB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG5cdCN2aWV3O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblx0I3BvcztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXHQjdHJ1bmNhdGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJ1bmNhdGUgLSBpZiB0cnVlIHRoZW4gcmVhZCBsYXN0IGJpdHMgYXMgbG93IHBhcnQgb2YgbnVtYmVyLCBpZiBmYWxzZSBwYWQgd2l0aCB6ZXJvIGJpdHNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGJ5dGVzLCB0cnVuY2F0ZSA9IHRydWUpIHtcblx0XHR0aGlzLiN2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuXHRcdHRoaXMuI3BvcyA9IDA7IC8vIGJpdCBwb3NpdGlvbiwgbm90IGJ5dGUgcG9zaXRpb25cblx0XHR0aGlzLiN0cnVuY2F0ZSA9IHRydW5jYXRlO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRlb2YoKSB7XG5cdFx0cmV0dXJuIGlkaXYodGhpcy4jcG9zLCA4KSA+PSB0aGlzLiN2aWV3Lmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhIG51bWJlciBvZiBiaXRzICg8PSA4KSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGFuIHVuc2lnbmVkIG51bWJlclxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gbnVtYmVyIG9mIGJpdHMgdG8gcmVhZFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0cmVhZEJpdHMobikge1xuXHRcdGFzc2VydChuIDw9IDgsIFwicmVhZGluZyBtb3JlIHRoYW4gMSBieXRlXCIpO1xuXG5cdFx0bGV0IGxlZnRTaGlmdCA9IDA7XG5cdFx0aWYgKHRoaXMuI3BvcyArIG4gPiB0aGlzLiN2aWV3Lmxlbmd0aCAqIDgpIHtcblx0XHRcdGNvbnN0IG5ld04gPSAodGhpcy4jdmlldy5sZW5ndGgqOCAtIHRoaXMuI3Bvcyk7XG5cblx0XHRcdGlmICghdGhpcy4jdHJ1bmNhdGUpIHtcblx0XHRcdFx0bGVmdFNoaWZ0ID0gbiAtIG5ld047XG5cdFx0XHR9XG5cblx0XHRcdG4gPSBuZXdOO1xuXHRcdH1cblxuXHRcdGFzc2VydChuID4gMCwgXCJlb2ZcIik7XG5cblx0XHQvLyBpdCBpcyBhc3N1bWVkIHdlIGRvbid0IG5lZWQgdG8gYmUgYXQgdGhlIGJ5dGUgYm91bmRhcnlcblxuXHRcdGxldCByZXMgPSAwO1xuXHRcdGxldCBpMCA9IHRoaXMuI3BvcztcblxuXHRcdGZvciAobGV0IGkgPSB0aGlzLiNwb3MgKyAxOyBpIDw9IHRoaXMuI3BvcyArIG47IGkrKykge1xuXHRcdFx0aWYgKGkgJSA4ID09IDApIHtcblx0XHRcdFx0Y29uc3QgblBhcnQgPSBpIC0gaTA7XG5cblx0XHRcdFx0cmVzICs9IGltYXNrKHRoaXMuI3ZpZXdbaWRpdihpLCA4KSAtIDFdLCBpMCAlIDgsIDgpIDw8IChuIC0gblBhcnQpO1xuXG5cdFx0XHRcdGkwID0gaTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PSB0aGlzLiNwb3MgKyBuKSB7XG5cdFx0XHRcdHJlcyArPSBpbWFzayh0aGlzLiN2aWV3W2lkaXYoaSwgOCldLCBpMCAlIDgsIGkgJSA4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLiNwb3MgKz0gbjtcblx0XHRyZXR1cm4gcmVzIDw8IGxlZnRTaGlmdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNb3ZlcyBwb3NpdGlvbiB0byBuZXh0IGJ5dGUgYm91bmRhcnlcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gaWYgdHJ1ZSB0aGVuIG1vdmUgdG8gbmV4dCBieXRlIGJvdW5kYXJ5IGlmIGFscmVhZHkgYXQgYnl0ZSBib3VuZGFyeVxuXHQgKi9cblx0bW92ZVRvQnl0ZUJvdW5kYXJ5KGZvcmNlID0gZmFsc2UpIHtcblx0XHRpZiAodGhpcy4jcG9zICUgOCAhPSAwKSB7XG5cdFx0XHRsZXQgbiA9IDggLSB0aGlzLiNwb3MgJSA4O1xuXG5cdFx0XHR2b2lkIHRoaXMucmVhZEJpdHMobik7XG5cdFx0fSBlbHNlIGlmIChmb3JjZSkge1xuXHRcdFx0dGhpcy5yZWFkQml0cyg4KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgOCBiaXRzXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHJlYWRCeXRlKCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIER1bXBzIHJlbWFpbmluZyBiaXRzIHdlICNwb3MgaXNuJ3QgeWV0IGF0IGVuZC5cblx0ICogVGhpcyBpcyBpbnRlbmRlZCBmb3IgZGVidWdnaW5nIHVzZS5cbiAgICAgKiBAcGFja2FnZVxuXHQgKi9cblx0ZHVtcFJlbWFpbmluZ0JpdHMoKSB7XG5cdFx0aWYgKCF0aGlzLmVvZigpKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInJlbWFpbmluZyBieXRlczpcIik7XG5cdFx0XHRmb3IgKGxldCBmaXJzdCA9IHRydWUsIGkgPSBpZGl2KHRoaXMuI3BvcywgOCk7IGkgPCB0aGlzLiN2aWV3Lmxlbmd0aDsgZmlyc3QgPSBmYWxzZSwgaSsrKSB7XG5cdFx0XHRcdGlmIChmaXJzdCAmJiB0aGlzLiNwb3MgJSA4ICE9IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhieXRlVG9CaXRTdHJpbmcoaW1hc2sodGhpcy4jdmlld1tpXSwgdGhpcy4jcG9zICUgOCwgOCkgPDwgOCAtIHRoaXMuI3BvcyAlIDcpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhieXRlVG9CaXRTdHJpbmcodGhpcy4jdmlld1tpXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiZW9mXCIpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEJpdFdyaXRlciB0dXJucyBhIHN0cmluZyBvZiAnMCdzIGFuZCAnMSdzIGludG8gYSBsaXN0IG9mIGJ5dGVzLlxuICogRmluYWxpemF0aW9uIHBhZHMgdGhlIGJpdHMgdXNpbmcgJzAqMScgaWYgbm90IHlldCBhbGlnbmVkIHdpdGggdGhlIGJ5dGUgYm91bmRhcnkuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBCaXRXcml0ZXIge1xuXHQvKipcblx0ICogQ29uY2F0ZW5hdGVkIGFuZCBwYWRkZWQgdXBvbiBmaW5hbGl6YXRpb25cblx0ICogQHR5cGUge3N0cmluZ1tdfVxuXHQgKi9cblx0I3BhcnRzO1xuXG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgYml0cyB3cml0dGVuIHNvIGZhclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0I247XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy4jcGFydHMgPSBbXTtcblx0XHR0aGlzLiNuID0gMDtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbGVuZ3RoKCkge1xuXHRcdHJldHVybiB0aGlzLiNuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlIGEgc3RyaW5nIG9mICcwJ3MgYW5kICcxJ3MgdG8gdGhlIEJpdFdyaXRlci5cbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYml0Q2hhcnNcblx0ICovXG5cdHdyaXRlKGJpdENoYXJzKSB7XG5cdFx0Zm9yIChsZXQgYyBvZiBiaXRDaGFycykge1xuXHRcdFx0aWYgKGMgIT0gJzAnICYmIGMgIT0gJzEnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJhZCBiaXQgY2hhclwiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLiNwYXJ0cy5wdXNoKGJpdENoYXJzKTtcblx0XHR0aGlzLiNuICs9IGJpdENoYXJzLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG5cdCAqL1xuXHR3cml0ZUJ5dGUoYnl0ZSkge1xuXHRcdHRoaXMud3JpdGUocGFkWmVyb2VzKGJ5dGUudG9TdHJpbmcoMiksIDgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgcGFkZGluZyB0byB0aGUgQml0V3JpdGVyIGluIG9yZGVyIHRvIGFsaWduIHdpdGggdGhlIGJ5dGUgYm91bmRhcnkuXG5cdCAqIElmICdmb3JjZSA9PSB0cnVlJyB0aGVuIDggYml0cyBhcmUgYWRkZWQgaWYgdGhlIEJpdFdyaXRlciBpcyBhbHJlYWR5IGFsaWduZWQuXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBcblx0ICovXG5cdHBhZFRvQnl0ZUJvdW5kYXJ5KGZvcmNlID0gZmFsc2UpIHtcblx0XHRsZXQgblBhZCA9IDA7XG5cdFx0aWYgKHRoaXMuI24gJSA4ICE9IDApIHtcblx0XHRcdG5QYWQgPSA4IC0gdGhpcy4jbiAlIDg7XG5cdFx0fSBlbHNlIGlmIChmb3JjZSkge1xuXHRcdFx0blBhZCA9IDg7XG5cdFx0fVxuXG5cdFx0aWYgKG5QYWQgIT0gMCkge1xuXHRcdFx0bGV0IHBhZGRpbmcgPSAobmV3IEFycmF5KG5QYWQpKS5maWxsKCcwJyk7XG5cdFx0XHRwYWRkaW5nW25QYWQgLSAxXSA9ICcxJztcblxuXHRcdFx0dGhpcy4jcGFydHMucHVzaChwYWRkaW5nLmpvaW4oJycpKTtcblxuXHRcdFx0dGhpcy4jbiArPSBuUGFkO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQYWRzIHRoZSBCaXRXcml0ZXIgdG8gYWxpZ24gd2l0aCB0aGUgYnl0ZSBib3VuZGFyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGJ5dGVzLlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBmb3JjZSBwYWRkaW5nICh3aWxsIGFkZCBvbmUgYnl0ZSBpZiBhbHJlYWR5IGFsaWduZWQpXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGZpbmFsaXplKGZvcmNlID0gdHJ1ZSkge1xuXHRcdHRoaXMucGFkVG9CeXRlQm91bmRhcnkoZm9yY2UpO1xuXG5cdFx0bGV0IGNoYXJzID0gdGhpcy4jcGFydHMuam9pbignJyk7XG5cblx0XHRsZXQgYnl0ZXMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDgpIHtcblx0XHRcdGxldCBieXRlQ2hhcnMgPSBjaGFycy5zbGljZShpLCBpICsgOCk7XG5cdFx0XHRsZXQgYnl0ZSA9IHBhcnNlSW50KGJ5dGVDaGFycywgMik7XG5cblx0XHRcdGJ5dGVzLnB1c2goYnl0ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVzO1xuXHR9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHR5cGVkZWYgeygpID0+IG51bWJlcn0gTnVtYmVyR2VuZXJhdG9yXG4gKi9cblxuLyoqXG4gKiBBIFNvdXJjZSBpbnN0YW5jZSB3cmFwcyBhIHN0cmluZyBzbyB3ZSBjYW4gdXNlIGl0IGNoZWFwbHkgYXMgYSByZWZlcmVuY2UgaW5zaWRlIGEgU2l0ZS5cbiAqIEFsc28gdXNlZCBieSBWU0NvZGUgcGx1Z2luXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2Uge1xuXHQjcmF3O1xuXHQjZmlsZUluZGV4O1xuXHQjZXJyb3JzOyAvLyBlcnJvcnMgYXJlIGNvbGxlY3RlZCBpbnRvIHRoaXMgb2JqZWN0XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYXcgXG5cdCAqIEBwYXJhbSB7P251bWJlcn0gZmlsZUluZGV4XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihyYXcsIGZpbGVJbmRleCA9IG51bGwpIHtcblx0XHR0aGlzLiNyYXcgPSBhc3NlcnREZWZpbmVkKHJhdyk7XG5cdFx0dGhpcy4jZmlsZUluZGV4ID0gZmlsZUluZGV4O1xuXHRcdHRoaXMuI2Vycm9ycyA9IFtdO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cdGdldCByYXcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3Jhdztcblx0fVxuXG4gICAgLyoqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKi9cblx0Z2V0IGZpbGVJbmRleCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZmlsZUluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtFcnJvcltdfVxuXHQgKi9cblx0Z2V0IGVycm9ycygpIHtcblx0XHRyZXR1cm4gdGhpcy4jZXJyb3JzO1xuXHR9XG5cblx0dGhyb3dFcnJvcnMoKSB7XG5cdFx0aWYgKHRoaXMuI2Vycm9ycy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyB0aGlzLiNlcnJvcnNbMF07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjaGFyIGZyb20gdGhlIHVuZGVybHlpbmcgc3RyaW5nLlxuXHQgKiBTaG91bGQgd29yayBmaW5lIHV0Zi04IHJ1bmVzLlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3Ncblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldENoYXIocG9zKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3Jhd1twb3NdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB3b3JkIHVuZGVyIHBvc1xuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgXG5cdCAqIEByZXR1cm5zIHs/c3RyaW5nfVxuXHQgKi9cblx0Z2V0V29yZChwb3MpIHtcblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGNvbnN0IGNoYXJzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gYyBcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpc1dvcmRDaGFyKGMpIHtcblx0XHRcdGlmIChjID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIChjID09ICdfJyB8fCAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHx8IChjID49ICdBJyAmJiBjIDw9ICdaJykgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGMgPSB0aGlzLiNyYXdbcG9zXTtcblx0XHR3aGlsZSAoaXNXb3JkQ2hhcihjKSkge1xuXHRcdFx0Y2hhcnMucHVzaChjKTtcblx0XHRcdHBvcyArPSAxO1xuXHRcdFx0YyA9IHRoaXMuI3Jhd1twb3NdO1xuXHRcdH1cblxuXHRcdGlmIChjaGFycy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjaGFycy5qb2luKFwiXCIpO1xuXHRcdH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXHRnZXQgbGVuZ3RoKCkge1xuXHRcdHJldHVybiB0aGlzLiNyYXcubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBsaW5lIHdoZXJlIHRoZSBnaXZlbiBjaGFyYWN0ZXIgaXMgbG9jYXRlZCAoMC1iYXNlZCkuXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvcyBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHBvc1RvTGluZShwb3MpIHtcblx0XHRsZXQgbGluZSA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwb3M7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuI3Jhd1tpXSA9PSAnXFxuJykge1xuXHRcdFx0XHRsaW5lICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpbmU7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgY29sdW1uIGFuZCBsaW5lIG51bWJlciB3aGVyZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGlzIGxvY2F0ZWQgKDAtYmFzZWQpLlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3Ncblx0ICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19XG5cdCAqL1xuXHQvLyByZXR1cm5zIFtjb2wsIGxpbmVdXG5cdHBvc1RvTGluZUFuZENvbChwb3MpIHtcblx0XHRsZXQgY29sID0gMDtcblx0XHRsZXQgbGluZSA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwb3M7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuI3Jhd1tpXSA9PSAnXFxuJykge1xuXHRcdFx0XHRjb2wgPSAwO1xuXHRcdFx0XHRsaW5lICs9IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2wgKz0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW2xpbmUsIGNvbF07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG1vcmUgaHVtYW4tcmVhZGFibGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIGJ5IHByZXBlbmRpbmcgdGhlIGxpbmUtbnVtYmVycyB0byBlYWNoIGxpbmUuXG5cdCAqIFRoZSBsaW5lLW51bWJlcnMgYXJlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIChuZXcgU291cmNlKFwiaGVsbG9cXG53b3JsZFwiKSkucHJldHR5KCkgPT4gXCIwMSAgaGVsbG9cXG4wMiAgd29ybGRcIlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRwcmV0dHkoKSB7XG5cdFx0Y29uc3QgbGluZXMgPSB0aGlzLiNyYXcuc3BsaXQoXCJcXG5cIik7XG5cblx0XHRjb25zdCBuTGluZXMgPSBsaW5lcy5sZW5ndGg7XG5cdFx0Y29uc3QgbkRpZ2l0cyA9IE1hdGgubWF4KE1hdGguY2VpbChNYXRoLmxvZzEwKG5MaW5lcykpLCAyKTsgLy8gbGluZS1udW1iZXIgaXMgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuTGluZXM7IGkrKykge1xuXHRcdFx0bGluZXNbaV0gPSBTdHJpbmcoaSArIDEpLnBhZFN0YXJ0KG5EaWdpdHMsICcwJykgKyBcIiAgXCIgKyBsaW5lc1tpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcblx0fVxufVxuXG4vKipcbiAqIEEgdGFnIGZ1bmN0aW9uIGZvciBhIGhlbGlvcyBzb3VyY2UuXG4gKiBJcyBqdXN0IGEgbWFya2VyIHNvIElERSBzdXBwb3J0IGNhbiB3b3JrIG9uIGxpdGVyYWwgaGVsaW9zIHNvdXJjZXMgaW5zaWRlIGphdmFzY3JpcHQvdHlwZXNjcmlwdCBmaWxlcy5cbiAqIEBleGFtcGxlXG4gKiBobGBoZWxsbyAke1wid29ybGRcIn0hYCA9PiBcImhlbGxvIHdvcmxkIVwiXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhIFxuICogQHBhcmFtICB7Li4uYW55fSBiIFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhsKGEsIC4uLmIpIHtcblx0cmV0dXJuIGEubWFwKChwYXJ0LCBpKSA9PiB7XG5cdFx0aWYgKGkgPCBiLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHBhcnQgKyBiW2ldLnRvU3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBwYXJ0O1xuXHRcdH1cblx0fSkuam9pbihcIlwiKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgd2FybmluZyBtZXNzYWdlIHRoYXQgYSBjZXJ0YWluIGZlYXR1cmUgd2lsbCBiZSBkZXByZWNhdGVkIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd9IGZ1dHVyZVZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtzdHJpbmd9IGRvY1VybFxuICovXG5mdW5jdGlvbiBkZXByZWNhdGlvbldhcm5pbmcoZmVhdHVyZSwgZnV0dXJlVmVyc2lvbiwgYWx0ZXJuYXRpdmUsIGRvY1VybCA9IFwiXCIpIHtcblx0bGV0IG1zZyA9IGAke2ZlYXR1cmV9IGlzIERFUFJFQ0FURUQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB2ZXJzaW9uICR7ZnV0dXJlVmVyc2lvbn0gb253YXJkcyFcbiR7YWx0ZXJuYXRpdmV9YDtcblxuXHRpZiAoZG9jVXJsICE9IFwiXCIpIHtcblx0XHRtc2cgKz0gYFxcbihmb3IgbW9yZSBpbmZvcm1hdGlvbjogJHtkb2NVcmx9KWA7XG5cdH1cblxuXHRjb25zb2xlLndhcm4obXNnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDM6IFRva2Vuc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBFYWNoIFRva2VuL0V4cHJlc3Npb24vU3RhdGVtZW50IGhhcyBhIFNpdGUsIHdoaWNoIGVuY2Fwc3VsYXRlcyBhIHBvc2l0aW9uIGluIGEgU291cmNlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTaXRlIHtcblx0I3NyYztcblx0I3N0YXJ0UG9zO1xuXHQjZW5kUG9zO1xuXG5cdC8qKiBAdHlwZSB7P1NpdGV9IC0gZW5kIG9mIHRva2VuLCBleGNsdXNpdmUsIFRPRE86IHJlcGxhY2Ugd2l0aCBlbmRQb3MgKi9cblx0I2VuZFNpdGU7XG5cblx0LyoqQHR5cGUgez9TaXRlfSAqL1xuXHQjY29kZU1hcFNpdGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U291cmNlfSBzcmMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gZW5kUG9zIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc3JjLCBzdGFydFBvcywgZW5kUG9zID0gc3RhcnRQb3MgKyAxKSB7XG5cdFx0dGhpcy4jc3JjID0gc3JjO1xuXHRcdHRoaXMuI3N0YXJ0UG9zID0gc3RhcnRQb3M7XG5cdFx0dGhpcy4jZW5kUG9zID0gZW5kUG9zO1xuXHRcdHRoaXMuI2VuZFNpdGUgPSBudWxsO1xuXHRcdHRoaXMuI2NvZGVNYXBTaXRlID0gbnVsbDtcblx0fVxuXG5cdHN0YXRpYyBkdW1teSgpIHtcblx0XHRyZXR1cm4gbmV3IFNpdGUobmV3IFNvdXJjZShcIlwiKSwgMCk7XG5cdH1cblxuXHRnZXQgc3JjKCkge1xuXHRcdHJldHVybiB0aGlzLiNzcmM7XG5cdH1cblxuXHRnZXQgc3RhcnRQb3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3N0YXJ0UG9zO1xuXHR9XG5cblx0Z2V0IGVuZFBvcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jZW5kUG9zO1xuXHR9XG5cdFxuXHRnZXQgZW5kU2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZW5kU2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7U2l0ZX1cblx0ICovXG5cdG1lcmdlKG90aGVyKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXRlKHRoaXMuI3NyYywgdGhpcy4jc3RhcnRQb3MsIG90aGVyLiNlbmRQb3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7P1NpdGV9IHNpdGVcblx0ICovXG5cdHNldEVuZFNpdGUoc2l0ZSkge1xuXHRcdHRoaXMuI2VuZFNpdGUgPSBzaXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/U2l0ZX0gXG5cdCAqL1xuXHRnZXQgY29kZU1hcFNpdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2NvZGVNYXBTaXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdHNldENvZGVNYXBTaXRlKHNpdGUpIHtcblx0XHR0aGlzLiNjb2RlTWFwU2l0ZSA9IHNpdGU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIFN5bnRheEVycm9yXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFxuXHQgKiBAcmV0dXJucyB7VXNlckVycm9yfVxuXHQgKi9cblx0c3ludGF4RXJyb3IoaW5mbyA9IFwiXCIpIHtcblx0XHRyZXR1cm4gVXNlckVycm9yLnN5bnRheEVycm9yKHRoaXMuI3NyYywgdGhpcy4jc3RhcnRQb3MsIHRoaXMuI2VuZFBvcywgaW5mbyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIFR5cGVFcnJvclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5mb1xuXHQgKiBAcmV0dXJucyB7VXNlckVycm9yfVxuXHQgKi9cblx0dHlwZUVycm9yKGluZm8gPSBcIlwiKSB7XG5cdFx0cmV0dXJuIFVzZXJFcnJvci50eXBlRXJyb3IodGhpcy4jc3JjLCB0aGlzLiNzdGFydFBvcywgdGhpcy4jZW5kUG9zLCBpbmZvKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgUmVmZXJlbmNlRXJyb3Jcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZm8gXG5cdCAqIEByZXR1cm5zIHtVc2VyRXJyb3J9XG5cdCAqL1xuXHRyZWZlcmVuY2VFcnJvcihpbmZvID0gXCJcIikge1xuXHRcdHJldHVybiBVc2VyRXJyb3IucmVmZXJlbmNlRXJyb3IodGhpcy4jc3JjLCB0aGlzLiNzdGFydFBvcywgdGhpcy4jZW5kUG9zLCBpbmZvKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgUnVudGltZUVycm9yXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvXG5cdCAqIEByZXR1cm5zIHtVc2VyRXJyb3J9XG5cdCAqL1xuXHRydW50aW1lRXJyb3IoaW5mbyA9IFwiXCIpIHtcblx0XHRpZiAodGhpcy4jY29kZU1hcFNpdGUgIT09IG51bGwpIHtcblx0XHRcdGxldCBzaXRlID0gdGhpcy4jY29kZU1hcFNpdGU7XG5cdFx0XHRyZXR1cm4gUnVudGltZUVycm9yLm5ld1J1bnRpbWVFcnJvcihzaXRlLiNzcmMsIHNpdGUuI3N0YXJ0UG9zLCBmYWxzZSwgaW5mbyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBSdW50aW1lRXJyb3IubmV3UnVudGltZUVycm9yKHRoaXMuI3NyYywgdGhpcy4jc3RhcnRQb3MsIHRydWUsIGluZm8pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBjb2x1bW4sbGluZSBwb3NpdGlvbiBpbiAndGhpcy4jc3JjJ1xuXHQgKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IC0gW3N0YXJ0TGluZSwgc3RhcnRDb2wsIGVuZExpbmUsIGVuZENvbF1cblx0ICovXG5cdGdldEZpbGVQb3MoKSB7XG5cdFx0Y29uc3QgW3N0YXJ0TGluZSwgc3RhcnRDb2xdID0gdGhpcy4jc3JjLnBvc1RvTGluZUFuZENvbCh0aGlzLiNzdGFydFBvcyk7XG5cblx0XHRjb25zdCBbZW5kTGluZSwgZW5kQ29sXSA9IHRoaXMuI3NyYy5wb3NUb0xpbmVBbmRDb2wodGhpcy4jZW5kUG9zKTtcblxuXHRcdHJldHVybiBbc3RhcnRMaW5lLCBzdGFydENvbCwgZW5kTGluZSwgZW5kQ29sXTtcblx0fVxufVxuXG5cbi8qKlxuICogVXNlckVycm9ycyBhcmUgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgb2YgSGVsaW9zIG1ha2VzIGEgbWlzdGFrZSAoZWcuIGEgc3ludGF4IGVycm9yKSxcbiAqIG9yIHdoZW4gdGhlIHVzZXIgb2YgSGVsaW9zIHRocm93cyBhbiBleHBsaWNpdCBlcnJvciBpbnNpZGUgYSBzY3JpcHQgKGVnLiBkaXZpc2lvbiBieSB6ZXJvKS5cbiAqL1xuIGV4cG9ydCBjbGFzcyBVc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdCNzcmM7XG5cdCNzdGFydFBvcztcblx0I2VuZFBvcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuXHQgKiBAcGFyYW0ge1NvdXJjZX0gc3JjIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3MgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlbmRQb3Ncblx0ICovXG5cdGNvbnN0cnVjdG9yKG1zZywgc3JjLCBzdGFydFBvcywgZW5kUG9zID0gc3RhcnRQb3MgKyAxKSB7XG5cdFx0c3VwZXIobXNnKTtcblx0XHR0aGlzLiNzcmMgPSBzcmM7XG5cdFx0dGhpcy4jc3RhcnRQb3MgPSBzdGFydFBvcztcblx0XHR0aGlzLiNlbmRQb3MgPSBlbmRQb3M7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtTb3VyY2V9IHNyYyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZW5kUG9zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFxuXHQgKi9cblx0c3RhdGljIG5ldyh0eXBlLCBzcmMsIHN0YXJ0UG9zLCBlbmRQb3MsIGluZm8gPSBcIlwiKSB7XG5cdFx0bGV0IGxpbmUgPSBzcmMucG9zVG9MaW5lKHN0YXJ0UG9zKTtcblxuXHRcdGxldCBtc2cgPSBgJHt0eXBlfSBvbiBsaW5lICR7bGluZSArIDF9YDtcblx0XHRpZiAoaW5mbyAhPSBcIlwiKSB7XG5cdFx0XHRtc2cgKz0gYDogJHtpbmZvfWA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBVc2VyRXJyb3IobXNnLCBzcmMsIHN0YXJ0UG9zLCBlbmRQb3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTb3VyY2V9XG5cdCAqL1xuXHRnZXQgc3JjKCkge1xuXHRcdHJldHVybiB0aGlzLiNzcmM7XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIFN5bnRheEVycm9yXG5cdCAqIEBwYXJhbSB7U291cmNlfSBzcmMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvcyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGVuZFBvc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5mbyBcblx0ICogQHJldHVybnMge1VzZXJFcnJvcn1cblx0ICovXG5cdHN0YXRpYyBzeW50YXhFcnJvcihzcmMsIHN0YXJ0UG9zLCBlbmRQb3MsIGluZm8gPSBcIlwiKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBVc2VyRXJyb3IubmV3KFwiU3ludGF4RXJyb3JcIiwgc3JjLCBzdGFydFBvcywgZW5kUG9zLCBpbmZvKTtcblxuXHRcdHNyYy5lcnJvcnMucHVzaChlcnJvcik7XG5cblx0XHRyZXR1cm4gZXJyb3I7XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIFR5cGVFcnJvclxuXHQgKiBAcGFyYW0ge1NvdXJjZX0gc3JjIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3MgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlbmRQb3Ncblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZm8gXG5cdCAqIEByZXR1cm5zIHtVc2VyRXJyb3J9XG5cdCAqL1xuXHRzdGF0aWMgdHlwZUVycm9yKHNyYywgc3RhcnRQb3MsIGVuZFBvcywgaW5mbyA9IFwiXCIpIHtcblx0XHRjb25zdCBlcnJvciA9IFVzZXJFcnJvci5uZXcoXCJUeXBlRXJyb3JcIiwgc3JjLCBzdGFydFBvcywgZW5kUG9zLCBpbmZvKTtcblxuXHRcdHNyYy5lcnJvcnMucHVzaChlcnJvcik7XG5cblx0XHRyZXR1cm4gZXJyb3I7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFcnJvcn0gZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNUeXBlRXJyb3IoZSkge1xuXHRcdHJldHVybiAoZSBpbnN0YW5jZW9mIFVzZXJFcnJvcikgJiYgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUeXBlRXJyb3JcIik7XG5cdH1cblxuXHQvKipcblx0ICogQ29uc3RydWN0cyBhIFJlZmVyZW5jZUVycm9yIChpLmUuIG5hbWUgdW5kZWZpbmVkLCBvciBuYW1lIHVudXNlZClcblx0ICogQHBhcmFtIHtTb3VyY2V9IHNyYyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZW5kUG9zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFxuXHQgKiBAcmV0dXJucyB7VXNlckVycm9yfVxuXHQgKi9cblx0c3RhdGljIHJlZmVyZW5jZUVycm9yKHNyYywgc3RhcnRQb3MsIGVuZFBvcywgaW5mbyA9IFwiXCIpIHtcblx0XHRjb25zdCBlcnJvciA9IFVzZXJFcnJvci5uZXcoXCJSZWZlcmVuY2VFcnJvclwiLCBzcmMsIHN0YXJ0UG9zLCBlbmRQb3MsIGluZm8pO1xuXG5cdFx0c3JjLmVycm9ycy5wdXNoKGVycm9yKTtcblxuXHRcdHJldHVybiBlcnJvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0Vycm9yfSBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc1JlZmVyZW5jZUVycm9yKGUpIHtcblx0XHRyZXR1cm4gKGUgaW5zdGFuY2VvZiBVc2VyRXJyb3IpICYmIGUubWVzc2FnZS5zdGFydHNXaXRoKFwiUmVmZXJlbmNlRXJyb3JcIik7XG5cdH1cblxuXHRnZXQgZGF0YSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpcyBlcnJvclwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IHN0YXJ0UG9zKCkge1xuXHRcdHJldHVybiB0aGlzLiNzdGFydFBvcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIGNvbHVtbi9saW5lIHBvc2l0aW9uIGluICd0aGlzLnNyYycuXG5cdCAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXX0gLSBbc3RhcnRMaW5lLCBzdGFydENvbCwgZW5kTGluZSwgZW5kQ29sXVxuXHQgKi9cblx0Z2V0RmlsZVBvcygpIHtcblx0XHRjb25zdCBbc3RhcnRMaW5lLCBzdGFydENvbF0gPSB0aGlzLiNzcmMucG9zVG9MaW5lQW5kQ29sKHRoaXMuI3N0YXJ0UG9zKTtcblx0XHRjb25zdCBbZW5kTGluZSwgZW5kQ29sXSA9IHRoaXMuI3NyYy5wb3NUb0xpbmVBbmRDb2wodGhpcy4jZW5kUG9zKTtcblxuXHRcdHJldHVybiBbc3RhcnRMaW5lLCBzdGFydENvbCwgZW5kTGluZSwgZW5kQ29sXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEdW1wcyB0aGUgZXJyb3Igd2l0aG91dCB0aHJvd2luZy5cblx0ICogSWYgJ3ZlcmJvc2UgPT0gdHJ1ZScgdGhlIFNvdXJjZSBpcyBhbHNvIHByZXR0eSBwcmludGVkIHdpdGggbGluZS1udW1iZXJzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcmJvc2UgXG5cdCAqL1xuXHRkdW1wKHZlcmJvc2UgPSBmYWxzZSkge1xuXHRcdGlmICh2ZXJib3NlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKHRoaXMuI3NyYy5wcmV0dHkoKSk7XG5cdFx0fVxuXG5cdFx0Y29uc29sZS5lcnJvcihcIlxcblwiICsgdGhpcy5tZXNzYWdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlcnJvciBtZXNzYWdlIChhbHRlcm5hdGl2ZSB0byBlLm1lc3NhZ2UpXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhdGNoZXMgYW55IFVzZXJFcnJvcnMgdGhyb3duIGluc2lkZSAnZm4oKWAuXG5cdCAqIER1bXBzIHRoZSBlcnJvclxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcGFyYW0geygpID0+IFR9IGZuIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcmJvc2UgXG5cdCAqIEByZXR1cm5zIHtUIHwgdW5kZWZpbmVkfVx0XG5cdCAqL1xuXHRzdGF0aWMgY2F0Y2goZm4sIHZlcmJvc2UgPSBmYWxzZSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgVXNlckVycm9yKSB7XG5cdFx0XHRcdGVycm9yLmR1bXAodmVyYm9zZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGVycm9yOiBVc2VyRXJyb3IpID0+IHZvaWR9IFRocm93XG4gKi9cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBSdW50aW1lRXJyb3IgZXh0ZW5kcyBVc2VyRXJyb3Ige1xuXHQjaXNJUjsgLy8gbGFzdCB0cmFjZSBhZGRlZFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbXNnIFxuXHQgKiBAcGFyYW0ge1NvdXJjZX0gc3JjIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcG9zIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSVIgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihtc2csIHNyYywgcG9zLCBpc0lSKSB7XG5cdFx0c3VwZXIobXNnLCBzcmMsIHBvcyk7XG5cdFx0dGhpcy4jaXNJUiA9IGlzSVI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTb3VyY2V9IHNyYyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvcyBcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0lSXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvXG5cdCAqIEByZXR1cm5zIHtSdW50aW1lRXJyb3J9XG5cdCAqL1xuXHRzdGF0aWMgbmV3UnVudGltZUVycm9yKHNyYywgcG9zLCBpc0lSLCBpbmZvID0gXCJcIikge1xuXHRcdGxldCBsaW5lID0gc3JjLnBvc1RvTGluZShwb3MpO1xuXG5cdFx0bGV0IG1zZyA9IGBSdW50aW1lRXJyb3Igb24gbGluZSAke2xpbmUgKyAxfSR7aXNJUiA/IFwiIG9mIElSXCIgOiBcIlwifWA7XG5cdFx0aWYgKGluZm8gIT0gXCJcIikge1xuXHRcdFx0bXNnICs9IGA6ICR7aW5mb31gO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUnVudGltZUVycm9yKG1zZywgc3JjLCBwb3MsIGlzSVIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U291cmNlfSBzcmMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNJUiBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZm8gXG5cdCAqIEByZXR1cm5zIHtSdW50aW1lRXJyb3J9XG5cdCAqL1xuXHRhZGRUcmFjZShzcmMsIHBvcywgaXNJUiwgaW5mbyA9IFwiXCIpIHtcblx0XHRpZiAoaXNJUiAmJiAhdGhpcy4jaXNJUikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bGV0IGxpbmUgPSBzcmMucG9zVG9MaW5lKHBvcyk7XG5cblx0XHRsZXQgbXNnID0gYFRyYWNlJHtpbmZvID09IFwiXCIgPyBcIjpcIiA6IFwiLFwifSBsaW5lICR7bGluZSArIDF9YDtcblx0XHRpZiAoaXNJUikge1xuXHRcdFx0bXNnICs9IFwiIG9mIElSXCI7XG5cdFx0fSBcblxuXHRcdGxldCB3b3JkID0gc3JjLmdldFdvcmQocG9zKTtcblx0XHRpZiAod29yZCAhPT0gbnVsbCAmJiB3b3JkICE9PSBcInByaW50XCIpIHtcblx0XHRcdG1zZyArPSBgIGluICcke3dvcmR9J2A7XG5cdFx0fVxuXG5cdFx0aWYgKGluZm8gIT0gXCJcIikge1xuXHRcdFx0bXNnICs9IGA6ICR7aW5mb31gO1xuXHRcdH1cblxuXHRcdFxuXHRcdG1zZyArPSBcIlxcblwiICsgdGhpcy5tZXNzYWdlO1xuXG5cdFx0cmV0dXJuIG5ldyBSdW50aW1lRXJyb3IobXNnLCB0aGlzLnNyYywgdGhpcy5zdGFydFBvcywgaXNJUik7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvIFxuXHQgKiBAcmV0dXJucyB7UnVudGltZUVycm9yfVxuXHQgKi9cblx0YWRkVHJhY2VTaXRlKHNpdGUsIGluZm8gPSBcIlwiKSB7XG5cdFx0aWYgKHNpdGUuY29kZU1hcFNpdGUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZFRyYWNlKHNpdGUuc3JjLCBzaXRlLnN0YXJ0UG9zLCB0cnVlLCBpbmZvKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVHJhY2Uoc2l0ZS5jb2RlTWFwU2l0ZS5zcmMsIHNpdGUuY29kZU1hcFNpdGUuc3RhcnRQb3MsIGZhbHNlLCBpbmZvKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUb2tlbiBpcyB0aGUgYmFzZSBjbGFzcyBvZiBhbGwgRXhwcmVzc2lvbnMgYW5kIFN0YXRlbWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuIHtcblx0I3NpdGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUpIHtcblx0XHR0aGlzLiNzaXRlID0gYXNzZXJ0RGVmaW5lZChzaXRlKTsgLy8gcG9zaXRpb24gaW4gc291cmNlIG9mIHN0YXJ0IG9mIHRva2VuXG5cdH1cblxuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zICd0cnVlJyBpZiAndGhpcycgaXMgYSBsaXRlcmFsIHByaW1pdGl2ZSwgYSBsaXRlcmFsIHN0cnVjdCBjb25zdHJ1Y3Rvciwgb3IgYSBsaXRlcmFsIGZ1bmN0aW9uIGV4cHJlc3Npb24uXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zICd0cnVlJyBpZiAndGhpcycgaXMgYSBXb3JkIHRva2VuLlxuXHQgKiBAcGFyYW0gez8oc3RyaW5nIHwgc3RyaW5nW10pfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzV29yZCh2YWx1ZSA9IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0tleXdvcmQoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgJ3RydWUnIGlmICd0aGlzJyBpcyBhIFN5bWJvbCB0b2tlbiAoZWcuICcrJywgJygnIGV0Yy4pXG5cdCAqIEBwYXJhbSB7PyhzdHJpbmcgfCBzdHJpbmdbXSl9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNTeW1ib2wodmFsdWUgPSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgJ3RydWUnIGlmICd0aGlzJyBpcyBhIGdyb3VwIChlZy4gJyguLi4pJykuXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBuRmllbGRzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNHcm91cCh2YWx1ZSwgbkZpZWxkcyA9IG51bGwpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIFN5bnRheEVycm9yIGF0IHRoZSBjdXJyZW50IFNpdGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgXG5cdCAqIEByZXR1cm5zIHtVc2VyRXJyb3J9XG5cdCAqL1xuXHRzeW50YXhFcnJvcihtc2cpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZS5zeW50YXhFcnJvcihtc2cpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBUeXBlRXJyb3IgYXQgdGhlIGN1cnJlbnQgU2l0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuXHQgKiBAcmV0dXJucyB7VXNlckVycm9yfVxuXHQgKi9cblx0dHlwZUVycm9yKG1zZykge1xuXHRcdHJldHVybiB0aGlzLiNzaXRlLnR5cGVFcnJvcihtc2cpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBSZWZlcmVuY2VFcnJvciBhdCB0aGUgY3VycmVudCBTaXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbXNnXG5cdCAqIEByZXR1cm5zIHtVc2VyRXJyb3J9XG5cdCAqL1xuXHRyZWZlcmVuY2VFcnJvcihtc2cpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZS5yZWZlcmVuY2VFcnJvcihtc2cpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhIFN5bnRheEVycm9yIGlmICd0aGlzJyBpc24ndCBhIFdvcmQuXG5cdCAqIEBwYXJhbSB7PyhzdHJpbmcgfCBzdHJpbmdbXSl9IHZhbHVlIFxuXHQgKiBAcmV0dXJucyB7V29yZCB8IG51bGx9XG5cdCAqL1xuXHRhc3NlcnRXb3JkKHZhbHVlID0gbnVsbCkge1xuXHRcdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zeW50YXhFcnJvcihgZXhwZWN0ZWQgXFwnJHt2YWx1ZX1cXCcsIGdvdCBcXCcke3RoaXMudG9TdHJpbmcoKX1cXCdgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zeW50YXhFcnJvcihgZXhwZWN0ZWQgd29yZCwgZ290ICR7dGhpcy50b1N0cmluZygpfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhIFN5bnRheEVycm9yIGlmICd0aGlzJyBpc24ndCBhIFN5bWJvbC5cblx0ICogQHBhcmFtIHs/KHN0cmluZyB8IHN0cmluZ1tdKX0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtTeW1ib2xUb2tlbiB8IG51bGx9XG5cdCAqL1xuXHRhc3NlcnRTeW1ib2wodmFsdWUgPSBudWxsKSB7XG5cdFx0aWYgKHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnN5bnRheEVycm9yKGBleHBlY3RlZCAnJHt2YWx1ZX0nLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zeW50YXhFcnJvcihgZXhwZWN0ZWQgc3ltYm9sLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYSBTeW50YXhFcnJvciBpZiAndGhpcycgaXNuJ3QgYSBHcm91cC5cblx0ICogQHBhcmFtIHs/c3RyaW5nfSB0eXBlIFxuXHQgKiBAcGFyYW0gez9udW1iZXJ9IG5GaWVsZHNcblx0ICogQHJldHVybnMge0dyb3VwIHwgbnVsbH1cblx0ICovXG5cdGFzc2VydEdyb3VwKHR5cGUgPSBudWxsLCBuRmllbGRzID0gbnVsbCkge1xuXHRcdGlmICh0eXBlICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnN5bnRheEVycm9yKGBpbnZhbGlkIHN5bnRheDogZXhwZWN0ZWQgJyR7dHlwZX0uLi4ke0dyb3VwLm1hdGNoU3ltYm9sKHR5cGUpfSdgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zeW50YXhFcnJvcihgaW52YWxpZCBzeW50YXg6IGV4cGVjdGVkIGdyb3VwYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHt1bmRlZmluZWQgfCBudWxsIHwgVG9rZW59IHRcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICogQHJldHVybnMge251bGwgfCBUb2tlbn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VG9rZW4odCwgc2l0ZSwgbXNnID0gXCJleHBlY3RlZCB0b2tlblwiKSB7XG5cdGlmICghdCkge1xuXHRcdHNpdGUuc3ludGF4RXJyb3IobXNnKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdDtcblx0fVxufVxuXG4vKipcbiAqIEEgV29yZCB0b2tlbiByZXByZXNlbnRzIGEgdG9rZW4gdGhhdCBtYXRjaGVzIC9bQS1aYS16X11bQS1aYS16XzAtOV0vXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBXb3JkIGV4dGVuZHMgVG9rZW4ge1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgdmFsdWUpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICogQHJldHVybnMge1dvcmR9XG5cdCAqL1xuXHRzdGF0aWMgbmV3KHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBXb3JkKFNpdGUuZHVtbXkoKSwgdmFsdWUpO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gez8oc3RyaW5nIHwgc3RyaW5nW10pfSB2YWx1ZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1dvcmQodmFsdWUgPSBudWxsKSB7XG5cdFx0aWYgKHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUubGFzdEluZGV4T2YodGhpcy4jdmFsdWUpICE9IC0xO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IHRoaXMuI3ZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHs/KHN0cmluZyB8IHN0cmluZ1tdKX0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtXb3JkfVxuXHQgKi9cblx0YXNzZXJ0V29yZCh2YWx1ZSA9IG51bGwpIHtcblx0XHRpZiAoIXRoaXMuaXNXb3JkKHZhbHVlKSkge1xuXHRcdFx0c3VwZXIuYXNzZXJ0V29yZCh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1dvcmR9XG5cdCAqL1xuXHRhc3NlcnROb3RJbnRlcm5hbCgpIHtcblx0XHRpZiAodGhpcy4jdmFsdWUgPT0gXCJfXCIpIHtcblx0XHRcdHRocm93IHRoaXMuc3ludGF4RXJyb3IoXCJfIGlzIHJlc2VydmVkXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy4jdmFsdWUuc3RhcnRzV2l0aChcIl9fXCIpKSB7XG5cdFx0XHR0aHJvdyB0aGlzLnN5bnRheEVycm9yKFwiX18gcHJlZml4IGlzIHJlc2VydmVkXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy4jdmFsdWUuZW5kc1dpdGgoXCJfX1wiKSkge1xuXHRcdFx0dGhyb3cgdGhpcy5zeW50YXhFcnJvcihcIl9fIHN1ZmZpeCBpcyByZXNlcnZlZFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzS2V5d29yZCgpIHtcblx0XHRzd2l0Y2ggKHRoaXMuI3ZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiY29uc3RcIjpcblx0XHRcdGNhc2UgXCJmdW5jXCI6XG5cdFx0XHRjYXNlIFwic3RydWN0XCI6XG5cdFx0XHRjYXNlIFwiZW51bVwiOlxuXHRcdFx0Y2FzZSBcImltcG9ydFwiOlxuXHRcdFx0Y2FzZSBcImlmXCI6XG5cdFx0XHRjYXNlIFwiZWxzZVwiOlxuXHRcdFx0Y2FzZSBcInN3aXRjaFwiOlxuXHRcdFx0Y2FzZSBcInNlbGZcIjpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtXb3JkIHwgbnVsbH1cblx0ICovXG5cdGFzc2VydE5vdEtleXdvcmQoKSB7XG5cdFx0dGhpcy5hc3NlcnROb3RJbnRlcm5hbCgpO1xuXG5cdFx0aWYgKHRoaXMuaXNLZXl3b3JkKCkpIHtcblx0XHRcdHRoaXMuc3ludGF4RXJyb3IoYCcke3RoaXMuI3ZhbHVlfScgaXMgYSByZXNlcnZlZCB3b3JkYCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgV29yZCh2YWx1ZSkgaW4gYSBsaXN0IG9mIHRva2Vuc1xuXHQgKiBSZXR1cm5zIC0xIGlmIG5vbmUgZm91bmRcblx0ICogQHBhcmFtIHtUb2tlbltdfSB0cyBcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzdGF0aWMgZmluZCh0cywgdmFsdWUpIHtcblx0XHRyZXR1cm4gdHMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5pc1dvcmQodmFsdWUpKTtcblx0fVxufVxuXG4vKipcbiAqIFN5bWJvbCB0b2tlbiByZXByZXNlbnQgYW55dGhpbmcgbm9uIGFscGhhbnVtZXJpY1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgU3ltYm9sVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG5cdCN2YWx1ZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgdmFsdWUpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gez8oc3RyaW5nIHwgc3RyaW5nW10pfSB2YWx1ZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1N5bWJvbCh2YWx1ZSA9IG51bGwpIHtcblx0XHRpZiAodmFsdWUgIT09IG51bGwpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZS5sYXN0SW5kZXhPZih0aGlzLiN2YWx1ZSkgIT0gLTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gdGhpcy4jdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gez8oc3RyaW5nIHwgc3RyaW5nW10pfSB2YWx1ZSBcblx0ICogQHJldHVybnMge1N5bWJvbFRva2VufVxuXHQgKi9cblx0YXNzZXJ0U3ltYm9sKHZhbHVlKSB7XG5cdFx0aWYgKCF0aGlzLmlzU3ltYm9sKHZhbHVlKSkge1xuXHRcdFx0c3VwZXIuYXNzZXJ0U3ltYm9sKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgU3ltYm9sKHZhbHVlKSBpbiBhIGxpc3Qgb2YgdG9rZW5zLlxuXHQgKiBSZXR1cm5zIC0xIGlmIG5vbmUgZm91bmQuXG5cdCAqIEBwYXJhbSB7VG9rZW5bXX0gdHNcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gdmFsdWVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBmaW5kKHRzLCB2YWx1ZSkge1xuXHRcdHJldHVybiB0cy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlzU3ltYm9sKHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IFN5bWJvbCh2YWx1ZSkgaW4gYSBsaXN0IG9mIHRva2Vucy5cblx0ICogUmV0dXJucyAtMSBpZiBub25lIGZvdW5kLlxuXHQgKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSB2YWx1ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBmaW5kTGFzdCh0cywgdmFsdWUpIHtcblx0XHRmb3IgKGxldCBpID0gdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh0c1tpXS5pc1N5bWJvbCh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9XG59XG5cbi8qKlxuICogR3JvdXAgdG9rZW4gY2FuICcoLi4uKScsICdbLi4uXScgb3IgJ3suLi59JyBhbmQgY2FuIGNvbnRhaW4gY29tbWEgc2VwYXJhdGVkIGZpZWxkcy5cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEdyb3VwIGV4dGVuZHMgVG9rZW4ge1xuXHQjdHlwZTtcblx0I2ZpZWxkcztcblx0I2ZpcnN0Q29tbWE7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBcIihcIiwgXCJbXCIgb3IgXCJ7XCJcblx0ICogQHBhcmFtIHtUb2tlbltdW119IGZpZWxkcyBcblx0ICogQHBhcmFtIHs/U3ltYm9sVG9rZW59IGZpcnN0Q29tbWFcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIHR5cGUsIGZpZWxkcywgZmlyc3RDb21tYSA9IG51bGwpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN0eXBlID0gdHlwZTtcblx0XHR0aGlzLiNmaWVsZHMgPSBmaWVsZHM7IC8vIGxpc3Qgb2YgbGlzdHMgb2YgdG9rZW5zXG5cdFx0dGhpcy4jZmlyc3RDb21tYSA9IGZpcnN0Q29tbWE7XG5cblx0XHRhc3NlcnQoZmllbGRzLmxlbmd0aCA8IDIgfHwgZmlyc3RDb21tYSAhPT0gbnVsbCk7XG5cdH1cblxuXHRnZXQgZmllbGRzKCkge1xuXHRcdHJldHVybiB0aGlzLiNmaWVsZHMuc2xpY2UoKTsgLy8gY29weSwgc28gZmllbGRzXyBkb2Vzbid0IGdldCBtdXRhdGVkXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHs/c3RyaW5nfSB0eXBlIFxuXHQgKiBAcGFyYW0ge251bWJlciB8IG51bGx9IG5GaWVsZHNcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0dyb3VwKHR5cGUgPSBudWxsLCBuRmllbGRzID0gbnVsbCkge1xuXHRcdGNvbnN0IG5GaWVsZHNPayA9IChuRmllbGRzID09PSBudWxsKSB8fCAobkZpZWxkcyA9PSB0aGlzLiNmaWVsZHMubGVuZ3RoKTtcblxuXHRcdGlmICh0eXBlICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZSA9PSB0eXBlICYmIG5GaWVsZHNPaztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5GaWVsZHNPaztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHs/c3RyaW5nfSB0eXBlIFxuXHQgKiBAcGFyYW0gez9udW1iZXJ9IG5GaWVsZHMgXG5cdCAqIEByZXR1cm5zIHtHcm91cCB8IG51bGx9XG5cdCAqL1xuXHRhc3NlcnRHcm91cCh0eXBlID0gbnVsbCwgbkZpZWxkcyA9IG51bGwpIHtcblx0XHRpZiAodHlwZSAhPT0gbnVsbCAmJiB0aGlzLiN0eXBlICE9IHR5cGUpIHtcblx0XHRcdHRoaXMuc3ludGF4RXJyb3IoYGludmFsaWQgc3ludGF4OiBleHBlY3RlZCAnJHt0eXBlfS4uLiR7R3JvdXAubWF0Y2hTeW1ib2wodHlwZSl9JywgZ290ICcke3RoaXMuI3R5cGV9Li4uJHtHcm91cC5tYXRjaFN5bWJvbCh0aGlzLiN0eXBlKX0nYCk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSAhPT0gbnVsbCAmJiBuRmllbGRzICE9PSBudWxsICYmIG5GaWVsZHMgIT0gdGhpcy4jZmllbGRzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMuI2ZpZWxkcy5sZW5ndGggPiAxICYmIG5GaWVsZHMgPD0gMSAmJiB0aGlzLiNmaXJzdENvbW1hICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuI2ZpcnN0Q29tbWEuc3ludGF4RXJyb3IoYGludmFsaWQgc3ludGF4LCB1bmV4cGVjdGVkICcsJ2ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zeW50YXhFcnJvcihgaW52YWxpZCBzeW50YXg6IGV4cGVjdGVkICcke3R5cGV9Li4uJHtHcm91cC5tYXRjaFN5bWJvbCh0eXBlKX0nIHdpdGggJHtuRmllbGRzfSBmaWVsZChzKSwgZ290ICcke3R5cGV9Li4uJHtHcm91cC5tYXRjaFN5bWJvbCh0eXBlKX0nIHdpdGggJHt0aGlzLiNmaWVsZHMubGVuZ3RofSBmaWVsZHNgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0bGV0IHMgPSB0aGlzLiN0eXBlO1xuXG5cdFx0bGV0IHBhcnRzID0gW107XG5cdFx0Zm9yIChsZXQgZiBvZiB0aGlzLiNmaWVsZHMpIHtcblx0XHRcdHBhcnRzLnB1c2goZi5tYXAodCA9PiB0LnRvU3RyaW5nKCkpLmpvaW4oXCIgXCIpKTtcblx0XHR9XG5cblx0XHRzICs9IHBhcnRzLmpvaW4oXCIsIFwiKSArIEdyb3VwLm1hdGNoU3ltYm9sKHRoaXMuI3R5cGUpO1xuXG5cdFx0cmV0dXJuIHM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUb2tlbn0gdCBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNPcGVuU3ltYm9sKHQpIHtcblx0XHRyZXR1cm4gdC5pc1N5bWJvbChcIntcIikgfHwgdC5pc1N5bWJvbChcIltcIikgfHwgdC5pc1N5bWJvbChcIihcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUb2tlbn0gdCBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNDbG9zZVN5bWJvbCh0KSB7XG5cdFx0cmV0dXJuIHQuaXNTeW1ib2woXCJ9XCIpIHx8IHQuaXNTeW1ib2woXCJdXCIpIHx8IHQuaXNTeW1ib2woXCIpXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBicmFja2V0LCBwYXJlbnRoZXNpcyBvciBicmFjZS5cblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIG5vdCBhIGdyb3VwIHN5bWJvbC5cblx0ICogQGV4YW1wbGVcblx0ICogR3JvdXAubWF0Y2hTeW1ib2woXCIoXCIpID0+IFwiKVwiXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgU3ltYm9sVG9rZW59IHRcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBtYXRjaFN5bWJvbCh0KSB7XG5cdFx0aWYgKHQgaW5zdGFuY2VvZiBTeW1ib2xUb2tlbikge1xuXHRcdFx0dCA9IHQudmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKHQgPT0gXCJ7XCIpIHtcblx0XHRcdHJldHVybiBcIn1cIjtcblx0XHR9IGVsc2UgaWYgKHQgPT0gXCJbXCIpIHtcblx0XHRcdHJldHVybiBcIl1cIjtcblx0XHR9IGVsc2UgaWYgKHQgPT0gXCIoXCIpIHtcblx0XHRcdHJldHVybiBcIilcIjtcblx0XHR9IGVsc2UgaWYgKHQgPT0gXCJ9XCIpIHtcblx0XHRcdHJldHVybiBcIntcIjtcblx0XHR9IGVsc2UgaWYgKHQgPT0gXCJdXCIpIHtcblx0XHRcdHJldHVybiBcIltcIjtcblx0XHR9IGVsc2UgaWYgKHQgPT0gXCIpXCIpIHtcblx0XHRcdHJldHVybiBcIihcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGEgZ3JvdXAgc3ltYm9sXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGaW5kcyB0aGUgaW5kZXggb2YgZmlyc3QgR3JvdXAodHlwZSkgaW4gbGlzdCBvZiB0b2tlbnNcblx0ICogUmV0dXJucyAtMSBpZiBub25lIGZvdW5kLlxuXHQgKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBmaW5kKHRzLCB0eXBlKSB7XG5cdFx0cmV0dXJuIHRzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0uaXNHcm91cCh0eXBlKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGxpdGVyYWwgdG9rZW5zXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBQcmltaXRpdmVMaXRlcmFsIGV4dGVuZHMgVG9rZW4ge1xuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogU2lnbmVkIGludCBsaXRlcmFsIHRva2VuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJbnRMaXRlcmFsIGV4dGVuZHMgUHJpbWl0aXZlTGl0ZXJhbCB7XG5cdCN2YWx1ZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCB2YWx1ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWUudG9TdHJpbmcoKTtcblx0fVxufVxuXG4vKipcbiAqIEJvb2wgbGl0ZXJhbCB0b2tlblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQm9vbExpdGVyYWwgZXh0ZW5kcyBQcmltaXRpdmVMaXRlcmFsIHtcblx0I3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCB2YWx1ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ5dGVBcnJheSBsaXRlcmFsIHRva2VuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBCeXRlQXJyYXlMaXRlcmFsIGV4dGVuZHMgUHJpbWl0aXZlTGl0ZXJhbCB7XG5cdCNieXRlcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGJ5dGVzKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jYnl0ZXMgPSBieXRlcztcblx0fVxuXG5cdGdldCBieXRlcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYnl0ZXM7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYCMke2J5dGVzVG9IZXgodGhpcy4jYnl0ZXMpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBTdHJpbmcgbGl0ZXJhbCB0b2tlbiAodXRmOClcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0cmluZ0xpdGVyYWwgZXh0ZW5kcyBQcmltaXRpdmVMaXRlcmFsIHtcblx0I3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIHZhbHVlKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jdmFsdWUgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYFwiJHt0aGlzLiN2YWx1ZS50b1N0cmluZygpfVwiYDtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAdHlwZWRlZiB7W251bWJlciwgU2l0ZV1bXX0gQ29kZU1hcFxuICovXG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEB0eXBlZGVmIHtNYXA8c3RyaW5nLCBJUj59IElSRGVmaW5pdGlvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBJUiBjbGFzcyBjb21iaW5lcyBhIHN0cmluZyBvZiBpbnRlcm1lZGlhdGUgcmVwcmVzZW50YXRpb24gc291cmNlY29kZSB3aXRoIGFuIG9wdGlvbmFsIHNpdGUuXG4gKiBUaGUgc2l0ZSBpcyB1c2VkIGZvciBtYXBwaW5nIElSIGNvZGUgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICogQHBhY2thZ2VcbiAqL1xuIGNsYXNzIElSIHtcblx0I2NvbnRlbnQ7XG5cdCNzaXRlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IElSW119IGNvbnRlbnQgXG5cdCAqIEBwYXJhbSB7P1NpdGV9IHNpdGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihjb250ZW50LCBzaXRlID0gbnVsbCkge1xuXHRcdGFzc2VydCghKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5zb21lKGl0ZW0gPT4gaXRlbSA9PSB1bmRlZmluZWQpKSwgXCJzb21lIGl0ZW1zIHVuZGVmaW5lZFwiKTtcblx0XHR0aGlzLiNjb250ZW50ID0gY29udGVudDtcblx0XHR0aGlzLiNzaXRlID0gc2l0ZTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgSVJbXX1cbiAgICAgKi9cblx0Z2V0IGNvbnRlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2NvbnRlbnQ7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHR5cGUgez9TaXRlfVxuICAgICAqL1xuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIElSIGluc3RhbmNlcyB0aGF0IHRoZW1zZWx2ZXMgb25seSBjb250YWluIHN0cmluZ3NcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcmV0dXJucyB7SVJbXX1cblx0ICovXG5cdGZsYXR0ZW4oKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLiNjb250ZW50ID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHJldHVybiBbdGhpc107XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge0lSW119XG5cdFx0XHQgKi9cblx0XHRcdGxldCByZXN1bHQgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaXRlbSBvZiB0aGlzLiNjb250ZW50KSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoaXRlbS5mbGF0dGVuKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcnNwZXJzZSBuZXN0ZWQgSVIgY29udGVudCB3aXRoIGEgc2VwYXJhdG9yXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlcFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHRqb2luKHNlcCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy4jY29udGVudCA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIEB0eXBlIHtJUltdfSAqL1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jY29udGVudC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQucHVzaCh0aGlzLiNjb250ZW50W2ldKTtcblxuXHRcdFx0XHRpZiAoaSA8IHRoaXMuI2NvbnRlbnQubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKG5ldyBJUihzZXApKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgSVIocmVzdWx0KTtcblx0XHR9XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtbc3RyaW5nLCBDb2RlTWFwXX1cblx0ICovXG5cdGdlbmVyYXRlU291cmNlKCkge1xuXHRcdGNvbnN0IHBhcnRzID0gdGhpcy5mbGF0dGVuKCk7XG5cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGNvbnN0IHBhcnRTcmNzID0gW107XG5cblx0XHQvKiogQHR5cGUge0NvZGVNYXB9ICovXG5cdFx0Y29uc3QgY29kZU1hcCA9IFtdO1xuXG5cdFx0bGV0IHBvcyA9IDA7XG5cdFx0Zm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuXHRcdFx0Y29uc3QgcmF3UGFydFNyYyA9IHBhcnQuY29udGVudDtcblxuXHRcdFx0aWYgKHR5cGVvZiByYXdQYXJ0U3JjID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Y29uc3Qgb3JpZ1NpdGUgPSBwYXJ0LnNpdGU7XG5cdFx0XHRcdGlmIChvcmlnU2l0ZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7W251bWJlciwgU2l0ZV19ICovXG5cdFx0XHRcdFx0Y29uc3QgcGFpciA9IFtwb3MsIG9yaWdTaXRlXTtcblxuXHRcdFx0XHRcdGNvZGVNYXAucHVzaChwYWlyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHBhcnRTcmMgPSByZXBsYWNlVGFicyhyYXdQYXJ0U3JjKTtcblxuXHRcdFx0XHRwb3MgKz0gcGFydFNyYy5sZW5ndGg7XG5cdFx0XHRcdHBhcnRTcmNzLnB1c2gocGFydFNyYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBJUiB0byBjb250YWluIG9ubHkgc3RyaW5ncyBhZnRlciBmbGF0dGVuXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbcGFydFNyY3Muam9pbihcIlwiKSwgY29kZU1hcF07XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHByZXR0eSgpIHtcblx0XHRjb25zdCBbc3JjLCBfXSA9IHRoaXMuZ2VuZXJhdGVTb3VyY2UoKTtcblxuXHRcdHJldHVybiAobmV3IFNvdXJjZShzcmMpKS5wcmV0dHkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcmFwcyAnaW5uZXInIElSIHNvdXJjZSB3aXRoIHNvbWUgZGVmaW5pdGlvbnMgKHVzZWQgZm9yIHRvcC1sZXZlbCBzdGF0ZW1lbnRzIGFuZCBmb3IgYnVpbHRpbnMpXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtJUn0gaW5uZXIgXG5cdCAqIEBwYXJhbSB7SVJEZWZpbml0aW9uc30gZGVmaW5pdGlvbnMgLSBuYW1lIC0+IGRlZmluaXRpb25cblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0c3RhdGljIHdyYXBXaXRoRGVmaW5pdGlvbnMoaW5uZXIsIGRlZmluaXRpb25zKSB7XG5cdFx0Y29uc3Qga2V5cyA9IEFycmF5LmZyb20oZGVmaW5pdGlvbnMua2V5cygpKS5yZXZlcnNlKCk7XG5cblx0XHRsZXQgcmVzID0gaW5uZXI7XG5cdFx0Zm9yIChsZXQga2V5IG9mIGtleXMpIHtcblx0XHRcdGNvbnN0IGRlZmluaXRpb24gPSBkZWZpbml0aW9ucy5nZXQoa2V5KTtcblxuXHRcdFx0aWYgKGRlZmluaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXMgPSBuZXcgSVIoW25ldyBJUihcIihcIiksIG5ldyBJUihrZXkpLCBuZXcgSVIoXCIpIC0+IHtcXG5cIiksXG5cdFx0XHRcdFx0cmVzLCBuZXcgSVIoYFxcbn0oXFxuJHtUQUJ9Lyoke2tleX0qL1xcbiR7VEFCfWApLCBkZWZpbml0aW9uLFxuXHRcdFx0XHRuZXcgSVIoXCJcXG4pXCIpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDQ6IENyeXB0b2dyYXBoeSBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBTaXplIG9mIGRlZmF1bHQgQmxha2UyYiBkaWdlc3RcbiAqIEBwYWNrYWdlXG4gKi9cbnZhciBCTEFLRTJCX0RJR0VTVF9TSVpFID0gMzI7IC8vIGJ5dGVzXG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgQkxBS0UyQl9ESUdFU1RfU0laRSBcbiAqICAoYmVjYXVzZSB0aGUgbm9kZWpzIGNyeXB0byBtb2R1bGUgb25seSBzdXBwb3J0cyBcbiAqICAgYmxha2UyYi01MTIgYW5kIG5vdCBibGFrZTJiLTI1NiwgYW5kIHdlIHdhbnQgdG8gYXZvaWQgbm9uLXN0YW5kYXJkIGRlcGVuZGVuY2llcyBpbiB0aGUgXG4gKiAgIHRlc3Qtc3VpdGUpXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IHMgLSAzMiBvciA2NFxuICovXG5mdW5jdGlvbiBzZXRCbGFrZTJiRGlnZXN0U2l6ZShzKSB7XG4gICAgQkxBS0UyQl9ESUdFU1RfU0laRSA9IHM7XG59XG4gXG4vKipcbiAqIE1ha2Ugc3VyZSByZXN1bHRpbmcgbnVtYmVyIGZpdHMgaW4gdWludDMyXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqL1xuZnVuY3Rpb24gaW1vZDMyKHgpIHtcblx0cmV0dXJuIHggPj4+IDA7XG59XG5cbi8qKlxuICogMzIgYml0IG51bWJlciByb3RhdGlvblxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gb3JpZ2luYWxseSB1aW50MzJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIG9yaWdpbmFsbHkgdWludDMyXG4gKi9cbmZ1bmN0aW9uIGlyb3RyKHgsIG4pIHtcblx0cmV0dXJuIGltb2QzMigoeCA+Pj4gbikgfCAoeCA8PCAoMzIgLSBuKSkpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge2JpZ2ludH0geCBcbiAqIEBwYXJhbSB7YmlnaW50fSBuIFxuICogQHJldHVybnMge2JpZ2ludH1cbiAqL1xuZnVuY3Rpb24gcG9zTW9kKHgsIG4pIHtcblx0Y29uc3QgcmVzID0geCAlIG47XG5cblx0aWYgKHJlcyA8IDBuKSB7XG5cdFx0cmV0dXJuIHJlcyArIG47XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxufVxuXG4vKipcbiAqIFVJbnQ2NCBudW1iZXIgKHJlcHJlc2VudGVkIGJ5IDIgVUludDMyIG51bWJlcnMpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVSW50NjQge1xuXHQjaGlnaDtcblx0I2xvdztcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggIC0gdWludDMyIG51bWJlclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG93IC0gdWludDMyIG51bWJlclxuXHQgKi9cblx0Y29uc3RydWN0b3IoaGlnaCwgbG93KSB7XHRcdFxuXHRcdHRoaXMuI2hpZ2ggPSBpbW9kMzIoaGlnaCk7XG5cdFx0dGhpcy4jbG93ID0gaW1vZDMyKGxvdyk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcmV0dXJucyB7VUludDY0fVxuXHQgKi9cblx0c3RhdGljIHplcm8oKSB7XG5cdFx0cmV0dXJuIG5ldyBVSW50NjQoMCwgMCk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyAtIDggdWludDggbnVtYmVyc1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhblxuXHQgKiBAcmV0dXJucyB7VUludDY0fVxuXHQgKi9cblx0c3RhdGljIGZyb21CeXRlcyhieXRlcywgbGl0dGxlRW5kaWFuID0gdHJ1ZSkge1xuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdGxldCBsb3c7XG5cblx0XHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0XHRsZXQgaGlnaDtcblxuXHRcdGlmIChsaXR0bGVFbmRpYW4pIHtcblx0XHRcdGxvdyAgPSAoYnl0ZXNbMF0gPDwgMCkgfCAoYnl0ZXNbMV0gPDwgOCkgfCAoYnl0ZXNbMl0gPDwgMTYpIHwgKGJ5dGVzWzNdIDw8IDI0KTtcblx0XHRcdGhpZ2ggPSAoYnl0ZXNbNF0gPDwgMCkgfCAoYnl0ZXNbNV0gPDwgOCkgfCAoYnl0ZXNbNl0gPDwgMTYpIHwgKGJ5dGVzWzddIDw8IDI0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlnaCA9IChieXRlc1swXSA8PCAyNCkgfCAoYnl0ZXNbMV0gPDwgMTYpIHwgKGJ5dGVzWzJdIDw8IDgpIHwgKGJ5dGVzWzNdIDw8IDApO1xuXHRcdFx0bG93ICA9IChieXRlc1s0XSA8PCAyNCkgfCAoYnl0ZXNbNV0gPDwgMTYpIHwgKGJ5dGVzWzZdIDw8IDgpIHwgKGJ5dGVzWzddIDw8IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgVUludDY0KGltb2QzMihoaWdoKSwgaW1vZDMyKGxvdykpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcblx0ICogQHJldHVybnMge1VJbnQ2NH1cblx0ICovXG5cdHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuXHRcdGNvbnN0IGhpZ2ggPSBwYXJzZUludChzdHIuc2xpY2UoMCwgIDgpLCAxNik7XG5cdFx0Y29uc3QgbG93ICA9IHBhcnNlSW50KHN0ci5zbGljZSg4LCAxNiksIDE2KTtcblxuXHRcdHJldHVybiBuZXcgVUludDY0KGhpZ2gsIGxvdyk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblx0Z2V0IGhpZ2goKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2hpZ2g7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblx0Z2V0IGxvdygpIHtcblx0XHRyZXR1cm4gdGhpcy4jbG93O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgW2xvd1swXSwgbG93WzFdLCBsb3dbMl0sIGxvd1szXSwgaGlnaFswXSwgaGlnaFsxXSwgaGlnaFsyXSwgaGlnaFszXV0gaWYgbGl0dGxlRW5kaWFuPT10cnVlXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW5cblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9CeXRlcyhsaXR0bGVFbmRpYW4gPSB0cnVlKSB7XG5cdFx0Y29uc3QgcmVzID0gW1xuXHRcdFx0KDB4MDAwMDAwZmYgJiB0aGlzLiNsb3cpLFxuXHRcdFx0KDB4MDAwMGZmMDAgJiB0aGlzLiNsb3cpID4+PiA4LFxuXHRcdFx0KDB4MDBmZjAwMDAgJiB0aGlzLiNsb3cpID4+PiAxNixcblx0XHRcdCgweGZmMDAwMDAwICYgdGhpcy4jbG93KSA+Pj4gMjQsXG5cdFx0XHQoMHgwMDAwMDBmZiAmIHRoaXMuI2hpZ2gpLFxuXHRcdFx0KDB4MDAwMGZmMDAgJiB0aGlzLiNoaWdoKSA+Pj4gOCxcblx0XHRcdCgweDAwZmYwMDAwICYgdGhpcy4jaGlnaCkgPj4+IDE2LFxuXHRcdFx0KDB4ZmYwMDAwMDAgJiB0aGlzLiNoaWdoKSA+Pj4gMjQsXG5cdFx0XTtcblxuXHRcdGlmICghbGl0dGxlRW5kaWFuKSB7XG5cdFx0XHRyZXMucmV2ZXJzZSgpOyBcblx0XHR9IFxuXHRcdFxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1VJbnQ2NH0gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0ZXEob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuI2hpZ2ggPT0gb3RoZXIuI2hpZ2gpICYmICh0aGlzLiNsb3cgPT0gb3RoZXIuI2xvdyk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcmV0dXJucyB7VUludDY0fSBcblx0ICovXG5cdG5vdCgpIHtcblx0XHRyZXR1cm4gbmV3IFVJbnQ2NCh+dGhpcy4jaGlnaCwgfnRoaXMuI2xvdyk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1VJbnQ2NH0gb3RoZXJcblx0ICogQHJldHVybnMge1VJbnQ2NH1cblx0ICovXG5cdGFuZChvdGhlcikge1xuXHRcdHJldHVybiBuZXcgVUludDY0KHRoaXMuI2hpZ2ggJiBvdGhlci4jaGlnaCwgdGhpcy4jbG93ICYgb3RoZXIuI2xvdyk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1VJbnQ2NH0gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtVSW50NjR9XG5cdCAqL1xuXHR4b3Iob3RoZXIpIHtcblx0XHRyZXR1cm4gbmV3IFVJbnQ2NCh0aGlzLiNoaWdoIF4gb3RoZXIuI2hpZ2gsIHRoaXMuI2xvdyBeIG90aGVyLiNsb3cpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtVSW50NjR9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7VUludDY0fVxuXHQgKi9cblx0YWRkKG90aGVyKSB7XG5cdFx0Y29uc3QgbG93ID0gdGhpcy4jbG93ICsgb3RoZXIuI2xvdztcblxuXHRcdGxldCBoaWdoID0gdGhpcy4jaGlnaCArIG90aGVyLiNoaWdoO1xuXG5cdFx0aWYgKGxvdyA+PSAweDEwMDAwMDAwMCkge1xuXHRcdFx0aGlnaCArPSAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgVUludDY0KGhpZ2gsIGxvdyk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbiBcblx0ICogQHJldHVybnMge1VJbnQ2NH1cblx0ICovXG5cdHJvdHIobikge1xuXHRcdGlmIChuID09IDMyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVJbnQ2NCh0aGlzLiNsb3csIHRoaXMuI2hpZ2gpO1xuXHRcdH0gZWxzZSBpZiAobiA+IDMyKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBVSW50NjQodGhpcy4jbG93LCB0aGlzLiNoaWdoKSkucm90cihuIC0gMzIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVJbnQ2NChcblx0XHRcdFx0aW1vZDMyKCh0aGlzLiNoaWdoID4+PiBuKSB8ICh0aGlzLiNsb3cgIDw8ICgzMiAtIG4pKSksIFxuXHRcdFx0XHRpbW9kMzIoKHRoaXMuI2xvdyAgPj4+IG4pIHwgKHRoaXMuI2hpZ2ggPDwgKDMyIC0gbikpKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gblxuXHQgKiBAcmV0dXJucyB7VUludDY0fVxuXHQgKi9cblx0c2hpZnRyKG4pIHtcblx0XHRpZiAobiA+PSAzMikge1xuXHRcdFx0cmV0dXJuIG5ldyBVSW50NjQoMCwgdGhpcy4jaGlnaCA+Pj4gbiAtIDMyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBVSW50NjQodGhpcy4jaGlnaCA+Pj4gbiwgKHRoaXMuI2xvdyA+Pj4gbikgfCAodGhpcy4jaGlnaCA8PCAoMzIgLSBuKSkpO1xuXHRcdH1cblx0fVx0XG59XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNyeXB0b2dyYXBoeSBwcmltaXRpdmVzIGFyZSBpbmNsdWRlZCBoZXJlIGluIG9yZGVyIHRvIGF2b2lkIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuICogICAgIG11bGJlcnJ5MzI6IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gKiAgICAgYmFzZTMyIGVuY29kaW5nIGFuZCBkZWNvZGluZ1xuICogICAgIGJlY2gzMiBlbmNvZGluZywgY2hlY2tpbmcsIGFuZCBkZWNvZGluZ1xuICogICAgIHNoYTJfMjU2LCBzaGEyXzUxMiwgc2hhMyBhbmQgYmxha2UyYiBoYXNoaW5nXG4gKiAgICAgZWQyNTUxOSBwdWJrZXkgZ2VuZXJhdGlvbiwgc2lnbmluZywgYW5kIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gKE5PVEU6IHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGlzIHNpbXBsZSBidXQgc2xvdylcbiAqL1xuZXhwb3J0IGNsYXNzIENyeXB0byB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc2ltcGxlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZWRcblx0ICogQHJldHVybnMge051bWJlckdlbmVyYXRvcn0gLSBhIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAqL1xuXHRzdGF0aWMgbXVsYmVycnkzMihzZWVkKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge051bWJlckdlbmVyYXRvcn1cblx0XHQgKi9cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgdCA9IHNlZWQgKz0gMHg2RDJCNzlGNTtcblx0XHRcdHQgPSBNYXRoLmltdWwodCBeIHQgPj4+IDE1LCB0IHwgMSk7XG5cdFx0XHR0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG5cdFx0XHRyZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFsaWFzIGZvciByYW5kIGdlbmVyYXRvciBvZiBjaG9pY2VcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VlZFxuXHQgKiBAcmV0dXJucyB7TnVtYmVyR2VuZXJhdG9yfSAtIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBmdW5jdGlvblxuXHQgKi9cblx0c3RhdGljIHJhbmQoc2VlZCkge1xuXHRcdHJldHVybiB0aGlzLm11bGJlcnJ5MzIoc2VlZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmZjIDQ2NDggYmFzZTMyIGFscGhhYmV0XG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgZ2V0IERFRkFVTFRfQkFTRTMyX0FMUEhBQkVUKCkge1xuXHRcdHJldHVybiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCI7XG5cdH1cblxuXHQvKipcblx0ICogQmVjaDMyIGJhc2UzMiBhbHBoYWJldFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGdldCBCRUNIMzJfQkFTRTMyX0FMUEhBQkVUKCkge1xuXHRcdHJldHVybiBcInFwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsXCI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFbmNvZGUgYnl0ZXMgaW4gc3BlY2lhbCBiYXNlMzIuXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by5lbmNvZGVCYXNlMzIodGV4dFRvQnl0ZXMoXCJmXCIpKSA9PiBcIm15XCJcblx0ICogQGV4YW1wbGVcblx0ICogQ3J5cHRvLmVuY29kZUJhc2UzMih0ZXh0VG9CeXRlcyhcImZvXCIpKSA9PiBcIm16eHFcIlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBDcnlwdG8uZW5jb2RlQmFzZTMyKHRleHRUb0J5dGVzKFwiZm9vXCIpKSA9PiBcIm16eHc2XCJcblx0ICogQGV4YW1wbGVcblx0ICogQ3J5cHRvLmVuY29kZUJhc2UzMih0ZXh0VG9CeXRlcyhcImZvb2JcIikpID0+IFwibXp4dzZ5cVwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by5lbmNvZGVCYXNlMzIodGV4dFRvQnl0ZXMoXCJmb29iYVwiKSkgPT4gXCJtenh3Nnl0YlwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by5lbmNvZGVCYXNlMzIodGV4dFRvQnl0ZXMoXCJmb29iYXJcIikpID0+IFwibXp4dzZ5dGJvaVwiXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgLSB1aW50OCBudW1iZXJzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldCAtIGxpc3Qgb2YgY2hhcnNcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZUJhc2UzMihieXRlcywgYWxwaGFiZXQgPSBDcnlwdG8uREVGQVVMVF9CQVNFMzJfQUxQSEFCRVQpIHtcblx0XHRyZXR1cm4gQ3J5cHRvLmVuY29kZUJhc2UzMkJ5dGVzKGJ5dGVzKS5tYXAoYyA9PiBhbHBoYWJldFtjXSkuam9pbihcIlwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBtZXRob2RcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge251bWJlcltdfSAtIGxpc3Qgb2YgbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDMyXG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlQmFzZTMyQnl0ZXMoYnl0ZXMpICB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cblx0XHRjb25zdCByZWFkZXIgPSBuZXcgQml0UmVhZGVyKGJ5dGVzLCBmYWxzZSk7XG5cblx0XHR3aGlsZSAoIXJlYWRlci5lb2YoKSkge1xuXHRcdFx0cmVzdWx0LnB1c2gocmVhZGVyLnJlYWRCaXRzKDUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSBiYXNlMzIgc3RyaW5nIGludG8gYnl0ZXMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9UZXh0KENyeXB0by5kZWNvZGVCYXNlMzIoXCJteVwiKSkgPT4gXCJmXCJcblx0ICogQGV4YW1wbGVcblx0ICogYnl0ZXNUb1RleHQoQ3J5cHRvLmRlY29kZUJhc2UzMihcIm16eHFcIikpID0+IFwiZm9cIlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBieXRlc1RvVGV4dChDcnlwdG8uZGVjb2RlQmFzZTMyKFwibXp4dzZcIikpID0+IFwiZm9vXCJcblx0ICogQGV4YW1wbGVcblx0ICogYnl0ZXNUb1RleHQoQ3J5cHRvLmRlY29kZUJhc2UzMihcIm16eHc2eXFcIikpID0+IFwiZm9vYlwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9UZXh0KENyeXB0by5kZWNvZGVCYXNlMzIoXCJtenh3Nnl0YlwiKSkgPT4gXCJmb29iYVwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9UZXh0KENyeXB0by5kZWNvZGVCYXNlMzIoXCJtenh3Nnl0Ym9pXCIpKSA9PiBcImZvb2JhclwiXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG5cdCAqIEByZXR1cm4ge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGRlY29kZUJhc2UzMihlbmNvZGVkLCBhbHBoYWJldCA9IENyeXB0by5ERUZBVUxUX0JBU0UzMl9BTFBIQUJFVCkge1xuXHRcdGNvbnN0IHdyaXRlciA9IG5ldyBCaXRXcml0ZXIoKTtcblxuXHRcdGNvbnN0IG4gPSBlbmNvZGVkLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRjb25zdCBjID0gZW5jb2RlZFtpXTtcblx0XHRcdGNvbnN0IGNvZGUgPSBhbHBoYWJldC5pbmRleE9mKGMudG9Mb3dlckNhc2UoKSk7XG5cblx0XHRcdGlmIChpID09IG4gLSAxKSB7XG5cdFx0XHRcdC8vIGxhc3QsIG1ha2Ugc3VyZSB3ZSBhbGlnbiB0byBieXRlXG5cblx0XHRcdFx0Y29uc3QgbkN1dCA9IG4qNSAtIDgqTWF0aC5mbG9vcihuKjUvOCk7XG5cblx0XHRcdFx0Y29uc3QgYml0cyA9IHBhZFplcm9lcyhjb2RlLnRvU3RyaW5nKDIpLCA1KVxuXG5cdFx0XHRcdHdyaXRlci53cml0ZShiaXRzLnNsaWNlKDAsIDUgLSBuQ3V0KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBiaXRzID0gcGFkWmVyb2VzKGNvZGUudG9TdHJpbmcoMiksIDUpO1xuXG5cdFx0XHRcdHdyaXRlci53cml0ZShiaXRzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSB3cml0ZXIuZmluYWxpemUoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBhbmQgaHVtYW4gcmVhZGFibGUgcHJlZml4IG9mIHRoZSBiZWNoMzIgZW5jb2Rpbmcgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGNoZWNrU3VtXG5cdCAqIEludGVybmFsIG1ldGhvZC5cbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHJwXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBleHBhbmRCZWNoMzJIdW1hblJlYWRhYmxlUGFydChocnApIHtcblx0XHRjb25zdCBieXRlcyA9IFtdO1xuXHRcdGZvciAobGV0IGMgb2YgaHJwKSB7XG5cdFx0XHRieXRlcy5wdXNoKGMuY2hhckNvZGVBdCgwKSA+PiA1KTtcblx0XHR9XG5cblx0XHRieXRlcy5wdXNoKDApO1xuXG5cdFx0Zm9yIChsZXQgYyBvZiBocnApIHtcblx0XHRcdGJ5dGVzLnB1c2goYy5jaGFyQ29kZUF0KDApICYgMzEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBieXRlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGFzIHBhcnQgb2YgdGhlIGJlY2gzMiBjaGVja3N1bS5cblx0ICogSW50ZXJuYWwgbWV0aG9kLlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c3RhdGljIGNhbGNCZWNoMzJQb2x5bW9kKGJ5dGVzKSB7XG5cdFx0Y29uc3QgR0VOID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuXG5cdFx0bGV0IGNoayA9IDE7XG5cdFx0Zm9yIChsZXQgYiBvZiBieXRlcykge1xuXHRcdFx0Y29uc3QgYyA9IChjaGsgPj4gMjUpO1xuXHRcdFx0Y2hrID0gKGNoayAmIDB4MWZmZmZmZmYpIDw8IDUgXiBiO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0XHRpZiAoKChjID4+IGkpICYgMSkgIT0gMCkge1xuXHRcdFx0XHRcdGNoayBePSBHRU5baV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2hrO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRoZSBiZWNoMzIgY2hlY2tzdW1cblx0ICogSW50ZXJuYWwgbWV0aG9kXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IGhycCBcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gZGF0YSAtIG51bWJlcnMgYmV0d2VlbiAwIGFuZCAzMlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gNiBudW1iZXJzIGJldHdlZW4gMCBhbmQgMzJcblx0ICovXG5cdHN0YXRpYyBjYWxjQmVjaDMyQ2hlY2tzdW0oaHJwLCBkYXRhKSB7XG5cdFx0Y29uc3QgYnl0ZXMgPSBDcnlwdG8uZXhwYW5kQmVjaDMySHVtYW5SZWFkYWJsZVBhcnQoaHJwKS5jb25jYXQoZGF0YSk7XG5cblx0XHRjb25zdCBjaGsgPSBDcnlwdG8uY2FsY0JlY2gzMlBvbHltb2QoYnl0ZXMuY29uY2F0KFswLDAsMCwwLDAsMF0pKSBeIDE7XG5cblx0XHRjb25zdCBjaGtTdW0gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0Y2hrU3VtLnB1c2goKGNoayA+PiA1ICogKDUgLSBpKSkgJiAzMSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoa1N1bTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYmVjaDMyIGNoZWNrc3VtbWVkIHN0cmluZyAodXNlZCB0byByZXByZXNlbnQgQ2FyZGFubyBhZGRyZXNzZXMpXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by5lbmNvZGVCZWNoMzIoXCJmb29cIiwgdGV4dFRvQnl0ZXMoXCJmb29iYXJcIikpID0+IFwiZm9vMXZlaGs3Y25wd2dyeTloOTZcIlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBDcnlwdG8uZW5jb2RlQmVjaDMyKFwiYWRkcl90ZXN0XCIsIGhleFRvQnl0ZXMoXCI3MGE5NTA4ZjAxNWNmYmNmZmMzZDg4YWM0YzFjOTM0YjViODJkMmJiMjgxZDQ2NDY3MmY2YzQ5NTM5XCIpKSA9PiBcImFkZHJfdGVzdDF3ejU0cHJjcHRuYXVsbHBhM3preWM4eW5mZGRjOTU0bTlxdzV2M25qN216ZjJ3Z2dzMnVsZFwiXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IGhycCBcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gZGF0YSAtIHVpbnQ4IDAgLSAyNTZcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVCZWNoMzIoaHJwLCBkYXRhKSB7XG5cdFx0YXNzZXJ0KGhycC5sZW5ndGggPiAwLCBcImh1bWFuLXJlYWRhYmxlLXBhcnQgbXVzdCBoYXZlIG5vbi16ZXJvIGxlbmd0aFwiKTtcblxuXHRcdGRhdGEgPSBDcnlwdG8uZW5jb2RlQmFzZTMyQnl0ZXMoZGF0YSk7XG5cblx0XHRjb25zdCBjaGtTdW0gPSBDcnlwdG8uY2FsY0JlY2gzMkNoZWNrc3VtKGhycCwgZGF0YSk7XG5cblx0XHRyZXR1cm4gaHJwICsgXCIxXCIgKyBkYXRhLmNvbmNhdChjaGtTdW0pLm1hcChpID0+IENyeXB0by5CRUNIMzJfQkFTRTMyX0FMUEhBQkVUW2ldKS5qb2luKFwiXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29tcG9zZXMgYSBiZWNoMzIgY2hlY2tzdW1tZWQgc3RyaW5nIChpLmUuIENhcmRhbm8gYWRkcmVzcyksIGFuZCByZXR1cm5zIHRoZSBodW1hbiByZWFkYWJsZSBwYXJ0IGFuZCB0aGUgb3JpZ2luYWwgYnl0ZXNcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIGNoZWNrc3VtIGlzIGludmFsaWQuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLmRlY29kZUJlY2gzMihcImFkZHJfdGVzdDF3ejU0cHJjcHRuYXVsbHBhM3preWM4eW5mZGRjOTU0bTlxdzV2M25qN216ZjJ3Z2dzMnVsZFwiKVsxXSkgPT4gXCI3MGE5NTA4ZjAxNWNmYmNmZmMzZDg4YWM0YzFjOTM0YjViODJkMmJiMjgxZDQ2NDY3MmY2YzQ5NTM5XCJcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYWRkciBcblx0ICogQHJldHVybnMge1tzdHJpbmcsIG51bWJlcltdXX1cblx0ICovXG5cdHN0YXRpYyBkZWNvZGVCZWNoMzIoYWRkcikge1xuXHRcdGFzc2VydChDcnlwdG8udmVyaWZ5QmVjaDMyKGFkZHIpLCBcImludmFsaWQgYmVjaDMyIGFkZHJcIik7XG5cblx0XHRjb25zdCBpID0gYWRkci5pbmRleE9mKFwiMVwiKTtcblxuXHRcdGFzc2VydChpICE9IC0xKTtcblxuXHRcdGNvbnN0IGhycCA9IGFkZHIuc2xpY2UoMCwgaSk7XG5cblx0XHRhZGRyID0gYWRkci5zbGljZShpKzEpO1xuXG5cdFx0Y29uc3QgZGF0YSA9IENyeXB0by5kZWNvZGVCYXNlMzIoYWRkci5zbGljZSgwLCBhZGRyLmxlbmd0aCAtIDYpLCBDcnlwdG8uQkVDSDMyX0JBU0UzMl9BTFBIQUJFVCk7XG5cblx0XHRyZXR1cm4gW2hycCwgZGF0YV07XG5cdH1cblxuXHQvKipcblx0ICogVmVyaWZ5IGEgYmVjaDMyIGNoZWNrc3VtXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by52ZXJpZnlCZWNoMzIoXCJmb28xdmVoazdjbnB3Z3J5OWg5NlwiKSA9PiB0cnVlXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by52ZXJpZnlCZWNoMzIoXCJmb28xdmVoazdjbnB3Z3J5OWg5N1wiKSA9PiBmYWxzZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBDcnlwdG8udmVyaWZ5QmVjaDMyKFwiYTEydWVsNWxcIikgPT4gdHJ1ZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBDcnlwdG8udmVyaWZ5QmVjaDMyKFwibW0xY3J4bTNpXCIpID0+IGZhbHNlXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by52ZXJpZnlCZWNoMzIoXCJBMUc3U0dEOFwiKSA9PiBmYWxzZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBDcnlwdG8udmVyaWZ5QmVjaDMyKFwiYWJjZGVmMXFwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsbXFxcXh3XCIpID0+IHRydWVcblx0ICogQGV4YW1wbGVcblx0ICogQ3J5cHRvLnZlcmlmeUJlY2gzMihcIj8xZXp5ZmNsXCIpID0+IHRydWVcblx0ICogQGV4YW1wbGVcblx0ICogQ3J5cHRvLnZlcmlmeUJlY2gzMihcImFkZHJfdGVzdDF3ejU0cHJjcHRuYXVsbHBhM3preWM4eW5mZGRjOTU0bTlxdzV2M25qN216ZjJ3Z2dzMnVsZFwiKSA9PiB0cnVlXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IGFkZHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgdmVyaWZ5QmVjaDMyKGFkZHIpIHtcblx0XHRjb25zdCBkYXRhID1bXTtcblxuXHRcdGNvbnN0IGkgPSBhZGRyLmluZGV4T2YoXCIxXCIpO1xuICAgICAgICBcblx0XHRpZiAoaSA9PSAtMSB8fCBpID09IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBocnAgPSBhZGRyLnNsaWNlKDAsIGkpO1xuXG5cdFx0YWRkciA9IGFkZHIuc2xpY2UoaSArIDEpO1xuXG5cdFx0Zm9yIChsZXQgYyBvZiBhZGRyKSB7XG5cdFx0XHRjb25zdCBqID0gQ3J5cHRvLkJFQ0gzMl9CQVNFMzJfQUxQSEFCRVQuaW5kZXhPZihjKTtcblx0XHRcdGlmIChqID09IC0xKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZGF0YS5wdXNoKGopO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNoa1N1bUEgPSBkYXRhLnNsaWNlKGRhdGEubGVuZ3RoIC0gNik7XG5cblx0XHRjb25zdCBjaGtTdW1CID0gQ3J5cHRvLmNhbGNCZWNoMzJDaGVja3N1bShocnAsIGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA2KSk7XG5cblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuXHRcdFx0aWYgKGNoa1N1bUFbal0gIT0gY2hrU3VtQltqXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBzaGEyLTI1NiAoMzJieXRlcykgaGFzaCBvZiBhIGxpc3Qgb2YgdWludDggbnVtYmVycy5cblx0ICogUmVzdWx0IGlzIGFsc28gYSBsaXN0IG9mIHVpbnQ4IG51bWJlci5cblx0ICogQGV4YW1wbGUgXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLnNoYTJfMjU2KFsweDYxLCAweDYyLCAweDYzXSkpID0+IFwiYmE3ODE2YmY4ZjAxY2ZlYTQxNDE0MGRlNWRhZTIyMjNiMDAzNjFhMzk2MTc3YTljYjQxMGZmNjFmMjAwMTVhZFwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIENyeXB0by5zaGEyXzI1Nih0ZXh0VG9CeXRlcyhcIkhlbGxvLCBXb3JsZCFcIikpID0+IFsyMjMsIDI1MywgOTYsIDMzLCAxODcsIDQzLCAyMTMsIDE3NiwgMTc1LCAxMDMsIDk4LCAxNDQsIDEyOCwgMTU4LCAxOTUsIDE2NSwgNDksIDE0NSwgMjIxLCAxMjksIDE5OSwgMjQ3LCAxMCwgNzUsIDQwLCAxMDQsIDEzOCwgNTQsIDMzLCAxMzAsIDE1MiwgMTExXVxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIC0gbGlzdCBvZiB1aW50OCBudW1iZXJzXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX0gLSBsaXN0IG9mIHVpbnQ4IG51bWJlcnNcblx0ICovXG5cdHN0YXRpYyBzaGEyXzI1NihieXRlcykge1xuXHRcdC8qKlxuXHRcdCAqIFBhZCBhIGJ5dGVhcnJheSBzbyBpdHMgc2l6ZSBpcyBhIG11bHRpcGxlIG9mIDY0ICg1MTIgYml0cykuXG5cdFx0ICogSW50ZXJuYWwgbWV0aG9kLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyW119IHNyYyAtIGxpc3Qgb2YgdWludDggbnVtYmVyc1xuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwYWQoc3JjKSB7XG5cdFx0XHRjb25zdCBuQml0cyA9IHNyYy5sZW5ndGgqODtcblxuXHRcdFx0Y29uc3QgZHN0ID0gc3JjLnNsaWNlKCk7XG5cblx0XHRcdGRzdC5wdXNoKDB4ODApO1xuXG5cdFx0XHRsZXQgblplcm9lcyA9ICg2NCAtIGRzdC5sZW5ndGglNjQpIC0gODtcblx0XHRcdGlmIChuWmVyb2VzIDwgMCkge1xuXHRcdFx0XHRuWmVyb2VzICs9IDY0O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5aZXJvZXM7IGkrKykge1xuXHRcdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXNzdW1lIG5CaXRzIGZpdHMgaW4gMzIgYml0c1xuXG5cdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdGRzdC5wdXNoKDApO1xuXHRcdFx0ZHN0LnB1c2goMCk7XG5cdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdGRzdC5wdXNoKGltb2Q4KG5CaXRzID4+IDI0KSk7XG5cdFx0XHRkc3QucHVzaChpbW9kOChuQml0cyA+PiAxNikpO1xuXHRcdFx0ZHN0LnB1c2goaW1vZDgobkJpdHMgPj4gOCkpO1xuXHRcdFx0ZHN0LnB1c2goaW1vZDgobkJpdHMgPj4gMCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZHN0O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJbXX0gLSA2NCB1aW50MzIgbnVtYmVyc1xuXHRcdCAqL1xuXHRcdGNvbnN0IGsgPSBbXG5cdFx0XHQweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuXHRcdFx0MHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcblx0XHRcdDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG5cdFx0XHQweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuXHRcdFx0MHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcblx0XHRcdDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG5cdFx0XHQweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuXHRcdFx0MHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2Nyxcblx0XHRcdDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG5cdFx0XHQweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuXHRcdFx0MHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcblx0XHRcdDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG5cdFx0XHQweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuXHRcdFx0MHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcblx0XHRcdDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG5cdFx0XHQweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyLFxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsIGhhc2ggKHVwZGF0ZWQgZHVyaW5nIGNvbXByZXNzaW9uIHBoYXNlKVxuXHRcdCAqIEB0eXBlIHtudW1iZXJbXX0gLSA4IHVpbnQzMiBudW1iZXJcblx0XHQgKi9cblx0XHRjb25zdCBoYXNoID0gW1xuXHRcdFx0MHg2YTA5ZTY2NywgXG5cdFx0XHQweGJiNjdhZTg1LCBcblx0XHRcdDB4M2M2ZWYzNzIsIFxuXHRcdFx0MHhhNTRmZjUzYSwgXG5cdFx0XHQweDUxMGU1MjdmLCBcblx0XHRcdDB4OWIwNTY4OGMsIFxuXHRcdFx0MHgxZjgzZDlhYiwgXG5cdFx0XHQweDViZTBjZDE5LFxuXHRcdF07XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSB4XG5cdFx0ICogQHJldHVybnMge251bWJlcn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzaWdtYTAoeCkge1xuXHRcdFx0cmV0dXJuIGlyb3RyKHgsIDcpIF4gaXJvdHIoeCwgMTgpIF4gKHggPj4+IDMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSB4XG5cdFx0ICogQHJldHVybnMge251bWJlcn1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzaWdtYTEoeCkge1xuXHRcdFx0cmV0dXJuIGlyb3RyKHgsIDE3KSBeIGlyb3RyKHgsIDE5KSBeICh4ID4+PiAxMCk7XG5cdFx0fVxuXG5cdFx0Ynl0ZXMgPSBwYWQoYnl0ZXMpO1xuXG5cdFx0Ly8gYnJlYWsgbWVzc2FnZSBpbiBzdWNjZXNzaXZlIDY0IGJ5dGUgY2h1bmtzXG5cdFx0Zm9yIChsZXQgY2h1bmtTdGFydCA9IDA7IGNodW5rU3RhcnQgPCBieXRlcy5sZW5ndGg7IGNodW5rU3RhcnQgKz0gNjQpIHtcblx0XHRcdGNvbnN0IGNodW5rID0gYnl0ZXMuc2xpY2UoY2h1bmtTdGFydCwgY2h1bmtTdGFydCArIDY0KTtcblxuXHRcdFx0Y29uc3QgdyA9IChuZXcgQXJyYXkoNjQpKS5maWxsKDApOyAvLyBhcnJheSBvZiAzMiBiaXQgbnVtYmVycyFcblxuXHRcdFx0Ly8gY29weSBjaHVuayBpbnRvIGZpcnN0IDE2IHBvc2l0aW9ucyBvZiB3XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0XHRcdFx0d1tpXSA9IChjaHVua1tpKjQgKyAwXSA8PCAyNCkgfFxuXHRcdFx0XHRcdCAgIChjaHVua1tpKjQgKyAxXSA8PCAxNikgfFxuXHRcdFx0XHRcdCAgIChjaHVua1tpKjQgKyAyXSA8PCAgOCkgfFxuXHRcdFx0XHRcdCAgIChjaHVua1tpKjQgKyAzXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4dGVuZHMgdGhlIGZpcnN0IDE2IHBvc2l0aW9ucyBpbnRvIHRoZSByZW1haW5pbmcgNDggcG9zaXRpb25zXG5cdFx0XHRmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG5cdFx0XHRcdHdbaV0gPSBpbW9kMzIod1tpLTE2XSArIHNpZ21hMCh3W2ktMTVdKSArIHdbaS03XSArIHNpZ21hMSh3W2ktMl0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW50aWFsaXplIHdvcmtpbmcgdmFyaWFibGVzIHRvIGN1cnJlbnQgaGFzaCB2YWx1ZVxuXHRcdFx0bGV0IGEgPSBoYXNoWzBdO1xuXHRcdFx0bGV0IGIgPSBoYXNoWzFdO1xuXHRcdFx0bGV0IGMgPSBoYXNoWzJdO1xuXHRcdFx0bGV0IGQgPSBoYXNoWzNdO1xuXHRcdFx0bGV0IGUgPSBoYXNoWzRdO1xuXHRcdFx0bGV0IGYgPSBoYXNoWzVdO1xuXHRcdFx0bGV0IGcgPSBoYXNoWzZdO1xuXHRcdFx0bGV0IGggPSBoYXNoWzddO1xuXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3Bcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBTMSA9IGlyb3RyKGUsIDYpIF4gaXJvdHIoZSwgMTEpIF4gaXJvdHIoZSwgMjUpO1xuXHRcdFx0XHRjb25zdCBjaCA9IChlICYgZikgXiAoKH5lKSAmIGcpO1xuXHRcdFx0XHRjb25zdCB0ZW1wMSA9IGltb2QzMihoICsgUzEgKyBjaCArIGtbaV0gKyB3W2ldKTtcblx0XHRcdFx0Y29uc3QgUzAgPSBpcm90cihhLCAyKSBeIGlyb3RyKGEsIDEzKSBeIGlyb3RyKGEsIDIyKTtcblx0XHRcdFx0Y29uc3QgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXHRcdFx0XHRjb25zdCB0ZW1wMiA9IGltb2QzMihTMCArIG1haik7XG5cblx0XHRcdFx0aCA9IGc7XG5cdFx0XHRcdGcgPSBmO1xuXHRcdFx0XHRmID0gZTtcblx0XHRcdFx0ZSA9IGltb2QzMihkICsgdGVtcDEpO1xuXHRcdFx0XHRkID0gYztcblx0XHRcdFx0YyA9IGI7XG5cdFx0XHRcdGIgPSBhO1xuXHRcdFx0XHRhID0gaW1vZDMyKHRlbXAxICsgdGVtcDIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGhhc2hcblx0XHRcdGhhc2hbMF0gPSBpbW9kMzIoaGFzaFswXSArIGEpO1xuXHRcdFx0aGFzaFsxXSA9IGltb2QzMihoYXNoWzFdICsgYik7XG5cdFx0XHRoYXNoWzJdID0gaW1vZDMyKGhhc2hbMl0gKyBjKTtcblx0XHRcdGhhc2hbM10gPSBpbW9kMzIoaGFzaFszXSArIGQpO1xuXHRcdFx0aGFzaFs0XSA9IGltb2QzMihoYXNoWzRdICsgZSk7XG5cdFx0XHRoYXNoWzVdID0gaW1vZDMyKGhhc2hbNV0gKyBmKTtcblx0XHRcdGhhc2hbNl0gPSBpbW9kMzIoaGFzaFs2XSArIGcpO1xuXHRcdFx0aGFzaFs3XSA9IGltb2QzMihoYXNoWzddICsgaCk7XG5cdFx0fVxuXG5cdFx0Ly8gcHJvZHVjZSB0aGUgZmluYWwgZGlnZXN0IG9mIHVpbnQ4IG51bWJlcnNcblx0XHRjb25zdCByZXN1bHQgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGhhc2hbaV07XG5cblx0XHRcdHJlc3VsdC5wdXNoKGltb2Q4KGl0ZW0gPj4gMjQpKTtcblx0XHRcdHJlc3VsdC5wdXNoKGltb2Q4KGl0ZW0gPj4gMTYpKTtcblx0XHRcdHJlc3VsdC5wdXNoKGltb2Q4KGl0ZW0gPj4gIDgpKTtcblx0XHRcdHJlc3VsdC5wdXNoKGltb2Q4KGl0ZW0gPj4gIDApKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBzaGEyLTUxMiAoNjRieXRlcykgaGFzaCBvZiBhIGxpc3Qgb2YgdWludDggbnVtYmVycy5cblx0ICogUmVzdWx0IGlzIGFsc28gYSBsaXN0IG9mIHVpbnQ4IG51bWJlci5cblx0ICogQGV4YW1wbGUgXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLnNoYTJfNTEyKFsweDYxLCAweDYyLCAweDYzXSkpID0+IFwiZGRhZjM1YTE5MzYxN2FiYWNjNDE3MzQ5YWUyMDQxMzExMmU2ZmE0ZTg5YTk3ZWEyMGE5ZWVlZTY0YjU1ZDM5YTIxOTI5OTJhMjc0ZmMxYTgzNmJhM2MyM2EzZmVlYmJkNDU0ZDQ0MjM2NDNjZTgwZTJhOWFjOTRmYTU0Y2E0OWZcIlxuXHQgKiBAZXhhbXBsZSBcblx0ICogYnl0ZXNUb0hleChDcnlwdG8uc2hhMl81MTIoW10pKSA9PiBcImNmODNlMTM1N2VlZmI4YmRmMTU0Mjg1MGQ2NmQ4MDA3ZDYyMGU0MDUwYjU3MTVkYzgzZjRhOTIxZDM2Y2U5Y2U0N2QwZDEzYzVkODVmMmIwZmY4MzE4ZDI4NzdlZWMyZjYzYjkzMWJkNDc0MTdhODFhNTM4MzI3YWY5MjdkYTNlXCJcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyAtIGxpc3Qgb2YgdWludDggbnVtYmVyc1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gbGlzdCBvZiB1aW50OCBudW1iZXJzXG5cdCAqL1xuXHRzdGF0aWMgc2hhMl81MTIoYnl0ZXMpIHtcblx0XHQvKipcblx0XHQgKiBQYWQgYSBieXRlYXJyYXkgc28gaXRzIHNpemUgaXMgYSBtdWx0aXBsZSBvZiAxMjggKDEwMjQgYml0cykuXG5cdFx0ICogSW50ZXJuYWwgbWV0aG9kLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyW119IHNyYyAtIGxpc3Qgb2YgdWludDggbnVtYmVyc1xuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwYWQoc3JjKSB7XG5cdFx0XHRjb25zdCBuQml0cyA9IHNyYy5sZW5ndGgqODtcblxuXHRcdFx0Y29uc3QgZHN0ID0gc3JjLnNsaWNlKCk7XG5cblx0XHRcdGRzdC5wdXNoKDB4ODApO1xuXG5cdFx0XHRsZXQgblplcm9lcyA9ICgxMjggLSBkc3QubGVuZ3RoJTEyOCkgLSA4O1xuXHRcdFx0aWYgKG5aZXJvZXMgPCAwKSB7XG5cdFx0XHRcdG5aZXJvZXMgKz0gMTI4O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5aZXJvZXM7IGkrKykge1xuXHRcdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXNzdW1lIG5CaXRzIGZpdHMgaW4gMzIgYml0c1xuXG5cdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdGRzdC5wdXNoKDApO1xuXHRcdFx0ZHN0LnB1c2goMCk7XG5cdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdGRzdC5wdXNoKGltb2Q4KG5CaXRzID4+IDI0KSk7XG5cdFx0XHRkc3QucHVzaChpbW9kOChuQml0cyA+PiAxNikpO1xuXHRcdFx0ZHN0LnB1c2goaW1vZDgobkJpdHMgPj4gOCkpO1xuXHRcdFx0ZHN0LnB1c2goaW1vZDgobkJpdHMgPj4gMCkpO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZHN0O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtVSW50NjRbXX0gLSA4MCB1aW50NjQgbnVtYmVyc1xuXHRcdCAqL1xuXHRcdGNvbnN0IGsgPSBbXG5cdFx0XHRuZXcgVUludDY0KDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIpLCBuZXcgVUludDY0KDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksIG5ldyBVSW50NjQoMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyksXG5cdFx0XHRuZXcgVUludDY0KDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgpLCBuZXcgVUludDY0KDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg5MjNmODJhNCwgMHhhZjE5NGY5YiksIG5ldyBVSW50NjQoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG5cdFx0XHRuZXcgVUludDY0KDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLCBuZXcgVUludDY0KDB4MTI4MzViMDEsIDB4NDU3MDZmYmUpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksIG5ldyBVSW50NjQoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG5cdFx0XHRuZXcgVUludDY0KDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYpLCBuZXcgVUludDY0KDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksIG5ldyBVSW50NjQoMHhjMTliZjE3NCwgMHhjZjY5MjY5NCksXG5cdFx0XHRuZXcgVUludDY0KDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIpLCBuZXcgVUludDY0KDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgwZmMxOWRjNiwgMHg4YjhjZDViNSksIG5ldyBVSW50NjQoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG5cdFx0XHRuZXcgVUludDY0KDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLCBuZXcgVUludDY0KDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksIG5ldyBVSW50NjQoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG5cdFx0XHRuZXcgVUludDY0KDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIpLCBuZXcgVUludDY0KDB4YTgzMWM2NmQsIDB4MmRiNDMyMTApLCBcblx0XHRcdG5ldyBVSW50NjQoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksIG5ldyBVSW50NjQoMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCksXG5cdFx0XHRuZXcgVUludDY0KDB4YzZlMDBiZjMsIDB4M2RhODhmYzIpLCBuZXcgVUludDY0KDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiksIG5ldyBVSW50NjQoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG5cdFx0XHRuZXcgVUludDY0KDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLCBuZXcgVUludDY0KDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksIG5ldyBVSW50NjQoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG5cdFx0XHRuZXcgVUludDY0KDB4NjUwYTczNTQsIDB4OGJhZjYzZGUpLCBuZXcgVUludDY0KDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksIG5ldyBVSW50NjQoMHg5MjcyMmM4NSwgMHgxNDgyMzUzYiksXG5cdFx0XHRuZXcgVUludDY0KDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQpLCBuZXcgVUludDY0KDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSksIG5ldyBVSW50NjQoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG5cdFx0XHRuZXcgVUludDY0KDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLCBuZXcgVUludDY0KDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTApLCBcblx0XHRcdG5ldyBVSW50NjQoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksIG5ldyBVSW50NjQoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG5cdFx0XHRuZXcgVUludDY0KDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgpLCBuZXcgVUludDY0KDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksIG5ldyBVSW50NjQoMHgzNGIwYmNiNSwgMHhlMTliNDhhOCksXG5cdFx0XHRuZXcgVUludDY0KDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMpLCBuZXcgVUludDY0KDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg1YjljY2E0ZiwgMHg3NzYzZTM3MyksIG5ldyBVSW50NjQoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG5cdFx0XHRuZXcgVUludDY0KDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLCBuZXcgVUludDY0KDB4NzhhNTYzNmYsIDB4NDMxNzJmNjApLCBcblx0XHRcdG5ldyBVSW50NjQoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksIG5ldyBVSW50NjQoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG5cdFx0XHRuZXcgVUludDY0KDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgpLCBuZXcgVUludDY0KDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTkpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksIG5ldyBVSW50NjQoMHhjNjcxNzhmMiwgMHhlMzcyNTMyYiksXG5cdFx0XHRuZXcgVUludDY0KDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMpLCBuZXcgVUludDY0KDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSksIG5ldyBVSW50NjQoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG5cdFx0XHRuZXcgVUludDY0KDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLCBuZXcgVUludDY0KDB4MGE2MzdkYzUsIDB4YTJjODk4YTYpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksIG5ldyBVSW50NjQoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG5cdFx0XHRuZXcgVUludDY0KDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQpLCBuZXcgVUludDY0KDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMpLCBcblx0XHRcdG5ldyBVSW50NjQoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksIG5ldyBVSW50NjQoMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyksXG5cdFx0XHRuZXcgVUludDY0KDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYpLCBuZXcgVUludDY0KDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLCBcblx0XHRcdG5ldyBVSW50NjQoMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYyksIG5ldyBVSW50NjQoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNyksXG5cdFx0XTtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWwgaGFzaCAodXBkYXRlZCBkdXJpbmcgY29tcHJlc3Npb24gcGhhc2UpXG5cdFx0ICogQHR5cGUge1VJbnQ2NFtdfSAtIDggdWludDY0IG51bWJlcnNcblx0XHQgKi9cblx0XHRjb25zdCBoYXNoID0gW1xuXHRcdFx0bmV3IFVJbnQ2NCgweDZhMDllNjY3LCAweGYzYmNjOTA4KSxcblx0XHRcdG5ldyBVSW50NjQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksXG5cdFx0XHRuZXcgVUludDY0KDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIpLFxuXHRcdFx0bmV3IFVJbnQ2NCgweGE1NGZmNTNhLCAweDVmMWQzNmYxKSxcblx0XHRcdG5ldyBVSW50NjQoMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSksXG5cdFx0XHRuZXcgVUludDY0KDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYpLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDFmODNkOWFiLCAweGZiNDFiZDZiKSxcblx0XHRcdG5ldyBVSW50NjQoMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSksXG5cdFx0XTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtVSW50NjR9IHhcblx0XHQgKiBAcmV0dXJucyB7VUludDY0fSBcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzaWdtYTAoeCkge1xuXHRcdFx0cmV0dXJuIHgucm90cigxKS54b3IoeC5yb3RyKDgpKS54b3IoeC5zaGlmdHIoNykpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7VUludDY0fSB4XG5cdFx0ICogQHJldHVybnMge1VJbnQ2NH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzaWdtYTEoeCkge1xuXHRcdFx0cmV0dXJuIHgucm90cigxOSkueG9yKHgucm90cig2MSkpLnhvcih4LnNoaWZ0cig2KSk7XG5cdFx0fVxuXG5cdFx0Ynl0ZXMgPSBwYWQoYnl0ZXMpO1xuXG5cdFx0Ly8gYnJlYWsgbWVzc2FnZSBpbiBzdWNjZXNzaXZlIDY0IGJ5dGUgY2h1bmtzXG5cdFx0Zm9yIChsZXQgY2h1bmtTdGFydCA9IDA7IGNodW5rU3RhcnQgPCBieXRlcy5sZW5ndGg7IGNodW5rU3RhcnQgKz0gMTI4KSB7XG5cdFx0XHRjb25zdCBjaHVuayA9IGJ5dGVzLnNsaWNlKGNodW5rU3RhcnQsIGNodW5rU3RhcnQgKyAxMjgpO1xuXG5cdFx0XHRjb25zdCB3ID0gKG5ldyBBcnJheSg4MCkpLmZpbGwoVUludDY0Lnplcm8oKSk7IC8vIGFycmF5IG9mIDMyIGJpdCBudW1iZXJzIVxuXG5cdFx0XHQvLyBjb3B5IGNodW5rIGludG8gZmlyc3QgMTYgaGkvbG8gcG9zaXRpb25zIG9mIHcgKGkuZS4gaW50byBmaXJzdCAzMiB1aW50MzIgcG9zaXRpb25zKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdFx0XHRcdHdbaV0gPSBVSW50NjQuZnJvbUJ5dGVzKGNodW5rLnNsaWNlKGkqOCwgaSo4ICsgOCksIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXh0ZW5kcyB0aGUgZmlyc3QgMTYgcG9zaXRpb25zIGludG8gdGhlIHJlbWFpbmluZyA4MCBwb3NpdGlvbnNcblx0XHRcdGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcblx0XHRcdFx0d1tpXSA9IHNpZ21hMSh3W2ktMl0pLmFkZCh3W2ktN10pLmFkZChzaWdtYTAod1tpLTE1XSkpLmFkZCh3W2ktMTZdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaW50aWFsaXplIHdvcmtpbmcgdmFyaWFibGVzIHRvIGN1cnJlbnQgaGFzaCB2YWx1ZVxuXHRcdFx0bGV0IGEgPSBoYXNoWzBdO1xuXHRcdFx0bGV0IGIgPSBoYXNoWzFdO1xuXHRcdFx0bGV0IGMgPSBoYXNoWzJdO1xuXHRcdFx0bGV0IGQgPSBoYXNoWzNdO1xuXHRcdFx0bGV0IGUgPSBoYXNoWzRdO1xuXHRcdFx0bGV0IGYgPSBoYXNoWzVdO1xuXHRcdFx0bGV0IGcgPSBoYXNoWzZdO1xuXHRcdFx0bGV0IGggPSBoYXNoWzddO1xuXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3Bcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHRcdFx0XHRjb25zdCBTMSA9IGUucm90cigxNCkueG9yKGUucm90cigxOCkpLnhvcihlLnJvdHIoNDEpKTtcblx0XHRcdFx0Y29uc3QgY2ggPSBlLmFuZChmKS54b3IoZS5ub3QoKS5hbmQoZykpO1xuXHRcdFx0XHRjb25zdCB0ZW1wMSA9IGguYWRkKFMxKS5hZGQoY2gpLmFkZChrW2ldKS5hZGQod1tpXSk7XG5cdFx0XHRcdGNvbnN0IFMwID0gYS5yb3RyKDI4KS54b3IoYS5yb3RyKDM0KSkueG9yKGEucm90cigzOSkpO1xuXHRcdFx0XHRjb25zdCBtYWogPSBhLmFuZChiKS54b3IoYS5hbmQoYykpLnhvcihiLmFuZChjKSk7XG5cdFx0XHRcdGNvbnN0IHRlbXAyID0gUzAuYWRkKG1haik7XG5cblx0XHRcdFx0aCA9IGc7XG5cdFx0XHRcdGcgPSBmO1xuXHRcdFx0XHRmID0gZTtcblx0XHRcdFx0ZSA9IGQuYWRkKHRlbXAxKTtcblx0XHRcdFx0ZCA9IGM7XG5cdFx0XHRcdGMgPSBiO1xuXHRcdFx0XHRiID0gYTtcblx0XHRcdFx0YSA9IHRlbXAxLmFkZCh0ZW1wMik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgaGFzaFxuXHRcdFx0aGFzaFswXSA9IGhhc2hbMF0uYWRkKGEpO1xuXHRcdFx0aGFzaFsxXSA9IGhhc2hbMV0uYWRkKGIpO1xuXHRcdFx0aGFzaFsyXSA9IGhhc2hbMl0uYWRkKGMpO1xuXHRcdFx0aGFzaFszXSA9IGhhc2hbM10uYWRkKGQpO1xuXHRcdFx0aGFzaFs0XSA9IGhhc2hbNF0uYWRkKGUpO1xuXHRcdFx0aGFzaFs1XSA9IGhhc2hbNV0uYWRkKGYpO1xuXHRcdFx0aGFzaFs2XSA9IGhhc2hbNl0uYWRkKGcpO1xuXHRcdFx0aGFzaFs3XSA9IGhhc2hbN10uYWRkKGgpO1xuXHRcdH1cblxuXHRcdC8vIHByb2R1Y2UgdGhlIGZpbmFsIGRpZ2VzdCBvZiB1aW50OCBudW1iZXJzXG5cdFx0bGV0IHJlc3VsdCA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gaGFzaFtpXTtcblxuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNvbmNhdChpdGVtLnRvQnl0ZXMoZmFsc2UpKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBzaGEzLTI1NiAoMzJieXRlcykgaGFzaCBvZiBhIGxpc3Qgb2YgdWludDggbnVtYmVycy5cblx0ICogUmVzdWx0IGlzIGFsc28gYSBsaXN0IG9mIHVpbnQ4IG51bWJlci5cblx0ICogU2hhMyBvbmx5IGJpdC13aXNlIG9wZXJhdGlvbnMsIHNvIDY0LWJpdCBvcGVyYXRpb25zIGNhbiBlYXNpbHkgYmUgcmVwbGljYXRlZCB1c2luZyAyIDMyLWJpdCBvcGVyYXRpb25zIGluc3RlYWRcblx0ICogQGV4YW1wbGVcblx0ICogYnl0ZXNUb0hleChDcnlwdG8uc2hhMyh0ZXh0VG9CeXRlcyhcImFiY1wiKSkpID0+IFwiM2E5ODVkYTc0ZmUyMjViMjA0NWMxNzJkNmJkMzkwYmQ4NTVmMDg2ZTNlOWQ1MjViNDZiZmUyNDUxMTQzMTUzMlwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLnNoYTMoKG5ldyBBcnJheSgxMzYpKS5maWxsKDEpKSkgPT4gXCJiMzZkYzIxNjdjNGQ5ZGRhMWE1OGI4NzA0NmM4ZDc2YTYzNTlhZmUzNjEyYzRkZThhMzg4NTdlMDkxMTdiMmRiXCJcblx0ICogQGV4YW1wbGVcblx0ICogYnl0ZXNUb0hleChDcnlwdG8uc2hhMygobmV3IEFycmF5KDEzNSkpLmZpbGwoMikpKSA9PiBcIjViZGY1ZDgxNWQyOWE5ZDcxNjFjNjY1MjBlZmMxN2MyZWRkNzg5OGYyYjk5YTAyOWU4ZDJlNGZmMTUzNDA3ZjRcIlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBieXRlc1RvSGV4KENyeXB0by5zaGEzKChuZXcgQXJyYXkoMTM0KSkuZmlsbCgzKSkpID0+IFwiOGU2NTc1NjYzZGZiNzVhODhmOTRhMzJjNWIzNjNjNDEwMjc4YjY1MDIwNzM0NTYwZDk2OGFhZGQ2ODk2YTYyMVwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLnNoYTMoKG5ldyBBcnJheSgxMzcpKS5maWxsKDQpKSkgPT4gXCJmMTBiMzljM2U0NTUwMDZhYTQyMTIwYjk3NTFmYWEwZjM1YzgyMTIxMWM5ZDA4NmJlYjI4YmYzYzQxMzRjNmM2XCJcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyAtIGxpc3Qgb2YgdWludDggbnVtYmVyc1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gbGlzdCBvZiB1aW50OCBudW1iZXJzXG5cdCAqL1xuXHRzdGF0aWMgc2hhMyhieXRlcykge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJ9IC0gc3RhdGUgd2lkdGggKDE2MDAgYml0cywgKVxuXHRcdCAqL1xuXHRcdGNvbnN0IFdJRFRIID0gMjAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge251bWJlcn0gLSByYXRlICgxMDg4IGJpdHMsIDEzNiBieXRlcylcblx0XHQgKi9cblx0XHRjb25zdCBSQVRFID0gMTM2O1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge251bWJlcn0gLSBjYXBhY2l0eVxuXHRcdCAqL1xuXHRcdGNvbnN0IENBUCA9IFdJRFRIIC0gUkFURTtcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IDEwMDAuLi4xIHBhZGRpbmcgdW50aWwgc2l6ZSBpcyBtdWx0aXBsZSBvZiByLlxuXHRcdCAqIElmIGFscmVhZHkgbXVsdGlwbGUgb2YgciB0aGVuIGFkZCBhIHdob2xlIGJsb2NrIG9mIHBhZGRpbmcuXG5cdFx0ICogQHBhcmFtIHtudW1iZXJbXX0gc3JjIC0gbGlzdCBvZiB1aW50OCBudW1iZXJzXG5cdFx0ICogQHJldHVybnMge251bWJlcltdfSAtIGxpc3Qgb2YgdWludDggbnVtYmVyc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHBhZChzcmMpIHtcblx0XHRcdGNvbnN0IGRzdCA9IHNyYy5zbGljZSgpO1xuXG5cdFx0XHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0XHRcdGxldCBuWmVyb2VzID0gUkFURSAtIDIgLSAoZHN0Lmxlbmd0aCVSQVRFKTtcblx0XHRcdGlmIChuWmVyb2VzIDwgLTEpIHtcblx0XHRcdFx0blplcm9lcyArPSBSQVRFIC0gMjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5aZXJvZXMgPT0gLTEpIHtcblx0XHRcdFx0ZHN0LnB1c2goMHg4Nik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkc3QucHVzaCgweDA2KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5aZXJvZXM7IGkrKykge1xuXHRcdFx0XHRcdGRzdC5wdXNoKDApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZHN0LnB1c2goMHg4MCk7XG5cdFx0XHR9XG5cblx0XHRcdGFzc2VydChkc3QubGVuZ3RoJVJBVEUgPT0gMCk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBkc3Q7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogMjQgbnVtYmVycyB1c2VkIGluIHRoZSBzaGEzIHBlcm11dGUgZnVuY3Rpb25cblx0XHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdFx0ICovXG5cdFx0Y29uc3QgT0ZGU0VUUyA9IFs2LCAxMiwgMTgsIDI0LCAzLCA5LCAxMCwgMTYsIDIyLCAxLCA3LCAxMywgMTksIDIwLCA0LCA1LCAxMSwgMTcsIDIzLCAyLCA4LCAxNCwgMTUsIDIxXTtcblxuXHRcdC8qKlxuXHRcdCAqIDI0IG51bWJlcnMgdXNlZCBpbiB0aGUgc2hhMyBwZXJtdXRlIGZ1bmN0aW9uXG5cdFx0ICogQHR5cGUge251bWJlcltdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IFNISUZUUyA9IFstMTIsIC0xMSwgMjEsIDE0LCAyOCwgMjAsIDMsIC0xMywgLTI5LCAxLCA2LCAyNSwgOCwgMTgsIDI3LCAtNCwgMTAsIDE1LCAtMjQsIC0zMCwgLTIzLCAtNywgLTksIDJdO1xuXG5cdFx0LyoqXG5cdFx0ICogUm91bmQgY29uc3RhbnRzIHVzZWQgaW4gdGhlIHNoYTMgcGVybXV0ZSBmdW5jdGlvblxuXHRcdCAqIEB0eXBlIHtVSW50NjRbXX0gXG5cdFx0ICovXG5cdFx0Y29uc3QgUkMgPSBbXG5cdFx0XHRuZXcgVUludDY0KDB4MDAwMDAwMDAsIDB4MDAwMDAwMDEpICwgXG5cdFx0XHRuZXcgVUludDY0KDB4MDAwMDAwMDAsIDB4MDAwMDgwODIpICwgXG5cdFx0XHRuZXcgVUludDY0KDB4ODAwMDAwMDAsIDB4MDAwMDgwOGEpICxcblx0XHRcdG5ldyBVSW50NjQoMHg4MDAwMDAwMCwgMHg4MDAwODAwMCkgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDAwMDAwMDAwLCAweDAwMDA4MDhiKSAsXG5cdFx0XHRuZXcgVUludDY0KDB4MDAwMDAwMDAsIDB4ODAwMDAwMDEpICxcblx0XHRcdG5ldyBVSW50NjQoMHg4MDAwMDAwMCwgMHg4MDAwODA4MSkgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDgwMDAwMDAwLCAweDAwMDA4MDA5KSAsXG5cdFx0XHRuZXcgVUludDY0KDB4MDAwMDAwMDAsIDB4MDAwMDAwOGEpICxcblx0XHRcdG5ldyBVSW50NjQoMHgwMDAwMDAwMCwgMHgwMDAwMDA4OCkgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDAwMDAwMDAwLCAweDgwMDA4MDA5KSAsXG5cdFx0XHRuZXcgVUludDY0KDB4MDAwMDAwMDAsIDB4ODAwMDAwMGEpICxcblx0XHRcdG5ldyBVSW50NjQoMHgwMDAwMDAwMCwgMHg4MDAwODA4YikgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDgwMDAwMDAwLCAweDAwMDAwMDhiKSAsXG5cdFx0XHRuZXcgVUludDY0KDB4ODAwMDAwMDAsIDB4MDAwMDgwODkpICxcblx0XHRcdG5ldyBVSW50NjQoMHg4MDAwMDAwMCwgMHgwMDAwODAwMykgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDgwMDAwMDAwLCAweDAwMDA4MDAyKSAsXG5cdFx0XHRuZXcgVUludDY0KDB4ODAwMDAwMDAsIDB4MDAwMDAwODApICxcblx0XHRcdG5ldyBVSW50NjQoMHgwMDAwMDAwMCwgMHgwMDAwODAwYSkgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDgwMDAwMDAwLCAweDgwMDAwMDBhKSAsXG5cdFx0XHRuZXcgVUludDY0KDB4ODAwMDAwMDAsIDB4ODAwMDgwODEpICxcblx0XHRcdG5ldyBVSW50NjQoMHg4MDAwMDAwMCwgMHgwMDAwODA4MCkgLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDAwMDAwMDAwLCAweDgwMDAwMDAxKSAsXG5cdFx0XHRuZXcgVUludDY0KDB4ODAwMDAwMDAsIDB4ODAwMDgwMDgpICxcblx0XHRdO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7VUludDY0W119IHMgXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcGVybXV0ZShzKSB7XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge1VJbnQ2NFtdfVxuXHRcdFx0ICovXHRcdFxuXHRcdFx0Y29uc3QgYyA9IG5ldyBBcnJheSg1KTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdHlwZSB7VUludDY0W119XG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGIgPSBuZXcgQXJyYXkoMjUpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0XHRcdFx0XHRjW2ldID0gc1tpXS54b3Ioc1tpKzVdKS54b3Ioc1tpKzEwXSkueG9yKHNbaSsxNV0pLnhvcihzW2krMjBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaTEgPSAoaSsxKSU1O1xuXHRcdFx0XHRcdGNvbnN0IGkyID0gKGkrNCklNTtcblxuXHRcdFx0XHRcdGNvbnN0IHRtcCA9IGNbaTJdLnhvcihjW2kxXS5yb3RyKDYzKSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDU7IGorKykge1xuXHRcdFx0XHRcdFx0c1tpKzUqal0gPSBzW2krNSpqXS54b3IodG1wKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cdFx0XHRcdFxuXG5cdFx0XHRcdGJbMF0gPSBzWzBdO1xuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDE7IGkgPCAyNTsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUU1tpLTFdO1xuXG5cdFx0XHRcdFx0Y29uc3QgbGVmdCA9IE1hdGguYWJzKFNISUZUU1tpLTFdKTtcblx0XHRcdFx0XHRjb25zdCByaWdodCA9IDMyIC0gbGVmdDtcblxuXHRcdFx0XHRcdGlmIChTSElGVFNbaS0xXSA8IDApIHtcblx0XHRcdFx0XHRcdGJbaV0gPSBzW29mZnNldF0ucm90cihyaWdodCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJbaV0gPSBzW29mZnNldF0ucm90cihyaWdodCArIDMyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgNTsgaisrKSB7XG5cdFx0XHRcdFx0XHRzW2kqNStqXSA9IGJbaSo1K2pdLnhvcihiW2kqNSArIChqKzEpJTVdLm5vdCgpLmFuZChiW2kqNSArIChqKzIpJTVdKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzWzBdID0gc1swXS54b3IoUkNbcm91bmRdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRieXRlcyA9IHBhZChieXRlcyk7XG5cblx0XHQvLyBpbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtVSW50NjRbXX1cblx0XHQgKi9cblx0XHRjb25zdCBzdGF0ZSA9IChuZXcgQXJyYXkoV0lEVEgvOCkpLmZpbGwoVUludDY0Lnplcm8oKSk7XG5cblx0XHRmb3IgKGxldCBjaHVua1N0YXJ0ID0gMDsgY2h1bmtTdGFydCA8IGJ5dGVzLmxlbmd0aDsgY2h1bmtTdGFydCArPSBSQVRFKSB7XG5cdFx0XHQvLyBleHRlbmQgdGhlIGNodW5rIHRvIGJlY29tZSBsZW5ndGggV0lEVEhcblx0XHRcdGNvbnN0IGNodW5rID0gYnl0ZXMuc2xpY2UoY2h1bmtTdGFydCwgY2h1bmtTdGFydCArIFJBVEUpLmNvbmNhdCgobmV3IEFycmF5KENBUCkpLmZpbGwoMCkpO1xuXG5cdFx0XHQvLyBlbGVtZW50LXdpc2UgeG9yIHdpdGggJ3N0YXRlJ1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBXSURUSDsgaSArPSA4KSB7XG5cdFx0XHRcdHN0YXRlW2kvOF0gPSBzdGF0ZVtpLzhdLnhvcihVSW50NjQuZnJvbUJ5dGVzKGNodW5rLnNsaWNlKGksIGkrOCkpKTtcblxuXHRcdFx0XHQvLyBiZXdhcmU6IGEgdWludDMyIGlzIHN0b3JlZCBhcyBsaXR0bGUgZW5kaWFuLCBidXQgYSBwYWlyIG9mIHVpbnQzMnMgdGhhdCBmb3JtIGEgdWluNjQgYXJlIHN0b3JlZCBpbiBiaWcgZW5kaWFuIGZvcm1hdCFcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgYmxvY2sgcGVybXV0YXRpb25zXG5cdFx0XHRwZXJtdXRlKHN0YXRlKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge251bWJlcltdfSAqL1xuXHRcdGxldCBoYXNoID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdGhhc2ggPSBoYXNoLmNvbmNhdChzdGF0ZVtpXS50b0J5dGVzKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYmxha2UyYiBoYXNoIG9mIGEgbGlzdCBvZiB1aW50OCBudW1iZXJzICh2YXJpYWJsZSBkaWdlc3Qgc2l6ZSkuXG5cdCAqIFJlc3VsdCBpcyBhbHNvIGEgbGlzdCBvZiB1aW50OCBudW1iZXIuXG5cdCAqIEJsYWtlMmIgaXMgYSA2NGJpdCBhbGdvcml0aG0sIHNvIHdlIG5lZWQgdG8gYmUgY2FyZWZ1bCB3aGVuIHJlcGxpY2F0aW5nIDY0LWJpdCBvcGVyYXRpb25zIHdpdGggMiAzMi1iaXQgbnVtYmVycyAobG93LXdvcmQgb3ZlcmZsb3cgbXVzdCBzcGlsbCBpbnRvIGhpZ2gtd29yZCwgYW5kIHNoaWZ0cyBtdXN0IGdvIG92ZXIgbG93L2hpZ2ggYm91bmRhcnkpXG5cdCAqIEBleGFtcGxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHQgKiBieXRlc1RvSGV4KENyeXB0by5ibGFrZTJiKFswLCAxXSkpID0+IFwiMDFjZjc5ZGE0OTQ1YzM3MGM2OGIyNjVlZjcwNjQxYWFhNjVlYWE4ZjU5NTNlMzkwMGQ5NzcyNGMyYzVhYTA5NVwiXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ3J5cHRvLmJsYWtlMmIodGV4dFRvQnl0ZXMoXCJhYmNcIiksIDY0KSkgPT4gXCJiYTgwYTUzZjk4MWM0ZDBkNmEyNzk3YjY5ZjEyZjZlOTRjMjEyZjE0Njg1YWM0Yjc0YjEyYmI2ZmRiZmZhMmQxN2Q4N2M1MzkyYWFiNzkyZGMyNTJkNWRlNDUzM2NjOTUxOGQzOGFhOGRiZjE5MjVhYjkyMzg2ZWRkNDAwOTkyM1wiXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaWdlc3RTaXplIC0gYXQgbW9zdCA2NFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgYmxha2UyYihieXRlcywgZGlnZXN0U2l6ZSA9IEJMQUtFMkJfRElHRVNUX1NJWkUpIHtcblx0XHQvKipcblx0XHQgKiAxMjggYnl0ZXMgKDE2KjggYnl0ZSB3b3Jkcylcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdGNvbnN0IFdJRFRIID0gMTI4O1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gdmVjdG9yXG5cdFx0ICovXG5cdFx0Y29uc3QgSVYgPSBbXG5cdFx0XHRuZXcgVUludDY0KDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksXG5cdFx0XHRuZXcgVUludDY0KDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIpLCBcblx0XHRcdG5ldyBVSW50NjQoMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSksXG5cdFx0XHRuZXcgVUludDY0KDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEpLFxuXHRcdFx0bmV3IFVJbnQ2NCgweDliMDU2ODhjLCAweDJiM2U2YzFmKSxcblx0XHRcdG5ldyBVSW50NjQoMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiksIFxuXHRcdFx0bmV3IFVJbnQ2NCgweDViZTBjZDE5LCAweDEzN2UyMTc5KSwgXG5cdFx0XTtcblxuXHRcdGNvbnN0IFNJR01BID0gW1xuXHRcdFx0WzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdLFxuXHRcdFx0WzE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNdLFxuXHRcdFx0WzExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDRdLFxuXHRcdFx0WzcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDhdLFxuXHRcdFx0WzksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTNdLFxuXHRcdFx0WzIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDldLFxuXHRcdFx0WzEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTFdLFxuXHRcdFx0WzEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTBdLFxuXHRcdFx0WzYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDVdLFxuXHRcdFx0WzEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDBdLFxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBzcmMgLSBsaXN0IG9mIHVpbnQ4IGJ5dGVzXG5cdFx0ICogQHJldHVybnMge251bWJlcltdfSAtIGxpc3Qgb2YgdWludDggYnl0ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwYWQoc3JjKSB7XG5cdFx0XHRjb25zdCBkc3QgPSBzcmMuc2xpY2UoKTtcblxuXHRcdFx0Y29uc3Qgblplcm9lcyA9IGRzdC5sZW5ndGggPT0gMCA/IFdJRFRIIDogKFdJRFRIIC0gZHN0Lmxlbmd0aCVXSURUSCklV0lEVEg7XG5cblx0XHRcdC8vIGp1c3QgcGFkZGluZyB3aXRoIHplcm9lcywgdGhlIGFjdHVhbCBtZXNzYWdlIGxlbmd0aCBpcyB1c2VkIGR1cmluZyBjb21wcmVzc2lvbiBzdGFnZSBvZiBmaW5hbCBibG9jayBpbiBvcmRlciB0byB1bmlxdWVseSBoYXNoIG1lc3NhZ2VzIG9mIGRpZmZlcmVudCBsZW5ndGhzXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5aZXJvZXM7IGkrKykge1xuXHRcdFx0XHRkc3QucHVzaCgwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGRzdDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge1VJbnQ2NFtdfSB2XG5cdFx0ICogQHBhcmFtIHtVSW50NjRbXX0gY2h1bmtcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gYSAtIGluZGV4XG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGIgLSBpbmRleFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gaW5kZXhcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gZCAtIGluZGV4XG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGkgLSBpbmRleCBpbiBjaHVuayBmb3IgbG93IHdvcmQgMVxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBqIC0gaW5kZXggaW4gY2h1bmsgZm9yIGxvdyB3b3JkIDJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtaXgodiwgY2h1bmssIGEsIGIsIGMsIGQsIGksIGopIHtcblx0XHRcdGNvbnN0IHggPSBjaHVua1tpXTtcblx0XHRcdGNvbnN0IHkgPSBjaHVua1tqXTtcblxuXHRcdFx0dlthXSA9IHZbYV0uYWRkKHZbYl0pLmFkZCh4KTtcblx0XHRcdHZbZF0gPSB2W2RdLnhvcih2W2FdKS5yb3RyKDMyKTtcblx0XHRcdHZbY10gPSB2W2NdLmFkZCh2W2RdKTtcblx0XHRcdHZbYl0gPSB2W2JdLnhvcih2W2NdKS5yb3RyKDI0KTtcblx0XHRcdHZbYV0gPSB2W2FdLmFkZCh2W2JdKS5hZGQoeSk7XG5cdFx0XHR2W2RdID0gdltkXS54b3IodlthXSkucm90cigxNik7XG5cdFx0XHR2W2NdID0gdltjXS5hZGQodltkXSk7XG5cdFx0XHR2W2JdID0gdltiXS54b3IodltjXSkucm90cig2Myk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtVSW50NjRbXX0gaCAtIHN0YXRlIHZlY3RvclxuXHRcdCAqIEBwYXJhbSB7VUludDY0W119IGNodW5rXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBjaHVua0VuZCAoZXhwZWN0ZWQgdG8gZml0IGluIHVpbnQzMilcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhc3Rcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjb21wcmVzcyhoLCBjaHVuaywgdCwgbGFzdCkge1xuXHRcdFx0Ly8gd29yayB2ZWN0b3JzXG5cdFx0XHRjb25zdCB2ID0gaC5zbGljZSgpLmNvbmNhdChJVi5zbGljZSgpKTtcblxuXHRcdFx0dlsxMl0gPSB2WzEyXS54b3IobmV3IFVJbnQ2NCgwLCBpbW9kMzIodCkpKTsgLy8gdlsxMl0uaGlnaCB1bm1vZGlmaWVkXG5cdFx0XHQvLyB2WzEzXSB1bm1vZGlmaWVkXG5cblx0XHRcdGlmIChsYXN0KSB7XG5cdFx0XHRcdHZbMTRdID0gdlsxNF0ueG9yKG5ldyBVSW50NjQoMHhmZmZmZmZmZiwgMHhmZmZmZmZmZikpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgMTI7IHJvdW5kKyspIHtcblx0XHRcdFx0Y29uc3QgcyA9IFNJR01BW3JvdW5kJTEwXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdG1peCh2LCBjaHVuaywgaSwgaSs0LCBpKzgsIGkrMTIsIHNbaSoyXSwgc1tpKjIrMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdG1peCh2LCBjaHVuaywgaSwgKGkrMSklNCArIDQsIChpKzIpJTQgKyA4LCAoaSszKSU0ICsgMTIsIHNbOCtpKjJdLCBzWzggKyBpKjIgKyAxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcdFx0aFtpXSA9IGhbaV0ueG9yKHZbaV0ueG9yKHZbaSs4XSkpO1xuXHRcdFx0fVx0XHRcblx0XHR9XG4gXG5cdFx0Y29uc3QgbkJ5dGVzID0gYnl0ZXMubGVuZ3RoO1xuXG5cdFx0Ynl0ZXMgPSBwYWQoYnl0ZXMpO1xuXG5cdFx0Ly8gaW5pdCBoYXNoIHZlY3RvclxuXHRcdGNvbnN0IGggPSBJVi5zbGljZSgpO1xuXHRcdFxuXG5cdFx0Ly8gc2V0dXAgdGhlIHBhcmFtIGJsb2NrXG5cdFx0Y29uc3QgcGFyYW1CbG9jayA9IG5ldyBVaW50OEFycmF5KDY0KTtcblx0XHRwYXJhbUJsb2NrWzBdID0gZGlnZXN0U2l6ZTsgLy8gbiBvdXRwdXQgIGJ5dGVzXG5cdFx0cGFyYW1CbG9ja1sxXSA9IDA7IC8vIGtleS1sZW5ndGggKGFsd2F5cyB6ZXJvIGluIG91ciBjYXNlKSBcblx0XHRwYXJhbUJsb2NrWzJdID0gMTsgLy8gZmFub3V0XG5cdFx0cGFyYW1CbG9ja1szXSA9IDE7IC8vIGRlcHRoXG5cblx0XHQvL21peCBpbiB0aGUgcGFyYW1ldGVyIGJsb2NrXG5cdFx0Y29uc3QgcGFyYW1CbG9ja1ZpZXcgPSBuZXcgRGF0YVZpZXcocGFyYW1CbG9jay5idWZmZXIpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRoW2ldID0gaFtpXS54b3IobmV3IFVJbnQ2NChcblx0XHRcdFx0cGFyYW1CbG9ja1ZpZXcuZ2V0VWludDMyKGkqOCs0LCB0cnVlKSxcblx0XHRcdFx0cGFyYW1CbG9ja1ZpZXcuZ2V0VWludDMyKGkqOCwgdHJ1ZSksXG5cdFx0XHQpKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gbG9vcCBhbGwgY2h1bmtzXG5cdFx0Zm9yIChsZXQgY2h1bmtTdGFydCA9IDA7IGNodW5rU3RhcnQgPCBieXRlcy5sZW5ndGg7IGNodW5rU3RhcnQgKz0gV0lEVEgpIHtcblx0XHRcdGNvbnN0IGNodW5rRW5kID0gY2h1bmtTdGFydCArIFdJRFRIOyAvLyBleGNsdXNpdmVcblx0XHRcdGNvbnN0IGNodW5rID0gYnl0ZXMuc2xpY2UoY2h1bmtTdGFydCwgY2h1bmtTdGFydCArIFdJRFRIKTtcblxuXHRcdFx0Y29uc3QgY2h1bms2NCA9IG5ldyBBcnJheShXSURUSC84KTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgV0lEVEg7IGkgKz0gOCkge1xuXHRcdFx0XHRjaHVuazY0W2kvOF0gPSBVSW50NjQuZnJvbUJ5dGVzKGNodW5rLnNsaWNlKGksIGkrOCkpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoY2h1bmtTdGFydCA9PSBieXRlcy5sZW5ndGggLSBXSURUSCkge1xuXHRcdFx0XHQvLyBsYXN0IGJsb2NrXG5cdFx0XHRcdGNvbXByZXNzKGgsIGNodW5rNjQsIG5CeXRlcywgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb21wcmVzcyhoLCBjaHVuazY0LCBjaHVua0VuZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGV4dHJhY3QgbG93ZXN0IEJMQUtFMkJfRElHRVNUX1NJWkUgYnl0ZXMgZnJvbSBoXG5cblx0XHQvKiogQHR5cGUge251bWJlcltdfSAqL1xuXHRcdGxldCBoYXNoID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkaWdlc3RTaXplLzg7IGkrKykge1xuXHRcdFx0aGFzaCA9IGhhc2guY29uY2F0KGhbaV0udG9CeXRlcygpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFzaC5zbGljZSgwLCBkaWdlc3RTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcnlwdG8uRWQyNTUxOSBleHBvcnRzIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuXHQgKiAgKiBDcnlwdG8uRWQyNTUxOS5kZXJpdmVQdWJsaWNLZXkocHJpdmF0ZUtleSlcblx0ICogICogQ3J5cHRvLkVkMjU1MTkuc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KVxuXHQgKiAgKiBDcnlwdG8uRWQyNTUxOS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpXG5cdCAqIFxuXHQgKiBUaGlzIGlzIGltcGxlbWVudGF0aW9uIGlzIHNsb3cgKH4wLjVzIHBlciB2ZXJpZmljYXRpb24pLCBidXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIGZvciBzaW1wbGUgY2xpZW50LXNpZGUgdXNhZ2Vcblx0ICogXG5cdCAqIFBvcnRlZCBmcm9tOiBodHRwczovL2VkMjU1MTkuY3IueXAudG8vcHl0aG9uL2VkMjU1MTkucHlcbiAgICAgKiBAcGFja2FnZVxuXHQgKi9cblx0c3RhdGljIGdldCBFZDI1NTE5KCkge1xuXHRcdGNvbnN0IFEgPSA1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OW47IC8vIGlwb3dpKDI1NW4pIC0gMTluXG5cdFx0Y29uc3QgUTM4ID0gNzIzNzAwNTU3NzMzMjI2MjIxMzk3MzE4NjU2MzA0Mjk5NDI0MDgyOTM3NDA0MTYwMjUzNTI1MjQ2NjA5OTAwMDQ5NDU3MDYwMjQ5NG47IC8vIChRICsgM24pLzhuXG5cdFx0Y29uc3QgQ1VSVkVfT1JERVIgPSA3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5bjsgLy8gaXBvdzIoMjUybikgKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M247XG5cdFx0Y29uc3QgRCA9IC00NTEzMjQ5MDYyNTQxNTU3MzM3NjgyODk0OTMwMDkyNjI0MTczNzg1NjQxMjg1MTkxMTI1MjQxNjI4OTQxNTkxODgyOTAwOTI0NTk4ODQwNzQwbjsgLy8gLTEyMTY2NW4gKiBpbnZlcnQoMTIxNjY2bik7XG5cdFx0Y29uc3QgSSA9IDE5NjgxMTYxMzc2NzA3NTA1OTU2ODA3MDc5MzA0OTg4NTQyMDE1NDQ2MDY2NTE1OTIzODkwMTYyNzQ0MDIxMDczMTIzODI5Nzg0NzUybjsgLy8gZXhwTW9kKDJuLCAoUSAtIDFuKS80biwgUSk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1tiaWdpbnQsIGJpZ2ludF19XG5cdFx0ICovXG5cdFx0Y29uc3QgQkFTRSA9IFtcblx0XHRcdDE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAybiwgLy8gcmVjb3ZlclgoQlsxXSkgJSBRXG5cdFx0XHQ0NjMxNjgzNTY5NDkyNjQ3ODE2OTQyODM5NDAwMzQ3NTE2MzE0MTMwNzk5Mzg2NjI1NjIyNTYxNTc4MzAzMzYwMzE2NTI1MTg1NTk2MG4sIC8vICg0bippbnZlcnQoNW4pKSAlIFFcblx0XHRdO1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtiaWdpbnR9IGIgXG5cdFx0ICogQHBhcmFtIHtiaWdpbnR9IGUgXG5cdFx0ICogQHBhcmFtIHtiaWdpbnR9IG0gXG5cdFx0ICogQHJldHVybnMge2JpZ2ludH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBleHBNb2QoYiwgZSwgbSkge1xuXHRcdFx0aWYgKGUgPT0gMG4pIHtcblx0XHRcdFx0cmV0dXJuIDFuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IHQgPSBleHBNb2QoYiwgZS8ybiwgbSk7XG5cdFx0XHRcdHQgPSAodCp0KSAlIG07XG5cblx0XHRcdFx0aWYgKChlICUgMm4pICE9IDBuKSB7XG5cdFx0XHRcdFx0dCA9IHBvc01vZCh0KmIsIG0pXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge2JpZ2ludH0gbiBcblx0XHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGludmVydChuKSB7XG5cdFx0XHRsZXQgYSA9IHBvc01vZChuLCBRKTtcblx0XHRcdGxldCBiID0gUTtcblxuXHRcdFx0bGV0IHggPSAwbjtcblx0XHRcdGxldCB5ID0gMW47XG5cdFx0XHRsZXQgdSA9IDFuO1xuXHRcdFx0bGV0IHYgPSAwbjtcblxuXHRcdFx0d2hpbGUgKGEgIT09IDBuKSB7XG5cdFx0XHRcdGNvbnN0IHEgPSBiIC8gYTtcblx0XHRcdFx0Y29uc3QgciA9IGIgJSBhO1xuXHRcdFx0XHRjb25zdCBtID0geCAtIHUqcTtcblx0XHRcdFx0Y29uc3QgbiA9IHkgLSB2KnE7XG5cdFx0XHRcdGIgPSBhO1xuXHRcdFx0XHRhID0gcjtcblx0XHRcdFx0eCA9IHU7XG5cdFx0XHRcdHkgPSB2O1xuXHRcdFx0XHR1ID0gbTtcblx0XHRcdFx0diA9IG47XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb3NNb2QoeCwgUSlcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge2JpZ2ludH0geSBcblx0XHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlY292ZXJYKHkpIHtcblx0XHRcdGNvbnN0IHl5ID0geSp5O1xuXHRcdFx0Y29uc3QgeHggPSAoeXkgLSAxbikgKiBpbnZlcnQoRCp5eSArIDFuKTtcblx0XHRcdGxldCB4ID0gZXhwTW9kKHh4LCBRMzgsIFEpO1xuXG5cdFx0XHRpZiAoKCh4KnggLSB4eCkgJSBRKSAhPSAwbikge1xuXHRcdFx0XHR4ID0gKHgqSSkgJSBRO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKHglMm4pICE9IDBuKSB7XG5cdFx0XHRcdHggPSBRIC0geDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVx0XHRcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnZlIHBvaW50ICdhZGRpdGlvbidcblx0XHQgKiBOb3RlOiB0aGlzIGlzIHByb2JhYmx5IHRoZSBib3R0bGVuZWNrIG9mIHRoaXMgRWQyNTUxOSBpbXBsZW1lbnRhdGlvblxuXHRcdCAqIEBwYXJhbSB7W2JpZ2ludCwgYmlnaW50XX0gYSBcblx0XHQgKiBAcGFyYW0ge1tiaWdpbnQsIGJpZ2ludF19IGIgXG5cdFx0ICogQHJldHVybnMge1tiaWdpbnQsIGJpZ2ludF19XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZWR3YXJkcyhhLCBiKSB7XG5cdFx0XHRjb25zdCB4MSA9IGFbMF07XG5cdFx0XHRjb25zdCB5MSA9IGFbMV07XG5cdFx0XHRjb25zdCB4MiA9IGJbMF07XG5cdFx0XHRjb25zdCB5MiA9IGJbMV07XG5cdFx0XHRjb25zdCBkeHh5eSA9IEQqeDEqeDIqeTEqeTI7XG5cdFx0XHRjb25zdCB4MyA9ICh4MSp5Mit4Mip5MSkgKiBpbnZlcnQoMW4rZHh4eXkpO1xuXHRcdFx0Y29uc3QgeTMgPSAoeTEqeTIreDEqeDIpICogaW52ZXJ0KDFuLWR4eHl5KTtcblx0XHRcdHJldHVybiBbcG9zTW9kKHgzLCBRKSwgcG9zTW9kKHkzLCBRKV07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtbYmlnaW50LCBiaWdpbnRdfSBwb2ludCBcblx0XHQgKiBAcGFyYW0ge2JpZ2ludH0gbiBcblx0XHQgKiBAcmV0dXJucyB7W2JpZ2ludCwgYmlnaW50XX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzY2FsYXJNdWwocG9pbnQsIG4pIHtcblx0XHRcdGlmIChuID09IDBuKSB7XG5cdFx0XHRcdHJldHVybiBbMG4sIDFuXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBzdW0gPSBzY2FsYXJNdWwocG9pbnQsIG4vMm4pO1xuXHRcdFx0XHRzdW0gPSBlZHdhcmRzKHN1bSwgc3VtKTtcblx0XHRcdFx0aWYgKChuICUgMm4pICE9IDBuKSB7XG5cdFx0XHRcdFx0c3VtID0gZWR3YXJkcyhzdW0sIHBvaW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdW07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQ3VydmUgcG9pbnQgJ211bHRpcGxpY2F0aW9uJ1xuXHRcdCAqIEBwYXJhbSB7YmlnaW50fSB5IFxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBlbmNvZGVJbnQoeSkge1xuXHRcdFx0Y29uc3QgYnl0ZXMgPSBiaWdJbnRUb0J5dGVzKHkpLnJldmVyc2UoKTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGJ5dGVzLmxlbmd0aCA8IDMyKSB7XG5cdFx0XHRcdGJ5dGVzLnB1c2goMCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBieXRlcztcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBzIFxuXHRcdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVjb2RlSW50KHMpIHtcblx0XHRcdHJldHVybiBieXRlc1RvQmlnSW50KHMucmV2ZXJzZSgpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge1tiaWdpbnQsIGJpZ2ludF19IHBvaW50XG5cdFx0ICogQHJldHVybnMge251bWJlcltdfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG5cdFx0XHRjb25zdCBbeCwgeV0gPSBwb2ludDtcblxuXHRcdFx0Y29uc3QgYnl0ZXMgPSBlbmNvZGVJbnQoeSk7XG5cblx0XHRcdC8vIGxhc3QgYml0IGlzIGRldGVybWluZWQgYnkgeFxuXG5cdFx0XHRieXRlc1szMV0gPSAoYnl0ZXNbMzFdICYgMGIwMTExMTExMTEpIHwgKE51bWJlcih4ICYgMW4pICogMGIxMDAwMDAwMCk7XG5cblx0XHRcdHJldHVybiBieXRlcztcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gaSAtIGJpdCBpbmRleFxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBvciAxXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0Qml0KGJ5dGVzLCBpKSB7XG5cdFx0XHRyZXR1cm4gKGJ5dGVzW01hdGguZmxvb3IoaS84KV0gPj4gaSU4KSAmIDFcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge1tiaWdpbnQsIGJpZ2ludF19IHBvaW50XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaXNPbkN1cnZlKHBvaW50KSB7XG5cdFx0XHRjb25zdCB4ID0gcG9pbnRbMF07XG5cdFx0XHRjb25zdCB5ID0gcG9pbnRbMV07XG5cdFx0XHRjb25zdCB4eCA9IHgqeDtcblx0XHRcdGNvbnN0IHl5ID0geSp5O1xuXHRcdFx0cmV0dXJuICgteHggKyB5eSAtIDFuIC0gRCp4eCp5eSkgJSBRID09IDBuO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyW119IHMgXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVjb2RlUG9pbnQocykge1xuXHRcdFx0YXNzZXJ0KHMubGVuZ3RoID09IDMyKTtcblxuXHRcdFx0Y29uc3QgYnl0ZXMgPSBzLnNsaWNlKCk7XG5cdFx0XHRieXRlc1szMV0gPSBieXRlc1szMV0gJiAwYjAxMTExMTExO1xuXG5cdFx0XHRjb25zdCB5ID0gZGVjb2RlSW50KGJ5dGVzKTtcblxuXHRcdFx0bGV0IHggPSByZWNvdmVyWCh5KTtcblx0XHRcdGlmIChOdW1iZXIoeCAmIDFuKSAhPSBnZXRCaXQocywgMjU1KSkge1xuXHRcdFx0XHR4ID0gUSAtIHg7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge1tiaWdpbnQsIGJpZ2ludF19XG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IHBvaW50ID0gW3gsIHldO1xuXG5cdFx0XHRpZiAoIWlzT25DdXJ2ZShwb2ludCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicG9pbnQgaXNuJ3Qgb24gY3VydmVcIik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDb3VsZG4ndCB0aGluayBvZiBhIHByb3BlciBuYW1lIGZvciB0aGlzIGZ1bmN0aW9uXG5cdFx0ICogQHBhcmFtIHtudW1iZXJbXX0gaCBcblx0XHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGNhbGNhKGgpIHtcblx0XHRcdGNvbnN0IGEgPSAyODk0ODAyMjMwOTMyOTA0ODg1NTg5Mjc0NjI1MjE3MTk3Njk2MzMxNzQ5NjE2NjQxMDE0MTAwOTg2NDM5NjAwMTk3ODI4MjQwOTk4NG47IC8vIGlwb3cyKDI1MylcblxuXHRcdFx0Y29uc3QgYnl0ZXMgPSBoLnNsaWNlKDAsIDMyKTtcblx0XHRcdGJ5dGVzWzBdID0gYnl0ZXNbMF0gJiAwYjExMTExMDAwO1xuXHRcdFx0Ynl0ZXNbMzFdID0gYnl0ZXNbMzFdICYgMGIwMDExMTExMTtcblxuXHRcdFx0Y29uc3QgeCA9IGJ5dGVzVG9CaWdJbnQoYnl0ZXMucmV2ZXJzZSgpKTtcblx0XHRcdHJldHVybiBhICsgeDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBtIFxuXHRcdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaWhhc2gobSkge1xuXHRcdFx0Y29uc3QgaCA9IENyeXB0by5zaGEyXzUxMihtKTtcblxuXHRcdFx0cmV0dXJuIGRlY29kZUludChoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBwcml2YXRlS2V5IFxuXHRcdFx0ICogQHJldHVybnMge251bWJlcltdfVxuXHRcdFx0ICovXG5cdFx0XHRkZXJpdmVQdWJsaWNLZXk6IGZ1bmN0aW9uKHByaXZhdGVLZXkpIHtcblx0XHRcdFx0Y29uc3QgcHJpdmF0ZUtleUhhc2ggPSBDcnlwdG8uc2hhMl81MTIocHJpdmF0ZUtleSk7XG5cdFx0XHRcdGNvbnN0IGEgPSBjYWxjYShwcml2YXRlS2V5SGFzaCk7XG5cdFx0XHRcdGNvbnN0IEEgPSBzY2FsYXJNdWwoQkFTRSwgYSk7XG5cblx0XHRcdFx0cmV0dXJuIGVuY29kZVBvaW50KEEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcltdfSBtZXNzYWdlIFxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJbXX0gcHJpdmF0ZUtleSBcblx0XHRcdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0XHRcdCAqL1xuXHRcdFx0c2lnbjogZnVuY3Rpb24obWVzc2FnZSwgcHJpdmF0ZUtleSkge1xuXHRcdFx0XHRjb25zdCBwcml2YXRlS2V5SGFzaCA9IENyeXB0by5zaGEyXzUxMihwcml2YXRlS2V5KTtcblx0XHRcdFx0Y29uc3QgYSA9IGNhbGNhKHByaXZhdGVLZXlIYXNoKTtcblxuXHRcdFx0XHQvLyBmb3IgY29udmVuaWVuY2UgY2FsY3VsYXRlIHB1YmxpY0tleSBoZXJlOlxuXHRcdFx0XHRjb25zdCBwdWJsaWNLZXkgPSBlbmNvZGVQb2ludChzY2FsYXJNdWwoQkFTRSwgYSkpO1xuXG5cdFx0XHRcdGNvbnN0IHIgPSBpaGFzaChwcml2YXRlS2V5SGFzaC5zbGljZSgzMiwgNjQpLmNvbmNhdChtZXNzYWdlKSk7XG5cdFx0XHRcdGNvbnN0IFIgPSBzY2FsYXJNdWwoQkFTRSwgcik7XG5cdFx0XHRcdGNvbnN0IFMgPSBwb3NNb2QociArIGloYXNoKGVuY29kZVBvaW50KFIpLmNvbmNhdChwdWJsaWNLZXkpLmNvbmNhdChtZXNzYWdlKSkqYSwgQ1VSVkVfT1JERVIpO1xuXG5cdFx0XHRcdHJldHVybiBlbmNvZGVQb2ludChSKS5jb25jYXQoZW5jb2RlSW50KFMpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJbXX0gc2lnbmF0dXJlIFxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJbXX0gbWVzc2FnZSBcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyW119IHB1YmxpY0tleSBcblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHR2ZXJpZnk6IGZ1bmN0aW9uKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG5cdFx0XHRcdGlmIChzaWduYXR1cmUubGVuZ3RoICE9IDY0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHNpZ25hdHVyZSBsZW5ndGggJHtzaWduYXR1cmUubGVuZ3RofWApO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAocHVibGljS2V5Lmxlbmd0aCAhPSAzMikge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBwdWJsaWNrZXkgbGVuZ3RoICR7cHVibGljS2V5Lmxlbmd0aH1gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IFIgPSBkZWNvZGVQb2ludChzaWduYXR1cmUuc2xpY2UoMCwgMzIpKTtcblx0XHRcdFx0Y29uc3QgQSA9IGRlY29kZVBvaW50KHB1YmxpY0tleSk7XG5cdFx0XHRcdGNvbnN0IFMgPSBkZWNvZGVJbnQoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuXHRcdFx0XHRjb25zdCBoID0gaWhhc2goc2lnbmF0dXJlLnNsaWNlKDAsIDMyKS5jb25jYXQocHVibGljS2V5KS5jb25jYXQobWVzc2FnZSkpO1xuXG5cdFx0XHRcdGNvbnN0IGxlZnQgPSBzY2FsYXJNdWwoQkFTRSwgUyk7XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gZWR3YXJkcyhSLCBzY2FsYXJNdWwoQSwgaCkpO1xuXG5cdFx0XHRcdHJldHVybiAobGVmdFswXSA9PSByaWdodFswXSkgJiYgKGxlZnRbMV0gPT0gcmlnaHRbMV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gNTogQ2JvciBlbmNvZGVyL2RlY29kZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGk6IG51bWJlciwgYnl0ZXM6IG51bWJlcltdKSA9PiB2b2lkfSBEZWNvZGVyXG4gKi9cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGFueSBDYm9yIHNlcmlhbGl6YWJsZSBkYXRhIGNsYXNzXG4gKiBBbHNvIGNvbnRhaW5zIGhlbHBlciBtZXRob2RzIGZvciAoZGUpc2VyaWFsaXppbmcgZGF0YSB0by9mcm9tIENib3JcbiAqL1xuZXhwb3J0IGNsYXNzIENib3JEYXRhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IG0gLSBtYWpvciB0eXBlXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBuIC0gc2l6ZSBwYXJhbWV0ZXJcblx0ICogQHJldHVybnMge251bWJlcltdfSAtIHVpbnQ4IGJ5dGVzXG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlSGVhZChtLCBuKSB7XG5cdFx0aWYgKG4gPD0gMjNuKSB7XG5cdFx0XHRyZXR1cm4gWzMyKm0gKyBOdW1iZXIobildO1xuXHRcdH0gZWxzZSBpZiAobiA+PSAyNG4gJiYgbiA8PSAyNTVuKSB7XG5cdFx0XHRyZXR1cm4gWzMyKm0gKyAyNCwgTnVtYmVyKG4pXTtcblx0XHR9IGVsc2UgaWYgKG4gPj0gMjU2biAmJiBuIDw9IDI1Nm4qMjU2biAtIDFuKSB7XG5cdFx0XHRyZXR1cm4gWzMyKm0gKyAyNSwgTnVtYmVyKChuLzI1Nm4pJTI1Nm4pLCBOdW1iZXIobiUyNTZuKV07XG5cdFx0fSBlbHNlIGlmIChuID49IDI1Nm4qMjU2biAmJiBuIDw9IDI1Nm4qMjU2bioyNTZuKjI1Nm4gLSAxbikge1xuXHRcdFx0bGV0IGU0ID0gYmlnSW50VG9CeXRlcyhuKTtcblxuXHRcdFx0d2hpbGUgKGU0Lmxlbmd0aCA8IDQpIHtcblx0XHRcdFx0ZTQudW5zaGlmdCgwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbMzIqbSArIDI2XS5jb25jYXQoZTQpO1xuXHRcdH0gZWxzZSBpZiAobiA+PSAyNTZuKjI1Nm4qMjU2bioyNTZuICYmIG4gPD0gMjU2bioyNTZuKjI1Nm4qMjU2bioyNTZuKjI1Nm4qMjU2bioyNTZuIC0gMW4pIHtcblx0XHRcdGxldCBlOCA9IGJpZ0ludFRvQnl0ZXMobik7XG5cblx0XHRcdHdoaWxlKGU4Lmxlbmd0aCA8IDgpIHtcblx0XHRcdFx0ZTgudW5zaGlmdCgwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbMzIqbSArIDI3XS5jb25jYXQoZTgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJuIG91dCBvZiByYW5nZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgLSBtdXRhdGVkIHRvIGNvbnRhaW4gdGhlIHJlc3Rcblx0ICogQHJldHVybnMge1tudW1iZXIsIGJpZ2ludF19IC0gW21ham9yVHlwZSwgbl1cblx0ICovXG5cdHN0YXRpYyBkZWNvZGVIZWFkKGJ5dGVzKSB7XG5cdFx0aWYgKGJ5dGVzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBjYm9yIGhlYWRcIik7XG5cdFx0fVxuXG5cdFx0bGV0IGZpcnN0ID0gYXNzZXJ0RGVmaW5lZChieXRlcy5zaGlmdCgpKTtcblxuXHRcdGlmIChmaXJzdCUzMiA8PSAyMykge1xuXHRcdFx0cmV0dXJuIFtpZGl2KGZpcnN0LCAzMiksIEJpZ0ludChmaXJzdCUzMildO1xuXHRcdH0gZWxzZSBpZiAoZmlyc3QlMzIgPT0gMjQpIHtcblx0XHRcdHJldHVybiBbaWRpdihmaXJzdCwgMzIpLCBieXRlc1RvQmlnSW50KGJ5dGVzLnNwbGljZSgwLCAxKSldO1xuXHRcdH0gZWxzZSBpZiAoZmlyc3QlMzIgPT0gMjUpIHtcblx0XHRcdHJldHVybiBbaWRpdihmaXJzdCwgMzIpLCBieXRlc1RvQmlnSW50KGJ5dGVzLnNwbGljZSgwLCAyKSldO1xuXHRcdH0gZWxzZSBpZiAoZmlyc3QlMzIgPT0gMjYpIHtcblx0XHRcdHJldHVybiBbaWRpdihmaXJzdCwgMzIpLCBieXRlc1RvQmlnSW50KGJ5dGVzLnNwbGljZSgwLCA0KSldO1xuXHRcdH0gZWxzZSBpZiAoZmlyc3QlMzIgPT0gMjcpIHtcblx0XHRcdHJldHVybiBbaWRpdihmaXJzdCwgMzIpLCBieXRlc1RvQmlnSW50KGJ5dGVzLnNwbGljZSgwLCA4KSldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgaGVhZGVyXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlSW5kZWZIZWFkKG0pIHtcblx0XHRyZXR1cm4gWzMyKm0gKyAzMV07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgLSBjYm9yIGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IC0gbWFqb3JUeXBlXG5cdCAqL1xuXHRzdGF0aWMgZGVjb2RlSW5kZWZIZWFkKGJ5dGVzKSB7XG5cdFx0bGV0IGZpcnN0ID0gYXNzZXJ0RGVmaW5lZChieXRlcy5zaGlmdCgpKTtcblxuXHRcdGxldCBtID0gaWRpdihmaXJzdCAtIDMxLCAzMik7XG5cblx0XHRyZXR1cm4gbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc051bGwoYnl0ZXMpIHtcblx0XHRyZXR1cm4gYnl0ZXNbMF0gPT0gMjQ2O1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVOdWxsKCkge1xuXHRcdHJldHVybiBbMjQ2XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgbm90IG51bGxcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICovXG5cdHN0YXRpYyBkZWNvZGVOdWxsKGJ5dGVzKSB7XG5cdFx0bGV0IGIgPSBhc3NlcnREZWZpbmVkKGJ5dGVzLnNoaWZ0KCkpO1xuXG5cdFx0aWYgKGIgIT0gMjQ2KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgbnVsbFwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtib29sZWFufSBiXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVCb29sKGIpIHtcblx0XHRpZiAoYikge1xuXHRcdFx0cmV0dXJuIFsyNDVdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gWzI0NF07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGRlY29kZUJvb2woYnl0ZXMpIHtcblx0XHRsZXQgYiA9IGFzc2VydERlZmluZWQoYnl0ZXMuc2hpZnQoKSk7XG5cblx0XHRpZiAoYiA9PSAyNDUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoYiA9PSAyNDQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBub24tYm9vbGVhbiBjYm9yIG9iamVjdFwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNEZWZCeXRlcyhieXRlcykge1xuXHRcdGlmIChieXRlcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgY2JvciBieXRlc1wiKTtcblx0XHR9XG5cblx0XHRsZXQgW20sIF9dID0gQ2JvckRhdGEuZGVjb2RlSGVhZChieXRlcy5zbGljZSgwLCA5KSk7XG5cblx0XHRyZXR1cm4gbSA9PSAyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzSW5kZWZCeXRlcyhieXRlcykge1xuXHRcdGlmIChieXRlcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgY2JvciBieXRlc1wiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMiozMiArIDMxID09IGJ5dGVzWzBdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ2JvckRhdGEuZW5jb2RlQnl0ZXMoaGV4VG9CeXRlcyhcIjRkMDEwMDAwMzMyMjIyMjAwNTEyMDAxMjAwMTFcIikpKSA9PiBcIjRlNGQwMTAwMDAzMzIyMjIyMDA1MTIwMDEyMDAxMVwiXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc3BsaXRJbkNodW5rc1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gY2JvciBieXRlc1xuXHQgKi9cblx0c3RhdGljIGVuY29kZUJ5dGVzKGJ5dGVzLCBzcGxpdEluQ2h1bmtzID0gZmFsc2UpIHtcblx0XHRieXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG5cblx0XHRpZiAoYnl0ZXMubGVuZ3RoIDw9IDY0IHx8ICFzcGxpdEluQ2h1bmtzKSB7XG5cdFx0XHRsZXQgaGVhZCA9IENib3JEYXRhLmVuY29kZUhlYWQoMiwgQmlnSW50KGJ5dGVzLmxlbmd0aCkpO1xuXHRcdFx0cmV0dXJuIGhlYWQuY29uY2F0KGJ5dGVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHJlcyA9IENib3JEYXRhLmVuY29kZUluZGVmSGVhZCgyKTtcblxuXHRcdFx0d2hpbGUgKGJ5dGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0bGV0IGNodW5rID0gYnl0ZXMuc3BsaWNlKDAsIDY0KTtcblxuXHRcdFx0XHRyZXMgPSByZXMuY29uY2F0KENib3JEYXRhLmVuY29kZUhlYWQoMiwgQmlnSW50KGNodW5rLmxlbmd0aCkpKS5jb25jYXQoY2h1bmspO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXMucHVzaCgyNTUpO1xuXG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGJvdGggYW4gaW5kZWYgYXJyYXkgb2YgYnl0ZXMsIGFuZCBhIGJ5dGVhcnJheSBvZiBzcGVjaWZpZWQgbGVuZ3RoXG5cdCAqIEBleGFtcGxlXG5cdCAqIGJ5dGVzVG9IZXgoQ2JvckRhdGEuZGVjb2RlQnl0ZXMoaGV4VG9CeXRlcyhcIjRlNGQwMTAwMDAzMzIyMjIyMDA1MTIwMDEyMDAxMVwiKSkpID0+IFwiNGQwMTAwMDAzMzIyMjIyMDA1MTIwMDEyMDAxMVwiXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIC0gY2JvcmJ5dGVzLCBtdXRhdGVkIHRvIGZvcm0gcmVtYWluaW5nXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX0gLSBieXRlQXJyYXlcblx0ICovXG5cdHN0YXRpYyBkZWNvZGVCeXRlcyhieXRlcykge1xuXHRcdC8vIGNoZWNrIGhlYWRlciB0eXBlXG5cdFx0YXNzZXJ0KGJ5dGVzLmxlbmd0aCA+IDApO1xuXG5cdFx0aWYgKENib3JEYXRhLmlzSW5kZWZCeXRlcyhieXRlcykpIHtcblx0XHRcdC8vIG11bHRpcGxlIGNodW5rc1xuXHRcdFx0dm9pZCBieXRlcy5zaGlmdCgpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtudW1iZXJbXX1cblx0XHRcdCAqL1xuXHRcdFx0bGV0IHJlcyA9IFtdO1xuXG5cdFx0XHR3aGlsZShieXRlc1swXSAhPSAyNTUpIHtcblx0XHRcdFx0bGV0IFtfLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXHRcdFx0XHRpZiAobiA+IDY0bikge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImJ5dGVhcnJheSBjaHVuayB0b28gbGFyZ2VcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXMgPSByZXMuY29uY2F0KGJ5dGVzLnNwbGljZSgwLCBOdW1iZXIobikpKTtcblx0XHRcdH1cblxuXHRcdFx0YXNzZXJ0KGJ5dGVzLnNoaWZ0KCkgPT0gMjU1KTtcblxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IFtfLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXG5cdFx0XHRyZXR1cm4gYnl0ZXMuc3BsaWNlKDAsIE51bWJlcihuKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzVXRmOChieXRlcykge1xuXHRcdGlmIChieXRlcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgY2JvciBieXRlc1wiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnl0ZXNbMF0gPT09IDEyMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgVXRmOCBzdHJpbmcgaW50byBDYm9yIGJ5dGVzLlxuXHQgKiBTdHJpbmdzIGxvbmdlciB0aGFuIDY0IGJ5dGVzIGFyZSBzcGxpdCBpbnRvIGxpc3RzIHdpdGggNjQgYnl0ZSBjaHVua3Ncblx0ICogTm90ZTogc3RyaW5nIHNwbGl0dGluZyBpc24ndCByZXZlcnNpYmxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzcGxpdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlVXRmOChzdHIsIHNwbGl0ID0gZmFsc2UpIHtcblx0XHRjb25zdCBieXRlcyA9IHRleHRUb0J5dGVzKHN0cik7XG5cblx0XHRpZiAoc3BsaXQgJiYgYnl0ZXMubGVuZ3RoID4gNjQpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVtYmVyW11bXX0gKi9cblx0XHRcdGNvbnN0IGNodW5rcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA2NCkge1xuXHRcdFx0XHRjb25zdCBjaHVuayA9IGJ5dGVzLnNsaWNlKGksIGkgKyA2NCk7XG5cblx0XHRcdFx0Y2h1bmtzLnB1c2goWzEyMCwgY2h1bmsubGVuZ3RoXS5jb25jYXQoY2h1bmspKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZURlZkxpc3QoY2h1bmtzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFsxMjAsIGJ5dGVzLmxlbmd0aF0uY29uY2F0KGJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCovXG5cdHN0YXRpYyBkZWNvZGVVdGY4SW50ZXJuYWwoYnl0ZXMpIHtcblx0XHRhc3NlcnQoYnl0ZXMuc2hpZnQoKSA9PT0gMTIwKTtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IGJ5dGVzLnNoaWZ0KCk7XG5cblx0XHRyZXR1cm4gYnl0ZXNUb1RleHQoYnl0ZXMuc3BsaWNlKDAsIGxlbmd0aCkpO1xuXHR9XG5cblx0LyoqXG5cdCogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0KiBAcmV0dXJucyB7c3RyaW5nfVxuXHQqL1xuXHRzdGF0aWMgZGVjb2RlVXRmOChieXRlcykge1xuXHRcdGFzc2VydChieXRlcy5sZW5ndGggPiAwKTtcblxuXHRcdGlmIChDYm9yRGF0YS5pc0RlZkxpc3QoYnl0ZXMpKSB7XG5cdFx0XHRsZXQgcmVzdWx0ID0gXCJcIjtcblxuXHRcdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChieXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0XHRyZXN1bHQgKz0gQ2JvckRhdGEuZGVjb2RlVXRmOEludGVybmFsKGl0ZW1CeXRlcyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIENib3JEYXRhLmRlY29kZVV0ZjhJbnRlcm5hbChieXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX0gLSBjYm9yIGJ5dGVzXG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlSW50ZWdlcihuKSB7XG5cdFx0aWYgKG4gPj0gMG4gJiYgbiA8PSAoMm4gPDwgNjNuKSAtIDFuKSB7XG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlSGVhZCgwLCBuKTtcblx0XHR9IGVsc2UgaWYgKG4gPj0gKDJuIDw8IDYzbikpIHtcblx0XHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVIZWFkKDYsIDJuKS5jb25jYXQoQ2JvckRhdGEuZW5jb2RlQnl0ZXMoYmlnSW50VG9CeXRlcyhuKSkpO1xuXHRcdH0gZWxzZSBpZiAobiA8PSAtMW4gJiYgbiA+PSAtKDJuIDw8IDYzbikpIHtcblx0XHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVIZWFkKDEsIC1uIC0gMW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlSGVhZCg2LCAzbikuY29uY2F0KENib3JEYXRhLmVuY29kZUJ5dGVzKGJpZ0ludFRvQnl0ZXMoLW4gLSAxbikpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdHN0YXRpYyBkZWNvZGVJbnRlZ2VyKGJ5dGVzKSB7XG5cdFx0bGV0IFttLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXG5cdFx0aWYgKG0gPT0gMCkge1xuXHRcdFx0cmV0dXJuIG47XG5cdFx0fSBlbHNlIGlmIChtID09IDEpIHtcblx0XHRcdHJldHVybiAtbiAtIDFuO1xuXHRcdH0gZWxzZSBpZiAobSA9PSA2KSB7XG5cdFx0XHRpZiAobiA9PSAybikge1xuXHRcdFx0XHRsZXQgYiA9IENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKTtcblxuXHRcdFx0XHRyZXR1cm4gYnl0ZXNUb0JpZ0ludChiKTtcblx0XHRcdH0gZWxzZSBpZiAobiA9PSAzbikge1xuXHRcdFx0XHRsZXQgYiA9IENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKTtcblxuXHRcdFx0XHRyZXR1cm4gLWJ5dGVzVG9CaWdJbnQoYikgLSAxbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0YWcgbjoke259YCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0YWcgbToke219YCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzSW5kZWZMaXN0KGJ5dGVzKSB7XG5cdFx0aWYgKGJ5dGVzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBjYm9yIGJ5dGVzXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiA0KjMyICsgMzEgPT0gYnl0ZXNbMF07XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZUluZGVmTGlzdFN0YXJ0KCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVJbmRlZkhlYWQoNCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtDYm9yRGF0YVtdIHwgbnVtYmVyW11bXX0gbGlzdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlTGlzdEludGVybmFsKGxpc3QpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdFx0ICovXG5cdFx0bGV0IHJlcyA9IFtdO1xuXHRcdGZvciAobGV0IGl0ZW0gb2YgbGlzdCkge1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBDYm9yRGF0YSkge1xuXHRcdFx0XHRyZXMgPSByZXMuY29uY2F0KGl0ZW0udG9DYm9yKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gcmVzLmNvbmNhdChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVJbmRlZkxpc3RFbmQoKSB7XG5cdFx0cmV0dXJuIFsyNTVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2JvckRhdGFbXSB8IG51bWJlcltdW119IGxpc3Rcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZUxpc3QobGlzdCkge1xuXHRcdC8vIFRoaXMgZm9sbG93cyB0aGUgc2VyaWFsaXphdGlvbiBmb3JtYXQgdGhhdCB0aGUgSGFza2VsbCBpbnB1dC1vdXRwdXQtaGsvcGx1dHVzIFVQTEMgZXZhbHVhdG9yXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3dlbGwtdHlwZWQvY2JvcmcvYmxvYi80YmRjODE4YTFmMGIzNWYzOGJjMTE4YTg3OTQ0NjMwMDQzYjU4Mzg0L3NlcmlhbGlzZS9zcmMvQ29kZWMvU2VyaWFsaXNlL0NsYXNzLmhzI0wxODFcblx0XHRyZXR1cm4gbGlzdC5sZW5ndGggPyBDYm9yRGF0YS5lbmNvZGVJbmRlZkxpc3QobGlzdCkgOiBDYm9yRGF0YS5lbmNvZGVEZWZMaXN0KGxpc3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2JvckRhdGFbXSB8IG51bWJlcltdW119IGxpc3Rcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZUluZGVmTGlzdChsaXN0KSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUluZGVmTGlzdFN0YXJ0KCkuY29uY2F0KENib3JEYXRhLmVuY29kZUxpc3RJbnRlcm5hbChsaXN0KSkuY29uY2F0KENib3JEYXRhLmVuY29kZUluZGVmTGlzdEVuZCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0RlZkxpc3QoYnl0ZXMpIHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IFttLCBfXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMuc2xpY2UoMCwgOSkpO1xuXHRcdFx0cmV0dXJuIG0gPT0gNDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJiYWQgaGVhZGVyXCIpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtiaWdpbnR9IG5cblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZURlZkxpc3RTdGFydChuKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUhlYWQoNCwgbik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtDYm9yRGF0YVtdIHwgbnVtYmVyW11bXX0gbGlzdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlRGVmTGlzdChsaXN0KSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZURlZkxpc3RTdGFydChCaWdJbnQobGlzdC5sZW5ndGgpKS5jb25jYXQoQ2JvckRhdGEuZW5jb2RlTGlzdEludGVybmFsKGxpc3QpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0xpc3QoYnl0ZXMpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuaXNJbmRlZkxpc3QoYnl0ZXMpIHx8IENib3JEYXRhLmlzRGVmTGlzdChieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHBhcmFtIHtEZWNvZGVyfSBpdGVtRGVjb2RlclxuXHQgKi9cblx0c3RhdGljIGRlY29kZUxpc3QoYnl0ZXMsIGl0ZW1EZWNvZGVyKSB7XG5cdFx0aWYgKENib3JEYXRhLmlzSW5kZWZMaXN0KGJ5dGVzKSkge1xuXHRcdFx0YXNzZXJ0KENib3JEYXRhLmRlY29kZUluZGVmSGVhZChieXRlcykgPT0gNCk7XG5cblx0XHRcdGxldCBpID0gMDtcblx0XHRcdHdoaWxlKGJ5dGVzWzBdICE9IDI1NSkge1xuXHRcdFx0XHRpdGVtRGVjb2RlcihpLCBieXRlcyk7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblxuXHRcdFx0YXNzZXJ0KGJ5dGVzLnNoaWZ0KCkgPT0gMjU1KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IFttLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXG5cdFx0XHRhc3NlcnQobSA9PSA0KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOdW1iZXIobik7IGkrKykge1xuXHRcdFx0XHRpdGVtRGVjb2RlcihpLCBieXRlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzVHVwbGUoYnl0ZXMpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuaXNJbmRlZkxpc3QoYnl0ZXMpIHx8IENib3JEYXRhLmlzRGVmTGlzdChieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXVtdfSB0dXBsZVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlVHVwbGUodHVwbGUpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlRGVmTGlzdCh0dXBsZSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcGFyYW0ge0RlY29kZXJ9IHR1cGxlRGVjb2RlclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIHR1cGxlXG5cdCAqL1xuXHRzdGF0aWMgZGVjb2RlVHVwbGUoYnl0ZXMsIHR1cGxlRGVjb2Rlcikge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cblx0XHRDYm9yRGF0YS5kZWNvZGVMaXN0KGJ5dGVzLCAoXywgaXRlbUJ5dGVzKSA9PiB7XG5cdFx0XHR0dXBsZURlY29kZXIoY291bnQsIGl0ZW1CeXRlcyk7XG5cdFx0XHRjb3VudCsrO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzTWFwKGJ5dGVzKSB7XG5cdFx0bGV0IFttLCBfXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMuc2xpY2UoMCwgOSkpO1xuXG5cdFx0cmV0dXJuIG0gPT0gNTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1tDYm9yRGF0YSB8IG51bWJlcltdLCBDYm9yRGF0YSB8IG51bWJlcltdXVtdfSBwYWlyTGlzdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlTWFwSW50ZXJuYWwocGFpckxpc3QpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdFx0ICovXG5cdFx0bGV0IHJlcyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgcGFpciBvZiBwYWlyTGlzdCkge1xuXHRcdFx0bGV0IGtleSA9IHBhaXJbMF07XG5cdFx0XHRsZXQgdmFsdWUgPSBwYWlyWzFdO1xuXG5cdFx0XHRpZiAoa2V5IGluc3RhbmNlb2YgQ2JvckRhdGEpIHtcblx0XHRcdFx0cmVzID0gcmVzLmNvbmNhdChrZXkudG9DYm9yKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gcmVzLmNvbmNhdChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBDYm9yRGF0YSkge1xuXHRcdFx0XHRyZXMgPSByZXMuY29uY2F0KHZhbHVlLnRvQ2JvcigpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcyA9IHJlcy5jb25jYXQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvKipcblx0ICogQSBkZWNvZGUgbWFwIG1ldGhvZCBkb2Vzbid0IGV4aXN0IGJlY2F1c2UgaXQgc3BlY2lmaWMgZm9yIHRoZSByZXF1ZXN0ZWQgdHlwZVxuXHQgKiBAcGFyYW0ge1tDYm9yRGF0YSB8IG51bWJlcltdLCBDYm9yRGF0YSB8IG51bWJlcltdXVtdfSBwYWlyTGlzdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzdGF0aWMgZW5jb2RlTWFwKHBhaXJMaXN0KSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUhlYWQoNSwgQmlnSW50KHBhaXJMaXN0Lmxlbmd0aCkpLmNvbmNhdChDYm9yRGF0YS5lbmNvZGVNYXBJbnRlcm5hbChwYWlyTGlzdCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEBwYXJhbSB7RGVjb2Rlcn0gcGFpckRlY29kZXJcblx0ICovXG5cdHN0YXRpYyBkZWNvZGVNYXAoYnl0ZXMsIHBhaXJEZWNvZGVyKSB7XG5cdFx0bGV0IFttLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXG5cdFx0YXNzZXJ0KG0gPT0gNSk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0cGFpckRlY29kZXIoaSwgYnl0ZXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc09iamVjdChieXRlcykge1xuXHRcdHJldHVybiBDYm9yRGF0YS5pc01hcChieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNYXA8bnVtYmVyLCBDYm9yRGF0YSB8IG51bWJlcltdPn0gb2JqZWN0XG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVPYmplY3Qob2JqZWN0KSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZU1hcChBcnJheS5mcm9tKG9iamVjdC5lbnRyaWVzKCkpLm1hcChwYWlyID0+IFtcblx0XHRcdENib3JEYXRhLmVuY29kZUludGVnZXIoQmlnSW50KHBhaXJbMF0pKSxcblx0XHRcdHBhaXJbMV1cblx0XHRdKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHBhcmFtIHtEZWNvZGVyfSBmaWVsZERlY29kZXJcblx0ICogQHJldHVybnMge1NldDxudW1iZXI+fVxuXHQgKi9cblx0c3RhdGljIGRlY29kZU9iamVjdChieXRlcywgZmllbGREZWNvZGVyKSB7XG5cdFx0LyoqIEB0eXBlIHtTZXQ8bnVtYmVyPn0gKi9cblx0XHRsZXQgZG9uZSA9IG5ldyBTZXQoKTtcblxuXHRcdENib3JEYXRhLmRlY29kZU1hcChieXRlcywgKF8sIHBhaXJCeXRlcykgPT4ge1xuXHRcdFx0bGV0IGkgPSBOdW1iZXIoQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihwYWlyQnl0ZXMpKTtcblxuXHRcdFx0ZmllbGREZWNvZGVyKGksIHBhaXJCeXRlcyk7XG5cdFx0XHRcblx0XHRcdGRvbmUuYWRkKGkpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRvbmU7XG5cdH1cblxuXHQvKipcblx0ICogVW5yZWxhdGVkIHRvIGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB0YWdcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0c3RhdGljIGVuY29kZVRhZyh0YWcpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlSGVhZCg2LCB0YWcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRzdGF0aWMgZGVjb2RlVGFnKGJ5dGVzKSB7XG5cdFx0bGV0IFttLCBuXSA9IENib3JEYXRhLmRlY29kZUhlYWQoYnl0ZXMpO1xuXG5cdFx0YXNzZXJ0KG0gPT0gNik7XG5cblx0XHRyZXR1cm4gbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0NvbnN0cihieXRlcykge1xuXHRcdGlmIChieXRlcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgY2JvciBieXRlc1wiKTtcblx0XHR9XG5cblx0XHRsZXQgW20sIF9dID0gQ2JvckRhdGEuZGVjb2RlSGVhZChieXRlcy5zbGljZSgwLCA5KSk7XG5cblx0XHRyZXR1cm4gbSA9PSA2O1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBhIGNvbnN0cnVjdG9yIHRhZyBvZiBhIENvbnN0ckRhdGEgdHlwZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGFnXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVDb25zdHJUYWcodGFnKSB7XG5cdFx0aWYgKHRhZyA+PSAwICYmIHRhZyA8PSA2KSB7XG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlSGVhZCg2LCAxMjFuICsgQmlnSW50KHRhZykpO1xuXHRcdH0gZWxzZSBpZiAodGFnID49IDcgJiYgdGFnIDw9IDEyNykge1xuXHRcdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUhlYWQoNiwgMTI4MG4gKyBCaWdJbnQodGFnIC0gNykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlSGVhZCg2LCAxMDJuKS5jb25jYXQoQ2JvckRhdGEuZW5jb2RlSGVhZCg0LCAybikpLmNvbmNhdChDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKEJpZ0ludCh0YWcpKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0YWdcblx0ICogQHBhcmFtIHtDYm9yRGF0YVtdIHwgbnVtYmVyW11bXX0gZmllbGRzXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBlbmNvZGVDb25zdHIodGFnLCBmaWVsZHMpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlQ29uc3RyVGFnKHRhZykuY29uY2F0KENib3JEYXRhLmVuY29kZUxpc3QoZmllbGRzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBkZWNvZGVDb25zdHJUYWcoYnl0ZXMpIHtcblx0XHQvLyBjb25zdHJcblx0XHRsZXQgW20sIG5dID0gQ2JvckRhdGEuZGVjb2RlSGVhZChieXRlcyk7XG5cblx0XHRhc3NlcnQobSA9PSA2KTtcblxuXHRcdGlmIChuIDwgMTI3bikge1xuXHRcdFx0cmV0dXJuIE51bWJlcihuIC0gMTIxbik7XG5cdFx0fSBlbHNlIGlmIChuID09IDEwMm4pIHtcblx0XHRcdGxldCBbbUNoZWNrLCBuQ2hlY2tdID0gQ2JvckRhdGEuZGVjb2RlSGVhZChieXRlcyk7XG5cdFx0XHRhc3NlcnQobUNoZWNrID09IDQgJiYgbkNoZWNrID09IDJuKTtcblxuXHRcdFx0cmV0dXJuIE51bWJlcihDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKGJ5dGVzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBOdW1iZXIobiAtIDEyODBuICsgN24pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YWdcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHBhcmFtIHtEZWNvZGVyfSBmaWVsZERlY29kZXJcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBkZWNvZGVDb25zdHIoYnl0ZXMsIGZpZWxkRGVjb2Rlcikge1xuXHRcdGxldCB0YWcgPSBDYm9yRGF0YS5kZWNvZGVDb25zdHJUYWcoYnl0ZXMpO1xuXG5cdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChieXRlcywgZmllbGREZWNvZGVyKTtcblxuXHRcdHJldHVybiB0YWc7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDY6IFVwbGMgZGF0YSB0eXBlc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBNaW4gbWVtb3J5IHVzZWQgYnkgYSBVcGxjRGF0YSB2YWx1ZSBkdXJpbmcgdmFsaWRhdGlvblxuICogQHBhY2thZ2VcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFVQTENfREFUQV9OT0RFX01FTV9TSVpFID0gNDtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBQbHV0dXMtY29yZSBkYXRhIGNsYXNzZXMgKG5vdCB0aGUgc2FtZSBhcyBQbHV0dXMtY29yZSB2YWx1ZSBjbGFzc2VzISlcbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNEYXRhIGV4dGVuZHMgQ2JvckRhdGEge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVzdGltYXRlIG9mIG1lbW9yeSB1c2FnZSBkdXJpbmcgdmFsaWRhdGlvblxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IG1lbVNpemUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wYXJlcyB0aGUgc2NoZW1hIGpzb25zXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IG90aGVyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNTYW1lKG90aGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9TY2hlbWFKc29uKCkgPT0gb3RoZXIudG9TY2hlbWFKc29uKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcltdfVxuXHQgKi9cblx0Z2V0IGJ5dGVzKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCBhIGJ5dGVhcnJheVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7YmlnaW50fVxuXHQgKi9cblx0Z2V0IGludCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gaW50XCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgaW5kZXgoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGEgY29uc3RyXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjRGF0YVtdfVxuXHQgKi9cblx0Z2V0IGZpZWxkcygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBjb25zdHJcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNEYXRhW119XG5cdCAqL1xuXHRnZXQgbGlzdCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBsaXN0XCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtbVXBsY0RhdGEsIFVwbGNEYXRhXVtdfVxuXHQgKi9cblx0Z2V0IG1hcCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBtYXBcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUigpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1NjaGVtYUpzb24oKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7VXBsY0RhdGF9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRpZiAodHlwZW9mIGJ5dGVzID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHJldHVybiBVcGxjRGF0YS5mcm9tQ2JvcihoZXhUb0J5dGVzKGJ5dGVzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChDYm9yRGF0YS5pc0xpc3QoYnl0ZXMpKSB7XG5cdFx0XHRcdHJldHVybiBMaXN0RGF0YS5mcm9tQ2JvcihieXRlcyk7XG5cdFx0XHR9IGVsc2UgaWYgKENib3JEYXRhLmlzSW5kZWZCeXRlcyhieXRlcykpIHtcblx0XHRcdFx0cmV0dXJuIEJ5dGVBcnJheURhdGEuZnJvbUNib3IoYnl0ZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKENib3JEYXRhLmlzRGVmQnl0ZXMoYnl0ZXMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEJ5dGVBcnJheURhdGEuZnJvbUNib3IoYnl0ZXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKENib3JEYXRhLmlzTWFwKGJ5dGVzKSkge1xuXHRcdFx0XHRcdHJldHVybiBNYXBEYXRhLmZyb21DYm9yKGJ5dGVzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChDYm9yRGF0YS5pc0NvbnN0cihieXRlcykpIHtcblx0XHRcdFx0XHRyZXR1cm4gQ29uc3RyRGF0YS5mcm9tQ2JvcihieXRlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gaW50LCBtdXN0IGNvbWUgbGFzdFxuXHRcdFx0XHRcdHJldHVybiBJbnREYXRhLmZyb21DYm9yKGJ5dGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGludCBkYXRhIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREYXRhIGV4dGVuZHMgVXBsY0RhdGEge1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge2JpZ2ludH1cblx0ICovXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgZ2V0dGVyXG5cdCAqIEB0eXBlIHtiaWdpbnR9XG5cdCAqL1xuXHRnZXQgaW50KCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBtZW0gc2l6ZSBvZiBhIGludGVnZXIgKHdpdGhvdXQgdGhlIERBVEFfTk9ERSBvdmVyaGVhZClcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBtZW1TaXplSW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IDBuKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgYWJzID0gdmFsdWUgPiAwbiA/IHZhbHVlIDogLXZhbHVlO1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLmZsb29yKE1hdGgubG9nMihOdW1iZXIoYWJzKSkpLzY0KSArIDE7XG5cdFx0fVxuICAgIH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBtZW1TaXplKCkge1xuXHRcdHJldHVybiBVUExDX0RBVEFfTk9ERV9NRU1fU0laRSArIEludERhdGEubWVtU2l6ZUludGVybmFsKHRoaXMuI3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBpbnRlZ2VyIGxpdGVyYWwgd3JhcHBlZCB3aXRoIGludGVnZXIgZGF0YSBmdW5jdGlvbiBjYWxsLlxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKCkge1xuXHRcdHJldHVybiBuZXcgSVIoYF9fY29yZV9faURhdGEoJHt0aGlzLiN2YWx1ZS50b1N0cmluZygpfSlgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0cmluZywgbm90IGpzIG9iamVjdCwgYmVjYXVzZSBvZiB1bmJvdW5kZWQgaW50ZWdlcnNcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU2NoZW1hSnNvbigpIHtcblx0XHRyZXR1cm4gYHtcImludFwiOiAke3RoaXMuI3ZhbHVlLnRvU3RyaW5nKCl9fWA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKHRoaXMuI3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7SW50RGF0YX1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdHJldHVybiBuZXcgSW50RGF0YShDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKGJ5dGVzKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBieXRlYXJyYXkgZGF0YSBjbGFzcy5cbiAqIFdyYXBzIGEgcmVndWxhciBsaXN0IG9mIHVpbnQ4IG51bWJlcnMgKHNvIG5vdCBVaW50OEFycmF5KVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZUFycmF5RGF0YSBleHRlbmRzIFVwbGNEYXRhIHtcblx0I2J5dGVzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoYnl0ZXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI2J5dGVzID0gYnl0ZXM7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB1dGYtOCBlbmNvZGluZ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc1xuXHQgKiBAcmV0dXJucyB7Qnl0ZUFycmF5RGF0YX1cblx0ICovXG5cdHN0YXRpYyBmcm9tU3RyaW5nKHMpIHtcblx0XHRsZXQgYnl0ZXMgPSB0ZXh0VG9CeXRlcyhzKTtcblxuXHRcdHJldHVybiBuZXcgQnl0ZUFycmF5RGF0YShieXRlcyk7XG5cdH1cblxuXHRnZXQgYnl0ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2J5dGVzLnNsaWNlKCk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1lbSBzaXplIG9mIGEgYnl0ZSBhcnJheSB3aXRob3V0IHRoZSBEQVRBX05PREUgb3ZlcmhlYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBtZW1TaXplSW50ZXJuYWwoYnl0ZXMpIHtcbiAgICAgICAgbGV0IG4gPSBieXRlcy5sZW5ndGg7XG5cdFx0aWYgKG4gPT09IDApIHtcblx0XHRcdHJldHVybiAxOyAvLyB0aGlzIGlzIHNvIGFubm95aW5nOiBoYXNrZWxsIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBzYXlzIGl0IHNob3VsZCBiZSAwLCBidXQgY3VycmVudCAoMjAyMjA5MjUpIHRlc3RuZXQgYW5kIG1haW5uZXQgc2V0dGluZ3Mgc2F5IGl0J3MgMVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigoYnl0ZXMubGVuZ3RoIC0gMSkvOCkgKyAxO1xuXHRcdH1cbiAgICB9XG5cblx0Z2V0IG1lbVNpemUoKSB7XG5cdFx0cmV0dXJuIFVQTENfREFUQV9OT0RFX01FTV9TSVpFICsgQnl0ZUFycmF5RGF0YS5tZW1TaXplSW50ZXJuYWwodGhpcy4jYnl0ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b0hleCgpIHtcblx0XHRyZXR1cm4gYnl0ZXNUb0hleCh0aGlzLiNieXRlcyk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYCMke3RoaXMudG9IZXgoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYnl0ZWFycmF5IGxpdGVyYWwgd3JhcHBlZCB3aXRoIGJ5dGVhcnJheSBkYXRhIGZ1bmN0aW9uIGFzIElSLlxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKCkge1xuXHRcdHJldHVybiBuZXcgSVIoYF9fY29yZV9fYkRhdGEoIyR7dGhpcy50b0hleCgpfSlgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TY2hlbWFKc29uKCkge1xuXHRcdHJldHVybiBge1wiYnl0ZXNcIjogXCIke3RoaXMudG9IZXgoKX1cIn1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHRvQ2JvcigpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlQnl0ZXModGhpcy4jYnl0ZXMsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtCeXRlQXJyYXlEYXRhfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0cmV0dXJuIG5ldyBCeXRlQXJyYXlEYXRhKENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQnl0ZWFycmF5IGNvbXBhcmlzb24sIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBzb3J0aW5nIGJ5dGVhcnJheXNcblx0ICogQGV4YW1wbGVcblx0ICogQnl0ZUFycmF5RGF0YS5jb21wKGhleFRvQnl0ZXMoXCIwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxXCIpLCBoZXhUb0J5dGVzKFwiMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMlwiKSkgPT4gLTFcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBiXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCAtPiBlcXVhbHMsIDEgLT4gZ3QsIC0xIC0+IGx0XG5cdCAqL1xuXHRzdGF0aWMgY29tcChhLCBiKSB7XG5cdFx0LyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cdFx0ZnVuY3Rpb24gbGVzc1RoYW4oKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7IGkrKykge1xuXHRcdFx0XHRpZiAoYVtpXSAhPSBiW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFbaV0gPCBiW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhLmxlbmd0aCA8IGIubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG5cdFx0ZnVuY3Rpb24gbGVzc09yR3JlYXRlcigpIHtcblx0XHRcdHJldHVybiBsZXNzVGhhbigpID8gLTEgOiAxO1xuXHRcdH1cblxuXHRcdGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGxlc3NPckdyZWF0ZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhW2ldICE9IGJbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGVzc09yR3JlYXRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGxpc3QgZGF0YSBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgTGlzdERhdGEgZXh0ZW5kcyBVcGxjRGF0YSB7XG5cdCNpdGVtcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YVtdfSBpdGVtc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoaXRlbXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI2l0ZW1zID0gaXRlbXM7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNEYXRhW119XG5cdCAqL1xuXHRnZXQgbGlzdCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jaXRlbXMuc2xpY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IG1lbVNpemUoKSB7XG5cdFx0bGV0IHN1bSA9IFVQTENfREFUQV9OT0RFX01FTV9TSVpFO1xuXG5cdFx0Zm9yIChsZXQgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuXHRcdFx0c3VtICs9IGl0ZW0ubWVtU2l6ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBbJHt0aGlzLiNpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKCkge1xuXHRcdGxldCBpciA9IG5ldyBJUihcIl9fY29yZV9fbWtOaWxEYXRhKCgpKVwiKTtcblx0XHRmb3IgKGxldCBpID0gdGhpcy4jaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlyID0gbmV3IElSKFtuZXcgSVIoXCJfX2NvcmVfX21rQ29ucyhcIiksIHRoaXMuI2l0ZW1zW2ldLnRvSVIoKSwgbmV3IElSKFwiLCBcIiksIGlyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUihbbmV3IElSKFwiX19jb3JlX19saXN0RGF0YShcIiksIGlyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU2NoZW1hSnNvbigpIHtcblx0XHRyZXR1cm4gYHtcImxpc3RcIjpbJHt0aGlzLiNpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnRvU2NoZW1hSnNvbigpKS5qb2luKFwiLCBcIil9XX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHRvQ2JvcigpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlTGlzdCh0aGlzLiNpdGVtcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge0xpc3REYXRhfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1VwbGNEYXRhW119XG5cdFx0ICovXG5cdFx0bGV0IGxpc3QgPSBbXTtcblxuXHRcdENib3JEYXRhLmRlY29kZUxpc3QoYnl0ZXMsIChfLCBpdGVtQnl0ZXMpID0+IHtcblx0XHRcdGxpc3QucHVzaChVcGxjRGF0YS5mcm9tQ2JvcihpdGVtQnl0ZXMpKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXcgTGlzdERhdGEobGlzdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBtYXAgZGF0YSBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgTWFwRGF0YSBleHRlbmRzIFVwbGNEYXRhIHtcblx0I3BhaXJzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1tVcGxjRGF0YSwgVXBsY0RhdGFdW119IHBhaXJzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYWlycykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jcGFpcnMgPSBwYWlycztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7W1VwbGNEYXRhLCBVcGxjRGF0YV1bXX1cblx0ICovXG5cdGdldCBtYXAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3BhaXJzLnNsaWNlKCk7XG5cdH1cblxuXHRnZXQgbWVtU2l6ZSgpIHtcblx0XHRsZXQgc3VtID0gVVBMQ19EQVRBX05PREVfTUVNX1NJWkU7XG5cblx0XHRmb3IgKGxldCBbaywgdl0gb2YgdGhpcy4jcGFpcnMpIHtcblx0XHRcdHN1bSArPSBrLm1lbVNpemUgKyB2Lm1lbVNpemU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgeyR7dGhpcy4jcGFpcnMubWFwKChbZnN0LCBzbmRdKSA9PiBgJHtmc3QudG9TdHJpbmcoKX06ICR7c25kLnRvU3RyaW5nKCl9YCkuam9pbihcIiwgXCIpfX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoKSB7XG5cdFx0bGV0IGlyID0gbmV3IElSKFwiX19jb3JlX19ta05pbFBhaXJEYXRhKCgpKVwiKTtcblxuXHRcdGZvciAobGV0IGkgPSB0aGlzLiNwYWlycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGEgPSB0aGlzLiNwYWlyc1tpXVswXS50b0lSKCk7XG5cdFx0XHRsZXQgYiA9IHRoaXMuI3BhaXJzW2ldWzFdLnRvSVIoKTtcblxuXHRcdFx0aXIgPSBuZXcgSVIoW25ldyBJUihcIl9fY29yZV9fbWtDb25zKF9fY29yZV9fbWtQYWlyRGF0YShcIiksIGEsIG5ldyBJUihcIiwgXCIpLCBiLCBuZXcgSVIoXCIsIFwiKSwgbmV3IElSKFwiKVwiKSwgbmV3IElSKFwiLCBcIiksIGlyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUihbbmV3IElSKFwiX19jb3JlX19tYXBEYXRhKFwiKSwgaXIsIG5ldyBJUihcIilcIildKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TY2hlbWFKc29uKCkge1xuXHRcdHJldHVybiBge1wibWFwXCI6IFske3RoaXMuI3BhaXJzLm1hcChwYWlyID0+IHsgcmV0dXJuIFwie1xcXCJrXFxcIjogXCIgKyBwYWlyWzBdLnRvU2NoZW1hSnNvbigpICsgXCIsIFxcXCJ2XFxcIjogXCIgKyBwYWlyWzFdLnRvU2NoZW1hSnNvbigpICsgXCJ9XCIgfSkuam9pbihcIiwgXCIpfV19YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZU1hcCh0aGlzLiNwYWlycyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge01hcERhdGF9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7W1VwbGNEYXRhLCBVcGxjRGF0YV1bXX1cblx0XHQgKi9cblx0XHRsZXQgcGFpcnMgPSBbXTtcblxuXHRcdENib3JEYXRhLmRlY29kZU1hcChieXRlcywgKF8sIHBhaXJCeXRlcykgPT4ge1xuXHRcdFx0cGFpcnMucHVzaChbVXBsY0RhdGEuZnJvbUNib3IocGFpckJ5dGVzKSwgVXBsY0RhdGEuZnJvbUNib3IocGFpckJ5dGVzKV0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG5ldyBNYXBEYXRhKHBhaXJzKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGNvbnN0cnVjdGVkIGRhdGEgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0ckRhdGEgZXh0ZW5kcyBVcGxjRGF0YSB7XG5cdCNpbmRleDtcblx0I2ZpZWxkcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7VXBsY0RhdGFbXX0gZmllbGRzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihpbmRleCwgZmllbGRzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNpbmRleCA9IGluZGV4O1xuXHRcdHRoaXMuI2ZpZWxkcyA9IGZpZWxkcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IGluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLiNpbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY0RhdGFbXX1cblx0ICovXG5cdGdldCBmaWVsZHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZpZWxkcy5zbGljZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcblx0XHRsZXQgc3VtID0gVVBMQ19EQVRBX05PREVfTUVNX1NJWkU7XG5cblx0XHRmb3IgKGxldCBmaWVsZCBvZiB0aGlzLiNmaWVsZHMpIHtcblx0XHRcdHN1bSArPSBmaWVsZC5tZW1TaXplO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdW07XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdGxldCBwYXJ0cyA9IHRoaXMuI2ZpZWxkcy5tYXAoZmllbGQgPT4gZmllbGQudG9TdHJpbmcoKSk7XG5cdFx0cmV0dXJuIGAke3RoaXMuI2luZGV4LnRvU3RyaW5nKCl9eyR7cGFydHMuam9pbihcIiwgXCIpfX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoKSB7XG5cdFx0bGV0IGlyID0gbmV3IElSKFwiX19jb3JlX19ta05pbERhdGEoKCkpXCIpO1xuXHRcdGZvciAobGV0IGkgPSB0aGlzLiNmaWVsZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlyID0gbmV3IElSKFtuZXcgSVIoXCJfX2NvcmVfX21rQ29ucyhcIiksIHRoaXMuI2ZpZWxkc1tpXS50b0lSKCksIG5ldyBJUihcIiwgXCIpLCBpciwgbmV3IElSKFwiKVwiKV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgSVIoW25ldyBJUihcIl9fY29yZV9fY29uc3RyRGF0YShcIiksIG5ldyBJUih0aGlzLiNpbmRleC50b1N0cmluZygpKSwgbmV3IElSKFwiLCBcIiksIGlyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU2NoZW1hSnNvbigpIHtcblx0XHRyZXR1cm4gYHtcImNvbnN0cnVjdG9yXCI6ICR7dGhpcy4jaW5kZXgudG9TdHJpbmcoKX0sIFwiZmllbGRzXCI6IFske3RoaXMuI2ZpZWxkcy5tYXAoZiA9PiBmLnRvU2NoZW1hSnNvbigpKS5qb2luKFwiLCBcIil9XX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHRvQ2JvcigpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlQ29uc3RyKHRoaXMuI2luZGV4LCB0aGlzLiNmaWVsZHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1VwbGNEYXRhW119XG5cdFx0ICovXG5cdFx0bGV0IGZpZWxkcyA9IFtdO1xuXG5cdFx0bGV0IHRhZyA9IENib3JEYXRhLmRlY29kZUNvbnN0cihieXRlcywgKF8sIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdGZpZWxkcy5wdXNoKFVwbGNEYXRhLmZyb21DYm9yKGZpZWxkQnl0ZXMpKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSh0YWcsIGZpZWxkcyk7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiA3OiBIZWxpb3MgZGF0YSBvYmplY3RzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBCYXNlLXR5cGUgb2YgYWxsIGRhdGEtdHlwZXMgdGhhdCBleGlzdCBib3RoIG9uLSBhbmQgb2ZmLWNoYWluLCBhbmQgbWFwIGRpcmVjdGx5IHRvIEhlbGlvcyBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWxpb3NEYXRhIGV4dGVuZHMgQ2JvckRhdGEge1xuXHRjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogTmFtZSBiZWdpbnMgd2l0aCB1bmRlcnNjb3JlIHNvIGl0IGNhbiBuZXZlciBjb25mbGljdCB3aXRoIHN0cnVjdHVyZSBmaWVsZCBuYW1lcy5cbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgKi9cblx0X3RvVXBsY0RhdGEoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cdHRvU2NoZW1hSnNvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9VcGxjRGF0YSgpLnRvU2NoZW1hSnNvbigpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtIZWxpb3NEYXRhfSBUXG4gKiBAdHlwZWRlZiB7e1xuICogICBuZXcoLi4uYXJnczogYW55W10pOiBUO1xuICogICBmcm9tVXBsY0Nib3I6IChieXRlczogKHN0cmluZyB8IG51bWJlcltdKSkgPT4gVCxcbiAqICAgZnJvbVVwbGNEYXRhOiAoZGF0YTogVXBsY0RhdGEpID0+IFRcbiAqIH19IEhlbGlvc0RhdGFDbGFzc1xuICovXG5cbi8qKlxuICogSGVsaW9zIEludCB0eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBISW50IGV4dGVuZHMgSGVsaW9zRGF0YSB7XG4gICAgLyoqIFxuICAgICAqIEB0eXBlIHtiaWdpbnR9IFxuICAgICAqL1xuICAgICN2YWx1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBiaWdpbnQgfCBzdHJpbmd9IHJhd1ZhbHVlXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChyYXdWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkgIT0gcmF3VmFsdWUudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGEgdmFsaWQgaW50ZWdlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IGJpZ2ludCB8IHN0cmluZ30gcmF3VmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYXdWYWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuI3ZhbHVlID0gSEludC5jbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YmlnaW50fVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHJldHVybnMge1VwbGNEYXRhfVxuICAgICAqL1xuICAgIF90b1VwbGNEYXRhKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludERhdGEodGhpcy4jdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SEludH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBISW50KGRhdGEuaW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlc1xuICAgICAqIEByZXR1cm5zIHtISW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIEhJbnQuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1pbGxpc2Vjb25kcyBzaW5jZSAxIGphbiAxOTcwXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lIGV4dGVuZHMgSEludCB7XG4gICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBiaWdpbnQgfCBzdHJpbmcgfCBEYXRlfSByYXdWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICovXG4gICAgICBzdGF0aWMgY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSkge1xuXG4gICAgICAgIGlmIChyYXdWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQocmF3VmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KHJhd1ZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkgIT0gcmF3VmFsdWUudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIHZhbGlkIGludGVnZXJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgYmlnaW50IHwgc3RyaW5nIHwgRGF0ZX0gcmF3VmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYXdWYWx1ZSkge1xuICAgICAgICBzdXBlcihUaW1lLmNsZWFuQ29uc3RydWN0b3JBcmcocmF3VmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhXG4gICAgICogQHJldHVybnMge1RpbWV9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZShkYXRhLmludCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7VGltZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBUaW1lLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEaWZmZXJlbmNlIGJldHdlZW4gdHdvIHRpbWUgdmFsdWVzIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIER1cmF0aW9uIGV4dGVuZHMgSEludCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtEdXJhdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbihkYXRhLmludCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7RHVyYXRpb259XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VcGxjQ2JvcihieXRlcykge1xuICAgICAgICByZXR1cm4gRHVyYXRpb24uZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbGlvcyBCb29sIHR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2wgZXh0ZW5kcyBIZWxpb3NEYXRhIHtcbiAgICAvKiogXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxuICAgICAqL1xuICAgICN2YWx1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHBhcmFtIHtib29sZWFuIHwgc3RyaW5nfSByYXdWYWx1ZSBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChyYXdWYWx1ZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhd1ZhbHVlID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIHZhbGlkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEJvb2xcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd1ZhbHVlID09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBjb252ZXJ0IHRvIGJvb2xlYW5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCBzdHJpbmd9IHJhd1ZhbHVlIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhd1ZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCb29sLmNsZWFuQ29uc3RydWN0b3JBcmcocmF3VmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBib29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHJldHVybnMge1VwbGNEYXRhfVxuICAgICAqL1xuICAgIF90b1VwbGNEYXRhKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0ckRhdGEodGhpcy4jdmFsdWUgPyAxIDogMCwgW10pO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhXG4gICAgICogQHJldHVybnMge0Jvb2x9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG4gICAgICAgIGFzc2VydChkYXRhLmZpZWxkcy5sZW5ndGggPT0gMCwgXCJib29sIGRhdGEgY2FuJ3QgaGF2ZSBmaWVsZHNcIik7XG5cbiAgICAgICAgaWYgKGRhdGEuaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmluZGV4ID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIDAgb3IgMSBmb3IgQ29uc3RyRGF0YSByZXByZXNlbnRpbmcgQm9vbFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuICAgICAqIEByZXR1cm5zIHtCb29sfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIEJvb2wuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbGlvcyBTdHJpbmcgdHlwZS5cbiAqIENhbid0IGJlIG5hbWVkICdTdHJpbmcnIGJlY2F1c2UgdGhhdCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgamF2YXNjcmlwdCAnU3RyaW5nJy10eXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBIU3RyaW5nIGV4dGVuZHMgSGVsaW9zRGF0YSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICAjdmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgKi9cbiAgICBfdG9VcGxjRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlEYXRhKHRleHRUb0J5dGVzKHRoaXMuI3ZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcbiAgICAgKiBAcmV0dXJucyB7SFN0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIU3RyaW5nKGJ5dGVzVG9UZXh0KGRhdGEuYnl0ZXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcbiAgICAgKiBAcmV0dXJucyB7SFN0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBIU3RyaW5nLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxpb3MgQnl0ZUFycmF5IHR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5dGVBcnJheSBleHRlbmRzIEhlbGlvc0RhdGEge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICAjYnl0ZXM7XG5cbiAgICAvKipcbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IHJhd1ZhbHVlIFxuICAgICAqL1xuICAgIHN0YXRpYyBjbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXdWYWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocmF3VmFsdWUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgICAgICByYXdWYWx1ZSA9IHJhd1ZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhyYXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJ5dGVzIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSByYXdWYWx1ZSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYXdWYWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuI2J5dGVzID0gQnl0ZUFycmF5LmNsZWFuQ29uc3RydWN0b3JBcmcocmF3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgYnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNieXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBoZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMuI2J5dGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgKi9cbiAgICBfdG9VcGxjRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQXJyYXlEYXRhKHRoaXMuI2J5dGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuICAgICAqIEByZXR1cm5zIHtCeXRlQXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZUFycmF5KGRhdGEuYnl0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzXG4gICAgICogQHJldHVybnMge0J5dGVBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBCeXRlQXJyYXkuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIER5bmFtaWNhbGx5IGNvbnN0cnVjdHMgYSBuZXcgTGlzdCBjbGFzcywgZGVwZW5kaW5nIG9uIHRoZSBpdGVtIHR5cGUuXG4gKiBAdGVtcGxhdGUge0hlbGlvc0RhdGF9IFRcbiAqIEBwYXJhbSB7SGVsaW9zRGF0YUNsYXNzPFQ+fSBJdGVtQ2xhc3NcbiAqIEByZXR1cm5zIHtIZWxpb3NEYXRhQ2xhc3M8SExpc3RfPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhMaXN0KEl0ZW1DbGFzcykge1xuICAgIGFzc2VydCghbmV3LnRhcmdldCwgXCJMaXN0IGNhbid0IGJlIGNhbGxlZCB3aXRoIG5ld1wiKTtcbiAgICBhc3NlcnQoSXRlbUNsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIEhlbGlvc0RhdGEpO1xuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBgW10ke0l0ZW1DbGFzcy5uYW1lfWA7XG5cbiAgICBjbGFzcyBITGlzdF8gZXh0ZW5kcyBIZWxpb3NEYXRhIHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBAdHlwZSB7VFtdfSBcbiAgICAgICAgICovXG4gICAgICAgICNpdGVtcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHthbnlbXX0gcmF3TGlzdCBcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd0xpc3QpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuI2l0ZW1zID0gcmF3TGlzdC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVtQ2xhc3MoaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhY2thZ2VcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldCBfbGlzdFR5cGVOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJsb2FkICdpbnN0YW5jZW9mJyBvcGVyYXRvclxuICAgICAgICAgKiBAcGFja2FnZVxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb3RoZXIgXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLl9saXN0VHlwZU5hbWUgPT09IHR5cGVOYW1lKSAmJiAob3RoZXIgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7VFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2l0ZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYWNrYWdlXG4gICAgICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIF90b1VwbGNEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0RGF0YSh0aGlzLiNpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLl90b1VwbGNEYXRhKCkpKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG4gICAgICAgICAqIEByZXR1cm5zIHtITGlzdF99XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSExpc3RfKGRhdGEubGlzdC5tYXAoZCA9PiBJdGVtQ2xhc3MuZnJvbVVwbGNEYXRhKGQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXMgXG4gICAgICAgICAqIEByZXR1cm5zIHtITGlzdF99XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gSExpc3RfLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhMaXN0XywgXCJuYW1lXCIsIHtcbiAgICAgICAgdmFsdWU6IHR5cGVOYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIHJldHVybiBITGlzdF87XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtIZWxpb3NEYXRhfSBUS2V5XG4gKiBAdGVtcGxhdGUge0hlbGlvc0RhdGF9IFRWYWx1ZVxuICogQHBhcmFtIHtIZWxpb3NEYXRhQ2xhc3M8VEtleT59IEtleUNsYXNzIFxuICogQHBhcmFtIHtIZWxpb3NEYXRhQ2xhc3M8VFZhbHVlPn0gVmFsdWVDbGFzc1xuICogQHJldHVybnMge0hlbGlvc0RhdGFDbGFzczxITWFwXz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBITWFwKEtleUNsYXNzLCBWYWx1ZUNsYXNzKSB7XG4gICAgYXNzZXJ0KCFuZXcudGFyZ2V0LCBcIkhNYXAgY2FuJ3QgYmUgY2FsbGVkIHdpdGggbmV3XCIpO1xuICAgIGFzc2VydChLZXlDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKTtcbiAgICBhc3NlcnQoVmFsdWVDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKTtcbiAgICBcbiAgICBjb25zdCB0eXBlTmFtZSA9IGBNYXBbJHtLZXlDbGFzcy5uYW1lfV0ke1ZhbHVlQ2xhc3MubmFtZX1gO1xuXG4gICAgY2xhc3MgSE1hcF8gZXh0ZW5kcyBIZWxpb3NEYXRhIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtbVEtleSwgVFZhbHVlXVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgI3BhaXJzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFja2FnZVxuICAgICAgICAgKiBAcGFyYW0gey4uLmFueX0gYXJnc1xuICAgICAgICAgKiBAcmV0dXJucyB7W2FueSwgYW55XVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNsZWFuQ29uc3RydWN0b3JBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7W2FueSwgYW55XVtdfSAqL1xuICAgICAgICAgICAgbGV0IHBhaXJzID0gW107XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhNYXBfLmNsZWFuQ29uc3RydWN0b3JBcmdzKEFycmF5LmZyb20oYXJnLmVudHJpZXMoKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBhcnJheSBvciBNYXAgYXJnXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxzdCA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICBwYWlycyA9IGxzdC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBhcnJheSBpdGVtIChwYWlyKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGFycmF5IGl0ZW0gb2YgbGVuZ3RoIDIgKHBhaXIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2l0ZW1bMF0sIGl0ZW1bMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBba2V5cywgdmFsdWVzXSA9IGFyZ3M7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQga2V5cyBhcnJheSBhcmdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHZhbHVlcyBhcnJheSBhcmdcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCAhPSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgYW5kIHZhbHVlcyBsaXN0IGRvbid0IGhhdmUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMgPSBrZXlzLm1hcCgoa2V5LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG51bWJlciBvZiBhcmdzXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCByYXdQYWlycyA9IEhNYXBfLmNsZWFuQ29uc3RydWN0b3JBcmdzKC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtbVEtleSwgVFZhbHVlXVtdfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwYWlycyA9IHJhd1BhaXJzLm1hcCgoW3Jhd0tleSwgcmF3VmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdLZXkgaW5zdGFuY2VvZiBLZXlDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd0tleTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5Q2xhc3MocmF3S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZSBpbnN0YW5jZW9mIFZhbHVlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVDbGFzcyhyYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuI3BhaXJzID0gcGFpcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhY2thZ2VcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldCBfbWFwVHlwZU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZU5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmxvYWQgJ2luc3RhbmNlb2YnIG9wZXJhdG9yXG4gICAgICAgICAqIEBwYWNrYWdlXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvdGhlciBcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0ob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIuX21hcFR5cGVOYW1lID09PSB0eXBlTmFtZSkgJiYgKG90aGVyIGluc3RhbmNlb2YgSGVsaW9zRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1tUS2V5LCBUVmFsdWVdW119XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcGFpcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcGFpcnM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhY2thZ2VcbiAgICAgICAgICogQHJldHVybnMge1VwbGNEYXRhfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RvVXBsY0RhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcERhdGEodGhpcy4jcGFpcnMubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXkuX3RvVXBsY0RhdGEoKSwgdmFsdWUuX3RvVXBsY0RhdGEoKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuICAgICAgICAgKiBAcmV0dXJucyB7SE1hcF99XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSE1hcF8oZGF0YS5tYXAubWFwKChba2QsIHZkXSkgPT4gW0tleUNsYXNzLmZyb21VcGxjRGF0YShrZCksIFZhbHVlQ2xhc3MuZnJvbVVwbGNEYXRhKHZkKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcbiAgICAgICAgICogQHJldHVybnMge0hNYXBffVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21VcGxjQ2JvcihieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIEhNYXBfLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhNYXBfLCBcIm5hbWVcIiwge1xuICAgICAgICB2YWx1ZTogdHlwZU5hbWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEhNYXBfO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7SGVsaW9zRGF0YX0gVFxuICogQHBhcmFtIHtIZWxpb3NEYXRhQ2xhc3M8VD59IFNvbWVDbGFzc1xuICogQHJldHVybnMge0hlbGlvc0RhdGFDbGFzczxPcHRpb25fPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wdGlvbihTb21lQ2xhc3MpIHtcbiAgICBhc3NlcnQoIW5ldy50YXJnZXQsIFwiT3B0aW9uIGNhbid0IGJlIGNhbGxlZCB3aXRoIG5ld1wiKTtcbiAgICBhc3NlcnQoU29tZUNsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIEhlbGlvc0RhdGEpO1xuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBgT3B0aW9uWyR7U29tZUNsYXNzLm5hbWV9XWA7XG5cbiAgICBjbGFzcyBPcHRpb25fIGV4dGVuZHMgSGVsaW9zRGF0YSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7P1R9XG4gICAgICAgICAqL1xuICAgICAgICAjdmFsdWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYWNrYWdlXG4gICAgICAgICAqIEBwYXJhbSB7P2FueX0gcmF3VmFsdWUgXG4gICAgICAgICAqIEByZXR1cm5zIHs/VH1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocmF3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJhd1ZhbHVlIGluc3RhbmNlb2YgU29tZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29tZUNsYXNzKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBAcGFyYW0gez9hbnl9IHJhd1ZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihyYXdWYWx1ZSA9IG51bGwpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuI3ZhbHVlID0gT3B0aW9uXy5jbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFja2FnZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IF9vcHRpb25UeXBlTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVybG9hZCAnaW5zdGFuY2VvZicgb3BlcmF0b3JcbiAgICAgICAgICogQHBhY2thZ2VcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG90aGVyIFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlci5fb3B0aW9uVHlwZU5hbWUgPT09IHR5cGVOYW1lKSAmJiAob3RoZXIgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7P1R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc29tZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFja2FnZVxuICAgICAgICAgKiBAcmV0dXJucyB7VXBsY0RhdGF9XG4gICAgICAgICAqL1xuICAgICAgICBfdG9VcGxjRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RyRGF0YSh0aGlzLiN2YWx1ZSA9PT0gbnVsbCA/IDEgOiAwLCB0aGlzLiN2YWx1ZSA9PT0gbnVsbCA/IFtdIDogW3RoaXMuI3ZhbHVlLl90b1VwbGNEYXRhKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuICAgICAgICAgKiBAcmV0dXJucyB7T3B0aW9uX31cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaW5kZXggPT0gMSkge1xuICAgICAgICAgICAgICAgIGFzc2VydChkYXRhLmZpZWxkcy5sZW5ndGggPT0gMCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbl8obnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChkYXRhLmZpZWxkcy5sZW5ndGggPT0gMSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbl8oU29tZUNsYXNzLmZyb21VcGxjRGF0YShkYXRhLmZpZWxkc1swXSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgb3B0aW9uIGNvbnN0ciBpbmRleFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7T3B0aW9uX31cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25fLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhMaXN0LCBcIm5hbWVcIiwge1xuICAgICAgICB2YWx1ZTogdHlwZU5hbWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9wdGlvbl87XG59XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBoYXNoLXR5cGVzXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBIYXNoIGV4dGVuZHMgSGVsaW9zRGF0YSB7XG5cdC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG5cdCNieXRlcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gcmF3VmFsdWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHN0YXRpYyBjbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiByYXdWYWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gaGV4VG9CeXRlcyhyYXdWYWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByYXdWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihieXRlcykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jYnl0ZXMgPSBieXRlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRnZXQgYnl0ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2J5dGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgaGV4KCkge1xuXHRcdHJldHVybiBieXRlc1RvSGV4KHRoaXMuI2J5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUJ5dGVzKHRoaXMuI2J5dGVzKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1VwbGNEYXRhfVxuICAgICAqL1xuICAgIF90b1VwbGNEYXRhKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVBcnJheURhdGEodGhpcy4jYnl0ZXMpO1xuICAgIH1cblxuXHQvKipcblx0ICogVXNlZCBpbnRlcm5hbGx5IGZvciBtZXRhZGF0YUhhc2ggYW5kIHNjcmlwdERhdGFIYXNoXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdHJldHVybiBuZXcgSGFzaChDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1pZ2h0IGJlIG5lZWRlZCBmb3IgaW50ZXJuYWwgdXNlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgXG5cdCAqIEByZXR1cm5zIHtIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21IZXgoc3RyKSB7XG5cdFx0cmV0dXJuIG5ldyBIYXNoKGhleFRvQnl0ZXMoc3RyKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIGJ5dGVzVG9IZXgodGhpcy4jYnl0ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SGFzaH0gb3RoZXJcblx0ICovXG5cdGVxKG90aGVyKSB7XG5cdFx0cmV0dXJuIGVxKHRoaXMuI2J5dGVzLCBvdGhlci4jYnl0ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SGFzaH0gYSBcblx0ICogQHBhcmFtIHtIYXNofSBiIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c3RhdGljIGNvbXBhcmUoYSwgYikge1xuXHRcdHJldHVybiBCeXRlQXJyYXlEYXRhLmNvbXAoYS4jYnl0ZXMsIGIuI2J5dGVzKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgRGF0dW1IYXNoIGV4dGVuZHMgSGFzaCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSByYXdWYWx1ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocmF3VmFsdWUpIHtcblx0XHRjb25zdCBieXRlcyA9IEhhc2guY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSk7XG5cblx0XHRhc3NlcnQoYnl0ZXMubGVuZ3RoID09IDMyKTtcblx0XHRzdXBlcihieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtEYXR1bUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IERhdHVtSGFzaChDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdCAqIEByZXR1cm5zIHtEYXR1bUhhc2h9XG5cdCAqL1xuXHQgc3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXR1bUhhc2goZGF0YS5ieXRlcyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge0RhdHVtSGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gRGF0dW1IYXNoLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgXG5cdCAqIEByZXR1cm5zIHtEYXR1bUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUhleChzdHIpIHtcblx0XHRyZXR1cm4gbmV3IERhdHVtSGFzaChoZXhUb0J5dGVzKHN0cikpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQdWJLZXlIYXNoIGV4dGVuZHMgSGFzaCB7XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gcmF3VmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihyYXdWYWx1ZSkge1xuXHRcdGNvbnN0IGJ5dGVzID0gSGFzaC5jbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKTtcblxuXHRcdGFzc2VydChieXRlcy5sZW5ndGggPT0gMjgsIGBleHBlY3RlZCAyOCBieXRlcyBmb3IgUHViS2V5SGFzaCwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuXHRcdHN1cGVyKGJ5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge1B1YktleUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFB1YktleUhhc2goQ2JvckRhdGEuZGVjb2RlQnl0ZXMoYnl0ZXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuXHQgKiBAcmV0dXJucyB7UHViS2V5SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSkge1xuXHRcdHJldHVybiBuZXcgUHViS2V5SGFzaChkYXRhLmJ5dGVzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7UHViS2V5SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gUHViS2V5SGFzaC5mcm9tVXBsY0RhdGEoVXBsY0RhdGEuZnJvbUNib3IoYnl0ZXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFxuXHQgKiBAcmV0dXJucyB7UHViS2V5SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tSGV4KHN0cikge1xuXHRcdHJldHVybiBuZXcgUHViS2V5SGFzaChoZXhUb0J5dGVzKHN0cikpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBTY3JpcHRIYXNoIGV4dGVuZHMgSGFzaCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSByYXdWYWx1ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocmF3VmFsdWUpIHtcblx0XHRjb25zdCBieXRlcyA9IEhhc2guY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSk7XG5cblx0XHRhc3NlcnQoYnl0ZXMubGVuZ3RoID09IDI4LCBgZXhwZWN0ZWQgMjggYnl0ZXMgZm9yIFNjcmlwdEhhc2gsIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcblx0XHRzdXBlcihieXRlcyk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pbnRpbmdQb2xpY3lIYXNoIGV4dGVuZHMgU2NyaXB0SGFzaCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge01pbnRpbmdQb2xpY3lIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0cmV0dXJuIG5ldyBNaW50aW5nUG9saWN5SGFzaChDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdCAqIEByZXR1cm5zIHtNaW50aW5nUG9saWN5SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSkge1xuXHRcdHJldHVybiBuZXcgTWludGluZ1BvbGljeUhhc2goZGF0YS5ieXRlcyk7XG5cdH1cblx0XHRcdFxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtNaW50aW5nUG9saWN5SGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gTWludGluZ1BvbGljeUhhc2guZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcblx0ICogQHJldHVybnMge01pbnRpbmdQb2xpY3lIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21IZXgoc3RyKSB7XG5cdFx0cmV0dXJuIG5ldyBNaW50aW5nUG9saWN5SGFzaChoZXhUb0J5dGVzKHN0cikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgYXMgYmVjaDMyIHN0cmluZyB1c2luZyAnYXNzZXQnIGFzIGh1bWFuIHJlYWRhYmxlIHBhcnRcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvQmVjaDMyKCkge1xuXHRcdHJldHVybiBDcnlwdG8uZW5jb2RlQmVjaDMyKFwiYXNzZXRcIiwgQ3J5cHRvLmJsYWtlMmIodGhpcy5ieXRlcywgMjApKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU3Rha2VLZXlIYXNoIGV4dGVuZHMgSGFzaCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSByYXdWYWx1ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocmF3VmFsdWUpIHtcblx0XHRjb25zdCBieXRlcyA9IEhhc2guY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSk7XG5cdFx0XG5cdFx0YXNzZXJ0KGJ5dGVzLmxlbmd0aCA9PSAyOCwgYGV4cGVjdGVkIDI4IGJ5dGVzIGZvciBTdGFrZUtleUhhc2gsIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcblx0XHRzdXBlcihieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtTdGFrZUtleUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFN0YWtlS2V5SGFzaChDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdCAqIEByZXR1cm5zIHtTdGFrZUtleUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcblx0XHRyZXR1cm4gbmV3IFN0YWtlS2V5SGFzaChkYXRhLmJ5dGVzKTtcblx0fVxuXHRcdFxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtTdGFrZUtleUhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG5cdFx0cmV0dXJuIFN0YWtlS2V5SGFzaC5mcm9tVXBsY0RhdGEoVXBsY0RhdGEuZnJvbUNib3IoYnl0ZXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFxuXHQgKiBAcmV0dXJucyB7U3Rha2VLZXlIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21IZXgoc3RyKSB7XG5cdFx0cmV0dXJuIG5ldyBTdGFrZUtleUhhc2goaGV4VG9CeXRlcyhzdHIpKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU3Rha2luZ1ZhbGlkYXRvckhhc2ggZXh0ZW5kcyBTY3JpcHRIYXNoIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7U3Rha2luZ1ZhbGlkYXRvckhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoKENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcblx0ICogQHJldHVybnMge1N0YWtpbmdWYWxpZGF0b3JIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBTdGFraW5nVmFsaWRhdG9ySGFzaChkYXRhLmJ5dGVzKTtcblx0fVxuXHRcdFx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge1N0YWtpbmdWYWxpZGF0b3JIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21VcGxjQ2JvcihieXRlcykge1xuXHRcdHJldHVybiBTdGFraW5nVmFsaWRhdG9ySGFzaC5mcm9tVXBsY0RhdGEoVXBsY0RhdGEuZnJvbUNib3IoYnl0ZXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFxuXHQgKiBAcmV0dXJucyB7U3Rha2luZ1ZhbGlkYXRvckhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUhleChzdHIpIHtcblx0XHRyZXR1cm4gbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoKGhleFRvQnl0ZXMoc3RyKSk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRvckhhc2ggZXh0ZW5kcyBTY3JpcHRIYXNoIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7VmFsaWRhdG9ySGFzaH1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdHJldHVybiBuZXcgVmFsaWRhdG9ySGFzaChDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdCAqIEByZXR1cm5zIHtWYWxpZGF0b3JIYXNofVxuXHQgKi9cblx0c3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG5cdFx0cmV0dXJuIG5ldyBWYWxpZGF0b3JIYXNoKGRhdGEuYnl0ZXMpO1xuXHR9XG5cdFx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge1ZhbGlkYXRvckhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG5cdFx0cmV0dXJuIFZhbGlkYXRvckhhc2guZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcblx0ICogQHJldHVybnMge1ZhbGlkYXRvckhhc2h9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUhleChzdHIpIHtcblx0XHRyZXR1cm4gbmV3IFZhbGlkYXRvckhhc2goaGV4VG9CeXRlcyhzdHIpKTtcblx0fVxufVxuXG4vKipcbiAqIEhhc2ggb2YgYSB0cmFuc2FjdGlvblxuICovXG5leHBvcnQgY2xhc3MgVHhJZCBleHRlbmRzIEhhc2gge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gcmF3VmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihyYXdWYWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IEhhc2guY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSk7XG5cblx0XHRhc3NlcnQoYnl0ZXMubGVuZ3RoID09IDMyLCBgZXhwZWN0ZWQgMzIgYnl0ZXMgZm9yIFR4SWQsIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcblx0XHRzdXBlcihieXRlcyk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgKi9cbiAgICBfdG9VcGxjRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtuZXcgQnl0ZUFycmF5RGF0YSh0aGlzLmJ5dGVzKV0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtUeElkfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0cmV0dXJuIG5ldyBUeElkKENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKSk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7VHhJZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0KGRhdGEuaW5kZXggPT0gMCk7XG4gICAgICAgIGFzc2VydChkYXRhLmZpZWxkcy5sZW5ndGggPT0gMSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUeElkKGRhdGEuZmllbGRzWzBdLmJ5dGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcltdfSBieXRlcyBcbiAgICAgKiBAcmV0dXJucyB7VHhJZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBUeElkLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgIH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0ciBcblx0ICogQHJldHVybnMge1R4SWR9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUhleChzdHIpIHtcblx0XHRyZXR1cm4gbmV3IFR4SWQoaGV4VG9CeXRlcyhzdHIpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaWxsZWQgd2l0aCAyNTUgc28gdGhhdCB0aGUgaW50ZXJuYWwgc2hvdygpIGZ1bmN0aW9uIGhhcyBtYXggZXhlY3V0aW9uIGJ1ZGdldCBjb3N0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmaWxsXG5cdCAqIEByZXR1cm5zIHtUeElkfVxuXHQgKi9cblx0c3RhdGljIGR1bW15KGZpbGwgPSAyNTUpIHtcblx0XHRyZXR1cm4gbmV3IFR4SWQoKG5ldyBBcnJheSgzMikpLmZpbGwoZmlsbCkpO1xuXHR9XG59XG5cbi8qKlxuICogSWQgb2YgYSBVdHhvXG4gKi9cbmV4cG9ydCBjbGFzcyBUeE91dHB1dElkIGV4dGVuZHMgSGVsaW9zRGF0YSB7XG4gICAgLyoqIEB0eXBlIHtUeElkfSAqL1xuICAgICN0eElkO1xuXG4gICAgLyoqIEB0eXBlIHtISW50fSAqL1xuICAgICN1dHhvSWR4O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICogQHJldHVybnMge1thbnksIGFueV19XG4gICAgICovXG4gICAgc3RhdGljIGNsZWFuQ29uc3RydWN0b3JBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbMF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGFyZy5zcGxpdChcIiNcIik7XG5cbiAgICAgICAgICAgICAgICBhc3NlcnQocGFydHMubGVuZ3RoID09IDIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFydHNbMV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHNpbmdsZSBhcmcgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW2FyZ3NbMF0sIGFyZ3NbMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBudW1iZXIgb2YgYXJnc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbcmF3VHhJZCwgcmF3VXR4b0lkeF0gPSBUeE91dHB1dElkLmNsZWFuQ29uc3RydWN0b3JBcmdzKC4uLmFyZ3MpO1xuXG4gICAgICAgIGNvbnN0IHR4SWQgPSAocmF3VHhJZCBpbnN0YW5jZW9mIFR4SWQpID8gcmF3VHhJZCA6IG5ldyBUeElkKHJhd1R4SWQpO1xuICAgICAgICBjb25zdCB1dHhvSWR4ID0gKHJhd1V0eG9JZHggaW5zdGFuY2VvZiBISW50KSA/IHJhd1V0eG9JZHggOiBuZXcgSEludChyYXdVdHhvSWR4KTtcblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuI3R4SWQgPSB0eElkO1xuICAgICAgICB0aGlzLiN1dHhvSWR4ID0gdXR4b0lkeDtcbiAgICB9XG5cbiAgICBnZXQgdHhJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3R4SWQ7XG4gICAgfVxuXG4gICAgZ2V0IHV0eG9JZHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN1dHhvSWR4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtVcGxjRGF0YX1cbiAgICAgKi9cbiAgICBfdG9VcGxjRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFt0aGlzLiN0eElkLl90b1VwbGNEYXRhKCksIHRoaXMuI3V0eG9JZHguX3RvVXBsY0RhdGEoKV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtUeE91dHB1dElkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSkge1xuICAgICAgICBhc3NlcnQoZGF0YS5pbmRleCA9PSAwKTtcbiAgICAgICAgYXNzZXJ0KGRhdGEuZmllbGRzLmxlbmd0aCA9PSAyKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR4T3V0cHV0SWQoVHhJZC5mcm9tVXBsY0RhdGEoZGF0YS5maWVsZHNbMF0pLCBISW50LmZyb21VcGxjRGF0YShkYXRhLmZpZWxkc1sxXSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuICAgICAqIEByZXR1cm5zIHtUeE91dHB1dElkfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFR4T3V0cHV0SWQuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNlZSBDSVAxOSBmb3IgZm9ybWF0dGluZyBvZiBmaXJzdCBieXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGRyZXNzIGV4dGVuZHMgSGVsaW9zRGF0YSB7XG5cdC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG5cdCNieXRlcztcblxuICAgIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nfSByYXdWYWx1ZVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuICAgIHN0YXRpYyBjbGVhbkNvbnN0cnVjdG9yQXJnKHJhd1ZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmF3VmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHJhd1ZhbHVlLnN0YXJ0c1dpdGgoXCJhZGRyXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbUJlY2gzMihyYXdWYWx1ZSkuYnl0ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZS5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSA9IHJhd1ZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gcmF3VmFsdWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHJhd1ZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNieXRlcyA9IEFkZHJlc3MuY2xlYW5Db25zdHJ1Y3RvckFyZyhyYXdWYWx1ZSk7XG5cbiAgICAgICAgYXNzZXJ0KHRoaXMuI2J5dGVzLmxlbmd0aCA9PSAyOSB8fCB0aGlzLiNieXRlcy5sZW5ndGggPT0gNTcsIGBleHBlY3RlZCAyOSBvciA1NyBieXRlcyBmb3IgQWRkcmVzcywgZ290ICR7dGhpcy4jYnl0ZXMubGVuZ3RofWApO1xuXHR9XG5cblx0Z2V0IGJ5dGVzKCkge1xuXHRcdHJldHVybiB0aGlzLiNieXRlcy5zbGljZSgpO1xuXHR9XG5cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVCeXRlcyh0aGlzLiNieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge0FkZHJlc3N9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IEFkZHJlc3MoQ2JvckRhdGEuZGVjb2RlQnl0ZXMoYnl0ZXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm5zIHtBZGRyZXNzfVxuXHQgKi9cblx0c3RhdGljIGZyb21CZWNoMzIoc3RyKSB7XG5cdFx0Ly8gaWdub3JlIHRoZSBwcmVmaXggKGVuY29kZWQgaW4gdGhlIGJ5dGVzIGFueXdheSlcblx0XHRsZXQgW3ByZWZpeCwgYnl0ZXNdID0gQ3J5cHRvLmRlY29kZUJlY2gzMihzdHIpO1xuXG5cdFx0bGV0IHJlc3VsdCA9IG5ldyBBZGRyZXNzKGJ5dGVzKTtcblxuXHRcdGFzc2VydChwcmVmaXggPT0gKEFkZHJlc3MuaXNGb3JUZXN0bmV0KHJlc3VsdCkgPyBcImFkZHJfdGVzdFwiIDogXCJhZGRyXCIpLCBcImludmFsaWQgQWRkcmVzcyBwcmVmaXhcIik7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIERvZXNuJ3QgY2hlY2sgdmFsaWRpdHlcblx0ICogQHBhcmFtIHtzdHJpbmd9IGhleFxuXHQgKiBAcmV0dXJucyB7QWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tSGV4KGhleCkge1xuXHRcdHJldHVybiBuZXcgQWRkcmVzcyhoZXhUb0J5dGVzKGhleCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJhdyBBZGRyZXNzIGJ5dGVzIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b0hleCgpIHtcblx0XHRyZXR1cm4gYnl0ZXNUb0hleCh0aGlzLiNieXRlcyk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHViS2V5SGFzaCB8IFZhbGlkYXRvckhhc2h9IGhhc2ggXG4gICAgICogQHBhcmFtIHs/KFN0YWtlS2V5SGFzaCB8IFN0YWtpbmdWYWxpZGF0b3JIYXNoKX0gc3Rha2luZ0hhc2ggXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Rlc3RuZXRcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhhc2hlcyhoYXNoLCBzdGFraW5nSGFzaCA9IG51bGwsIGlzVGVzdG5ldCA9IGNvbmZpZy5JU19URVNUTkVUKSB7XG4gICAgICAgIGlmIChoYXNoIGluc3RhbmNlb2YgUHViS2V5SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YktleUhhc2goaGFzaCwgc3Rha2luZ0hhc2gsIGlzVGVzdG5ldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzaCBpbnN0YW5jZW9mIFZhbGlkYXRvckhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLmZyb21WYWxpZGF0b3JIYXNoKGhhc2gsIHN0YWtpbmdIYXNoLCBpc1Rlc3RuZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogU2ltcGxlIHBheW1lbnQgYWRkcmVzcyB3aXRob3V0IGEgc3Rha2luZyBwYXJ0XG5cdCAqIEBwYXJhbSB7UHViS2V5SGFzaH0gaGFzaFxuXHQgKiBAcGFyYW0gez8oU3Rha2VLZXlIYXNoIHwgU3Rha2luZ1ZhbGlkYXRvckhhc2gpfSBzdGFraW5nSGFzaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUZXN0bmV0XG5cdCAqIEByZXR1cm5zIHtBZGRyZXNzfVxuXHQgKi9cblx0c3RhdGljIGZyb21QdWJLZXlIYXNoKGhhc2gsIHN0YWtpbmdIYXNoID0gbnVsbCwgaXNUZXN0bmV0ID0gY29uZmlnLklTX1RFU1RORVQpIHtcblx0XHRpZiAoc3Rha2luZ0hhc2ggIT09IG51bGwpIHtcblx0XHRcdGlmIChzdGFraW5nSGFzaCBpbnN0YW5jZW9mIFN0YWtlS2V5SGFzaCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFkZHJlc3MoXG5cdFx0XHRcdFx0W2lzVGVzdG5ldCA/IDB4MDAgOiAweDAxXS5jb25jYXQoaGFzaC5ieXRlcykuY29uY2F0KHN0YWtpbmdIYXNoLmJ5dGVzKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXNzZXJ0KHN0YWtpbmdIYXNoIGluc3RhbmNlb2YgU3Rha2luZ1ZhbGlkYXRvckhhc2gpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFkZHJlc3MoXG5cdFx0XHRcdFx0W2lzVGVzdG5ldCA/IDB4MjAgOiAweDIxXS5jb25jYXQoaGFzaC5ieXRlcykuY29uY2F0KHN0YWtpbmdIYXNoLmJ5dGVzKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IEFkZHJlc3MoW2lzVGVzdG5ldCA/IDB4NjAgOiAweDYxXS5jb25jYXQoaGFzaC5ieXRlcykpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaW1wbGUgc2NyaXB0IGFkZHJlc3Mgd2l0aG91dCBhIHN0YWtpbmcgcGFydFxuXHQgKiBPbmx5IHJlbGV2YW50IGZvciB2YWxpZGF0b3Igc2NyaXB0c1xuXHQgKiBAcGFyYW0ge1ZhbGlkYXRvckhhc2h9IGhhc2hcblx0ICogQHBhcmFtIHs/KFN0YWtlS2V5SGFzaCB8IFN0YWtpbmdWYWxpZGF0b3JIYXNoKX0gc3Rha2luZ0hhc2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGVzdG5ldFxuXHQgKiBAcmV0dXJucyB7QWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tVmFsaWRhdG9ySGFzaChoYXNoLCBzdGFraW5nSGFzaCA9IG51bGwsIGlzVGVzdG5ldCA9IGNvbmZpZy5JU19URVNUTkVUKSB7XG5cdFx0aWYgKHN0YWtpbmdIYXNoICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoc3Rha2luZ0hhc2ggaW5zdGFuY2VvZiBTdGFrZUtleUhhc2gpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBZGRyZXNzKFxuXHRcdFx0XHRcdFtpc1Rlc3RuZXQgPyAweDEwIDogMHgxMV0uY29uY2F0KGhhc2guYnl0ZXMpLmNvbmNhdChzdGFraW5nSGFzaC5ieXRlcylcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFzc2VydChzdGFraW5nSGFzaCBpbnN0YW5jZW9mIFN0YWtpbmdWYWxpZGF0b3JIYXNoKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBBZGRyZXNzKFxuXHRcdFx0XHRcdFtpc1Rlc3RuZXQgPyAweDMwIDogMHgzMV0uY29uY2F0KGhhc2guYnl0ZXMpLmNvbmNhdChzdGFraW5nSGFzaC5ieXRlcylcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBBZGRyZXNzKFtpc1Rlc3RuZXQgPyAweDcwIDogMHg3MV0uY29uY2F0KGhhc2guYnl0ZXMpKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9CZWNoMzIoKSB7XG5cdFx0cmV0dXJuIENyeXB0by5lbmNvZGVCZWNoMzIoXG5cdFx0XHRBZGRyZXNzLmlzRm9yVGVzdG5ldCh0aGlzKSA/IFwiYWRkcl90ZXN0XCIgOiBcImFkZHJcIixcblx0XHRcdHRoaXMuI2J5dGVzXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGV4OiBieXRlc1RvSGV4KHRoaXMuI2J5dGVzKSxcblx0XHRcdGJlY2gzMjogdGhpcy50b0JlY2gzMigpLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRm9yVGVzdG5ldChhZGRyZXNzKSB7XG5cdFx0bGV0IHR5cGUgPSBhZGRyZXNzLmJ5dGVzWzBdICYgMGIwMDAwMTExMTtcblxuXHRcdHJldHVybiB0eXBlID09IDA7XG5cdH1cblxuXHQvKipcbiAgICAgKiBcbiAgICAgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvQ3JlZGVudGlhbERhdGEoKSB7XG5cdFx0bGV0IHZoID0gdGhpcy52YWxpZGF0b3JIYXNoO1xuXG5cdFx0aWYgKHZoICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbnN0ckRhdGEoMSwgW25ldyBCeXRlQXJyYXlEYXRhKHZoLmJ5dGVzKV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgcGtoID0gdGhpcy5wdWJLZXlIYXNoO1xuXG5cdFx0XHRpZiAocGtoID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbnN0ckRhdGEoMCwgW25ldyBCeXRlQXJyYXlEYXRhKHBraC5ieXRlcyldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0NvbnN0ckRhdGF9XG5cdCAqL1xuXHR0b1N0YWtpbmdEYXRhKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy4jYnl0ZXNbMF0gPj4gNDtcblx0XHRjb25zdCBzaCA9IHRoaXMuc3Rha2luZ0hhc2g7XG5cblx0XHRpZiAoc2ggPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDEsIFtdKTsgLy8gbm9uZVxuXHRcdH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA0IHx8IHR5cGUgPT0gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMyB8fCB0eXBlID09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Rha2luZyBjcmVkZW50aWFsIC0+IDAsIDEgLT4gcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICBuZXcgQ29uc3RyRGF0YSgwLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFraW5nVmFsaWRhdG9yIGNyZWRlbnRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDb25zdHJEYXRhKDEsIFtuZXcgQnl0ZUFycmF5RGF0YShzaC5ieXRlcyldKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Rha2luZyBjcmVkZW50aWFsIC0+IDAsIDEgLT4gcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICBuZXcgQ29uc3RyRGF0YSgwLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFrZUtleUhhc2ggY3JlZGVudGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENvbnN0ckRhdGEoMCwgW25ldyBCeXRlQXJyYXlEYXRhKHNoLmJ5dGVzKV0pLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNEYXRhfVxuXHQgKi9cblx0X3RvVXBsY0RhdGEoKSB7XG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFt0aGlzLnRvQ3JlZGVudGlhbERhdGEoKSwgdGhpcy50b1N0YWtpbmdEYXRhKCldKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGVzdG5ldFxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSwgaXNUZXN0bmV0ID0gY29uZmlnLklTX1RFU1RORVQpIHtcbiAgICAgICAgYXNzZXJ0KGRhdGEuaW5kZXggPT0gMCk7XG4gICAgICAgIGFzc2VydChkYXRhLmZpZWxkcy5sZW5ndGggPT0gMik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjcmVkRGF0YSA9IGRhdGEuZmllbGRzWzBdO1xuICAgICAgICBjb25zdCBzdGFrRGF0YSA9IGRhdGEuZmllbGRzWzFdO1xuXG4gICAgICAgIGFzc2VydChjcmVkRGF0YS5maWVsZHMubGVuZ3RoID09IDEpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7PyhTdGFrZUtleUhhc2ggfCBTdGFraW5nVmFsaWRhdG9ySGFzaCl9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgc2g7XG5cblx0XHQvLyBmb3Igc29tZSB3ZWlyZCByZWFzb24gT3B0aW9uOjpOb25lIGhhcyBpbmRleCAxXG4gICAgICAgIGlmIChzdGFrRGF0YS5pbmRleCA9PSAxKSB7XG4gICAgICAgICAgICBzaCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoc3Rha0RhdGEuaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgYXNzZXJ0KHN0YWtEYXRhLmZpZWxkcy5sZW5ndGggPT0gMSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyID0gc3Rha0RhdGEuZmllbGRzWzBdO1xuICAgICAgICAgICAgYXNzZXJ0KGlubmVyLmZpZWxkcy5sZW5ndGggPT0gMSk7XG5cbiAgICAgICAgICAgIGlmIChpbm5lci5pbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJJbm5lciA9IGlubmVyLmZpZWxkc1swXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoaW5uZXJJbm5lci5maWVsZHMubGVuZ3RoID09IDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlubmVySW5uZXIuaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaCA9IG5ldyBTdGFrZUtleUhhc2goaW5uZXJJbm5lci5maWVsZHNbMF0uYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJJbm5lci5pbmRleCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoID0gbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoKGlubmVySW5uZXIuZmllbGRzWzBdLmJ5dGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXIuaW5kZXggPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0YWtpbmcgcG9pbnRlciBub3QgeWV0IGhhbmRsZWRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNyZWREYXRhLmluZGV4ID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLmZyb21QdWJLZXlIYXNoKG5ldyBQdWJLZXlIYXNoKGNyZWREYXRhLmZpZWxkc1swXS5ieXRlcyksIHNoLCBpc1Rlc3RuZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNyZWREYXRhLmluZGV4ID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLmZyb21WYWxpZGF0b3JIYXNoKG5ldyBWYWxpZGF0b3JIYXNoKGNyZWREYXRhLmZpZWxkc1swXS5ieXRlcyksIHNoLCBpc1Rlc3RuZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUZXN0bmV0XG4gICAgICogQHJldHVybnMge0FkZHJlc3N9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VcGxjQ2JvcihieXRlcywgaXNUZXN0bmV0ID0gY29uZmlnLklTX1RFU1RORVQpIHtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSwgaXNUZXN0bmV0KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/UHViS2V5SGFzaH1cblx0ICovXG5cdGdldCBwdWJLZXlIYXNoKCkge1xuXHRcdGxldCB0eXBlID0gdGhpcy4jYnl0ZXNbMF0gPj4gNDtcblxuXHRcdGlmICh0eXBlICUgMiA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFB1YktleUhhc2godGhpcy4jYnl0ZXMuc2xpY2UoMSwgMjkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/VmFsaWRhdG9ySGFzaH1cblx0ICovXG5cdGdldCB2YWxpZGF0b3JIYXNoKCkge1xuXHRcdGxldCB0eXBlID0gdGhpcy4jYnl0ZXNbMF0gPj4gNDtcblxuXHRcdGlmICh0eXBlICUgMiA9PSAxKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFZhbGlkYXRvckhhc2godGhpcy4jYnl0ZXMuc2xpY2UoMSwgMjkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/KFN0YWtlS2V5SGFzaCB8IFN0YWtpbmdWYWxpZGF0b3JIYXNoKX1cblx0ICovXG5cdGdldCBzdGFraW5nSGFzaCgpIHtcblx0XHRsZXQgdHlwZSA9IHRoaXMuI2J5dGVzWzBdID4+IDQ7XG5cbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jYnl0ZXMuc2xpY2UoMjkpO1xuICAgICAgICBcblxuICAgICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICAgICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA9PSAyOCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWtlS2V5SGFzaChieXRlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAyIHx8IHR5cGUgPT0gMykge1xuICAgICAgICAgICAgYXNzZXJ0KGJ5dGVzLmxlbmd0aCA9PSAyOCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoKGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IDQgfHwgdHlwZSA9PSA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFraW5nIHBvaW50ZXIgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCB0byBzb3J0IHR4Ym9keSB3aXRoZHJhd2Fsc1xuXHQgKiBAcGFyYW0ge0FkZHJlc3N9IGFcblx0ICogQHBhcmFtIHtBZGRyZXNzfSBiXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBjb21wU3Rha2luZ0hhc2hlcyhhLCBiKSB7XG5cdFx0cmV0dXJuIEhhc2guY29tcGFyZShhc3NlcnREZWZpbmVkKGEuc3Rha2luZ0hhc2gpLCBhc3NlcnREZWZpbmVkKGIuc3Rha2luZ0hhc2gpKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgQXNzZXRDbGFzcyBleHRlbmRzIEhlbGlvc0RhdGEge1xuXHQvKipcblx0ICogQHR5cGUge01pbnRpbmdQb2xpY3lIYXNofVxuXHQgKi9cblx0I21waDtcblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcltdfVxuXHQgKi9cblx0I3Rva2VuTmFtZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHthbnlbXX0gYXJnc1xuXHQgKiBAcmV0dXJucyB7W01pbnRpbmdQb2xpY3lIYXNoLCBudW1iZXJbXV19XG5cdCAqL1xuXHRzdGF0aWMgY2xlYW5Db25zdHJ1Y3RvckFyZ3MoYXJncykge1xuXHRcdGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRjb25zdCBhcmcgPSBhcmdzWzBdO1x0XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Y29uc3QgZmllbGRzID0gYXJnLnNwbGl0KFwiLlwiKVxuXG5cdFx0XHRcdGFzc2VydChmaWVsZHMubGVuZ3RoID09IDIsIFwiZXhwZWN0ZWQgJy4nIGluIGhleCBlbmNvZGVkIEFzc2V0Q2xhc3NcIik7XG5cblx0XHRcdFx0cmV0dXJuIFtuZXcgTWludGluZ1BvbGljeUhhc2goZmllbGRzWzBdKSwgaGV4VG9CeXRlcyhmaWVsZHNbMV0pXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgQXNzZXRDbGFzcyBhcmcgdHlwZVwiKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcblx0XHRcdGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuXHRcdFx0Y29uc3QgYXJnMSA9IGFyZ3NbMV07XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdGFyZzAgaW5zdGFuY2VvZiBNaW50aW5nUG9saWN5SGFzaCA/IGFyZzAgOiBuZXcgTWludGluZ1BvbGljeUhhc2goYXJnMCksXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoYXJnMSkgPyBhcmcxIDogaGV4VG9CeXRlcyhhcmcxKVxuXHRcdFx0XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBudW1iZXIgb2YgQXNzZXRDbGFzcyBhcmdzXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBcblx0ICogQHBhcmFtIHthbnlbXX0gYXJncyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IFttcGgsIHRva2VuTmFtZV0gPSBBc3NldENsYXNzLmNsZWFuQ29uc3RydWN0b3JBcmdzKGFyZ3MpO1xuXG5cdFx0dGhpcy4jbXBoID0gbXBoO1xuXHRcdHRoaXMuI3Rva2VuTmFtZSA9IHRva2VuTmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIHdoZW4gZ2VuZXJhdGluZyBzY3JpcHQgY29udGV4dHMgZm9yIHJ1bm5pbmcgcHJvZ3JhbXNcblx0ICogQHJldHVybnMge0NvbnN0ckRhdGF9XG5cdCAqL1xuXHRfdG9VcGxjRGF0YSgpIHtcblx0XHRyZXR1cm4gbmV3IENvbnN0ckRhdGEoMCwgW1xuXHRcdFx0dGhpcy4jbXBoLl90b1VwbGNEYXRhKCksXG5cdFx0XHRuZXcgQnl0ZUFycmF5RGF0YSh0aGlzLiN0b2tlbk5hbWUpXG5cdFx0XSlcblx0fVxuXG5cdC8qKlxuXHQgKiBcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcblx0ICogQHJldHVybnMge0Fzc2V0Q2xhc3N9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcblx0XHRhc3NlcnQoZGF0YS5pbmRleCA9PSAwKTtcblx0XHRhc3NlcnQoZGF0YS5maWVsZHMubGVuZ3RoID09IDIpO1xuXG5cdFx0Y29uc3QgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbVVwbGNEYXRhKGRhdGEuZmllbGRzWzBdKTtcblx0XHRjb25zdCB0b2tlbk5hbWUgPSBkYXRhLmZpZWxkc1sxXS5ieXRlcztcblxuXHRcdHJldHVybiBuZXcgQXNzZXRDbGFzcyhtcGgsIHRva2VuTmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVDb25zdHIoMCwgW1xuXHRcdFx0dGhpcy4jbXBoLnRvQ2JvcigpLFxuXHRcdFx0Q2JvckRhdGEuZW5jb2RlQnl0ZXModGhpcy4jdG9rZW5OYW1lKVxuXHRcdF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge01pbnRpbmdQb2xpY3lIYXNoIHwgbnVsbH1cblx0XHQgKi9cblx0XHRsZXQgbXBoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtudW1iZXJbXSB8IG51bGx9XG5cdFx0ICovXG5cdFx0bGV0IHRva2VuTmFtZSA9IG51bGw7XG5cblx0XHRjb25zdCB0YWcgPSBDYm9yRGF0YS5kZWNvZGVDb25zdHIoYnl0ZXMsIChpLCBmaWVsZEJ5dGVzKSA9PiB7XG5cdFx0XHRzd2l0Y2ggKGkpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdG1waCA9IE1pbnRpbmdQb2xpY3lIYXNoLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dG9rZW5OYW1lID0gQ2JvckRhdGEuZGVjb2RlQnl0ZXMoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBmaWVsZFwiKTtcblx0XHRcdH0gXG5cdFx0fSk7XG5cblx0XHRhc3NlcnQodGFnID09IDApO1xuXG5cdFx0aWYgKG1waCA9PSBudWxsIHx8IHRva2VuTmFtZSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnN1ZmZpY2llbnQgZmllbGRzXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IEFzc2V0Q2xhc3MobXBoLCB0b2tlbk5hbWUpO1xuXHRcdH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyB7QXNzZXRDbGFzc31cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBBc3NldENsYXNzLmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbGxlY3Rpb24gb2Ygbm9uLWxvdmVsYWNlIGFzc2V0c1xuICovXG5leHBvcnQgY2xhc3MgQXNzZXRzIGV4dGVuZHMgQ2JvckRhdGEge1xuXHQvKiogQHR5cGUge1tNaW50aW5nUG9saWN5SGFzaCwgW251bWJlcltdLCBiaWdpbnRdW11dW119ICovXG5cdCNhc3NldHM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7W01pbnRpbmdQb2xpY3lIYXNoIHwgbnVtYmVyW10gfCBzdHJpbmcsIFtudW1iZXJbXSB8IHN0cmluZywgYmlnaW50IHwgbnVtYmVyXVtdXVtdfSBhc3NldHMgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihhc3NldHMgPSBbXSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jYXNzZXRzID0gYXNzZXRzLm1hcCgoW3Jhd01waCwgdG9rZW5zXSkgPT4ge1xuXHRcdFx0Y29uc3QgbXBoID0gcmF3TXBoIGluc3RhbmNlb2YgTWludGluZ1BvbGljeUhhc2ggPyByYXdNcGggOiBuZXcgTWludGluZ1BvbGljeUhhc2gocmF3TXBoKTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bXBoLFxuXHRcdFx0XHR0b2tlbnMubWFwKChbcmF3TmFtZSwgYW1vdW50XSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBBcnJheS5pc0FycmF5KHJhd05hbWUpID8gcmF3TmFtZSA6IGhleFRvQnl0ZXMocmF3TmFtZSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gW25hbWUsIEJpZ0ludChhbW91bnQpXTtcblx0XHRcdFx0fSlcblx0XHRcdF07XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge01pbnRpbmdQb2xpY3lIYXNoW119XG5cdCAqL1xuXHRnZXQgbWludGluZ1BvbGljaWVzKCkge1xuXHRcdHJldHVybiB0aGlzLiNhc3NldHMubWFwKChbbXBoLCBfXSkgPT4gbXBoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IG5Ub2tlblR5cGVzKCkge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XG5cdFx0dGhpcy4jYXNzZXRzLmZvckVhY2goKFttcGgsIHRva2Vuc10pID0+IHtcblx0XHRcdHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBfXSkgPT4ge1xuXHRcdFx0XHRjb3VudCArPSAxXG5cdFx0XHR9KVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1plcm8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Fzc2V0cy5sZW5ndGggPT0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01pbnRpbmdQb2xpY3lIYXNofSBtcGhcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdG9rZW5OYW1lIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGhhcyhtcGgsIHRva2VuTmFtZSkge1xuXHRcdGxldCBpbm5lciA9IHRoaXMuI2Fzc2V0cy5maW5kKGFzc2V0ID0+IG1waC5lcShhc3NldFswXSkpO1xuXG5cdFx0aWYgKGlubmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBpbm5lclsxXS5maW5kSW5kZXgocGFpciA9PiBlcShwYWlyWzBdLCB0b2tlbk5hbWUpKSAhPSAtMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01pbnRpbmdQb2xpY3lIYXNofSBtcGhcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdG9rZW5OYW1lIFxuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Z2V0KG1waCwgdG9rZW5OYW1lKSB7XG5cdFx0bGV0IGlubmVyID0gdGhpcy4jYXNzZXRzLmZpbmQoYXNzZXQgPT4gbXBoLmVxKGFzc2V0WzBdKSk7XG5cblx0XHRpZiAoaW5uZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGV0IHRva2VuID0gaW5uZXJbMV0uZmluZChwYWlyID0+IGVxKHBhaXJbMF0sIHRva2VuTmFtZSkpO1xuXG5cdFx0XHRpZiAodG9rZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5bMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMG47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwbjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTXV0YXRlcyAndGhpcydcblx0ICovXG5cdHJlbW92ZVplcm9lcygpIHtcblx0XHRmb3IgKGxldCBhc3NldCBvZiB0aGlzLiNhc3NldHMpIHtcblx0XHRcdGFzc2V0WzFdID0gYXNzZXRbMV0uZmlsdGVyKHRva2VuID0+IHRva2VuWzFdICE9IDBuKTtcblx0XHR9XG5cblx0XHR0aGlzLiNhc3NldHMgPSB0aGlzLiNhc3NldHMuZmlsdGVyKGFzc2V0ID0+IGFzc2V0WzFdLmxlbmd0aCAhPSAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNdXRhdGVzICd0aGlzJ1xuXHQgKiBAcGFyYW0ge01pbnRpbmdQb2xpY3lIYXNofSBtcGhcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdG9rZW5OYW1lIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gcXVhbnRpdHlcblx0ICovXG5cdGFkZENvbXBvbmVudChtcGgsIHRva2VuTmFtZSwgcXVhbnRpdHkpIHtcblx0XHRpZiAocXVhbnRpdHkgPT0gMG4pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgaW5uZXIgPSB0aGlzLiNhc3NldHMuZmluZChhc3NldCA9PiBtcGguZXEoYXNzZXRbMF0pKTtcblxuXHRcdGlmIChpbm5lciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLiNhc3NldHMucHVzaChbbXBoLCBbW3Rva2VuTmFtZSwgcXVhbnRpdHldXV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgdG9rZW4gPSBpbm5lclsxXS5maW5kKHBhaXIgPT4gZXEocGFpclswXSwgdG9rZW5OYW1lKSk7XG5cblx0XHRcdGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlubmVyWzFdLnB1c2goW3Rva2VuTmFtZSwgcXVhbnRpdHldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRva2VuWzFdICs9IHF1YW50aXR5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMucmVtb3ZlWmVyb2VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBc3NldHN9IG90aGVyIFxuXHQgKiBAcGFyYW0geyhhOiBiaWdpbnQsIGI6IGJpZ2ludCkgPT4gYmlnaW50fSBvcCBcblx0ICogQHJldHVybnMge0Fzc2V0c31cblx0ICovXG5cdGFwcGx5QmluT3Aob3RoZXIsIG9wKSB7XG5cdFx0bGV0IHJlcyA9IG5ldyBBc3NldHMoKTtcblxuXHRcdGZvciAobGV0IFttcGgsIHRva2Vuc10gb2YgdGhpcy4jYXNzZXRzKSB7XG5cdFx0XHRmb3IgKGxldCBbdG9rZW5OYW1lLCBxdWFudGl0eV0gb2YgdG9rZW5zKSB7XG5cdFx0XHRcdHJlcy5hZGRDb21wb25lbnQobXBoLCB0b2tlbk5hbWUsIG9wKHF1YW50aXR5LCAwbikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IFttcGgsIHRva2Vuc10gb2Ygb3RoZXIuI2Fzc2V0cykge1xuXHRcdFx0Zm9yIChsZXQgW3Rva2VuTmFtZSwgcXVhbnRpdHldIG9mIHRva2Vucykge1xuXHRcdFx0XHRyZXMuYWRkQ29tcG9uZW50KG1waCwgdG9rZW5OYW1lLCBvcCgwbiwgcXVhbnRpdHkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXNzZXRzfSBvdGhlciBcblx0ICogQHJldHVybnMge0Fzc2V0c31cblx0ICovXG5cdGFkZChvdGhlcikge1xuXHRcdHJldHVybiB0aGlzLmFwcGx5QmluT3Aob3RoZXIsIChhLCBiKSA9PiBhICsgYik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtBc3NldHN9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7QXNzZXRzfVxuXHQgKi9cblx0c3ViKG90aGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlCaW5PcChvdGhlciwgKGEsIGIpID0+IGEgLSBiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNdXRhdGVzICd0aGlzJ1xuXHQgKiBUaHJvd3MgZXJyb3IgaWYgbXBoIGlzIGFscmVhZHkgY29udGFpbmVkIGluICd0aGlzJ1xuXHQgKiBAcGFyYW0ge01pbnRpbmdQb2xpY3lIYXNofSBtcGhcblx0ICogQHBhcmFtIHtbbnVtYmVyW10sIGJpZ2ludF1bXX0gdG9rZW5zXG5cdCAqL1xuXHRhZGRUb2tlbnMobXBoLCB0b2tlbnMpIHtcblx0XHRmb3IgKGxldCBhc3NldCBvZiB0aGlzLiNhc3NldHMpIHtcblx0XHRcdGlmIChhc3NldFswXS5lcShtcGgpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgTXVsdGlBc3NldCBhbHJlYWR5IGNvbnRhaW5zICR7Ynl0ZXNUb0hleChtcGguYnl0ZXMpfWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuI2Fzc2V0cy5wdXNoKFttcGgsIHRva2Vucy5zbGljZSgpXSk7XG5cblx0XHQvLyBzb3J0IGltbWVkaWF0ZWx5XG5cdFx0dGhpcy5zb3J0KCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNaW50aW5nUG9saWN5SGFzaH0gbXBoXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXVtdfVxuXHQgKi9cblx0Z2V0VG9rZW5OYW1lcyhtcGgpIHtcblx0XHRmb3IgKGxldCBbb3RoZXJNcGgsIHRva2Vuc10gb2YgdGhpcy4jYXNzZXRzKSB7XG5cdFx0XHRpZiAob3RoZXJNcGguZXEobXBoKSkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcCgoW3Rva2VuTmFtZSwgX10pID0+IHRva2VuTmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXNzZXRzfSBvdGhlciBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRlcShvdGhlcikge1xuXHRcdGZvciAobGV0IGFzc2V0IG9mIHRoaXMuI2Fzc2V0cykge1xuXHRcdFx0Zm9yIChsZXQgdG9rZW4gb2YgYXNzZXRbMV0pIHtcblx0XHRcdFx0aWYgKHRva2VuWzFdICE9IG90aGVyLmdldChhc3NldFswXSwgdG9rZW5bMF0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgYXNzZXQgb2Ygb3RoZXIuI2Fzc2V0cykge1xuXHRcdFx0Zm9yIChsZXQgdG9rZW4gb2YgYXNzZXRbMV0pIHtcblx0XHRcdFx0aWYgKHRva2VuWzFdICE9IHRoaXMuZ2V0KGFzc2V0WzBdLCB0b2tlblswXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdHJpY3QgZ3QsIGlmIG90aGVyIGNvbnRhaW5zIGFzc2V0cyB0aGlzIG9uZSBkb2Vzbid0IGNvbnRhaW4gPT4gcmV0dXJuIGZhbHNlXG5cdCAqIEBwYXJhbSB7QXNzZXRzfSBvdGhlciBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRndChvdGhlcikge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgYXNzZXQgb2YgdGhpcy4jYXNzZXRzKSB7XG5cdFx0XHRmb3IgKGxldCB0b2tlbiBvZiBhc3NldFsxXSkge1xuXHRcdFx0XHRpZiAodG9rZW5bMV0gPD0gb3RoZXIuZ2V0KGFzc2V0WzBdLCB0b2tlblswXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGxldCBhc3NldCBvZiBvdGhlci4jYXNzZXRzKSB7XG5cdFx0XHRmb3IgKGxldCB0b2tlbiBvZiBhc3NldFsxXSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuaGFzKGFzc2V0WzBdLCB0b2tlblswXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0Fzc2V0c30gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0Z2Uob3RoZXIpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIG90aGVyLmlzWmVybygpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGFzc2V0IG9mIHRoaXMuI2Fzc2V0cykge1xuXHRcdFx0Zm9yIChsZXQgdG9rZW4gb2YgYXNzZXRbMV0pIHtcblx0XHRcdFx0aWYgKHRva2VuWzFdIDwgb3RoZXIuZ2V0KGFzc2V0WzBdLCB0b2tlblswXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGxldCBhc3NldCBvZiBvdGhlci4jYXNzZXRzKSB7XG5cdFx0XHRmb3IgKGxldCB0b2tlbiBvZiBhc3NldFsxXSkge1xuXHRcdFx0XHRpZiAoIXRoaXMuaGFzKGFzc2V0WzBdLCB0b2tlblswXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGFsbFBvc2l0aXZlKCkge1xuXHRcdGZvciAobGV0IGFzc2V0IG9mIHRoaXMuI2Fzc2V0cykge1xuXHRcdFx0Zm9yIChsZXQgcGFpciBvZiBhc3NldFsxXSkge1xuXHRcdFx0XHRpZiAocGFpclsxXSA8IDBuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHBhaXJbMV0gPT0gMG4pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBjb250YWluZWQgcXVhbnRpdHkgPD0gMG5cblx0ICovXG5cdGFzc2VydEFsbFBvc2l0aXZlKCkge1xuXHRcdGFzc2VydCh0aGlzLmFsbFBvc2l0aXZlKCksIFwibm9uLXBvc2l0aXZlIHRva2VuIGFtb3VudHMgZGV0ZWN0ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVNYXAoXG5cdFx0XHR0aGlzLiNhc3NldHMubWFwKFxuXHRcdFx0XHRvdXRlclBhaXIgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBbb3V0ZXJQYWlyWzBdLnRvQ2JvcigpLCBDYm9yRGF0YS5lbmNvZGVNYXAob3V0ZXJQYWlyWzFdLm1hcChcblx0XHRcdFx0XHRcdGlubmVyUGFpciA9PiB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdFx0Q2JvckRhdGEuZW5jb2RlQnl0ZXMoaW5uZXJQYWlyWzBdKSwgQ2JvckRhdGEuZW5jb2RlSW50ZWdlcihpbm5lclBhaXJbMV0pXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpKV1cblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdClcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7QXNzZXRzfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0bGV0IG1zID0gbmV3IEFzc2V0cygpO1xuXG5cdFx0Q2JvckRhdGEuZGVjb2RlTWFwKGJ5dGVzLCAoXywgcGFpckJ5dGVzKSA9PiB7XG5cdFx0XHRsZXQgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbUNib3IocGFpckJ5dGVzKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdHlwZSB7W251bWJlcltdLCBiaWdpbnRdW119XG5cdFx0XHQgKi9cblx0XHRcdGxldCBpbm5lck1hcCA9IFtdO1xuXHRcdFx0XG5cdFx0XHRDYm9yRGF0YS5kZWNvZGVNYXAocGFpckJ5dGVzLCAoXywgaW5uZXJQYWlyQnl0ZXMpID0+IHtcblx0XHRcdFx0aW5uZXJNYXAucHVzaChbXG5cdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlQnl0ZXMoaW5uZXJQYWlyQnl0ZXMpLFxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUludGVnZXIoaW5uZXJQYWlyQnl0ZXMpLFxuXHRcdFx0XHRdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRtcy4jYXNzZXRzLnB1c2goW21waCwgaW5uZXJNYXBdKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRsZXQgb2JqID0ge307XG5cblx0XHRmb3IgKGxldCBbbXBoLCB0b2tlbnNdIG9mIHRoaXMuI2Fzc2V0cykge1xuXHRcdFx0bGV0IGlubmVyT2JqID0ge307XG5cblx0XHRcdGZvciAobGV0IFt0b2tlbk5hbWUsIHF1YW50aXR5XSBvZiB0b2tlbnMpIHtcblx0XHRcdFx0aW5uZXJPYmpbYnl0ZXNUb0hleCh0b2tlbk5hbWUpXSA9IHF1YW50aXR5LnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdG9ialttcGguZHVtcCgpXSA9IGlubmVyT2JqO1xuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCB3aGVuIGdlbmVyYXRpbmcgc2NyaXB0IGNvbnRleHRzIGZvciBydW5uaW5nIHByb2dyYW1zXG5cdCAqIEByZXR1cm5zIHtNYXBEYXRhfVxuXHQgKi9cblx0X3RvVXBsY0RhdGEoKSB7XG5cdFx0LyoqIEB0eXBlIHtbVXBsY0RhdGEsIFVwbGNEYXRhXVtdfSAqL1xuXHRcdGxldCBwYWlycyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgYXNzZXQgb2YgdGhpcy4jYXNzZXRzKSB7XG5cdFx0XHQvKiogQHR5cGUge1tVcGxjRGF0YSwgVXBsY0RhdGFdW119ICovXG5cdFx0XHRsZXQgaW5uZXJQYWlycyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCB0b2tlbiBvZiBhc3NldFsxXSkge1xuXHRcdFx0XHRpbm5lclBhaXJzLnB1c2goW1xuXHRcdFx0XHRcdG5ldyBCeXRlQXJyYXlEYXRhKHRva2VuWzBdKSxcblx0XHRcdFx0XHRuZXcgSW50RGF0YSh0b2tlblsxXSksXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwYWlycy5wdXNoKFtcblx0XHRcdFx0bmV3IEJ5dGVBcnJheURhdGEoYXNzZXRbMF0uYnl0ZXMpLFxuXHRcdFx0XHRuZXcgTWFwRGF0YShpbm5lclBhaXJzKSxcblx0XHRcdF0pXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBNYXBEYXRhKHBhaXJzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1pbnRpbmcgcG9saWNpZXMgYXJlIGluIGNvcnJlY3Qgb3JkZXJcblx0ICogTXV0YXRlcyAndGhpcydcblx0ICogT3JkZXIgb2YgdG9rZW5zIHBlciBtaW50aW5nUG9saWN5SGFzaCBpc24ndCBjaGFuZ2VkXG5cdCAqL1xuXHRzb3J0KCkge1xuXHRcdHRoaXMuI2Fzc2V0cy5zb3J0KChhLCBiKSA9PiB7XG5cdFx0XHRyZXR1cm4gSGFzaC5jb21wYXJlKGFbMF0sIGJbMF0pO1xuXHRcdH0pO1xuXHR9XG5cblx0YXNzZXJ0U29ydGVkKCkge1xuXHRcdHRoaXMuI2Fzc2V0cy5mb3JFYWNoKChiLCBpKSA9PiB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0Y29uc3QgYSA9IHRoaXMuI2Fzc2V0c1tpLTFdO1xuXG5cdFx0XHRcdGFzc2VydChIYXNoLmNvbXBhcmUoYVswXSwgYlswXSkgPT0gLTEsIFwiYXNzZXRzIG5vdCBzb3J0ZWRcIilcblx0XHRcdH1cblx0XHR9KVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBWYWx1ZSBleHRlbmRzIEhlbGlvc0RhdGEge1xuXHQvKiogQHR5cGUge2JpZ2ludH0gKi9cblx0I2xvdmVsYWNlO1xuXG5cdC8qKiBAdHlwZSB7QXNzZXRzfSAqL1xuXHQjYXNzZXRzO1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBsb3ZlbGFjZSBcblx0ICogQHBhcmFtIHtBc3NldHN9IGFzc2V0cyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGxvdmVsYWNlID0gMG4sIGFzc2V0cyA9IG5ldyBBc3NldHMoKSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jbG92ZWxhY2UgPSBsb3ZlbGFjZTtcblx0XHR0aGlzLiNhc3NldHMgPSBhc3NldHM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNaW50aW5nUG9saWN5SGFzaH0gbXBoIFxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbk5hbWUgXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBxdWFudGl0eSBcblx0ICogQHJldHVybnMge1ZhbHVlfVxuXHQgKi9cblx0c3RhdGljIGFzc2V0KG1waCwgdG9rZW5OYW1lLCBxdWFudGl0eSkge1xuXHRcdHJldHVybiBuZXcgVmFsdWUoMG4sIG5ldyBBc3NldHMoW1xuXHRcdFx0W21waCwgW1xuXHRcdFx0XHRbdG9rZW5OYW1lLCBxdWFudGl0eV1cblx0XHRcdF1dXG5cdFx0XSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtiaWdpbnR9XG5cdCAqL1xuXHRnZXQgbG92ZWxhY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2xvdmVsYWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRlciBmb3IgbG92ZWxhY2Vcblx0ICogTm90ZTogbXV0YXRpb24gaXMgaGFuZHkgd2hlbiBiYWxhbmNpbmcgdHJhbnNhY3Rpb25zXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBsb3ZlbGFjZVxuXHQgKi9cblx0c2V0TG92ZWxhY2UobG92ZWxhY2UpIHtcblx0XHR0aGlzLiNsb3ZlbGFjZSA9IGxvdmVsYWNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtBc3NldHN9XG5cdCAqL1xuXHRnZXQgYXNzZXRzKCkge1xuXHRcdHJldHVybiB0aGlzLiNhc3NldHM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdGlmICh0aGlzLiNhc3NldHMuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKHRoaXMuI2xvdmVsYWNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZVR1cGxlKFtcblx0XHRcdFx0Q2JvckRhdGEuZW5jb2RlSW50ZWdlcih0aGlzLiNsb3ZlbGFjZSksXG5cdFx0XHRcdHRoaXMuI2Fzc2V0cy50b0Nib3IoKVxuXHRcdFx0XSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7VmFsdWV9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRsZXQgbXYgPSBuZXcgVmFsdWUoKTtcblxuXHRcdGlmIChDYm9yRGF0YS5pc1R1cGxlKGJ5dGVzKSkge1xuXHRcdFx0Q2JvckRhdGEuZGVjb2RlVHVwbGUoYnl0ZXMsIChpLCBmaWVsZEJ5dGVzKSA9PiB7XG5cdFx0XHRcdHN3aXRjaChpKSB7XG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0bXYuI2xvdmVsYWNlID0gQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdG12LiNhc3NldHMgPSBBc3NldHMuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGZpZWxkXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bXYuI2xvdmVsYWNlID0gQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihieXRlcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG12O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VmFsdWVbXX0gdmFsdWVzIFxuXHQgKiBAcmV0dXJucyB7VmFsdWV9XG5cdCAqL1xuXHRzdGF0aWMgc3VtKHZhbHVlcykge1xuXHRcdGxldCBzID0gbmV3IFZhbHVlKDBuKTtcblxuXHRcdHZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuXHRcdFx0cyA9IHMuYWRkKHYpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHM7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1ZhbHVlfSBvdGhlciBcblx0ICogQHJldHVybnMge1ZhbHVlfVxuXHQgKi9cblx0YWRkKG90aGVyKSB7XG5cdFx0cmV0dXJuIG5ldyBWYWx1ZSh0aGlzLiNsb3ZlbGFjZSArIG90aGVyLiNsb3ZlbGFjZSwgdGhpcy4jYXNzZXRzLmFkZChvdGhlci4jYXNzZXRzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtWYWx1ZX0gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtWYWx1ZX1cblx0ICovXG5cdHN1YihvdGhlcikge1xuXHRcdHJldHVybiBuZXcgVmFsdWUodGhpcy4jbG92ZWxhY2UgLSBvdGhlci4jbG92ZWxhY2UsIHRoaXMuI2Fzc2V0cy5zdWIob3RoZXIuI2Fzc2V0cykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VmFsdWV9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGVxKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLiNsb3ZlbGFjZSA9PSBvdGhlci4jbG92ZWxhY2UpICYmICh0aGlzLiNhc3NldHMuZXEob3RoZXIuI2Fzc2V0cykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0cmljdGx5IGdyZWF0ZXIgdGhhbi4gUmV0dXJucyBmYWxzZSBpZiBhbnkgYXNzZXQgaXMgbWlzc2luZyBcblx0ICogQHBhcmFtIHtWYWx1ZX0gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0Z3Qob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuI2xvdmVsYWNlID4gb3RoZXIuI2xvdmVsYWNlKSAmJiAodGhpcy4jYXNzZXRzLmd0KG90aGVyLiNhc3NldHMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdHJpY3RseSA+PSBcblx0ICogQHBhcmFtIHtWYWx1ZX0gb3RoZXIgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0Z2Uob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuI2xvdmVsYWNlID49IG90aGVyLiNsb3ZlbGFjZSkgJiYgKHRoaXMuI2Fzc2V0cy5nZShvdGhlci4jYXNzZXRzKSk7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBjb250YWluZWQgcXVhbnRpdHkgaXMgbmVnYXRpdmVcblx0ICogVXNlZCB3aGVuIGJ1aWxkaW5nIHRyYW5zYWN0aW9ucyBiZWNhdXNlIHRyYW5zYWN0aW9ucyBjYW4ndCBjb250YWluIG5lZ2F0aXZlIHZhbHVlc1xuXHQgKiBAcmV0dXJucyB7VmFsdWV9IC0gcmV0dXJucyB0aGlzXG5cdCAqL1xuXHRhc3NlcnRBbGxQb3NpdGl2ZSgpIHtcblx0XHRhc3NlcnQodGhpcy4jbG92ZWxhY2UgPj0gMG4pO1xuXG5cdFx0dGhpcy4jYXNzZXRzLmFzc2VydEFsbFBvc2l0aXZlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bG92ZWxhY2U6IHRoaXMuI2xvdmVsYWNlLnRvU3RyaW5nKCksXG5cdFx0XHRhc3NldHM6IHRoaXMuI2Fzc2V0cy5kdW1wKClcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgd2hlbiBidWlsZGluZyBzY3JpcHQgY29udGV4dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5TY3JpcHRDb250ZXh0XG5cdCAqIEByZXR1cm5zIHtNYXBEYXRhfVxuXHQgKi9cblx0X3RvVXBsY0RhdGEoaXNJblNjcmlwdENvbnRleHQgPSBmYWxzZSkge1xuXHRcdGxldCBtYXAgPSB0aGlzLiNhc3NldHMuX3RvVXBsY0RhdGEoKTtcblxuXHRcdGlmICh0aGlzLiNsb3ZlbGFjZSAhPSAwbiB8fCBpc0luU2NyaXB0Q29udGV4dCkge1xuXHRcdFx0bGV0IGlubmVyID0gbWFwLm1hcDsgXG5cblx0XHRcdGlubmVyLnVuc2hpZnQoW1xuXHRcdFx0XHRuZXcgQnl0ZUFycmF5RGF0YShbXSksXG5cdFx0XHRcdG5ldyBNYXBEYXRhKFtcblx0XHRcdFx0XHRbbmV3IEJ5dGVBcnJheURhdGEoW10pLCBuZXcgSW50RGF0YSh0aGlzLiNsb3ZlbGFjZSldXG5cdFx0XHRcdF0pLFxuXHRcdFx0XSk7XG5cblx0XHRcdC8vICdpbm5lcicgaXMgY29weSwgc28gbXV0YXRpbmcgd29uJ3QgY2hhbmdlIHRoZSBvcmlnaW5hbFxuXHRcdFx0bWFwID0gbmV3IE1hcERhdGEoaW5uZXIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXA7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZnVsIHdoZW4gZGVzZXJpYWxpemluZyBpbmxpbmUgZGF0dW1zXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGFcblx0ICogQHJldHVybnMge1ZhbHVlfVxuXHQgKi9cblx0c3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG5cdFx0bGV0IHN1bSA9IG5ldyBWYWx1ZSgpO1xuXG5cdFx0bGV0IG91dGVyTWFwID0gZGF0YS5tYXA7XG5cblx0XHRmb3IgKGxldCBbbXBoRGF0YSwgdG9rZW5zRGF0YV0gb2Ygb3V0ZXJNYXApIHtcblx0XHRcdGxldCBtcGhCeXRlcyA9IG1waERhdGEuYnl0ZXM7XG5cblx0XHRcdGxldCBpbm5lck1hcCA9IHRva2Vuc0RhdGEubWFwO1xuXG5cdFx0XHRpZiAobXBoQnl0ZXMubGVuZ3RoID09IDApIHtcblx0XHRcdFx0Ly9sb3ZlbGFjZVxuXHRcdFx0XHRhc3NlcnQoaW5uZXJNYXAubGVuZ3RoID09IDEgJiYgaW5uZXJNYXBbMF1bMF0uYnl0ZXMubGVuZ3RoID09IDApOyBcblx0XHRcdFx0c3VtID0gc3VtLmFkZChuZXcgVmFsdWUoaW5uZXJNYXBbMF1bMV0uaW50KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBvdGhlciBhc3NldHNcblx0XHRcdFx0bGV0IG1waCA9IG5ldyBNaW50aW5nUG9saWN5SGFzaChtcGhCeXRlcyk7XG5cblx0XHRcdFx0Zm9yIChsZXQgW3Rva2VuTmFtZURhdGEsIHF1YW50aXR5RGF0YV0gb2YgaW5uZXJNYXApIHtcblx0XHRcdFx0XHRsZXQgdG9rZW5OYW1lID0gdG9rZW5OYW1lRGF0YS5ieXRlcztcblx0XHRcdFx0XHRsZXQgcXVhbnRpdHkgPSBxdWFudGl0eURhdGEuaW50O1xuXG5cdFx0XHRcdFx0c3VtID0gc3VtLmFkZChWYWx1ZS5hc3NldChtcGgsIHRva2VuTmFtZSwgcXVhbnRpdHkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzdW07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtWYWx1ZX1cblx0ICovXG5cdHN0YXRpYyBmcm9tVXBsY0Nib3IoYnl0ZXMpIHtcblx0XHRyZXR1cm4gVmFsdWUuZnJvbVVwbGNEYXRhKFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKSk7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gODogVXBsYyBjb3N0LW1vZGVsc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29zdFxuICogQHByb3BlcnR5IHtiaWdpbnR9IG1lbVxuICogQHByb3BlcnR5IHtiaWdpbnR9IGNwdVxuICovXG5cbi8qKlxuICogTmV0d29ya1BhcmFtcyBjb250YWlucyBhbGwgcHJvdG9jb2wgcGFyYW1ldGVycy4gVGhlc2UgYXJlIG5lZWRlZCB0byBkbyBjb3JyZWN0LCB1cC10by1kYXRlLCBjb3N0IGNhbGN1bGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5ldHdvcmtQYXJhbXMge1xuXHQjcmF3O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3IFxuXHQgKi9cblx0Y29uc3RydWN0b3IocmF3KSB7XG5cdFx0dGhpcy4jcmF3ID0gcmF3O1xuXHR9XG5cdFxuICAgIC8qKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblx0Z2V0IGNvc3RNb2RlbCgpIHtcblx0XHRyZXR1cm4gYXNzZXJ0RGVmaW5lZCh0aGlzLiNyYXc/LmxhdGVzdFBhcmFtcz8uY29zdE1vZGVscz8uUGx1dHVzU2NyaXB0VjIsIFwiJ29iai5sYXRlc3RQYXJhbXMuY29zdE1vZGVscy5QbHV0dXNTY3JpcHRWMicgdW5kZWZpbmVkXCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvc3RNb2RlbFBhcmFtZXRlcihrZXkpIHtcblx0XHRyZXR1cm4gYXNzZXJ0TnVtYmVyKHRoaXMuY29zdE1vZGVsW2tleV0sIGAnb2JqLiR7a2V5fScgdW5kZWZpbmVkYCk7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHJldHVybnMge0Nvc3R9XG5cdCAqL1xuXHRnZXRUZXJtQ29zdChuYW1lKSB7XG5cdFx0bGV0IG1lbUtleSA9IGBjZWske25hbWV9Q29zdC1leEJ1ZGdldE1lbW9yeWA7XG5cdFx0bGV0IGNwdUtleSA9IGBjZWske25hbWV9Q29zdC1leEJ1ZGdldENQVWA7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVtOiBCaWdJbnQoYXNzZXJ0TnVtYmVyKHRoaXMuY29zdE1vZGVsW21lbUtleV0sIGAnb2JqLiR7bWVtS2V5fScgdW5kZWZpbmVkYCkpLFxuXHRcdFx0Y3B1OiBCaWdJbnQoYXNzZXJ0TnVtYmVyKHRoaXMuY29zdE1vZGVsW2NwdUtleV0sIGAnb2JqLiR7Y3B1S2V5fScgdW5kZWZpbmVkYCkpLFxuXHRcdH07XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7Q29zdH1cblx0ICovXG5cdGdldCBwbHV0dXNDb3JlU3RhcnR1cENvc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGVybUNvc3QoXCJTdGFydHVwXCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0Nvc3R9XG5cdCAqL1xuXHRnZXQgcGx1dHVzQ29yZVZhcmlhYmxlQ29zdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUZXJtQ29zdChcIlZhclwiKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtDb3N0fVxuXHQgKi9cblx0Z2V0IHBsdXR1c0NvcmVMYW1iZGFDb3N0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRlcm1Db3N0KFwiTGFtXCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0Nvc3R9XG5cdCAqL1xuXHRnZXQgcGx1dHVzQ29yZURlbGF5Q29zdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUZXJtQ29zdChcIkRlbGF5XCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0Nvc3R9XG5cdCAqL1xuXHRnZXQgcGx1dHVzQ29yZUNhbGxDb3N0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRlcm1Db3N0KFwiQXBwbHlcIik7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7Q29zdH1cblx0ICovXG5cdGdldCBwbHV0dXNDb3JlQ29uc3RDb3N0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRlcm1Db3N0KFwiQ29uc3RcIik7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7Q29zdH1cblx0ICovXG5cdGdldCBwbHV0dXNDb3JlRm9yY2VDb3N0KCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRlcm1Db3N0KFwiRm9yY2VcIik7XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7Q29zdH1cblx0ICovXG5cdGdldCBwbHV0dXNDb3JlQnVpbHRpbkNvc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGVybUNvc3QoXCJCdWlsdGluXCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHR5cGUge1tudW1iZXIsIG51bWJlcl19IC0gYSArIGIqc2l6ZVxuXHQgKi9cblx0Z2V0IHR4RmVlUGFyYW1zKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRhc3NlcnROdW1iZXIodGhpcy4jcmF3Py5sYXRlc3RQYXJhbXM/LnR4RmVlRml4ZWQpLFxuXHRcdFx0YXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy50eEZlZVBlckJ5dGUpLFxuXHRcdF07XG5cdH1cblxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7W251bWJlciwgbnVtYmVyXX0gLSBbbWVtRmVlLCBjcHVGZWVdXG5cdCAqL1xuXHRnZXQgZXhGZWVQYXJhbXMoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGFzc2VydE51bWJlcih0aGlzLiNyYXc/LmxhdGVzdFBhcmFtcz8uZXhlY3V0aW9uVW5pdFByaWNlcz8ucHJpY2VNZW1vcnkpLFxuXHRcdFx0YXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy5leGVjdXRpb25Vbml0UHJpY2VzPy5wcmljZVN0ZXBzKSxcblx0XHRdO1xuXHR9XG5cdFxuXHQvKipcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdCAqL1xuXHRnZXQgc29ydGVkQ29zdFBhcmFtcygpIHtcblx0XHRsZXQgYmFzZU9iaiA9IHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy5jb3N0TW9kZWxzPy5QbHV0dXNTY3JpcHRWMjtcblx0XHRsZXQga2V5cyA9IE9iamVjdC5rZXlzKGJhc2VPYmopO1xuXG5cdFx0a2V5cy5zb3J0KCk7XG5cblx0XHRyZXR1cm4ga2V5cy5tYXAoa2V5ID0+IGFzc2VydE51bWJlcihiYXNlT2JqW2tleV0pKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbG92ZWxhY2VQZXJVVFhPQnl0ZSgpIHtcblx0XHRyZXR1cm4gYXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy51dHhvQ29zdFBlckJ5dGUpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBtaW5Db2xsYXRlcmFsUGN0KCkge1xuXHRcdHJldHVybiBhc3NlcnROdW1iZXIodGhpcy4jcmF3Py5sYXRlc3RQYXJhbXM/LmNvbGxhdGVyYWxQZXJjZW50YWdlKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWF4Q29sbGF0ZXJhbElucHV0cygpIHtcblx0XHRyZXR1cm4gYXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy5tYXhDb2xsYXRlcmFsSW5wdXRzKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtbbnVtYmVyLCBudW1iZXJdfSAtIFttZW0sIGNwdV1cblx0ICovXG5cdGdldCBtYXhUeEV4ZWN1dGlvbkJ1ZGdldCgpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0YXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy5tYXhUeEV4ZWN1dGlvblVuaXRzPy5tZW1vcnkpLFxuXHRcdFx0YXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0UGFyYW1zPy5tYXhUeEV4ZWN1dGlvblVuaXRzPy5zdGVwcyksXG5cdFx0XTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWF4VHhTaXplKCkge1xuXHRcdHJldHVybiBhc3NlcnROdW1iZXIodGhpcy4jcmF3Py5sYXRlc3RQYXJhbXM/Lm1heFR4U2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge2JpZ2ludH1cblx0ICovXG5cdGdldCBtYXhUeEZlZSgpIHtcblx0XHRjb25zdCBbYSwgYl0gPSB0aGlzLnR4RmVlUGFyYW1zO1xuXHRcdGNvbnN0IFtmZWVQZXJNZW0sIGZlZVBlckNwdV0gPSB0aGlzLmV4RmVlUGFyYW1zO1xuXHRcdGNvbnN0IFttYXhNZW0sIG1heENwdV0gPSB0aGlzLm1heFR4RXhlY3V0aW9uQnVkZ2V0O1xuXG5cdFx0cmV0dXJuIEJpZ0ludChhKSArIEJpZ0ludChNYXRoLmNlaWwoYip0aGlzLm1heFR4U2l6ZSkpICsgQmlnSW50KE1hdGguY2VpbChmZWVQZXJNZW0qbWF4TWVtKSkgKyBCaWdJbnQoTWF0aC5jZWlsKGZlZVBlckNwdSptYXhDcHUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIGxhdGVzdCBzbG90IGluIG5ldHdvcmtQYXJhbWV0ZXJzIHRvIGRldGVybWluZSB0aW1lLlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBzbG90XG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRzbG90VG9UaW1lKHNsb3QpIHtcblx0XHRsZXQgc2Vjb25kc1BlclNsb3QgPSBhc3NlcnROdW1iZXIodGhpcy4jcmF3Py5zaGVsbGV5R2VuZXNpcz8uc2xvdExlbmd0aCk7XG5cblx0XHRsZXQgbGFzdFNsb3QgPSBCaWdJbnQoYXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0VGlwPy5zbG90KSk7XG5cdFx0bGV0IGxhc3RUaW1lID0gQmlnSW50KGFzc2VydE51bWJlcih0aGlzLiNyYXc/LmxhdGVzdFRpcD8udGltZSkpO1xuXG5cdFx0bGV0IHNsb3REaWZmID0gc2xvdCAtIGxhc3RTbG90O1xuXG5cdFx0cmV0dXJuIGxhc3RUaW1lICsgc2xvdERpZmYqQmlnSW50KHNlY29uZHNQZXJTbG90KjEwMDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUgbGF0ZXN0IHNsb3QgaW4gbmV0d29yayBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSBzbG90LlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB0aW1lIC0gbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzBcblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdHRpbWVUb1Nsb3QodGltZSkge1xuXHRcdGxldCBzZWNvbmRzUGVyU2xvdCA9IGFzc2VydE51bWJlcih0aGlzLiNyYXc/LnNoZWxsZXlHZW5lc2lzPy5zbG90TGVuZ3RoKTtcblxuXHRcdGxldCBsYXN0U2xvdCA9IEJpZ0ludChhc3NlcnROdW1iZXIodGhpcy4jcmF3Py5sYXRlc3RUaXA/LnNsb3QpKTtcblx0XHRsZXQgbGFzdFRpbWUgPSBCaWdJbnQoYXNzZXJ0TnVtYmVyKHRoaXMuI3Jhdz8ubGF0ZXN0VGlwPy50aW1lKSk7XG5cblx0XHRsZXQgdGltZURpZmYgPSB0aW1lIC0gbGFzdFRpbWU7XG5cblx0XHRyZXR1cm4gbGFzdFNsb3QgKyBCaWdJbnQoTWF0aC5yb3VuZChOdW1iZXIodGltZURpZmYpLygxMDAwKnNlY29uZHNQZXJTbG90KSkpO1xuXHR9XG59XG5cbi8qKlxuICogRWFjaCBidWlsdGluIGhhcyBhbiBhc3NvY2lhdGVkIENvc3RNb2RlbC5cbiAqIFRoZSBDb3N0TW9kZWwgY2FsY3VsYXRlcyB0aGUgZXhlY3V0aW9uIGNvc3Qgb2YgYSBidWlsdGluLCBkZXBlbmRpbmcgb24gdGhlIGJ5dGUtc2l6ZSBvZiB0aGUgaW5wdXRzLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQ29zdE1vZGVsIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lXG5cdCAqIEByZXR1cm5zIHtDb3N0TW9kZWx9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzIFxuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Y2FsYyhhcmdzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG59XG5cbi8qKlxuICogQSBzaW1wbGUgY29uc3RhbnQgY29zdCwgaW5kZXBlbmRlbnQgb2YgYXJnIHNpemUuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBDb25zdENvc3QgZXh0ZW5kcyBDb3N0TW9kZWwge1xuXHQjY29uc3RhbnQ7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBjb25zdGFudFxuXHQgKi9cblx0Y29uc3RydWN0b3IoY29uc3RhbnQpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI2NvbnN0YW50ID0gY29uc3RhbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXMgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlTmFtZSAtIGVnLiBhZGRJbnRlZ2VyLWNwdS1hcmd1bWVudHNcblx0ICogQHJldHVybnMge0NvbnN0Q29zdH1cblx0ICovXG5cdHN0YXRpYyBmcm9tUGFyYW1zKHBhcmFtcywgYmFzZU5hbWUpIHtcblx0XHRsZXQgYSA9IHBhcmFtcy5nZXRDb3N0TW9kZWxQYXJhbWV0ZXIoYCR7YmFzZU5hbWV9YCk7XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0Q29zdChCaWdJbnQoYSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGFyZ3Ncblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdGNhbGMoYXJncykge1xuXHRcdHJldHVybiB0aGlzLiNjb25zdGFudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRyZXR1cm4gYGNvbnN0OiAke3RoaXMuI2NvbnN0YW50LnRvU3RyaW5nKCl9YDtcblx0fVxufVxuXG4vKipcbiAqIGNvc3QgPSBhICsgYipzaXplKGFyZylcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIExpbmVhckNvc3QgZXh0ZW5kcyBDb3N0TW9kZWwge1xuXHQjYTtcblx0I2I7XG5cblx0LyoqXG5cdCAqIGEgKyBiKlNpemVGbih4LCB5KVxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYSAtIGludGVyY2VwdFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYiAtIHNsb3BlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihhLCBiKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNhID0gYTtcblx0XHR0aGlzLiNiID0gYjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7W2JpZ2ludCwgYmlnaW50XX1cblx0ICovXG5cdHN0YXRpYyBnZXRQYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBhID0gcGFyYW1zLmdldENvc3RNb2RlbFBhcmFtZXRlcihgJHtiYXNlTmFtZX0taW50ZXJjZXB0YCk7XG5cdFx0bGV0IGIgPSBwYXJhbXMuZ2V0Q29zdE1vZGVsUGFyYW1ldGVyKGAke2Jhc2VOYW1lfS1zbG9wZWApO1xuXG5cdFx0cmV0dXJuIFtCaWdJbnQoYSksIEJpZ0ludChiKV07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyfSBzaXplXG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRjYWxjSW50ZXJuYWwoc2l6ZSkge1xuXHRcdHJldHVybiB0aGlzLiNhICsgdGhpcy4jYipCaWdJbnQoc2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIGBpbnRlcmNlcHQ6ICR7dGhpcy4jYS50b1N0cmluZygpfSwgc2xvcGU6ICR7dGhpcy4jYi50b1N0cmluZygpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBjb3N0ID0gYSArIGIqc2l6ZShhcmdzW2ldKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQXJnU2l6ZUNvc3QgZXh0ZW5kcyBMaW5lYXJDb3N0IHtcblx0I2k7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBhIC0gaW50ZXJjZXB0XG5cdCAqIEBwYXJhbSB7YmlnaW50fSBiIC0gc2xvcGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgLSBpbmRleCBvZiB0aGUgYXJnXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihhLCBiLCBpKSB7XG5cdFx0c3VwZXIoYSwgYik7XG5cdFx0dGhpcy4jaSA9IGk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYXJnc1xuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Y2FsYyhhcmdzKSB7XG5cdFx0YXNzZXJ0KHRoaXMuI2kgPCBhcmdzLmxlbmd0aCAmJiB0aGlzLiNpID49IDApO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FsY0ludGVybmFsKGFyZ3NbdGhpcy4jaV0pO1xuXHR9XG59XG5cbi8qKlxuICogY29zdCA9IGEgKyBiKnNpemUoYXJnMClcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEFyZzBTaXplQ29zdCBleHRlbmRzIEFyZ1NpemVDb3N0IHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBhIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYiBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIpIHtcblx0XHRzdXBlcihhLCBiLCAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7QXJnMFNpemVDb3N0fVxuXHQgKi9cblx0c3RhdGljIGZyb21QYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblxuXHRcdHJldHVybiBuZXcgQXJnMFNpemVDb3N0KGEsIGIpO1xuXHR9XG59XG5cbi8qKlxuICogY29zdCA9IGEgKyBiKnNpemUoYXJnMSlcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEFyZzFTaXplQ29zdCBleHRlbmRzIEFyZ1NpemVDb3N0IHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBhIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYiBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIpIHtcblx0XHRzdXBlcihhLCBiLCAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7QXJnMVNpemVDb3N0fVxuXHQgKi9cblx0c3RhdGljIGZyb21QYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblxuXHRcdHJldHVybiBuZXcgQXJnMVNpemVDb3N0KGEsIGIpO1xuXHR9XG59XG5cbi8qKlxuICogY29zdCA9IGEgKyBiKnNpemUoYXJnMilcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEFyZzJTaXplQ29zdCBleHRlbmRzIEFyZ1NpemVDb3N0IHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBhIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYiBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIpIHtcblx0XHRzdXBlcihhLCBiLCAyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7QXJnMlNpemVDb3N0fVxuXHQgKi9cblx0c3RhdGljIGZyb21QYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblxuXHRcdHJldHVybiBuZXcgQXJnMlNpemVDb3N0KGEsIGIpO1xuXHR9XG59XG5cbi8qKlxuICogY29zdCA9IGEgKyBiKm1pbihhcmdzKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgTWluQXJnU2l6ZUNvc3QgZXh0ZW5kcyBMaW5lYXJDb3N0IHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBhIC0gaW50ZXJjZXB0XG5cdCAqIEBwYXJhbSB7YmlnaW50fSBiIC0gc2xvcGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIpIHtcblx0XHRzdXBlcihhLCBiKTtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXMgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlTmFtZSAtIGVnLiBhZGRJbnRlZ2VyLWNwdS1hcmd1bWVudHNcblx0ICogQHJldHVybnMge01heEFyZ1NpemVDb3N0fVxuXHQgKi9cblx0c3RhdGljIGZyb21QYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblxuXHRcdHJldHVybiBuZXcgTWluQXJnU2l6ZUNvc3QoYSwgYik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyW119IGFyZ3Ncblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdGNhbGMoYXJncykge1xuXHRcdHJldHVybiB0aGlzLmNhbGNJbnRlcm5hbChNYXRoLm1pbiguLi5hcmdzKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBjb3N0ID0gYSArIGIqbWF4KGFyZ3MpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBNYXhBcmdTaXplQ29zdCBleHRlbmRzIExpbmVhckNvc3Qge1xuXHQvKipcblx0ICogQHBhcmFtIHtiaWdpbnR9IGEgLSBpbnRlcmNlcHRcblx0ICogQHBhcmFtIHtiaWdpbnR9IGIgLSBzbG9wZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoYSwgYikge1xuXHRcdHN1cGVyKGEsIGIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gcGFyYW1zIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZU5hbWUgLSBlZy4gYWRkSW50ZWdlci1jcHUtYXJndW1lbnRzXG5cdCAqIEByZXR1cm5zIHtNYXhBcmdTaXplQ29zdH1cblx0ICovXG5cdHN0YXRpYyBmcm9tUGFyYW1zKHBhcmFtcywgYmFzZU5hbWUpIHtcblx0XHRsZXQgW2EsIGJdID0gTGluZWFyQ29zdC5nZXRQYXJhbXMocGFyYW1zLCBiYXNlTmFtZSk7XG5cblx0XHRyZXR1cm4gbmV3IE1heEFyZ1NpemVDb3N0KGEsIGIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge251bWJlcltdfSBhcmdzXG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRjYWxjKGFyZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWxjSW50ZXJuYWwoTWF0aC5tYXgoLi4uYXJncykpO1xuXHR9XG59XG5cbi8qKlxuICogY29zdCA9IGEgKyBiKnN1bShzaXplcyhhcmdzKSlcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN1bUFyZ1NpemVzQ29zdCBleHRlbmRzIExpbmVhckNvc3Qge1xuXHQvKipcblx0ICogQHBhcmFtIHtiaWdpbnR9IGEgLSBpbnRlcmNlcHRcblx0ICogQHBhcmFtIHtiaWdpbnR9IGIgLSBzbG9wZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoYSwgYikge1xuXHRcdHN1cGVyKGEsIGIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gcGFyYW1zIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZU5hbWUgLSBlZy4gYWRkSW50ZWdlci1jcHUtYXJndW1lbnRzXG5cdCAqIEByZXR1cm5zIHtNYXhBcmdTaXplQ29zdH1cblx0ICovXG5cdHN0YXRpYyBmcm9tUGFyYW1zKHBhcmFtcywgYmFzZU5hbWUpIHtcblx0XHRsZXQgW2EsIGJdID0gTGluZWFyQ29zdC5nZXRQYXJhbXMocGFyYW1zLCBiYXNlTmFtZSk7XG5cblx0XHRyZXR1cm4gbmV3IFN1bUFyZ1NpemVzQ29zdChhLCBiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJbXX0gYXJnc1xuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Y2FsYyhhcmdzKSB7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRmb3IgKGxldCBhcmcgb2YgYXJncykge1xuXHRcdFx0c3VtICs9IGFyZztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jYWxjSW50ZXJuYWwoc3VtKTtcblx0fVxufVxuXG4vKipcbiAqIGNvc3QgPSBhICsgYiptYXgoc2l6ZShhcmcwKS1zaXplKGFyZzEpLCBtaW4pXG4gKiAob25seSBmb3IgVXBsYyBmdW5jdGlvbnMgd2l0aCB0d28gYXJndW1lbnRzKSBcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEFyZ1NpemVEaWZmQ29zdCBleHRlbmRzIExpbmVhckNvc3Qge1xuXHQjbWluO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYSAtIGludGVyY2VwdFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYiAtIHNsb3BlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIsIG1pbikge1xuXHRcdHN1cGVyKGEsIGIpO1xuXHRcdHRoaXMuI21pbiA9IG1pblxuXHR9XG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7QXJnU2l6ZURpZmZDb3N0fVxuXHQgKi9cblx0c3RhdGljIGZyb21QYXJhbXMocGFyYW1zLCBiYXNlTmFtZSkge1xuXHRcdGxldCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblx0XHRsZXQgbWluID0gcGFyYW1zLmdldENvc3RNb2RlbFBhcmFtZXRlcihgJHtiYXNlTmFtZX0tbWluaW11bWApO1xuXG5cdFx0cmV0dXJuIG5ldyBBcmdTaXplRGlmZkNvc3QoYSwgYiwgbWluKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzXG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRjYWxjKGFyZ3MpIHtcblx0XHRhc3NlcnQoYXJncy5sZW5ndGggPT0gMik7XG5cdFx0bGV0IFt4LCB5XSA9IGFyZ3M7XG5cblx0XHRyZXR1cm4gdGhpcy5jYWxjSW50ZXJuYWwoTWF0aC5tYXgoeCAtIHksIHRoaXMuI21pbikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRkdW1wKCkge1xuXHRcdHJldHVybiBzdXBlci5kdW1wKCkgKyBgLCBtaW5pbXVtOiAke3RoaXMuI21pbi50b1N0cmluZygpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBjb3N0ID0gKHNpemUoYXJnMCkgPiBzaXplKGFyZzEpKSA/IGNvbnN0YW50IDogYSArIGIqc2l6ZShhcmcwKSpzaXplKGFyZzEpXG4gKiAob25seSBmb3IgVXBsYyBmdW5jdGlvbnMgd2l0aCB0d28gYXJndW1lbnRzKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQXJnU2l6ZVByb2RDb3N0IGV4dGVuZHMgTGluZWFyQ29zdCB7XG5cdCNjb25zdGFudDtcblxuXHQvKipcblx0ICogQHBhcmFtIHtiaWdpbnR9IGEgLSBpbnRlcmNlcHRcblx0ICogQHBhcmFtIHtiaWdpbnR9IGIgLSBzbG9wZVxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gY29uc3RhbnRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIsIGNvbnN0YW50KSB7XG5cdFx0c3VwZXIoYSwgYik7XG5cdFx0dGhpcy4jY29uc3RhbnQgPSBjb25zdGFudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtcyBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VOYW1lIC0gZWcuIGFkZEludGVnZXItY3B1LWFyZ3VtZW50c1xuXHQgKiBAcmV0dXJucyB7TWF4QXJnU2l6ZUNvc3R9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKSB7XG5cdFx0Y29uc3QgW2EsIGJdID0gTGluZWFyQ29zdC5nZXRQYXJhbXMocGFyYW1zLCBgJHtiYXNlTmFtZX0tbW9kZWwtYXJndW1lbnRzYCk7XG5cdFx0Y29uc3QgY29uc3RhbnQgPSBwYXJhbXMuZ2V0Q29zdE1vZGVsUGFyYW1ldGVyKGAke2Jhc2VOYW1lfS1jb25zdGFudGApO1xuXG5cdFx0cmV0dXJuIG5ldyBBcmdTaXplUHJvZENvc3QoYSwgYiwgQmlnSW50KGNvbnN0YW50KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYXJnc1xuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Y2FsYyhhcmdzKSB7XG5cdFx0YXNzZXJ0KGFyZ3MubGVuZ3RoID09IDIpO1xuXHRcdFxuXHRcdGNvbnN0IFt4LCB5XSA9IGFyZ3M7XG5cblx0XHRpZiAoeCA+IHkpIHtcblx0XHRcdHJldHVybiB0aGlzLiNjb25zdGFudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FsY0ludGVybmFsKHgqeSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRkdW1wKCkge1xuXHRcdHJldHVybiBzdXBlci5kdW1wKCkgKyBgLCBjb25zdGFudDogJHt0aGlzLiNjb25zdGFudC50b1N0cmluZygpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBjb3N0ID0gKHNpemUoYXJnMCkgIT0gc2l6ZShhcmcxKSkgPyBjb25zdGFudCA6IGEgKyBiKnNpemUoYXJnMClcbiAqIChvbmx5IGZvciBVcGxjIGZ1bmN0aW9ucyB3aXRoIHR3byBhcmd1bWVudHMpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBBcmdTaXplRGlhZ0Nvc3QgZXh0ZW5kcyBMaW5lYXJDb3N0IHtcblx0I2NvbnN0YW50O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYVxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gYlxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gY29uc3RhbnRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGEsIGIsIGNvbnN0YW50KSB7XG5cdFx0c3VwZXIoYSwgYik7XG5cdFx0dGhpcy4jY29uc3RhbnQgPSBjb25zdGFudDtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXMgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlTmFtZSAtIGVnLiBhZGRJbnRlZ2VyLWNwdS1hcmd1bWVudHNcblx0ICogQHJldHVybnMge0FyZ1NpemVEaWFnQ29zdH1cblx0ICovXG5cdHN0YXRpYyBmcm9tUGFyYW1zKHBhcmFtcywgYmFzZU5hbWUpIHtcblx0XHRjb25zdCBbYSwgYl0gPSBMaW5lYXJDb3N0LmdldFBhcmFtcyhwYXJhbXMsIGJhc2VOYW1lKTtcblx0XHRjb25zdCBjb25zdGFudCA9IHBhcmFtcy5nZXRDb3N0TW9kZWxQYXJhbWV0ZXIoYCR7YmFzZU5hbWV9LWNvbnN0YW50YCk7XG5cblx0XHRyZXR1cm4gbmV3IEFyZ1NpemVEaWFnQ29zdChhLCBiLCBCaWdJbnQoY29uc3RhbnQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzIFxuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0Y2FsYyhhcmdzKSB7XG5cdFx0YXNzZXJ0KGFyZ3MubGVuZ3RoID09IDIpO1xuXG5cdFx0aWYgKGFyZ3NbMF0gPT0gYXJnc1sxXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FsY0ludGVybmFsKGFyZ3NbMF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jY29uc3RhbnQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRkdW1wKCkge1xuXHRcdHJldHVybiBzdXBlci5kdW1wKCkgKyBgLCBjb25zdGFudDogJHt0aGlzLiNjb25zdGFudC50b1N0cmluZygpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBDb3N0TW9kZWxDbGFzc1xuICogQHByb3BlcnR5IHsocGFyYW1zOiBOZXR3b3JrUGFyYW1zLCBiYXNlTmFtZTogc3RyaW5nKSA9PiBDb3N0TW9kZWx9IGZyb21QYXJhbXNcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gOTogVXBsYyBidWlsdC1pbiBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb3N0LW1vZGVsIGNvbmZpZ3VyYXRpb24gb2YgVXBsY0J1aWx0aW4uXG4gKiBBbHNvIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgYnVpbHRpbiBtdXN0IGJlICdmb3JjZWQnIGJlZm9yZSBiZWluZyBjYWxsYWJsZS5cbiAqIEBwYWNrYWdlXG4gKi9cbiBjbGFzcyBVcGxjQnVpbHRpbkNvbmZpZyB7XG5cdCNuYW1lO1xuXHQjZm9yY2VDb3VudDtcblx0I21lbUNvc3RNb2RlbENsYXNzO1xuXHQjY3B1Q29zdE1vZGVsQ2xhc3M7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZm9yY2VDb3VudCAtIG51bWJlciBvZiB0eXBlIHBhcmFtZXRlcnMgb2YgYSBQbHV0dXMtY29yZSBidWlsdGluIGZ1bmN0aW9uICgwLCAxIG9yIDIpXG5cdCAqIEBwYXJhbSB7Q29zdE1vZGVsQ2xhc3N9IG1lbUNvc3RNb2RlbENsYXNzIFxuXHQgKiBAcGFyYW0ge0Nvc3RNb2RlbENsYXNzfSBjcHVDb3N0TW9kZWxDbGFzcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIGZvcmNlQ291bnQsIG1lbUNvc3RNb2RlbENsYXNzLCBjcHVDb3N0TW9kZWxDbGFzcykge1xuXHRcdHRoaXMuI25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuI2ZvcmNlQ291bnQgPSBmb3JjZUNvdW50O1xuXHRcdHRoaXMuI21lbUNvc3RNb2RlbENsYXNzID0gbWVtQ29zdE1vZGVsQ2xhc3M7XG5cdFx0dGhpcy4jY3B1Q29zdE1vZGVsQ2xhc3MgPSBjcHVDb3N0TW9kZWxDbGFzcztcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lO1xuXHR9XG5cblx0Z2V0IGZvcmNlQ291bnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZvcmNlQ291bnQ7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXNcblx0ICogQHJldHVybnMge1tDb3N0TW9kZWwsIENvc3RNb2RlbF19XG5cdCAqL1xuXHRpbnN0YW50aWF0ZUNvc3RNb2RlbHMocGFyYW1zKSB7XG5cdFx0aWYgKHRoaXMuI21lbUNvc3RNb2RlbENsYXNzICE9PSBudWxsICYmIHRoaXMuI2NwdUNvc3RNb2RlbENsYXNzICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgbWVtQ29zdE1vZGVsID0gdGhpcy4jbWVtQ29zdE1vZGVsQ2xhc3MuZnJvbVBhcmFtcyhwYXJhbXMsIGAke3RoaXMuI25hbWV9LW1lbW9yeS1hcmd1bWVudHNgKTtcblx0XHRcdGxldCBjcHVDb3N0TW9kZWwgPSB0aGlzLiNjcHVDb3N0TW9kZWxDbGFzcy5mcm9tUGFyYW1zKHBhcmFtcywgYCR7dGhpcy4jbmFtZX0tY3B1LWFyZ3VtZW50c2ApO1xuXG5cdFx0XHRyZXR1cm4gW21lbUNvc3RNb2RlbCwgY3B1Q29zdE1vZGVsXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBjb3N0IG1vZGVsIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIGJ1aWx0aW4gJHt0aGlzLiNuYW1lfWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IHBhcmFtc1xuXHQgKiBAcGFyYW0ge251bWJlcltdfSBhcmdTaXplc1xuXHQgKiBAcmV0dXJucyB7Q29zdH1cblx0ICovXG5cdGNhbGNDb3N0KHBhcmFtcywgYXJnU2l6ZXMpIHtcblx0XHQvLyBOb3RlOiBpbnN0YW50aWF0aW5nIGV2ZXJ5dGltZSBtaWdodCBiZSBzbG93LiBTaG91bGQgdGhpcyBiZSBjYWNoZWQgKGVnLiBpbiB0aGUgcGFyYW1zIG9iamVjdD8pP1xuXHRcdGNvbnN0IFttZW1Db3N0TW9kZWwsIGNwdUNvc3RNb2RlbF0gPSB0aGlzLmluc3RhbnRpYXRlQ29zdE1vZGVscyhwYXJhbXMpO1xuXG5cdFx0Y29uc3QgbWVtQ29zdCA9IG1lbUNvc3RNb2RlbC5jYWxjKGFyZ1NpemVzKTtcblx0XHRjb25zdCBjcHVDb3N0ID0gY3B1Q29zdE1vZGVsLmNhbGMoYXJnU2l6ZXMpO1xuXG5cdFx0cmV0dXJuIHttZW06IG1lbUNvc3QsIGNwdTogY3B1Q29zdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBwYXJhbXNcblx0ICovXG5cdGR1bXBDb3N0TW9kZWwocGFyYW1zKSB7XG5cdFx0Y29uc3QgW21lbUNvc3RNb2RlbCwgY3B1Q29zdE1vZGVsXSA9IHRoaXMuaW5zdGFudGlhdGVDb3N0TW9kZWxzKHBhcmFtcyk7XG5cblx0XHRjb25zb2xlLmxvZyhgJHt0aGlzLm5hbWV9LW1lbW9yeS1hcmd1bWVudHM9eyR7bWVtQ29zdE1vZGVsLmR1bXAoKX0sXFxuJHt0aGlzLm5hbWV9LWNwdS1hcmd1bWVudHM9eyR7Y3B1Q29zdE1vZGVsLmR1bXAoKX19YCk7XG5cdH1cbn1cblxuLyoqIFxuICogQSBsaXN0IG9mIGFsbCBQbHV0dXNTY3JpcHQgYnVpbGlucywgd2l0aCBhc3NvY2lhdGVkIGNvc3Rtb2RlbHMgKGFjdHVhbCBjb3N0bW9kZWwgcGFyYW1ldGVycyBhcmUgbG9hZGVkIGZyb20gTmV0d29ya1BhcmFtcyBkdXJpbmcgcnVudGltZSlcbiAqIEBwYWNrYWdlXG4gKiBAdHlwZSB7VXBsY0J1aWx0aW5Db25maWdbXX0gXG4gKi9cbmNvbnN0IFVQTENfQlVJTFRJTlMgPSAoXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VXBsY0J1aWx0aW5Db25maWdbXX1cblx0ICovXG5cdGZ1bmN0aW9uICgpIHtcblx0XHQvKipcblx0XHQgKiBDb25zdHJ1Y3RzIGEgYnVpbHRpbkluZm8gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGZvcmNlQ291bnQgXG5cdFx0ICogQHBhcmFtIHtDb3N0TW9kZWxDbGFzc30gbWVtQ29zdE1vZGVsXG5cdFx0ICogQHBhcmFtIHtDb3N0TW9kZWxDbGFzc30gY3B1Q29zdE1vZGVsXG5cdFx0ICogQHJldHVybnMge1VwbGNCdWlsdGluQ29uZmlnfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJ1aWx0aW5Db25maWcobmFtZSwgZm9yY2VDb3VudCwgbWVtQ29zdE1vZGVsLCBjcHVDb3N0TW9kZWwpIHtcblx0XHRcdC8vIGJ1aWx0aW5zIG1pZ2h0IG5lZWQgYmUgd3JhcHBlZCBpbiBgZm9yY2VgIGEgbnVtYmVyIG9mIHRpbWVzIGlmIHRoZXkgYXJlIG5vdCBmdWxseSB0eXBlZFxuXHRcdFx0cmV0dXJuIG5ldyBVcGxjQnVpbHRpbkNvbmZpZyhuYW1lLCBmb3JjZUNvdW50LCBtZW1Db3N0TW9kZWwsIGNwdUNvc3RNb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJhZGRJbnRlZ2VyXCIsICAgICAgICAgICAgICAgMCwgTWF4QXJnU2l6ZUNvc3QsIE1heEFyZ1NpemVDb3N0KSwgLy8gMFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInN1YnRyYWN0SW50ZWdlclwiLCAgICAgICAgICAwLCBNYXhBcmdTaXplQ29zdCwgTWF4QXJnU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcIm11bHRpcGx5SW50ZWdlclwiLCAgICAgICAgICAwLCBTdW1BcmdTaXplc0Nvc3QsIFN1bUFyZ1NpemVzQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiZGl2aWRlSW50ZWdlclwiLCAgICAgICAgICAgIDAsIEFyZ1NpemVEaWZmQ29zdCwgQXJnU2l6ZVByb2RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJxdW90aWVudEludGVnZXJcIiwgICAgICAgICAgMCwgQXJnU2l6ZURpZmZDb3N0LCBBcmdTaXplUHJvZENvc3QpLCBcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJyZW1haW5kZXJJbnRlZ2VyXCIsICAgICAgICAgMCwgQXJnU2l6ZURpZmZDb3N0LCBBcmdTaXplUHJvZENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcIm1vZEludGVnZXJcIiwgICAgICAgICAgICAgICAwLCBBcmdTaXplRGlmZkNvc3QsIEFyZ1NpemVQcm9kQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiZXF1YWxzSW50ZWdlclwiLCAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgTWluQXJnU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImxlc3NUaGFuSW50ZWdlclwiLCAgICAgICAgICAwLCBDb25zdENvc3QsIE1pbkFyZ1NpemVDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJsZXNzVGhhbkVxdWFsc0ludGVnZXJcIiwgICAgMCwgQ29uc3RDb3N0LCBNaW5BcmdTaXplQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiYXBwZW5kQnl0ZVN0cmluZ1wiLCAgICAgICAgIDAsIFN1bUFyZ1NpemVzQ29zdCwgU3VtQXJnU2l6ZXNDb3N0KSwgLy8gMTBcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJjb25zQnl0ZVN0cmluZ1wiLCAgICAgICAgICAgMCwgU3VtQXJnU2l6ZXNDb3N0LCBBcmcxU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInNsaWNlQnl0ZVN0cmluZ1wiLCAgICAgICAgICAwLCBBcmcyU2l6ZUNvc3QsIEFyZzJTaXplQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibGVuZ3RoT2ZCeXRlU3RyaW5nXCIsICAgICAgIDAsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJpbmRleEJ5dGVTdHJpbmdcIiwgICAgICAgICAgMCwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImVxdWFsc0J5dGVTdHJpbmdcIiwgICAgICAgICAwLCBDb25zdENvc3QsIEFyZ1NpemVEaWFnQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibGVzc1RoYW5CeXRlU3RyaW5nXCIsICAgICAgIDAsIENvbnN0Q29zdCwgTWluQXJnU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImxlc3NUaGFuRXF1YWxzQnl0ZVN0cmluZ1wiLCAwLCBDb25zdENvc3QsIE1pbkFyZ1NpemVDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJzaGEyXzI1NlwiLCAgICAgICAgICAgICAgICAgMCwgQ29uc3RDb3N0LCBBcmcwU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInNoYTNfMjU2XCIsICAgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIEFyZzBTaXplQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiYmxha2UyYl8yNTZcIiwgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQXJnMFNpemVDb3N0KSwgLy8gMjBcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJ2ZXJpZnlFZDI1NTE5U2lnbmF0dXJlXCIsICAgMCwgQ29uc3RDb3N0LCBBcmcyU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImFwcGVuZFN0cmluZ1wiLCAgICAgICAgICAgICAwLCBTdW1BcmdTaXplc0Nvc3QsIFN1bUFyZ1NpemVzQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiZXF1YWxzU3RyaW5nXCIsICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQXJnU2l6ZURpYWdDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJlbmNvZGVVdGY4XCIsICAgICAgICAgICAgICAgMCwgQXJnMFNpemVDb3N0LCBBcmcwU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImRlY29kZVV0ZjhcIiwgICAgICAgICAgICAgICAwLCBBcmcwU2l6ZUNvc3QsIEFyZzBTaXplQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiaWZUaGVuRWxzZVwiLCAgICAgICAgICAgICAgIDEsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJjaG9vc2VVbml0XCIsICAgICAgICAgICAgICAgMSwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInRyYWNlXCIsICAgICAgICAgICAgICAgICAgICAxLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiZnN0UGFpclwiLCAgICAgICAgICAgICAgICAgIDIsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJzbmRQYWlyXCIsICAgICAgICAgICAgICAgICAgMiwgQ29uc3RDb3N0LCBDb25zdENvc3QpLCAvLyAzMFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImNob29zZUxpc3RcIiwgICAgICAgICAgICAgICAyLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibWtDb25zXCIsICAgICAgICAgICAgICAgICAgIDEsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJoZWFkTGlzdFwiLCAgICAgICAgICAgICAgICAgMSwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInRhaWxMaXN0XCIsICAgICAgICAgICAgICAgICAxLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibnVsbExpc3RcIiwgICAgICAgICAgICAgICAgIDEsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJjaG9vc2VEYXRhXCIsICAgICAgICAgICAgICAgMSwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImNvbnN0ckRhdGFcIiwgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibWFwRGF0YVwiLCAgICAgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJsaXN0RGF0YVwiLCAgICAgICAgICAgICAgICAgMCwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcImlEYXRhXCIsICAgICAgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksIC8vIDQwXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiYkRhdGFcIiwgICAgICAgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJ1bkNvbnN0ckRhdGFcIiwgICAgICAgICAgICAgMCwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInVuTWFwRGF0YVwiLCAgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwidW5MaXN0RGF0YVwiLCAgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJ1bklEYXRhXCIsICAgICAgICAgICAgICAgICAgMCwgQ29uc3RDb3N0LCBDb25zdENvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInVuQkRhdGFcIiwgICAgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwiZXF1YWxzRGF0YVwiLCAgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgTWluQXJnU2l6ZUNvc3QpLFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcIm1rUGFpckRhdGFcIiwgICAgICAgICAgICAgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwibWtOaWxEYXRhXCIsICAgICAgICAgICAgICAgIDAsIENvbnN0Q29zdCwgQ29uc3RDb3N0KSxcblx0XHRcdGJ1aWx0aW5Db25maWcoXCJta05pbFBhaXJEYXRhXCIsICAgICAgICAgICAgMCwgQ29uc3RDb3N0LCBDb25zdENvc3QpLCAvLyA1MFxuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInNlcmlhbGlzZURhdGFcIiwgICAgICAgICAgICAwLCBBcmcwU2l6ZUNvc3QsIEFyZzBTaXplQ29zdCksXG5cdFx0XHRidWlsdGluQ29uZmlnKFwidmVyaWZ5RWNkc2FTZWNwMjU2azFTaWduYXR1cmVcIiwgICAwLCBDb25zdENvc3QsIENvbnN0Q29zdCksIC8vIHRoZXNlIHBhcmFtZXRlcnMgYXJlIGZyb20gYWlrZW4sIGJ1dCB0aGUgY2FyZGFuby1jbGkgcGFyYW1ldGVyIGZpbGUgZGlmZmVyP1xuXHRcdFx0YnVpbHRpbkNvbmZpZyhcInZlcmlmeVNjaG5vcnJTZWNwMjU2azFTaWduYXR1cmVcIiwgMCwgQ29uc3RDb3N0LCBBcmcxU2l6ZUNvc3QpLCAvLyB0aGVzZSBwYXJhbWV0ZXJzIGFyZSBmcm9tLCBidXQgdGhlIGNhcmRhbm8tY2xpIHBhcmFtZXRlciBmaWxlIGRpZmZlcnM/XG5cdFx0XTtcblx0fVxuKSgpO1xuXG4vKipcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNoZWNrIGNvc3QtbW9kZWwgcGFyYW1ldGVyc1xuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuICovXG5mdW5jdGlvbiBkdW1wQ29zdE1vZGVscyhuZXR3b3JrUGFyYW1zKSB7XG5cdGZvciAobGV0IGJ1aWx0aW4gb2YgVVBMQ19CVUlMVElOUykge1xuXHRcdGJ1aWx0aW4uZHVtcENvc3RNb2RlbChuZXR3b3JrUGFyYW1zKTtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgaW5kZXggb2YgYSBuYW1lZCBidWlsdGluXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYnVpbHRpbiBkb2Vzbid0IGV4aXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFVwbGNCdWlsdGluKG5hbWUpIHtcblx0bGV0IGkgPSBVUExDX0JVSUxUSU5TLmZpbmRJbmRleChpbmZvID0+IHsgcmV0dXJuIFwiX19jb3JlX19cIiArIGluZm8ubmFtZSA9PSBuYW1lIH0pO1xuXHRhc3NlcnQoaSAhPSAtMSwgYCR7bmFtZX0gaXMgbm90IGEgcmVhbCBidWlsdGluYCk7XG5cdHJldHVybiBpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG5hbWVkIGJ1aWx0aW4gZXhpc3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RyaWN0IC0gaWYgdHJ1ZSB0aGVuIHRocm93cyBhbiBlcnJvciBpZiBidWlsdGluIGRvZXNuJ3QgZXhpc3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVcGxjQnVpbHRpbihuYW1lLCBzdHJpY3QgPSBmYWxzZSkge1xuXHRpZiAobmFtZS5zdGFydHNXaXRoKFwiX19jb3JlXCIpKSB7XG5cdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0dm9pZCB0aGlzLmZpbmRCdWlsdGluKG5hbWUpOyAvLyBhc3NlcnQgdGhhdCBidWlsdGluIGV4aXN0c1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAxMDogVXBsYyBBU1Rcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiBBIEhlbGlvcy9VcGxjIFByb2dyYW0gY2FuIGhhdmUgZGlmZmVyZW50IHB1cnBvc2VzXG4gKiBAcGFja2FnZVxuICovXG5jb25zdCBTY3JpcHRQdXJwb3NlID0ge1xuXHRUZXN0aW5nOiAtMSxcblx0TWludGluZzogIDAsXG5cdFNwZW5kaW5nOiAxLFxuXHRTdGFraW5nOiAgMixcblx0TW9kdWxlOiAgIDNcbn07XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0UHVycG9zZU5hbWUoaWQpIHtcblx0c3dpdGNoIChpZCkge1xuXHRcdGNhc2UgU2NyaXB0UHVycG9zZS5UZXN0aW5nOlxuXHRcdFx0cmV0dXJuIFwidGVzdGluZ1wiO1xuXHRcdGNhc2UgU2NyaXB0UHVycG9zZS5NaW50aW5nOlxuXHRcdFx0cmV0dXJuIFwibWludGluZ1wiO1xuXHRcdGNhc2UgU2NyaXB0UHVycG9zZS5TcGVuZGluZzpcblx0XHRcdHJldHVybiBcInNwZW5kaW5nXCI7XG5cdFx0Y2FzZSBTY3JpcHRQdXJwb3NlLlN0YWtpbmc6XG5cdFx0XHRyZXR1cm4gXCJzdGFraW5nXCI7XG5cdFx0Y2FzZSBTY3JpcHRQdXJwb3NlLk1vZHVsZTpcblx0XHRcdHJldHVybiBcIm1vZHVsZVwiO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBTY3JpcHRQdXJwb3NlICR7aWR9YCk7XG5cdH1cbn1cblxuXG4vKiogXG4gKiBhIFVwbGNWYWx1ZSBpcyBwYXNzZWQgYXJvdW5kIGJ5IFBsdXR1cy1jb3JlIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgVXBsY1ZhbHVlIHtcblx0I3NpdGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUpIHtcblx0XHRhc3NlcnQoc2l0ZSAhPSB1bmRlZmluZWQgJiYgKHNpdGUgaW5zdGFuY2VvZiBTaXRlKSk7XG5cdFx0dGhpcy4jc2l0ZSA9IHNpdGU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGEgY29weSBvZiB0aGUgVXBsY1ZhbHVlIGF0IGEgZGlmZmVyZW50IFNpdGUuXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtTaXRlfSBuZXdTaXRlIFxuXHQgKiBAcmV0dXJucyB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBAcGFja2FnZVxuICAgICAqIEB0eXBlIHtTaXRlfVxuICAgICAqL1xuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IGxlbmd0aCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBsaXN0IG5vciBhIG1hcFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaXplIGluIHdvcmRzICg4IGJ5dGVzLCA2NCBiaXRzKSBvY2N1cGllZCBpbiB0YXJnZXQgbm9kZVxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIG1vc3QgdmFsdWVzIGNhbid0IGJlIGNhbGxlZCAob3ZlcnJpZGRlbiBieSBVcGxjQW5vbilcbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1VwbGNSdGUgfCBVcGxjU3RhY2t9IHJ0ZSBcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZX0gdmFsdWVcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGNhbGwocnRlLCBzaXRlLCB2YWx1ZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhIFBsdXR1cy1jb3JlIGZ1bmN0aW9uLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7VXBsY1J0ZSB8IFVwbGNTdGFja30gcnRlIFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxVcGxjVmFsdWU+fVxuXHQgKi9cblx0YXN5bmMgZXZhbChydGUpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7YmlnaW50fVxuXHQgKi9cblx0Z2V0IGludCgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhIFBsdXR1cy1jb3JlIGludCwgZ290ICcke3RoaXMudG9TdHJpbmcoKX0nYCk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcltdfVxuXHQgKi9cblx0Z2V0IGJ5dGVzKCkge1xuXHRcdHRocm93IHRoaXMuc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGEgUGx1dHVzLWNvcmUgYnl0ZWFycmF5LCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHN0cmluZygpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhIFBsdXR1cy1jb3JlIHN0cmluZywgZ290ICcke3RoaXMudG9TdHJpbmcoKX0nYCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdGdldCBib29sKCkge1xuXHRcdHRocm93IHRoaXMuc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGEgUGx1dHVzLWNvcmUgYm9vbCwgZ290ICcke3RoaXMudG9TdHJpbmcoKX0nYCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzdGluZ3Vpc2hlcyBhIHBhaXIgZnJvbSBhIG1hcEl0ZW1cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1BhaXIoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRnZXQgZmlyc3QoKSB7XG5cdFx0dGhyb3cgdGhpcy5zaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgYSBQbHV0dXMtY29yZSBwYWlyLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Z2V0IHNlY29uZCgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhIFBsdXR1cy1jb3JlIHBhaXIsIGdvdCAnJHt0aGlzLnRvU3RyaW5nKCl9J2ApO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc3Rpbmd1aXNoZXMgYSBsaXN0IGZyb20gYSBtYXBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0xpc3QoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjVHlwZX1cblx0ICovXG5cdGdldCBpdGVtVHlwZSgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKFwibm90IGEgbGlzdFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY1ZhbHVlW119XG5cdCAqL1xuXHRnZXQgbGlzdCgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhIFBsdXR1cy1jb3JlIGxpc3QsIGdvdCAnJHt0aGlzLnRvU3RyaW5nKCl9J2ApO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblx0aXNEYXRhKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY0RhdGF9XG5cdCAqL1xuXHRnZXQgZGF0YSgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBQbHV0dXMtY29yZSBkYXRhLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFVwbGNWYWx1ZT59XG5cdCAqL1xuXHRmb3JjZSgpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBkZWxheWVkIHZhbHVlLCBnb3QgJyR7dGhpcy50b1N0cmluZygpfSdgKTtcblx0fVxuXG5cdC8qKlxuICAgICAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtVcGxjVW5pdH1cblx0ICovXG5cdGFzc2VydFVuaXQoKSB7XG5cdFx0dGhyb3cgdGhpcy5zaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgUGx1dHVzLWNvcmUgdW5pdCwgZ290ICcke3RoaXMudG9TdHJpbmd9J2ApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHR5cGVCaXRzKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB2YWx1ZSB3aXRob3V0IHR5cGUgaGVhZGVyXG4gICAgICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlclxuXHQgKi9cblx0dG9GbGF0VmFsdWVJbnRlcm5hbChiaXRXcml0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdmFsdWUgd2l0aCBwbHV0dXMgZmxhdCBlbmNvZGluZy5cblx0ICogTWVtYmVyIGZ1bmN0aW9uIG5vdCBuYW1lZCAndG9GbGF0JyBhcyBub3QgdG8gY29uZnVzZSB3aXRoICd0b0ZsYXQnIG1lbWJlciBvZiB0ZXJtcy5cbiAgICAgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyXG5cdCAqL1xuXHR0b0ZsYXRWYWx1ZShiaXRXcml0ZXIpIHtcblx0XHRiaXRXcml0ZXIud3JpdGUoJzEnICsgdGhpcy50eXBlQml0cygpICsgJzAnKTtcblx0XHRcblx0XHR0aGlzLnRvRmxhdFZhbHVlSW50ZXJuYWwoYml0V3JpdGVyKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVXBsY1R5cGUge1xuXHQjdHlwZUJpdHM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlQml0cyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHR5cGVCaXRzKSB7XG5cdFx0dGhpcy4jdHlwZUJpdHMgPSB0eXBlQml0cztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dHlwZUJpdHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGVCaXRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSB2YWx1ZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1NhbWVUeXBlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGVCaXRzID09IHZhbHVlLnR5cGVCaXRzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNUeXBlfVxuXHQgKi9cblx0c3RhdGljIG5ld0RhdGFUeXBlKCkge1xuXHRcdHJldHVybiBuZXcgVXBsY1R5cGUoXCIxMDAwXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtVcGxjVHlwZX1cblx0ICovXG5cdHN0YXRpYyBuZXdEYXRhUGFpclR5cGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjVHlwZShbXCIwMTExXCIsIFwiMDExMVwiLCBcIjAxMTBcIiwgXCIxMDAwXCIsIFwiMTAwMFwiXS5qb2luKFwiMVwiKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gbHN0XG5cdCAqIEByZXR1cm5zIHtVcGxjVHlwZX1cblx0ICovXG5cdHN0YXRpYyBmcm9tTnVtYmVycyhsc3QpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNUeXBlKGxzdC5tYXAoeCA9PiBieXRlVG9CaXRTdHJpbmcoeCwgNCwgZmFsc2UpKS5qb2luKFwiMVwiKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHR5cGVkZWYge1s/c3RyaW5nLCBVcGxjVmFsdWVdW119IFVwbGNSYXdTdGFja1xuICovXG5cbi8qKlxuKiBAdHlwZWRlZiB7b2JqZWN0fSBVcGxjUlRFQ2FsbGJhY2tzXG4qIEBwcm9wZXJ0eSB7KG1zZzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+fSBbb25QcmludF1cbiogQHByb3BlcnR5IHsoc2l0ZTogU2l0ZSwgcmF3U3RhY2s6IFVwbGNSYXdTdGFjaykgPT4gUHJvbWlzZTxib29sZWFuPn0gW29uU3RhcnRDYWxsXVxuKiBAcHJvcGVydHkgeyhzaXRlOiBTaXRlLCByYXdTdGFjazogVXBsY1Jhd1N0YWNrKSA9PiBQcm9taXNlPHZvaWQ+fSBbb25FbmRDYWxsXVxuKiBAcHJvcGVydHkgeyhuYW1lOiBzdHJpbmcsIGlzVGVybTogYm9vbGVhbiwgY29zdDogQ29zdCkgPT4gdm9pZH0gW29uSW5jckNvc3RdXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtVcGxjUlRFQ2FsbGJhY2tzfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9VUExDX1JURV9DQUxMQkFDS1MgPSB7XG5cdG9uUHJpbnQ6IGFzeW5jIGZ1bmN0aW9uICgvKiogQHR5cGUge3N0cmluZ30gKi8gbXNnKSB7cmV0dXJufSxcblx0b25TdGFydENhbGw6IGFzeW5jIGZ1bmN0aW9uKC8qKiBAdHlwZSB7U2l0ZX0gKi8gc2l0ZSwgLyoqIEB0eXBlIHtVcGxjUmF3U3RhY2t9ICovIHJhd1N0YWNrKSB7cmV0dXJuIGZhbHNlfSxcblx0b25FbmRDYWxsOiBhc3luYyBmdW5jdGlvbigvKiogQHR5cGUge1NpdGV9ICovIHNpdGUsIC8qKiBAdHlwZSB7VXBsY1Jhd1N0YWNrfSAqLyByYXdTdGFjaykge3JldHVybn0sXG5cdG9uSW5jckNvc3Q6IGZ1bmN0aW9uKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyBuYW1lLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIGlzVGVybSwgLyoqIEB0eXBlIHtDb3N0fSAqLyBjb3N0KSB7cmV0dXJufSxcbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBSdW50aW1lIEVudmlyb25tZW50IGlzIHVzZWQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwcm9ncmFtbWluZyBldmFsdWF0aW9uIChlZy4gYnkgYSBkZWJ1Z2dlcilcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFVwbGNSdGUge1xuXHQjY2FsbGJhY2tzO1xuXG5cdCNuZXR3b3JrUGFyYW1zO1xuXG5cdC8qKlxuXHQgKiB0aGlzLm9uTm90aWZ5Q2FsbHMgaXMgc2V0IHRvICdmYWxzZScgd2hlbiB0aGUgZGVidWdnZXIgaXMgaW4gc3RlcCBvdmVyLW1vZGUuXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0I25vdGlmeUNhbGxzO1xuXG5cdC8qKlxuXHQgKiB0aGlzLm9uTm90aWZ5Q2FsbHMgaXMgc2V0IGJhY2sgdG8gdHJ1ZSBpZiB0aGUgZW5kQ2FsbCBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSByYXdTdGFjayBhcyB0aGUgbWFya2VyLlxuXHQgKiBAdHlwZSB7P1VwbGNSYXdTdGFja31cblx0ICovXG5cdCNtYXJrZXI7XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIHtbP3N0cmluZywgVXBsY1ZhbHVlXVtdfSBVcGxjUmF3U3RhY2tcblx0ICovXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY1JURUNhbGxiYWNrc30gY2FsbGJhY2tzIFxuXHQgKiBAcGFyYW0gez9OZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjYWxsYmFja3MgPSBERUZBVUxUX1VQTENfUlRFX0NBTExCQUNLUywgbmV0d29ya1BhcmFtcyA9IG51bGwpIHtcblx0XHRhc3NlcnREZWZpbmVkKGNhbGxiYWNrcyk7XG5cdFx0dGhpcy4jY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuXHRcdHRoaXMuI25ldHdvcmtQYXJhbXMgPSBuZXR3b3JrUGFyYW1zO1xuXHRcdHRoaXMuI25vdGlmeUNhbGxzID0gdHJ1ZTtcblx0XHR0aGlzLiNtYXJrZXIgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gZm9yIGJyZWFrZG93blxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGVybVxuXHQgKiBAcGFyYW0ge0Nvc3R9IGNvc3QgXG5cdCAqL1xuXHRpbmNyQ29zdChuYW1lLCBpc1Rlcm0sIGNvc3QpIHtcblx0XHRpZiAoY29zdC5tZW0gPD0gMG4gfHwgY29zdC5jcHUgPD0gMG4pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvc3Qgbm90IGluY3JlYXNpbmdcIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2NhbGxiYWNrcy5vbkluY3JDb3N0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuI2NhbGxiYWNrcy5vbkluY3JDb3N0KG5hbWUsIGlzVGVybSwgY29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jclN0YXJ0dXBDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNuZXR3b3JrUGFyYW1zICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmluY3JDb3N0KFwic3RhcnR1cFwiLCB0cnVlLCB0aGlzLiNuZXR3b3JrUGFyYW1zLnBsdXR1c0NvcmVTdGFydHVwQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jclZhcmlhYmxlQ29zdCgpIHtcblx0XHRpZiAodGhpcy4jbmV0d29ya1BhcmFtcyAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5pbmNyQ29zdChcInZhcmlhYmxlXCIsIHRydWUsIHRoaXMuI25ldHdvcmtQYXJhbXMucGx1dHVzQ29yZVZhcmlhYmxlQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckxhbWJkYUNvc3QoKSB7XG5cdFx0aWYgKHRoaXMuI25ldHdvcmtQYXJhbXMgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuaW5jckNvc3QoXCJsYW1iZGFcIiwgdHJ1ZSwgdGhpcy4jbmV0d29ya1BhcmFtcy5wbHV0dXNDb3JlTGFtYmRhQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckRlbGF5Q29zdCgpIHtcblx0XHRpZiAodGhpcy4jbmV0d29ya1BhcmFtcyAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5pbmNyQ29zdChcImRlbGF5XCIsIHRydWUsIHRoaXMuI25ldHdvcmtQYXJhbXMucGx1dHVzQ29yZURlbGF5Q29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckNhbGxDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNuZXR3b3JrUGFyYW1zICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmluY3JDb3N0KFwiY2FsbFwiLCB0cnVlLCB0aGlzLiNuZXR3b3JrUGFyYW1zLnBsdXR1c0NvcmVDYWxsQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckNvbnN0Q29zdCgpIHtcblx0XHRpZiAodGhpcy4jbmV0d29ya1BhcmFtcyAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5pbmNyQ29zdChcImNvbnN0XCIsIHRydWUsIHRoaXMuI25ldHdvcmtQYXJhbXMucGx1dHVzQ29yZUNvbnN0Q29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckZvcmNlQ29zdCgpIHtcblx0XHRpZiAodGhpcy4jbmV0d29ya1BhcmFtcyAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5pbmNyQ29zdChcImZvcmNlXCIsIHRydWUsIHRoaXMuI25ldHdvcmtQYXJhbXMucGx1dHVzQ29yZUZvcmNlQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckJ1aWx0aW5Db3N0KCkge1xuXHRcdGlmICh0aGlzLiNuZXR3b3JrUGFyYW1zICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmluY3JDb3N0KFwiYnVpbHRpblwiLCB0cnVlLCB0aGlzLiNuZXR3b3JrUGFyYW1zLnBsdXR1c0NvcmVCdWlsdGluQ29zdCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY0J1aWx0aW59IGZuXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlW119IGFyZ3Ncblx0ICovXG5cdGNhbGNBbmRJbmNyQ29zdChmbiwgLi4uYXJncykge1xuXHRcdGlmICh0aGlzLiNuZXR3b3JrUGFyYW1zICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgY29zdCA9IGZuLmNhbGNDb3N0KHRoaXMuI25ldHdvcmtQYXJhbXMsIC4uLmFyZ3MpO1xuXG5cdFx0XHR0aGlzLmluY3JDb3N0KGZuLm5hbWUsIGZhbHNlLCBjb3N0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB2YXJpYWJsZSB1c2luZyBEZWJydWlqbiBpbmRleC4gVGhyb3dzIGVycm9yIGhlcmUgYmVjYXVzZSBVcGxjUlRFIGlzIHRoZSBzdGFjayByb290IGFuZCBkb2Vzbid0IGNvbnRhaW4gYW55IHZhbHVlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgXG5cdCAqIEByZXR1cm5zIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRnZXQoaSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcInZhcmlhYmxlIGluZGV4IG91dCBvZiByYW5nZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2hpbGQgc3RhY2suXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSB2YWx1ZSBcblx0ICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZU5hbWUgXG5cdCAqIEByZXR1cm5zIHtVcGxjU3RhY2t9XG5cdCAqL1xuXHRwdXNoKHZhbHVlLCB2YWx1ZU5hbWUgPSBudWxsKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjU3RhY2sodGhpcywgdmFsdWUsIHZhbHVlTmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIHByaW50IGNhbGxiYWNrIChvciBkb2VzIG5vdGhpbmcgaWYgcHJpbnQgY2FsbGJhY2sgaXNuJ3QgZGVmaW5lZClcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZyBcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyBwcmludChtc2cpIHtcblx0XHRpZiAodGhpcy4jY2FsbGJhY2tzLm9uUHJpbnQgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhd2FpdCB0aGlzLiNjYWxsYmFja3Mub25QcmludChtc2cpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb25TdGFydENhbGwgY2FsbGJhY2suXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtVcGxjUmF3U3RhY2t9IHJhd1N0YWNrIFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIHN0YXJ0Q2FsbChzaXRlLCByYXdTdGFjaykge1xuXHRcdGlmICh0aGlzLiNub3RpZnlDYWxscyAmJiB0aGlzLiNjYWxsYmFja3Mub25TdGFydENhbGwgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZXQgc3RvcE5vdGlmeWluZyA9IGF3YWl0IHRoaXMuI2NhbGxiYWNrcy5vblN0YXJ0Q2FsbChzaXRlLCByYXdTdGFjayk7XG5cdFx0XHRpZiAoc3RvcE5vdGlmeWluZykge1xuXHRcdFx0XHR0aGlzLiNub3RpZnlDYWxscyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLiNtYXJrZXIgPSByYXdTdGFjaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uRW5kQ2FsbCBjYWxsYmFjayBpZiAnI25vdGlmeUNhbGxzID09IHRydWUnLlxuXHQgKiAnI25vdGlmeUNhbGxzJyBpcyBzZXQgdG8gdHJ1ZSBpZiAncmF3U3RhY2sgPT0gI21hcmtlcicuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtVcGxjUmF3U3RhY2t9IHJhd1N0YWNrIFxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZX0gcmVzdWx0IFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIGVuZENhbGwoc2l0ZSwgcmF3U3RhY2ssIHJlc3VsdCkge1xuXHRcdGlmICghdGhpcy4jbm90aWZ5Q2FsbHMgJiYgdGhpcy4jbWFya2VyID09IHJhd1N0YWNrKSB7XG5cdFx0XHR0aGlzLiNub3RpZnlDYWxscyA9IHRydWU7XG5cdFx0XHR0aGlzLiNtYXJrZXIgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNub3RpZnlDYWxscyAmJiB0aGlzLiNjYWxsYmFja3Mub25FbmRDYWxsICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0cmF3U3RhY2sgPSByYXdTdGFjay5zbGljZSgpO1xuXHRcdFx0cmF3U3RhY2sucHVzaChbXCJfX3Jlc3VsdFwiLCByZXN1bHRdKTtcblx0XHRcdGF3YWl0IHRoaXMuI2NhbGxiYWNrcy5vbkVuZENhbGwoc2l0ZSwgcmF3U3RhY2spO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VXBsY1Jhd1N0YWNrfVxuXHQgKi9cblx0dG9MaXN0KCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxufVxuXG4vKipcbiAqIFVwbGNTdGFjayBjb250YWlucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHJldHJpZXZlZCB1c2luZyBhIERlYnJ1aWpuIGluZGV4LlxuICovXG5jbGFzcyBVcGxjU3RhY2sge1xuXHQjcGFyZW50O1xuXHQjdmFsdWU7XG5cdCN2YWx1ZU5hbWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7KD9VcGxjU3RhY2spIHwgVXBsY1J0ZX0gcGFyZW50XG5cdCAqIEBwYXJhbSB7P1VwbGNWYWx1ZX0gdmFsdWVcblx0ICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZU5hbWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUgPSBudWxsLCB2YWx1ZU5hbWUgPSBudWxsKSB7XG5cdFx0dGhpcy4jcGFyZW50ID0gcGFyZW50O1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy4jdmFsdWVOYW1lID0gdmFsdWVOYW1lO1xuXHR9XG5cblx0aW5jclN0YXJ0dXBDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyU3RhcnR1cENvc3QoKVxuXHRcdH1cblx0fVxuXG5cdGluY3JWYXJpYWJsZUNvc3QoKSB7XG5cdFx0aWYgKHRoaXMuI3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jcGFyZW50LmluY3JWYXJpYWJsZUNvc3QoKVxuXHRcdH1cblx0fVxuXG5cdGluY3JMYW1iZGFDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyTGFtYmRhQ29zdCgpXG5cdFx0fVxuXHR9XG5cdFxuXHRpbmNyRGVsYXlDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyRGVsYXlDb3N0KCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckNhbGxDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyQ2FsbENvc3QoKTtcblx0XHR9XG5cdH1cblxuXHRpbmNyQ29uc3RDb3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyQ29uc3RDb3N0KCk7XG5cdFx0fVxuXHR9XG5cblx0aW5jckZvcmNlQ29zdCgpIHtcblx0XHRpZiAodGhpcy4jcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLiNwYXJlbnQuaW5jckZvcmNlQ29zdCgpXG5cdFx0fVxuXHR9XG5cblx0aW5jckJ1aWx0aW5Db3N0KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BhcmVudC5pbmNyQnVpbHRpbkNvc3QoKVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNCdWlsdGlufSBmblxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZVtdfSBhcmdzXG5cdCAqL1xuXHRjYWxjQW5kSW5jckNvc3QoZm4sIC4uLmFyZ3MpIHtcblx0XHRpZiAodGhpcy4jcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLiNwYXJlbnQuY2FsY0FuZEluY3JDb3N0KGZuLCAuLi5hcmdzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIHZhbHVlIHVzaW5nIHRoZSBEZWJydWlqbiBpbmRleC4gSWYgJ2kgPT0gMScgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBpcyByZXR1cm5lZC5cblx0ICogT3RoZXJ3aXNlICdpJyBpcyBkZWNyZW1lbnQgYW5kIHBhc3NlZCB0byB0aGUgcGFyZW50IHN0YWNrLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBcblx0ICogQHJldHVybnMge1VwbGNWYWx1ZX1cblx0ICovXG5cdGdldChpKSB7XG5cdFx0aSAtPSAxO1xuXG5cdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0aWYgKHRoaXMuI3ZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBsdXR1cy1jb3JlIHN0YWNrIHZhbHVlIG5vdCBzZXRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2VydChpID4gMCk7XG5cdFx0XHRpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInZhcmlhYmxlIGluZGV4IG91dCBvZiByYW5nZVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiNwYXJlbnQuZ2V0KGkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBjaGlsZCBzdGFjay5cblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IHZhbHVlIFxuXHQgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlTmFtZSBcblx0ICogQHJldHVybnMge1VwbGNTdGFja31cblx0ICovXG5cdHB1c2godmFsdWUsIHZhbHVlTmFtZSA9IG51bGwpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNTdGFjayh0aGlzLCB2YWx1ZSwgdmFsdWVOYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyB0aGUgb25QcmludCBjYWxsYmFjayBpbiB0aGUgUlRFIChyb290IG9mIHN0YWNrKS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZyBcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyBwcmludChtc2cpIHtcblx0XHRpZiAodGhpcy4jcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRhd2FpdCB0aGlzLiNwYXJlbnQucHJpbnQobXNnKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIG9uU3RhcnRDYWxsIGNhbGxiYWNrIGluIHRoZSBSVEUgKHJvb3Qgb2Ygc3RhY2spLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VXBsY1Jhd1N0YWNrfSByYXdTdGFjayBcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyBzdGFydENhbGwoc2l0ZSwgcmF3U3RhY2spIHtcblx0XHRpZiAodGhpcy4jcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRhd2FpdCB0aGlzLiNwYXJlbnQuc3RhcnRDYWxsKHNpdGUsIHJhd1N0YWNrKTtcblx0XHR9XG5cdH1cblxuXHQvKiogXG5cdCAqIENhbGxzIHRoZSBvbkVuZENhbGwgY2FsbGJhY2sgaW4gdGhlIFJURSAocm9vdCBvZiBzdGFjaykuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge1VwbGNSYXdTdGFja30gcmF3U3RhY2tcblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IHJlc3VsdFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0Ki9cblx0YXN5bmMgZW5kQ2FsbChzaXRlLCByYXdTdGFjaywgcmVzdWx0KSB7XG5cdFx0aWYgKHRoaXMuI3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdGhpcy4jcGFyZW50LmVuZENhbGwoc2l0ZSwgcmF3U3RhY2ssIHJlc3VsdCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFxuXHQgKiBAcmV0dXJucyB7VXBsY1Jhd1N0YWNrfVxuXHQqL1xuXHR0b0xpc3QoKSB7XG5cdFx0bGV0IGxzdCA9IHRoaXMuI3BhcmVudCAhPT0gbnVsbCA/IHRoaXMuI3BhcmVudC50b0xpc3QoKSA6IFtdO1xuXHRcdGlmICh0aGlzLiN2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0bHN0LnB1c2goW3RoaXMuI3ZhbHVlTmFtZSwgdGhpcy4jdmFsdWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxzdDtcblx0fVxufVxuXG4vKipcbiAqIEFub255bW91cyBQbHV0dXMtY29yZSBmdW5jdGlvbi5cbiAqIFJldHVybnMgYSBuZXcgVXBsY0Fub24gd2hlbmV2ZXIgaXQgaXMgY2FsbGVkL2FwcGxpZWQgKGFyZ3MgYXJlICdhY2N1bXVsYXRlZCcpLCBleGNlcHQgZmluYWwgYXBwbGljYXRpb24sIHdoZW4gdGhlIGZ1bmN0aW9uIGl0c2VsZiBpcyBldmFsdWF0ZWQuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjQW5vbiBleHRlbmRzIFVwbGNWYWx1ZSB7XG5cdC8qKlxuXHQgKiBAdHlwZWRlZiB7KGNhbGxTaXRlOiBTaXRlLCBzdWJTdGFjazogVXBsY1N0YWNrLCAuLi5hcmdzOiBVcGxjVmFsdWVbXSkgPT4gKFVwbGNWYWx1ZSB8IFByb21pc2U8VXBsY1ZhbHVlPil9IFVwbGNBbm9uQ2FsbGJhY2tcblx0ICovXG5cblx0I3J0ZTtcblx0I25BcmdzO1xuXHQjYXJnTmFtZXM7XG5cblx0LyoqXG5cdCAqIEluY3JlbWVudCBldmVyeSB0aW1lIGZ1bmN0aW9uIGEgbmV3IGFyZ3VtZW50IGlzIGFwcGxpZWQuXG5cdCAqL1xuXHQjYXJnQ291bnQ7XG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gZnVuY3Rpb24gaXMgZnVsbHkgYXBwbGllZC5cblx0ICogQHR5cGUge1VwbGNBbm9uQ2FsbGJhY2t9XG5cdCAqL1xuXHQjZm47XG5cdCNjYWxsU2l0ZTtcblxuXHQvKipcblx0ICogXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtVcGxjUnRlIHwgVXBsY1N0YWNrfSBydGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nW10gfCBudW1iZXJ9IGFyZ3MgLSBhcmdzIGNhbiBiZSBsaXN0IG9mIGFyZ05hbWVzIChmb3IgZGVidWdnaW5nKSwgb3IgdGhlIG51bWJlciBvZiBhcmdzXG5cdCAqIEBwYXJhbSB7VXBsY0Fub25DYWxsYmFja30gZm4gXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhcmdDb3VudCBcblx0ICogQHBhcmFtIHs/U2l0ZX0gY2FsbFNpdGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBydGUsIGFyZ3MsIGZuLCBhcmdDb3VudCA9IDAsIGNhbGxTaXRlID0gbnVsbCkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdGFzc2VydCh0eXBlb2YgYXJnQ291bnQgPT0gXCJudW1iZXJcIik7XG5cblx0XHRsZXQgbkFyZ3MgPSAwO1xuXHRcdC8qKiBAdHlwZSB7P3N0cmluZ1tdfSAqL1xuXHRcdGxldCBhcmdOYW1lcyA9IG51bGw7XG5cdFx0aWYgKCh0eXBlb2YgYXJncyAhPSAnbnVtYmVyJykpIHtcblx0XHRcdGlmIChhcmdzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0bkFyZ3MgPSBhcmdzLmxlbmd0aDtcblx0XHRcdFx0YXJnTmFtZXMgPSBhcmdzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGFuIEFycmF5XCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRuQXJncyA9IGFyZ3M7XG5cdFx0fVxuXG5cdFx0YXNzZXJ0KG5BcmdzID49IDEpO1xuXG5cdFx0dGhpcy4jcnRlID0gcnRlO1xuXHRcdHRoaXMuI25BcmdzID0gbkFyZ3M7XG5cdFx0dGhpcy4jYXJnTmFtZXMgPSBhcmdOYW1lcztcblx0XHR0aGlzLiNhcmdDb3VudCA9IGFyZ0NvdW50O1xuXHRcdHRoaXMuI2ZuID0gZm47XG5cdFx0dGhpcy4jY2FsbFNpdGUgPSBjYWxsU2l0ZTtcblx0fVxuXG5cdGdldCBtZW1TaXplKCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gbmV3U2l0ZSBcblx0ICogQHJldHVybnMge1VwbGNBbm9ufVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjQW5vbihcblx0XHRcdG5ld1NpdGUsXG5cdFx0XHR0aGlzLiNydGUsXG5cdFx0XHR0aGlzLiNhcmdOYW1lcyAhPT0gbnVsbCA/IHRoaXMuI2FyZ05hbWVzIDogdGhpcy4jbkFyZ3MsXG5cdFx0XHR0aGlzLiNmbixcblx0XHRcdHRoaXMuI2FyZ0NvdW50LFxuXHRcdFx0dGhpcy4jY2FsbFNpdGUsXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IGNhbGxTaXRlXG5cdCAqIEBwYXJhbSB7VXBsY1N0YWNrfSBzdWJTdGFja1xuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZVtdfSBhcmdzXG5cdCAqIEByZXR1cm5zIHtVcGxjVmFsdWUgfCBQcm9taXNlPFVwbGNWYWx1ZT59XG5cdCAqL1xuXHRjYWxsU3luYyhjYWxsU2l0ZSwgc3ViU3RhY2ssIGFyZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy4jZm4oY2FsbFNpdGUsIHN1YlN0YWNrLCAuLi5hcmdzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNSdGUgfCBVcGxjU3RhY2t9IHJ0ZSBcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZX0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFVwbGNWYWx1ZT59XG5cdCAqL1xuXHRhc3luYyBjYWxsKHJ0ZSwgc2l0ZSwgdmFsdWUpIHtcblx0XHRhc3NlcnQoc2l0ZSAhPSB1bmRlZmluZWQgJiYgc2l0ZSBpbnN0YW5jZW9mIFNpdGUpO1xuXG5cdFx0bGV0IHN1YlN0YWNrID0gdGhpcy4jcnRlLnB1c2godmFsdWUsIHRoaXMuI2FyZ05hbWVzICE9PSBudWxsID8gdGhpcy4jYXJnTmFtZXNbdGhpcy4jYXJnQ291bnRdIDogbnVsbCk7IC8vIHRoaXMgaXMgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgdGhlIHN0YWNrIGdyb3dzXG5cdFx0bGV0IGFyZ0NvdW50ID0gdGhpcy4jYXJnQ291bnQgKyAxO1xuXHRcdGxldCBjYWxsU2l0ZSA9IHRoaXMuI2NhbGxTaXRlICE9PSBudWxsID8gdGhpcy4jY2FsbFNpdGUgOiBzaXRlO1xuXG5cdFx0Ly8gZnVuY3Rpb24gaXMgZnVsbHkgYXBwbGllZCwgY29sbGVjdCB0aGUgYXJncyBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRpZiAoYXJnQ291bnQgPT0gdGhpcy4jbkFyZ3MpIHtcblx0XHRcdC8qKiBAdHlwZSB7VXBsY1ZhbHVlW119ICovXG5cdFx0XHRsZXQgYXJncyA9IFtdO1xuXG5cdFx0XHRsZXQgcmF3U3RhY2sgPSBydGUudG9MaXN0KCk7IC8vIHVzZSB0aGUgUlRFIG9mIHRoZSBjYWxsc2l0ZVxuXG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy4jbkFyZ3M7IGkgPj0gMTsgaS0tKSB7XG5cdFx0XHRcdGxldCBhcmdWYWx1ZSA9IHN1YlN0YWNrLmdldChpKTtcblx0XHRcdFx0YXJncy5wdXNoKGFyZ1ZhbHVlKTtcblx0XHRcdFx0cmF3U3RhY2sucHVzaChbYF9fYXJnJHt0aGlzLiNuQXJncyAtIGl9YCwgYXJnVmFsdWVdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbm90aWZ5IHRoZSBSVEUgb2YgdGhlIG5ldyBsaXZlIHN0YWNrIChsaXN0IG9mIHBhaXJzIGluc3RlYWQgb2YgVXBsY1N0YWNrKSwgYW5kIGF3YWl0IHBlcm1pc3Npb24gdG8gY29udGludWVcblx0XHRcdGF3YWl0IHRoaXMuI3J0ZS5zdGFydENhbGwoY2FsbFNpdGUsIHJhd1N0YWNrKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IHJlc3VsdCA9IHRoaXMuY2FsbFN5bmMoY2FsbFNpdGUsIHN1YlN0YWNrLCBhcmdzKTtcblxuXHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Ly8gdGhlIHNhbWUgcmF3U3RhY2sgb2JqZWN0IGNhbiBiZSB1c2VkIGFzIGEgbWFya2VyIGZvciAnU3RlcC1PdmVyJyBpbiB0aGUgZGVidWdnZXJcblx0XHRcdFx0YXdhaXQgdGhpcy4jcnRlLmVuZENhbGwoY2FsbFNpdGUsIHJhd1N0YWNrLCByZXN1bHQpO1xuXHRcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KGNhbGxTaXRlKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHQvLyBUT0RPOiBiZXR0ZXIgdHJhY2Vcblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBSdW50aW1lRXJyb3IpIHtcblx0XHRcdFx0XHRlID0gZS5hZGRUcmFjZVNpdGUoY2FsbFNpdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZnVuY3Rpb24gaXNuJ3QgeWV0IGZ1bGx5IGFwcGxpZWQsIHJldHVybiBhIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBVcGxjQW5vblxuXHRcdFx0YXNzZXJ0KHRoaXMuI25BcmdzID4gMSk7XG5cblx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24oXG5cdFx0XHRcdGNhbGxTaXRlLFxuXHRcdFx0XHRzdWJTdGFjayxcblx0XHRcdFx0dGhpcy4jYXJnTmFtZXMgIT09IG51bGwgPyB0aGlzLiNhcmdOYW1lcyA6IHRoaXMuI25BcmdzLFxuXHRcdFx0XHR0aGlzLiNmbixcblx0XHRcdFx0YXJnQ291bnQsXG5cdFx0XHRcdGNhbGxTaXRlLFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJmblwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0eXBlQml0cygpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhIFVwbGNBbm9uIHZhbHVlIGRvZXNuJ3QgaGF2ZSBhIGxpdGVyYWwgcmVwcmVzZW50YXRpb25cIik7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB2YWx1ZSB3aXRoIHBsdXR1cyBmbGF0IGVuY29kaW5nLlxuXHQgKiBNZW1iZXIgZnVuY3Rpb24gbm90IG5hbWVkICd0b0ZsYXQnIGFzIG5vdCB0byBjb25mdXNlIHdpdGggJ3RvRmxhdCcgbWVtYmVyIG9mIHRlcm1zLlxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyXG5cdCAqL1xuXHR0b0ZsYXRWYWx1ZShiaXRXcml0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhIFVwbGNBbm9uIHZhbHVlIGRvZXNuJ3QgaGF2ZSBhIGxpdGVyYWwgcmVwcmVzZW50YXRpb25cIik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjRGVsYXllZFZhbHVlIGV4dGVuZHMgVXBsY1ZhbHVlIHtcblx0I2V2YWx1YXRvcjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7KCkgPT4gKFVwbGNWYWx1ZSB8IFByb21pc2U8VXBsY1ZhbHVlPil9IGV2YWx1YXRvclxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgZXZhbHVhdG9yKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jZXZhbHVhdG9yID0gZXZhbHVhdG9yO1xuXHR9XG5cblx0Z2V0IG1lbVNpemUoKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBuZXdTaXRlIFxuXHQgKiBAcmV0dXJucyB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjRGVsYXllZFZhbHVlKG5ld1NpdGUsIHRoaXMuI2V2YWx1YXRvcik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybiB7UHJvbWlzZTxVcGxjVmFsdWU+fVxuXHQgKi9cblx0Zm9yY2UoKSB7XG5cdFx0bGV0IHJlcyA9IHRoaXMuI2V2YWx1YXRvcigpO1xuXG5cdFx0aWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgXykgPT4ge1xuXHRcdFx0XHRyZXNvbHZlKHJlcyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYGRlbGF5YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dHlwZUJpdHMoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiYSBVcGxjRGVsYXllZFZhbHVlIHZhbHVlIGRvZXNuJ3QgaGF2ZSBhIGxpdGVyYWwgcmVwcmVzZW50YXRpb25cIik7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlcyB2YWx1ZSB3aXRoIHBsdXR1cyBmbGF0IGVuY29kaW5nLlxuXHQgKiBNZW1iZXIgZnVuY3Rpb24gbm90IG5hbWVkICd0b0ZsYXQnIGFzIG5vdCB0byBjb25mdXNlIHdpdGggJ3RvRmxhdCcgbWVtYmVyIG9mIHRlcm1zLlxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyXG5cdCAqL1xuXHR0b0ZsYXRWYWx1ZShiaXRXcml0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhIFVwbGNEZWxheWVkVmFsdWUgdmFsdWUgZG9lc24ndCBoYXZlIGEgbGl0ZXJhbCByZXByZXNlbnRhdGlvblwiKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIEludGVnZXIgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNJbnQgZXh0ZW5kcyBVcGxjVmFsdWUge1xuXHQjdmFsdWU7XG5cdCNzaWduZWQ7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgLSBzdXBwb3NlZCB0byBiZSBhcmJpdHJhcnkgcHJlY2lzaW9uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lnbmVkIC0gdW5zaWduZWQgaXMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCB2YWx1ZSwgc2lnbmVkID0gdHJ1ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ2JpZ2ludCcsIFwibm90IGEgYmlnaW50XCIpO1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdFx0dGhpcy4jc2lnbmVkID0gc2lnbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBVcGxjSW50IHdpdGhvdXQgcmVxdWlyaW5nIGEgU2l0ZVxuXHQgKiBAcGFyYW0ge2JpZ2ludCB8IG51bWJlcn0gdmFsdWVcblx0ICogQHJldHVybnMge1VwbGNJbnR9IFxuXHQgKi9cblx0c3RhdGljIG5ldyh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcblx0XHRcdGFzc2VydCh2YWx1ZSAlIDEuMCA9PSAwLjAsIFwibXVzdCBiZSB3aG9sZSBudW1iZXJcIik7XG5cdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoU2l0ZS5kdW1teSgpLCBCaWdJbnQodmFsdWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBVcGxjSW50KFNpdGUuZHVtbXkoKSwgdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBzaWduZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3NpZ25lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgVXBsY0ludCB3cmFwcGVkIGluIGEgVXBsY0NvbnN0LCBzbyBpdCBjYW4gYmUgdXNlZCBhIHRlcm1cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0c3RhdGljIG5ld1NpZ25lZFRlcm0oc2l0ZSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNDb25zdChuZXcgVXBsY0ludChzaXRlLCB2YWx1ZSwgdHJ1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEludERhdGEubWVtU2l6ZUludGVybmFsKHRoaXMuI3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IG5ld1NpdGUgXG5cdCAqIEByZXR1cm5zIHtVcGxjSW50fVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjSW50KG5ld1NpdGUsIHRoaXMuI3ZhbHVlLCB0aGlzLiNzaWduZWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtiaWdpbnR9XG5cdCAqL1xuXHRnZXQgaW50KCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBzaW5nbGUgYnl0ZSBpbiB0aGUgUGx1dHVzLWNvcmUgYnl0ZS1saXN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGludFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYiBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHN0YXRpYyBwYXJzZVJhd0J5dGUoYikge1xuXHRcdHJldHVybiBiICYgMGIwMTExMTExMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgJ2InIGlzIHRoZSBsYXN0IGJ5dGUgaW4gdGhlIFBsdXR1cy1jb3JlIGJ5dGUtbGlzdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBiIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyByYXdCeXRlSXNMYXN0KGIpIHtcblx0XHRyZXR1cm4gKGIgJiAwYjEwMDAwMDAwKSA9PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbWJpbmVzIGEgbGlzdCBvZiBQbHV0dXMtY29yZSBieXRlcyBpbnRvIGEgYmlnaW50IChsZWFkaW5nIGJpdCBvZiBlYWNoIGJ5dGUgaXMgaWdub3JlZCkuXG4gICAgICogRGlmZmVycyBmcm9tIGJ5dGVzVG9CaWdJbnQgaW4gdXRpbHMuanMgYmVjYXVzZSBvbmx5IDcgYml0cyBhcmUgdXNlZCBmcm9tIGVhY2ggYnl0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdHN0YXRpYyBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG5cdFx0bGV0IHZhbHVlID0gQmlnSW50KDApO1xuXG5cdFx0bGV0IG4gPSBieXRlcy5sZW5ndGg7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0bGV0IGIgPSBieXRlc1tpXTtcblxuXHRcdFx0Ly8gNyAobm90IDgpLCBiZWNhdXNlIGxlYWRpbmcgYml0IGlzbid0IHVzZWQgaGVyZVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSArIEJpZ0ludChiKSAqIGlwb3cyKEJpZ0ludChpKSAqIDduKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB6aWd6YWcgZW5jb2Rpbmdcblx0ICogQGV4YW1wbGVcblx0ICogKG5ldyBVcGxjSW50KFNpdGUuZHVtbXkoKSwgLTFuLCB0cnVlKSkudG9VbnNpZ25lZCgpLmludCA9PiAxblxuXHQgKiBAZXhhbXBsZVxuXHQgKiAobmV3IFVwbGNJbnQoU2l0ZS5kdW1teSgpLCAtMW4sIHRydWUpKS50b1Vuc2lnbmVkKCkudG9TaWduZWQoKS5pbnQgPT4gLTFuXG5cdCAqIEBleGFtcGxlXG5cdCAqIChuZXcgVXBsY0ludChTaXRlLmR1bW15KCksIC0ybiwgdHJ1ZSkpLnRvVW5zaWduZWQoKS50b1NpZ25lZCgpLmludCA9PiAtMm5cblx0ICogQGV4YW1wbGVcblx0ICogKG5ldyBVcGxjSW50KFNpdGUuZHVtbXkoKSwgLTNuLCB0cnVlKSkudG9VbnNpZ25lZCgpLnRvU2lnbmVkKCkuaW50ID0+IC0zblxuXHQgKiBAZXhhbXBsZVxuXHQgKiAobmV3IFVwbGNJbnQoU2l0ZS5kdW1teSgpLCAtNG4sIHRydWUpKS50b1Vuc2lnbmVkKCkudG9TaWduZWQoKS5pbnQgPT4gLTRuXG5cdCAqIEByZXR1cm5zIHtVcGxjSW50fVxuXHQgKi9cblx0dG9VbnNpZ25lZCgpIHtcblx0XHRpZiAodGhpcy4jc2lnbmVkKSB7XG5cdFx0XHRpZiAodGhpcy4jdmFsdWUgPCAwbikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQodGhpcy5zaXRlLCAtdGhpcy4jdmFsdWUqMm4gLSAxbiwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjSW50KHRoaXMuc2l0ZSwgdGhpcy4jdmFsdWUgKiAybiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cblxuXHQvKiogXG5cdCAqIFVuYXBwbGllcyB6aWd6YWcgZW5jb2RpbmcgXG5cdCAqIEBleGFtcGxlXG5cdCAqIChuZXcgVXBsY0ludChTaXRlLmR1bW15KCksIDFuLCBmYWxzZSkpLnRvU2lnbmVkKCkuaW50ID0+IC0xblxuXHQgKiBAcmV0dXJucyB7VXBsY0ludH1cblx0Ki9cblx0dG9TaWduZWQoKSB7XG5cdFx0aWYgKHRoaXMuI3NpZ25lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLiN2YWx1ZSAlIDJuID09IDBuKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0ludCh0aGlzLnNpdGUsIHRoaXMuI3ZhbHVlIC8gMm4sIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjSW50KHRoaXMuc2l0ZSwgLSh0aGlzLiN2YWx1ZSArIDFuKSAvIDJuLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZS50b1N0cmluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXJcblx0ICovXG5cdHRvRmxhdEludGVybmFsKGJpdFdyaXRlcikge1xuXHRcdGxldCB6aWd6YWcgPSB0aGlzLnRvVW5zaWduZWQoKTtcblx0XHRsZXQgYml0U3RyaW5nID0gcGFkWmVyb2VzKHppZ3phZy4jdmFsdWUudG9TdHJpbmcoMiksIDcpO1xuXG5cdFx0Ly8gc3BsaXQgZXZlcnkgN3RoXG5cdFx0bGV0IHBhcnRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiaXRTdHJpbmcubGVuZ3RoOyBpICs9IDcpIHtcblx0XHRcdHBhcnRzLnB1c2goYml0U3RyaW5nLnNsaWNlKGksIGkgKyA3KSk7XG5cdFx0fVxuXG5cdFx0Ly8gcmV2ZXJzZSB0aGUgcGFydHNcblx0XHRwYXJ0cy5yZXZlcnNlKCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdC8vIGxhc3Rcblx0XHRcdFx0Yml0V3JpdGVyLndyaXRlKCcwJyArIHBhcnRzW2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJpdFdyaXRlci53cml0ZSgnMScgKyBwYXJ0c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdW5zaWduZWQgaW50ZWdlciB3aXRoIHBsdXR1cyBmbGF0IGVuY29kaW5nLlxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgc2lnbmVkLlxuXHQgKiBVc2VkIGJ5IGVuY29kaW5nIHBsdXR1cyBjb3JlIHByb2dyYW0gdmVyc2lvbiBhbmQgZGVicnVpam4gaW5kaWNlcy5cblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdFVuc2lnbmVkKGJpdFdyaXRlcikge1xuXHRcdGFzc2VydCghdGhpcy4jc2lnbmVkKTtcblxuXHRcdHRoaXMudG9GbGF0SW50ZXJuYWwoYml0V3JpdGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dHlwZUJpdHMoKSB7XG5cdFx0cmV0dXJuIFwiMDAwMFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXIgXG5cdCAqL1xuXHR0b0ZsYXRWYWx1ZUludGVybmFsKGJpdFdyaXRlcikge1xuXHRcdGFzc2VydCh0aGlzLiNzaWduZWQpO1xuXG5cdFx0dGhpcy50b0ZsYXRJbnRlcm5hbChiaXRXcml0ZXIpO1xuXHR9XG59XG5cbi8qKlxuICogUGx1dHVzLWNvcmUgQnl0ZUFycmF5IHZhbHVlIGNsYXNzXG4gKiBXcmFwcyBhIHJlZ3VsYXIgbGlzdCBvZiB1aW50OCBudW1iZXJzIChzbyBub3QgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNCeXRlQXJyYXkgZXh0ZW5kcyBVcGxjVmFsdWUge1xuXHQjYnl0ZXM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgYnl0ZXMpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHRhc3NlcnQoYnl0ZXMgIT0gdW5kZWZpbmVkKTtcblx0XHR0aGlzLiNieXRlcyA9IGJ5dGVzO1xuXHRcdGZvciAobGV0IGIgb2YgdGhpcy4jYnl0ZXMpIHtcblx0XHRcdGFzc2VydCh0eXBlb2YgYiA9PSAnbnVtYmVyJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdCBhIFVwbGNCeXRlQXJyYXkgd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7VXBsY0J5dGVBcnJheX1cblx0ICovXG5cdHN0YXRpYyBuZXcoYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNCeXRlQXJyYXkoU2l0ZS5kdW1teSgpLCBieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBuZXcgVXBsY0J5dGVBcnJheSB3cmFwcGVkIGluIFVwbGNDb25zdCBzbyBpdCBjYW4gYmUgdXNlZCBhcyBhIHRlcm0uXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0c3RhdGljIG5ld1Rlcm0oc2l0ZSwgYnl0ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNDb25zdChuZXcgVXBsY0J5dGVBcnJheShzaXRlLCBieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJ5dGVBcnJheURhdGEubWVtU2l6ZUludGVybmFsKHRoaXMuI2J5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IG5ld1NpdGUgXG5cdCAqIEByZXR1cm5zIHtVcGxjQnl0ZUFycmF5fVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjQnl0ZUFycmF5KG5ld1NpdGUsIHRoaXMuI2J5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdCAqL1xuXHRnZXQgYnl0ZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2J5dGVzLnNsaWNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBoZXggcmVwcmVzZW50YXRpb24gb2YgYnl0ZSBhcnJheVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAjJHtieXRlc1RvSGV4KHRoaXMuI2J5dGVzKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0eXBlQml0cygpIHtcblx0XHRyZXR1cm4gXCIwMDAxXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlclxuXHQgKi9cblx0dG9GbGF0VmFsdWVJbnRlcm5hbChiaXRXcml0ZXIpIHtcblx0XHRVcGxjQnl0ZUFycmF5LndyaXRlQnl0ZXMoYml0V3JpdGVyLCB0aGlzLiNieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGUgYSBsaXN0IG9mIGJ5dGVzIHRvIHRoZSBiaXRXcml0ZXIgdXNpbmcgZmxhdCBlbmNvZGluZy5cblx0ICogVXNlZCBieSBVcGxjU3RyaW5nLCBVcGxjQnl0ZUFycmF5IGFuZCBVcGxjRGF0YVZhbHVlXG5cdCAqIEVxdWl2YWxlbnQgdG8gRV9CKiBmdW5jdGlvbiBpbiBQbHV0dXMtY29yZSBkb2NzXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXIgXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKi9cblx0c3RhdGljIHdyaXRlQnl0ZXMoYml0V3JpdGVyLCBieXRlcykge1xuXHRcdGJpdFdyaXRlci5wYWRUb0J5dGVCb3VuZGFyeSh0cnVlKTtcblxuXHRcdC8vIHRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBFX0MqIGZ1bmN0aW9uIGluIFBsdXR1cy1jb3JlIGRvY3Ncblx0XHRsZXQgbiA9IGJ5dGVzLmxlbmd0aDtcblx0XHRsZXQgcG9zID0gMDtcblxuXHRcdC8vIHdyaXRlIGNodW5rcyBvZiAyNTVcblx0XHR3aGlsZSAocG9zIDwgbikge1xuXHRcdFx0Ly8gZWFjaCBpdGVyYXRpb24gaXMgZXF1aXZhbGVudCB0byBFX0MgZnVuY3Rpb24gaW4gUGx1dHVzLWNvcmUgZG9jc1xuXG5cdFx0XHRsZXQgbkNodW5rID0gTWF0aC5taW4obiAtIHBvcywgMjU1KTtcblxuXHRcdFx0Ly8gZXF1aXZhbGVudCB0byBFXzggZnVuY3Rpb24gaW4gUGx1dHVzLWNvcmUgZG9jc1xuXHRcdFx0Yml0V3JpdGVyLndyaXRlKHBhZFplcm9lcyhuQ2h1bmsudG9TdHJpbmcoMiksIDgpKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHBvczsgaSA8IHBvcyArIG5DaHVuazsgaSsrKSB7XG5cdFx0XHRcdGxldCBiID0gYnl0ZXNbaV07XG5cblx0XHRcdFx0Ly8gZXF1aXZhbGVudCB0byBFXzggZnVuY3Rpb24gaW4gUGx1dHVzLWNvcmUgZG9jc1xuXHRcdFx0XHRiaXRXcml0ZXIud3JpdGUocGFkWmVyb2VzKGIudG9TdHJpbmcoMiksIDgpKTtcblx0XHRcdH1cblxuXHRcdFx0cG9zICs9IG5DaHVuaztcblx0XHR9XG5cblx0XHRiaXRXcml0ZXIud3JpdGUoJzAwMDAwMDAwJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBzdHJpbmcgdmFsdWUgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNTdHJpbmcgZXh0ZW5kcyBVcGxjVmFsdWUge1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgdmFsdWUpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBVcGxjU3RyaW4gd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICogQHJldHVybnMge1VwbGNTdHJpbmd9XG5cdCAqL1xuXHRzdGF0aWMgbmV3KHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjU3RyaW5nKFNpdGUuZHVtbXkoKSwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVXBsY1N0cmluZyB3cmFwcGVkIHdpdGggVXBsY0NvbnN0IHNvIGl0IGNhbiBiZSB1c2VkIGFzIGEgdGVybS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtVcGxjQ29uc3R9XG5cdCAqL1xuXHRzdGF0aWMgbmV3VGVybShzaXRlLCB2YWx1ZSkge1xuXHRcdHJldHVybiBuZXcgVXBsY0NvbnN0KG5ldyBVcGxjU3RyaW5nKHNpdGUsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBtZW1TaXplKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBuZXdTaXRlIFxuXHQgKiBAcmV0dXJucyB7VXBsY1N0cmluZ31cblx0ICovXG5cdGNvcHkobmV3U2l0ZSkge1xuXHRcdHJldHVybiBuZXcgVXBsY1N0cmluZyhuZXdTaXRlLCB0aGlzLiN2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBzdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYFwiJHt0aGlzLiN2YWx1ZX1cImA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHR5cGVCaXRzKCkge1xuXHRcdHJldHVybiBcIjAwMTBcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyXG5cdCAqL1xuXHR0b0ZsYXRWYWx1ZUludGVybmFsKGJpdFdyaXRlcikge1xuXHRcdGxldCBieXRlcyA9IEFycmF5LmZyb20oKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodGhpcy4jdmFsdWUpKTtcblxuXHRcdFVwbGNCeXRlQXJyYXkud3JpdGVCeXRlcyhiaXRXcml0ZXIsIGJ5dGVzKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIHVuaXQgdmFsdWUgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNVbml0IGV4dGVuZHMgVXBsY1ZhbHVlIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgVXBsY1VuaXQgd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEByZXR1cm5zIHtVcGxjVW5pdH1cblx0ICovXG5cdHN0YXRpYyBuZXcgKCkge1xuXHRcdHJldHVybiBuZXcgVXBsY1VuaXQoU2l0ZS5kdW1teSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFVwbGNVbml0IHdyYXBwZWQgd2l0aCBVcGxjQ29uc3Qgc28gaXQgY2FuIGJlIHVzZWQgYXMgYSB0ZXJtXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge1VwbGNDb25zdH1cblx0ICovXG5cdHN0YXRpYyBuZXdUZXJtKHNpdGUpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNDb25zdChuZXcgVXBsY1VuaXQoc2l0ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IG5ld1NpdGUgXG5cdCAqIEByZXR1cm5zIHtVcGxjVW5pdH1cblx0ICovXG5cdGNvcHkobmV3U2l0ZSkge1xuXHRcdHJldHVybiBuZXcgVXBsY1VuaXQobmV3U2l0ZSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCIoKVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0eXBlQml0cygpIHtcblx0XHRyZXR1cm4gXCIwMDExXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlclxuXHQgKi9cblx0dG9GbGF0VmFsdWVJbnRlcm5hbChiaXRXcml0ZXIpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VXBsY1VuaXR9XG5cdCAqL1xuXHRhc3NlcnRVbml0KCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbi8qKlxuICogUGx1dHVzLWNvcmUgYm9vbGVhbiB2YWx1ZSBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgVXBsY0Jvb2wgZXh0ZW5kcyBVcGxjVmFsdWUge1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIHZhbHVlKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jdmFsdWUgPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgVXBsY0Jvb2wgd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtVcGxjQm9vbH1cblx0ICovXG5cdHN0YXRpYyBuZXcodmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNCb29sKFNpdGUuZHVtbXkoKSwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVXBsY0Jvb2wgd3JhcHBlZCB3aXRoIFVwbGNDb25zdCBzbyBpdCBjYW4gYmUgdXNlZCBhcyBhIHRlcm0uXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBcblx0ICogQHJldHVybnMge1VwbGNDb25zdH1cblx0ICovXG5cdHN0YXRpYyBuZXdUZXJtKHNpdGUsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjQ29uc3QobmV3IFVwbGNCb29sKHNpdGUsIHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBtZW1TaXplKCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gbmV3U2l0ZSBcblx0ICogQHJldHVybnMge1VwbGNCb29sfVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjQm9vbChuZXdTaXRlLCB0aGlzLiN2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqL1xuXHRnZXQgYm9vbCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNEYXRhfVxuXHQgKi9cblx0Z2V0IGRhdGEoKSB7XG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKHRoaXMuI3ZhbHVlID8gMSA6IDAsIFtdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHR5cGVCaXRzKCkge1xuXHRcdHJldHVybiAnMDEwMCc7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlclxuXHQgKi9cblx0dG9GbGF0VmFsdWVJbnRlcm5hbChiaXRXcml0ZXIpIHtcblx0XHRpZiAodGhpcy4jdmFsdWUpIHtcblx0XHRcdGJpdFdyaXRlci53cml0ZSgnMScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiaXRXcml0ZXIud3JpdGUoJzAnKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBwYWlyIHZhbHVlIGNsYXNzXG4gKiBDYW4gY29udGFpbiBhbnkgb3RoZXIgdmFsdWUgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVwbGNQYWlyIGV4dGVuZHMgVXBsY1ZhbHVlIHtcblx0I2ZpcnN0O1xuXHQjc2Vjb25kO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IGZpcnN0XG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSBzZWNvbmRcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGZpcnN0LCBzZWNvbmQpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNmaXJzdCA9IGZpcnN0O1xuXHRcdHRoaXMuI3NlY29uZCA9IHNlY29uZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgVXBsY1BhaXIgd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSBmaXJzdCBcblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IHNlY29uZCBcblx0ICogQHJldHVybnMge1VwbGNQYWlyfVxuXHQgKi9cblx0c3RhdGljIG5ldyhmaXJzdCwgc2Vjb25kKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjUGFpcihTaXRlLmR1bW15KCksIGZpcnN0LCBzZWNvbmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVXBsY0Jvb2wgd3JhcHBlZCB3aXRoIFVwbGNDb25zdCBzbyBpdCBjYW4gYmUgdXNlZCBhcyBhIHRlcm0uXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IGZpcnN0XG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSBzZWNvbmRcblx0ICogQHJldHVybnMge1VwbGNDb25zdH1cblx0ICovXG5cdHN0YXRpYyBuZXdUZXJtKHNpdGUsIGZpcnN0LCBzZWNvbmQpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNDb25zdChuZXcgVXBsY1BhaXIoc2l0ZSwgZmlyc3QsIHNlY29uZCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbWVtU2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZmlyc3QubWVtU2l6ZSArIHRoaXMuI3NlY29uZC5tZW1TaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gbmV3U2l0ZSBcblx0ICogQHJldHVybnMge1VwbGNQYWlyfVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjUGFpcihuZXdTaXRlLCB0aGlzLiNmaXJzdCwgdGhpcy4jc2Vjb25kKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAoJHt0aGlzLiNmaXJzdC50b1N0cmluZygpfSwgJHt0aGlzLiNzZWNvbmQudG9TdHJpbmcoKX0pYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzUGFpcigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Z2V0IGZpcnN0KCkge1xuXHRcdHJldHVybiB0aGlzLiNmaXJzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Z2V0IHNlY29uZCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2Vjb25kO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjRGF0YX1cblx0ICovXG5cdGdldCBrZXkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZpcnN0LmRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNEYXRhfVxuXHQgKi9cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLiNzZWNvbmQuZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dHlwZUJpdHMoKSB7XG5cdFx0Ly8gNyAoNyAoNikgKGZzdCkpIChzbmQpXG5cdFx0cmV0dXJuIFtcIjAxMTFcIiwgXCIwMTExXCIsIFwiMDExMFwiLCB0aGlzLiNmaXJzdC50eXBlQml0cygpLCB0aGlzLiNzZWNvbmQudHlwZUJpdHMoKV0uam9pbihcIjFcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlclxuXHQgKi9cblx0dG9GbGF0VmFsdWVJbnRlcm5hbChiaXRXcml0ZXIpIHtcblx0XHR0aGlzLiNmaXJzdC50b0ZsYXRWYWx1ZUludGVybmFsKGJpdFdyaXRlcik7XG5cdFx0dGhpcy4jc2Vjb25kLnRvRmxhdFZhbHVlSW50ZXJuYWwoYml0V3JpdGVyKTtcblx0fVxufVxuXG4vKiogXG4gKiBQbHV0dXMtY29yZSBsaXN0IHZhbHVlIGNsYXNzLlxuICogT25seSB1c2VkIGR1cmluZyBldmFsdWF0aW9uLlxuKi9cbmV4cG9ydCBjbGFzcyBVcGxjTGlzdCBleHRlbmRzIFVwbGNWYWx1ZSB7XG5cdCNpdGVtVHlwZTtcblx0I2l0ZW1zO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VXBsY1R5cGV9IGl0ZW1UeXBlIFxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZVtdfSBpdGVtcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGl0ZW1UeXBlLCBpdGVtcykge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI2l0ZW1UeXBlID0gaXRlbVR5cGU7XG5cdFx0dGhpcy4jaXRlbXMgPSBpdGVtcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgVXBsY0xpc3Qgd2l0aG91dCByZXF1aXJpbmcgYSBTaXRlXG5cdCAqIEBwYXJhbSB7VXBsY1R5cGV9IHR5cGUgXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlW119IGl0ZW1zIFxuXHQgKi9cblx0c3RhdGljIG5ldyh0eXBlLCBpdGVtcykge1xuXHRcdHJldHVybiBuZXcgVXBsY0xpc3QoU2l0ZS5kdW1teSgpLCB0eXBlLCBpdGVtcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2l0ZW1zLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IG1lbVNpemUoKSB7XG5cdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRmb3IgKGxldCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG5cdFx0XHRzdW0gKz0gaXRlbS5jb3B5KHRoaXMuc2l0ZSkubWVtU2l6ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9XG5cblx0Z2V0IGl0ZW1UeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLiNpdGVtVHlwZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IG5ld1NpdGVcblx0ICogQHJldHVybnMge1VwbGNMaXN0fVxuXHQgKi9cblx0Y29weShuZXdTaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBVcGxjTGlzdChuZXdTaXRlLCB0aGlzLiNpdGVtVHlwZSwgdGhpcy4jaXRlbXMuc2xpY2UoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0xpc3QoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNWYWx1ZVtdfVxuXHQgKi9cblx0Z2V0IGxpc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2l0ZW1zLnNsaWNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgWyR7dGhpcy4jaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS50b1N0cmluZygpKS5qb2luKFwiLCBcIil9XWA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHR5cGVCaXRzKCkge1xuXHRcdC8vIDcgKDUpICh0eXBlIGJpdHMgb2YgY29udGVudClcblx0XHRyZXR1cm4gW1wiMDExMVwiLCBcIjAxMDFcIiwgdGhpcy4jaXRlbVR5cGUudHlwZUJpdHMoKV0uam9pbihcIjFcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdFZhbHVlSW50ZXJuYWwoYml0V3JpdGVyKSB7XG5cdFx0Zm9yIChsZXQgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuXHRcdFx0Yml0V3JpdGVyLndyaXRlKCcxJyk7XG5cblx0XHRcdGl0ZW0uY29weSh0aGlzLnNpdGUpLnRvRmxhdFZhbHVlSW50ZXJuYWwoYml0V3JpdGVyKTtcblx0XHR9XG5cblx0XHRiaXRXcml0ZXIud3JpdGUoJzAnKTtcblx0fVxufVxuXG4vKipcbiAqIFdyYXBwZXIgZm9yIFVwbGNEYXRhLlxuICovXG5leHBvcnQgY2xhc3MgVXBsY0RhdGFWYWx1ZSBleHRlbmRzIFVwbGNWYWx1ZSB7XG5cdCNkYXRhO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBkYXRhKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jZGF0YSA9IGFzc2VydERlZmluZWQoZGF0YSk7XG5cdFx0YXNzZXJ0KGRhdGEgaW5zdGFuY2VvZiBVcGxjRGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBtZW1TaXplKCkge1xuXHRcdHJldHVybiB0aGlzLiNkYXRhLm1lbVNpemU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBuZXdTaXRlIFxuXHQgKiBAcmV0dXJucyB7VXBsY0RhdGFWYWx1ZX1cblx0ICovXG5cdGNvcHkobmV3U2l0ZSkge1xuXHRcdHJldHVybiBuZXcgVXBsY0RhdGFWYWx1ZShuZXdTaXRlLCB0aGlzLiNkYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRGF0YSgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY0RhdGF9XG5cdCAqL1xuXHRnZXQgZGF0YSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBkYXRhKCR7dGhpcy4jZGF0YS50b1N0cmluZygpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0eXBlQml0cygpIHtcblx0XHRyZXR1cm4gVXBsY1R5cGUubmV3RGF0YVR5cGUoKS50eXBlQml0cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXJcblx0ICovXG5cdHRvRmxhdFZhbHVlSW50ZXJuYWwoYml0V3JpdGVyKSB7XG5cdFx0VXBsY0J5dGVBcnJheS53cml0ZUJ5dGVzKGJpdFdyaXRlciwgdGhpcy4jZGF0YS50b0Nib3IoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YVZhbHVlIHwgVXBsY0RhdGF9IGRhdGEgXG5cdCAqIEByZXR1cm5zIHtVcGxjRGF0YX1cblx0ICovXG5cdHN0YXRpYyB1bndyYXAoZGF0YSkge1xuXHRcdGlmIChkYXRhIGluc3RhbmNlb2YgVXBsY0RhdGFWYWx1ZSkge1xuXHRcdFx0cmV0dXJuIGRhdGEuZGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBQbHV0dXMtY29yZSB0ZXJtc1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVXBsY1Rlcm0ge1xuXHQjc2l0ZTtcblx0I3R5cGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgdHlwZSkge1xuXHRcdGFzc2VydChzaXRlICE9IHVuZGVmaW5lZCAmJiBzaXRlIGluc3RhbmNlb2YgU2l0ZSk7XG5cdFx0dGhpcy4jc2l0ZSA9IHNpdGU7XG5cdFx0dGhpcy4jdHlwZSA9IHR5cGU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1NpdGV9XG5cdCAqL1xuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmljIHRlcm0gdG9TdHJpbmcgbWV0aG9kXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYChUZXJtICR7dGhpcy4jdHlwZS50b1N0cmluZygpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgYSB2YWx1ZSwgYW5kIGFsc28gaW5jcmVtZW50cyB0aGUgY29zdFxuXHQgKiBAcGFyYW0ge1VwbGNSdGUgfCBVcGxjU3RhY2t9IHJ0ZSBcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGV2YWwocnRlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYml0cyBvZiBmbGF0IGVuY29kZWQgUGx1dHVzLWNvcmUgdGVybXMgdG8gYml0V3JpdGVyLiBEb2Vzbid0IHJldHVybiBhbnl0aGluZy5cblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdChiaXRXcml0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG59XG5cbi8qKlxuICogUGx1dHVzLWNvcmUgdmFyaWFibGUgcmVmIHRlcm0gKGluZGV4IGlzIGEgRGVicnVpam4gaW5kZXgpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjVmFyaWFibGUgZXh0ZW5kcyBVcGxjVGVybSB7XG5cdCNpbmRleDtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1VwbGNJbnR9IGluZGV4IFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgaW5kZXgpIHtcblx0XHRzdXBlcihzaXRlLCAwKTtcblx0XHR0aGlzLiNpbmRleCA9IGluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYHgke3RoaXMuI2luZGV4LnRvU3RyaW5nKCl9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyIFxuXHQgKi9cblx0dG9GbGF0KGJpdFdyaXRlcikge1xuXHRcdGJpdFdyaXRlci53cml0ZSgnMDAwMCcpO1xuXHRcdHRoaXMuI2luZGV4LnRvRmxhdFVuc2lnbmVkKGJpdFdyaXRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjUnRlIHwgVXBsY1N0YWNrfSBydGVcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGV2YWwocnRlKSB7XG5cdFx0Ly8gYWRkIGNvc3RzIGJlZm9yZSBnZXQgdGhlIHZhbHVlXG5cdFx0cnRlLmluY3JWYXJpYWJsZUNvc3QoKTtcblxuXHRcdHJldHVybiBydGUuZ2V0KE51bWJlcih0aGlzLiNpbmRleC5pbnQpKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGRlbGF5IHRlcm0uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjRGVsYXkgZXh0ZW5kcyBVcGxjVGVybSB7XG5cdCNleHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VXBsY1Rlcm19IGV4cHIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBleHByKSB7XG5cdFx0c3VwZXIoc2l0ZSwgMSk7XG5cdFx0dGhpcy4jZXhwciA9IGV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ30gXG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYChkZWxheSAke3RoaXMuI2V4cHIudG9TdHJpbmcoKX0pYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0JpdFdyaXRlcn0gYml0V3JpdGVyIFxuXHQgKi9cblx0dG9GbGF0KGJpdFdyaXRlcikge1xuXHRcdGJpdFdyaXRlci53cml0ZSgnMDAwMScpO1xuXHRcdHRoaXMuI2V4cHIudG9GbGF0KGJpdFdyaXRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjUnRlIHwgVXBsY1N0YWNrfSBydGUgXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFVwbGNWYWx1ZT59XG5cdCAqL1xuXHRhc3luYyBldmFsKHJ0ZSkge1xuXHRcdHJ0ZS5pbmNyRGVsYXlDb3N0KCk7XG5cblx0XHRyZXR1cm4gbmV3IFVwbGNEZWxheWVkVmFsdWUodGhpcy5zaXRlLCAoKSA9PiAgdGhpcy4jZXhwci5ldmFsKHJ0ZSkpO1xuXHR9XG59XG5cbi8qKlxuICogUGx1dHVzLWNvcmUgbGFtYmRhIHRlcm1cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFVwbGNMYW1iZGEgZXh0ZW5kcyBVcGxjVGVybSB7XG5cdCNyaHM7XG5cdCNhcmdOYW1lO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtVcGxjVGVybX0gcmhzXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gYXJnTmFtZVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgcmhzLCBhcmdOYW1lID0gbnVsbCkge1xuXHRcdHN1cGVyKHNpdGUsIDIpO1xuXHRcdHRoaXMuI3JocyA9IHJocztcblx0XHR0aGlzLiNhcmdOYW1lID0gYXJnTmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0cmluZyB3aXRoIHVuaWNvZGUgbGFtYmRhIHN5bWJvbFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAoXFx1MDM5YiR7dGhpcy4jYXJnTmFtZSAhPT0gbnVsbCA/IFwiIFwiICsgdGhpcy4jYXJnTmFtZSArIFwiIC0+XCIgOiBcIlwifSAke3RoaXMuI3Jocy50b1N0cmluZygpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXIgXG5cdCAqL1xuXHR0b0ZsYXQoYml0V3JpdGVyKSB7XG5cdFx0Yml0V3JpdGVyLndyaXRlKCcwMDEwJyk7XG5cdFx0dGhpcy4jcmhzLnRvRmxhdChiaXRXcml0ZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY1J0ZSB8IFVwbGNTdGFja30gcnRlIFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxVcGxjVmFsdWU+fVxuXHQgKi9cblx0YXN5bmMgZXZhbChydGUpIHtcblx0XHRydGUuaW5jckxhbWJkYUNvc3QoKTtcblxuXHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIHRoaXMuI2FyZ05hbWUgIT09IG51bGwgPyBbdGhpcy4jYXJnTmFtZV0gOiAxLCAoY2FsbFNpdGUsIHN1YlN0YWNrKSA9PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jcmhzLmV2YWwoc3ViU3RhY2spO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogUGx1dHVzLWNvcmUgZnVuY3Rpb24gYXBwbGljYXRpb24gdGVybSAoaS5lLiBmdW5jdGlvbiBjYWxsKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVXBsY0NhbGwgZXh0ZW5kcyBVcGxjVGVybSB7XG5cdCNhO1xuXHQjYjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7VXBsY1Rlcm19IGFcblx0ICogQHBhcmFtIHtVcGxjVGVybX0gYlxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgYSwgYikge1xuXHRcdHN1cGVyKHNpdGUsIDMpO1xuXHRcdHRoaXMuI2EgPSBhO1xuXHRcdHRoaXMuI2IgPSBiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYFske3RoaXMuI2EudG9TdHJpbmcoKX0gJHt0aGlzLiNiLnRvU3RyaW5nKCl9XWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdChiaXRXcml0ZXIpIHtcblx0XHRiaXRXcml0ZXIud3JpdGUoJzAwMTEnKTtcblx0XHR0aGlzLiNhLnRvRmxhdChiaXRXcml0ZXIpO1xuXHRcdHRoaXMuI2IudG9GbGF0KGJpdFdyaXRlcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjUnRlIHwgVXBsY1N0YWNrfSBydGUgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0YXN5bmMgZXZhbChydGUpIHtcblx0XHRydGUuaW5jckNhbGxDb3N0KCk7XG5cblx0XHRsZXQgZm4gPSBhd2FpdCB0aGlzLiNhLmV2YWwocnRlKTtcblx0XHRsZXQgYXJnID0gYXdhaXQgdGhpcy4jYi5ldmFsKHJ0ZSk7XG5cblx0XHRyZXR1cm4gYXdhaXQgZm4uY2FsbChydGUsIHRoaXMuc2l0ZSwgYXJnKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGNvbnN0IHRlcm0gKGkuZS4gYSBsaXRlcmFsIGluIGNvbnZlbnRpb25hbCBzZW5zZSlcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFVwbGNDb25zdCBleHRlbmRzIFVwbGNUZXJtIHtcblx0I3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNWYWx1ZX0gdmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdHN1cGVyKHZhbHVlLnNpdGUsIDQpO1xuXG5cdFx0dGhpcy4jdmFsdWUgPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVwbGNJbnQpIHtcblx0XHRcdGFzc2VydCh2YWx1ZS5zaWduZWQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VXBsY1ZhbHVlfVxuXHQgKi9cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdChiaXRXcml0ZXIpIHtcblx0XHRiaXRXcml0ZXIud3JpdGUoJzAxMDAnKTtcblx0XHR0aGlzLiN2YWx1ZS50b0ZsYXRWYWx1ZShiaXRXcml0ZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY1N0YWNrIHwgVXBsY1J0ZX0gcnRlIFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxVcGxjVmFsdWU+fVxuXHQgKi9cblx0YXN5bmMgZXZhbChydGUpIHtcblx0XHRydGUuaW5jckNvbnN0Q29zdCgpO1xuXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuI3ZhbHVlLmV2YWwocnRlKTtcblx0fVxufVxuXG4vKipcbiAqIFBsdXR1cy1jb3JlIGZvcmNlIHRlcm1cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFVwbGNGb3JjZSBleHRlbmRzIFVwbGNUZXJtIHtcblx0I2V4cHI7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge1VwbGNUZXJtfSBleHByXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBleHByKSB7XG5cdFx0c3VwZXIoc2l0ZSwgNSk7XG5cdFx0dGhpcy4jZXhwciA9IGV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgKGZvcmNlICR7dGhpcy4jZXhwci50b1N0cmluZygpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXIgXG5cdCAqL1xuXHR0b0ZsYXQoYml0V3JpdGVyKSB7XG5cdFx0Yml0V3JpdGVyLndyaXRlKCcwMTAxJyk7XG5cdFx0dGhpcy4jZXhwci50b0ZsYXQoYml0V3JpdGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNSdGUgfCBVcGxjU3RhY2t9IHJ0ZSBcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGV2YWwocnRlKSB7XG5cdFx0cnRlLmluY3JGb3JjZUNvc3QoKTtcblxuXHRcdHJldHVybiBhd2FpdCAoYXdhaXQgdGhpcy4jZXhwci5ldmFsKHJ0ZSkpLmZvcmNlKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBlcnJvciB0ZXJtXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjRXJyb3IgZXh0ZW5kcyBVcGxjVGVybSB7XG5cdC8qKiAnbXNnJyBpcyBvbmx5IHVzZWQgZm9yIGRlYnVnZ2luIGFuZCBkb2Vzbid0IGFjdHVhbGx5IGFwcGVhciBpbiB0aGUgZmluYWwgcHJvZ3JhbSAqL1xuXHQjbXNnO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBtc2cgPSBcIlwiKSB7XG5cdFx0c3VwZXIoc2l0ZSwgNik7XG5cdFx0dGhpcy4jbXNnID0gbXNnO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCIoZXJyb3IpXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdChiaXRXcml0ZXIpIHtcblx0XHRiaXRXcml0ZXIud3JpdGUoJzAxMTAnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYSBSdW50aW1lRXJyb3Igd2hlbiBldmFsdWF0ZWQuXG5cdCAqIEBwYXJhbSB7VXBsY1J0ZSB8IFVwbGNTdGFja30gcnRlIFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxVcGxjVmFsdWU+fVxuXHQgKi9cblx0YXN5bmMgZXZhbChydGUpIHtcblx0XHR0aHJvdyB0aGlzLnNpdGUucnVudGltZUVycm9yKHRoaXMuI21zZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBidWlsdGluIGZ1bmN0aW9uIHJlZiB0ZXJtXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVcGxjQnVpbHRpbiBleHRlbmRzIFVwbGNUZXJtIHtcblx0LyoqIHVua25vd24gYnVpbHRpbnMgc3RheSBpbnRlZ2VycyAqL1xuXHQjbmFtZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gbmFtZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG5hbWUpIHtcblx0XHRzdXBlcihzaXRlLCA3KTtcblx0XHR0aGlzLiNuYW1lID0gbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGlzLiNuYW1lID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHJldHVybiBgKGJ1aWx0aW4gJHt0aGlzLiNuYW1lfSlgO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYChidWlsdGluIHVua25vd24ke3RoaXMuI25hbWUudG9TdHJpbmcoKX0pYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCaXRXcml0ZXJ9IGJpdFdyaXRlciBcblx0ICovXG5cdHRvRmxhdChiaXRXcml0ZXIpIHtcblx0XHRiaXRXcml0ZXIud3JpdGUoJzAxMTEnKTtcblxuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdGxldCBpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLiNuYW1lID09IFwic3RyaW5nXCIpIHtcblx0XHRcdGkgPSBVUExDX0JVSUxUSU5TLmZpbmRJbmRleChpbmZvID0+IGluZm8ubmFtZSA9PSB0aGlzLiNuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSA9IHRoaXMuI25hbWU7XG5cdFx0fVxuXG5cdFx0bGV0IGJpdFN0cmluZyA9IHBhZFplcm9lcyhpLnRvU3RyaW5nKDIpLCA3KTtcblxuXHRcdGJpdFdyaXRlci53cml0ZShiaXRTdHJpbmcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gcGFyYW1zXG5cdCAqIEBwYXJhbSAgey4uLlVwbGNWYWx1ZX0gYXJnc1xuXHQgKiBAcmV0dXJucyB7Q29zdH1cblx0ICovXG5cdGNhbGNDb3N0KHBhcmFtcywgLi4uYXJncykge1xuXHRcdGxldCBpID0gVVBMQ19CVUlMVElOUy5maW5kSW5kZXgoaW5mbyA9PiBpbmZvLm5hbWUgPT0gdGhpcy4jbmFtZSk7XG5cblx0XHRsZXQgYXJnU2l6ZXMgPSBhcmdzLm1hcChhID0+IGEubWVtU2l6ZSk7XG5cblx0XHRpZiAoIWFyZ1NpemVzLmV2ZXJ5KHNpemUgPT4gIU51bWJlci5pc05hTihzaXplKSAmJiBzaXplID49IDApKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFyZyBzaXplXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBVUExDX0JVSUxUSU5TW2ldLmNhbGNDb3N0KHBhcmFtcywgYXJnU2l6ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgSVJDb3JlQ2FsbEV4cHJcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlW119IGFyZ3Ncblx0ICogQHJldHVybnMge1VwbGNWYWx1ZX1cblx0ICovXG5cdHN0YXRpYyBldmFsU3RhdGljKG5hbWUsIGFyZ3MpIHtcblx0XHRsZXQgYnVpbHRpbiA9IG5ldyBVcGxjQnVpbHRpbihuYW1lLnNpdGUsIG5hbWUudmFsdWUpO1xuXG5cdFx0bGV0IGR1bW15UnRlID0gbmV3IFVwbGNSdGUoKTtcblxuXHRcdGxldCBhbm9uID0gYnVpbHRpbi5ldmFsSW50ZXJuYWwoZHVtbXlSdGUpO1xuXG5cdFx0bGV0IHN1YlN0YWNrID0gbmV3IFVwbGNTdGFjayhkdW1teVJ0ZSk7XG5cblx0XHRsZXQgcmVzID0gYW5vbi5jYWxsU3luYyhuYW1lLnNpdGUsIHN1YlN0YWNrLCBhcmdzKTtcblxuXHRcdGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBjYWxsIHRyYWNlIHRocm91Z2ggZXZhbFN0YXRpY1wiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjUnRlIHwgVXBsY1N0YWNrfSBydGVcblx0ICogQHJldHVybnMge1VwbGNBbm9ufVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHJ0ZSA9IG5ldyBVcGxjUnRlKCkpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMuI25hbWUgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgZXZhbHVhdGUgdW5rbm93biBQbHV0dXMtY29yZSBidWlsdGluXCIpO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAodGhpcy4jbmFtZSkge1xuXHRcdFx0Y2FzZSBcImFkZEludGVnZXJcIjpcblx0XHRcdFx0Ly8gcmV0dXJuaW5nIGEgbGFtYmRhIGlzIGFzc3VtZWQgdG8gYmUgZnJlZVxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHQvLyBidXQgY2FsbGluZyBhIGxhbWJkYSBoYXMgYSBjb3N0IGFzc29jaWF0ZWRcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjSW50KGNhbGxTaXRlLCBhLmludCArIGIuaW50KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwic3VidHJhY3RJbnRlZ2VyXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoY2FsbFNpdGUsIGEuaW50IC0gYi5pbnQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJtdWx0aXBseUludGVnZXJcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0ludChjYWxsU2l0ZSwgYS5pbnQgKiBiLmludCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcImRpdmlkZUludGVnZXJcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdGlmIChiLmludCA9PT0gMG4pIHtcblx0XHRcdFx0XHRcdHRocm93IGNhbGxTaXRlLnJ1bnRpbWVFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0ludChjYWxsU2l0ZSwgYS5pbnQgLyBiLmludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJtb2RJbnRlZ2VyXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRpZiAoYi5pbnQgPT09IDBuKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoY2FsbFNpdGUsIGEuaW50ICUgYi5pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiZXF1YWxzSW50ZWdlclwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQm9vbChjYWxsU2l0ZSwgYS5pbnQgPT0gYi5pbnQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJsZXNzVGhhbkludGVnZXJcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIGEuaW50IDwgYi5pbnQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJsZXNzVGhhbkVxdWFsc0ludGVnZXJcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIGEuaW50IDw9IGIuaW50KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiYXBwZW5kQnl0ZVN0cmluZ1wiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQnl0ZUFycmF5KGNhbGxTaXRlLCBhLmJ5dGVzLmNvbmNhdChiLmJ5dGVzKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcImNvbnNCeXRlU3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRsZXQgYnl0ZXMgPSBiLmJ5dGVzO1xuXHRcdFx0XHRcdGJ5dGVzLnVuc2hpZnQoTnVtYmVyKGEuaW50ICUgMjU2bikpO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0J5dGVBcnJheShjYWxsU2l0ZSwgYnl0ZXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJzbGljZUJ5dGVTdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMywgKGNhbGxTaXRlLCBfLCBhLCBiLCBjKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiLCBjKTtcblxuXHRcdFx0XHRcdGxldCBzdGFydCA9IE51bWJlcihhLmludCk7XG5cdFx0XHRcdFx0bGV0IG4gPSBOdW1iZXIoYi5pbnQpO1xuXHRcdFx0XHRcdGxldCBieXRlcyA9IGMuYnl0ZXM7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdGFydCArIG4gPiBieXRlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdG4gPSBieXRlcy5sZW5ndGggLSBzdGFydDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAobiA8IDApIHtcblx0XHRcdFx0XHRcdG4gPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBzdWIgPSBieXRlcy5zbGljZShzdGFydCwgc3RhcnQgKyBuKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0J5dGVBcnJheShjYWxsU2l0ZSwgc3ViKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwibGVuZ3RoT2ZCeXRlU3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDEsIChjYWxsU2l0ZSwgXywgYSkgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoY2FsbFNpdGUsIEJpZ0ludChhLmJ5dGVzLmxlbmd0aCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJpbmRleEJ5dGVTdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdGxldCBieXRlcyA9IGEuYnl0ZXM7XG5cdFx0XHRcdFx0bGV0IGkgPSBiLmludDtcblx0XHRcdFx0XHRpZiAoaSA8IDAgfHwgaSA+PSBieXRlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImluZGV4IG91dCBvZiByYW5nZVwiKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoY2FsbFNpdGUsIEJpZ0ludChieXRlc1tOdW1iZXIoaSldKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcImVxdWFsc0J5dGVTdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIEJ5dGVBcnJheURhdGEuY29tcChhLmJ5dGVzLCBiLmJ5dGVzKSA9PSAwKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwibGVzc1RoYW5CeXRlU3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNCb29sKGNhbGxTaXRlLCBCeXRlQXJyYXlEYXRhLmNvbXAoYS5ieXRlcywgYi5ieXRlcykgPT0gLTEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJsZXNzVGhhbkVxdWFsc0J5dGVTdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIEJ5dGVBcnJheURhdGEuY29tcChhLmJ5dGVzLCBiLmJ5dGVzKSA8PSAwKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiYXBwZW5kU3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNTdHJpbmcoY2FsbFNpdGUsIGEuc3RyaW5nICsgYi5zdHJpbmcpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJlcXVhbHNTdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIGEuc3RyaW5nID09IGIuc3RyaW5nKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiZW5jb2RlVXRmOFwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQnl0ZUFycmF5KGNhbGxTaXRlLCB0ZXh0VG9CeXRlcyhhLnN0cmluZykpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJkZWNvZGVVdGY4XCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDEsIChjYWxsU2l0ZSwgXywgYSkgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSk7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjU3RyaW5nKGNhbGxTaXRlLCBieXRlc1RvVGV4dChhLmJ5dGVzKSk7XG5cdFx0XHRcdFx0fSBjYXRjaChfKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoXCJpbnZhbGlkIHV0Zi04XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwic2hhMl8yNTZcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0J5dGVBcnJheShjYWxsU2l0ZSwgQ3J5cHRvLnNoYTJfMjU2KGEuYnl0ZXMpKVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJzaGEzXzI1NlwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQnl0ZUFycmF5KGNhbGxTaXRlLCBDcnlwdG8uc2hhMyhhLmJ5dGVzKSlcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiYmxha2UyYl8yNTZcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0J5dGVBcnJheShjYWxsU2l0ZSwgQ3J5cHRvLmJsYWtlMmIoYS5ieXRlcykpOyBcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidmVyaWZ5RWQyNTUxOVNpZ25hdHVyZVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAzLCAoY2FsbFNpdGUsIF8sIGtleSwgbXNnLCBzaWduYXR1cmUpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGtleSwgbXNnLCBzaWduYXR1cmUpO1xuXG5cdFx0XHRcdFx0bGV0IGtleUJ5dGVzID0ga2V5LmJ5dGVzO1xuXHRcdFx0XHRcdGlmIChrZXlCeXRlcy5sZW5ndGggIT0gMzIpIHtcblx0XHRcdFx0XHRcdHRocm93IGNhbGxTaXRlLnJ1bnRpbWVFcnJvcihgZXhwZWN0ZWQga2V5IG9mIGxlbmd0aCAzMiBmb3IgdmVyaWZ5RWQyNTUxOVNpZ25hdHVyZSwgZ290IGtleSBvZiBsZW5ndGggJHtrZXlCeXRlcy5sZW5ndGh9YCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IG1zZ0J5dGVzID0gbXNnLmJ5dGVzO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGxldCBzaWduYXR1cmVCeXRlcyA9IHNpZ25hdHVyZS5ieXRlcztcblx0XHRcdFx0XHRpZiAoc2lnbmF0dXJlQnl0ZXMubGVuZ3RoICE9IDY0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoYGV4cGVjdGVkIHNpZ25hdHVyZSBvZiBsZW5ndGggNjQgZm9yIHZlcmlmeUVkMjU1MTlTaWduYXR1cmUsIGdvdCBzaWduYXR1cmUgb2YgbGVuZ3RoICR7c2lnbmF0dXJlQnl0ZXMubGVuZ3RofWApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBvayA9IENyeXB0by5FZDI1NTE5LnZlcmlmeShzaWduYXR1cmVCeXRlcywgbXNnQnl0ZXMsIGtleUJ5dGVzKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0Jvb2woY2FsbFNpdGUsIG9rKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiaWZUaGVuRWxzZVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAzLCAoY2FsbFNpdGUsIF8sIGEsIGIsIGMpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIsIGMpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGEuYm9vbCA/IGIuY29weShjYWxsU2l0ZSkgOiBjLmNvcHkoY2FsbFNpdGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJjaG9vc2VVbml0XCI6XG5cdFx0XHRcdC8vIHdoYXQgaXMgdGhlIHBvaW50IG9mIHRoaXMgZnVuY3Rpb24/XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRhLmFzc2VydFVuaXQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBiLmNvcHkoY2FsbFNpdGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJ0cmFjZVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJ0ZS5wcmludChhLnN0cmluZykudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYi5jb3B5KGNhbGxTaXRlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiZnN0UGFpclwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKGEuaXNQYWlyKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhLmZpcnN0LmNvcHkoY2FsbFNpdGUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIHBhaXIgb3IgZGF0YS1wYWlyIGZvciBmaXJzdCBhcmcsIGdvdCAnJHthLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwic25kUGFpclwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKGEuaXNQYWlyKCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhLnNlY29uZC5jb3B5KGNhbGxTaXRlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBwYWlyIG9yIGRhdGEtcGFpciBmb3IgZmlyc3QgYXJnLCBnb3QgJyR7YS50b1N0cmluZygpfSdgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcImNob29zZUxpc3RcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMywgKGNhbGxTaXRlLCBfLCBhLCBiLCBjKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiLCBjKTtcblxuXHRcdFx0XHRcdGlmIChhLmlzTGlzdCgpKSB7XG5cdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYi5jb3B5KGNhbGxTaXRlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjLmNvcHkoY2FsbFNpdGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGxpc3Qgb3IgbWFwIGZpcnN0IGFyZywgZ290ICcke2EudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJta0NvbnNcIjpcblx0XHRcdFx0Ly8gb25seSBhbGxvdyBkYXRhIGl0ZW1zIGluIGxpc3Rcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMiwgKGNhbGxTaXRlLCBfLCBhLCBiKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhLCBiKTtcblxuXHRcdFx0XHRcdGlmIChiLmlzTGlzdCgpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWIuaXRlbVR5cGUuaXNTYW1lVHlwZShhKSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYHdyb25nIHR5cGUgZm9yIDJuZCBhcmcgb2YgbWtDb25zYCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGxldCBsc3QgPSBiLmxpc3Q7XG5cdFx0XHRcdFx0XHRsc3QudW5zaGlmdChhKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjTGlzdChjYWxsU2l0ZSwgYi5pdGVtVHlwZSwgbHN0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBsaXN0IG9yIG1hcCBmb3Igc2Vjb25kIGFyZywgZ290ICcke2IudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJoZWFkTGlzdFwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKGEuaXNMaXN0KCkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxzdCA9IGEubGlzdDtcblx0XHRcdFx0XHRcdGlmIChsc3QubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUucnVudGltZUVycm9yKFwiZW1wdHkgbGlzdFwiKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGxzdFswXS5jb3B5KGNhbGxTaXRlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUudHlwZUVycm9yKGBfX2NvcmVfX2hlYWQgZXhwZWN0cyBsaXN0IG9yIG1hcCwgZ290ICcke2EudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJ0YWlsTGlzdFwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKGEuaXNMaXN0KCkpIHtcblx0XHRcdFx0XHRcdGxldCBsc3QgPSBhLmxpc3Q7XG5cdFx0XHRcdFx0XHRpZiAobHN0Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGNhbGxTaXRlLnJ1bnRpbWVFcnJvcihcImVtcHR5IGxpc3RcIik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0xpc3QoY2FsbFNpdGUsIGEuaXRlbVR5cGUsIGxzdC5zbGljZSgxKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IGNhbGxTaXRlLnR5cGVFcnJvcihgX19jb3JlX190YWlsIGV4cGVjdHMgbGlzdCBvciBtYXAsIGdvdCAnJHthLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwibnVsbExpc3RcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdGlmIChhLmlzTGlzdCgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNCb29sKGNhbGxTaXRlLCBhLmxpc3QubGVuZ3RoID09IDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYF9fY29yZV9fbnVsbExpc3QgZXhwZWN0cyBsaXN0IG9yIG1hcCwgZ290ICcke2EudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJjaG9vc2VEYXRhXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDYsIChjYWxsU2l0ZSwgXywgYSwgYiwgYywgZCwgZSwgZikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYiwgYywgZCwgZSwgZik7XG5cblx0XHRcdFx0XHRsZXQgZGF0YSA9IGEuZGF0YTtcblxuXHRcdFx0XHRcdGlmIChkYXRhIGluc3RhbmNlb2YgQ29uc3RyRGF0YSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgTWFwRGF0YSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGM7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdERhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEludERhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ5dGVBcnJheURhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiY29uc3RyRGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0Y29uc3QgaSA9IGEuaW50O1xuXHRcdFx0XHRcdGFzc2VydChpID49IDApO1xuXG5cdFx0XHRcdFx0Y29uc3QgbHN0ID0gYi5saXN0O1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjRGF0YVZhbHVlKGNhbGxTaXRlLCBuZXcgQ29uc3RyRGF0YShOdW1iZXIoaSksIGxzdC5tYXAoaXRlbSA9PiBpdGVtLmRhdGEpKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcIm1hcERhdGFcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0RhdGFWYWx1ZShjYWxsU2l0ZSwgbmV3IE1hcERhdGEoYS5saXN0Lm1hcChwYWlyID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiBbcGFpci5maXJzdC5kYXRhLCBwYWlyLnNlY29uZC5kYXRhXTtcblx0XHRcdFx0XHR9KSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJsaXN0RGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjRGF0YVZhbHVlKGNhbGxTaXRlLCBuZXcgTGlzdERhdGEoYS5saXN0Lm1hcChpdGVtID0+IGl0ZW0uZGF0YSkpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiaURhdGFcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNEYXRhVmFsdWUoY2FsbFNpdGUsIG5ldyBJbnREYXRhKGEuaW50KSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcImJEYXRhXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDEsIChjYWxsU2l0ZSwgXywgYSkgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNEYXRhVmFsdWUoY2FsbFNpdGUsIG5ldyBCeXRlQXJyYXlEYXRhKGEuYnl0ZXMpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidW5Db25zdHJEYXRhXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDEsIChjYWxsU2l0ZSwgXywgYSkgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSk7XG5cblx0XHRcdFx0XHRpZiAoIWEuaXNEYXRhKCkpIHtcblx0XHRcdFx0XHRcdHRocm93IGNhbGxTaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgZGF0YSBmb3IgYXJnIG9mIHVuQ29uc3RyRGF0YSwgZ290ICR7YS50b1N0cmluZygpfWApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBkYXRhID0gYS5kYXRhO1xuXHRcdFx0XHRcdGlmICghKGRhdGEgaW5zdGFuY2VvZiBDb25zdHJEYXRhKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUucnVudGltZUVycm9yKGB1bmV4cGVjdGVkIHVuQ29uc3RyRGF0YSBhcmd1bWVudCAnJHtkYXRhLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNQYWlyKGNhbGxTaXRlLCBuZXcgVXBsY0ludChjYWxsU2l0ZSwgQmlnSW50KGRhdGEuaW5kZXgpKSwgbmV3IFVwbGNMaXN0KGNhbGxTaXRlLCBVcGxjVHlwZS5uZXdEYXRhVHlwZSgpLCBkYXRhLmZpZWxkcy5tYXAoZiA9PiBuZXcgVXBsY0RhdGFWYWx1ZShjYWxsU2l0ZSwgZikpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJ1bk1hcERhdGFcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdGlmICghYS5pc0RhdGEoKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBkYXRhIGZvciBhcmcgb2YgdW5NYXBEYXRhLCBnb3QgJHthLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcERhdGEpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoYHVuZXhwZWN0ZWQgdW5NYXBEYXRhIGFyZ3VtZW50ICcke2RhdGEudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0xpc3QoY2FsbFNpdGUsIFVwbGNUeXBlLm5ld0RhdGFQYWlyVHlwZSgpLCBkYXRhLm1hcC5tYXAoKFtmc3QsIHNuZF0pID0+IG5ldyBVcGxjUGFpcihjYWxsU2l0ZSwgbmV3IFVwbGNEYXRhVmFsdWUoY2FsbFNpdGUsIGZzdCksIG5ldyBVcGxjRGF0YVZhbHVlKGNhbGxTaXRlLCBzbmQpKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidW5MaXN0RGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKCFhLmlzRGF0YSgpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGRhdGEgZm9yIGFyZyBvZiB1bkxpc3REYXRhLCBnb3QgJHthLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKCEoZGF0YSBpbnN0YW5jZW9mIExpc3REYXRhKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUucnVudGltZUVycm9yKGB1bmV4cGVjdGVkIHVuTGlzdERhdGEgYXJndW1lbnQgJyR7ZGF0YS50b1N0cmluZygpfSdgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjTGlzdChjYWxsU2l0ZSwgVXBsY1R5cGUubmV3RGF0YVR5cGUoKSwgZGF0YS5saXN0Lm1hcChpdGVtID0+IG5ldyBVcGxjRGF0YVZhbHVlKGNhbGxTaXRlLCBpdGVtKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidW5JRGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKCFhLmlzRGF0YSgpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGRhdGEgZm9yIGFyZyBvZiB1bklEYXRhLCBnb3QgJHthLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKCEoZGF0YSBpbnN0YW5jZW9mIEludERhdGEpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoYHVuZXhwZWN0ZWQgdW5JRGF0YSBhcmd1bWVudCAnJHtkYXRhLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNJbnQoY2FsbFNpdGUsIGRhdGEudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidW5CRGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAxLCAoY2FsbFNpdGUsIF8sIGEpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEpO1xuXG5cdFx0XHRcdFx0aWYgKCFhLmlzRGF0YSgpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGRhdGEgZm9yIGFyZyBvZiB1bkJEYXRhLCBnb3QgJHthLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKCEoZGF0YSBpbnN0YW5jZW9mIEJ5dGVBcnJheURhdGEpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS5ydW50aW1lRXJyb3IoYHVuZXhwZWN0ZWQgdW5CRGF0YSBhcmd1bWVudCAnJHtkYXRhLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNCeXRlQXJyYXkoY2FsbFNpdGUsIGRhdGEuYnl0ZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwiZXF1YWxzRGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNBbm9uKHRoaXMuc2l0ZSwgcnRlLCAyLCAoY2FsbFNpdGUsIF8sIGEsIGIpID0+IHtcblx0XHRcdFx0XHRydGUuY2FsY0FuZEluY3JDb3N0KHRoaXMsIGEsIGIpO1xuXG5cdFx0XHRcdFx0aWYgKCFhLmlzRGF0YSgpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjYWxsU2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGRhdGEgZm9yIDFzdCBhcmcgb2YgZXF1YWxzRGF0YSwgZ290ICR7YS50b1N0cmluZygpfWApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghYi5pc0RhdGEoKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgY2FsbFNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBkYXRhIGZvciAybmQgYXJnIG9mIGVxdWFsc0RhdGEsIGdvdCAke2IudG9TdHJpbmcoKX1gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNCb29sKGNhbGxTaXRlLCBhLmRhdGEuaXNTYW1lKGIuZGF0YSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJta1BhaXJEYXRhXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDIsIChjYWxsU2l0ZSwgXywgYSwgYikgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSwgYik7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFVwbGNQYWlyKGNhbGxTaXRlLCBuZXcgVXBsY0RhdGFWYWx1ZShjYWxsU2l0ZSwgYS5kYXRhKSwgbmV3IFVwbGNEYXRhVmFsdWUoY2FsbFNpdGUsIGIuZGF0YSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJta05pbERhdGFcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdGEuYXNzZXJ0VW5pdCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjTGlzdChjYWxsU2l0ZSwgVXBsY1R5cGUubmV3RGF0YVR5cGUoKSwgW10pO1xuXHRcdFx0XHR9KTtcblx0XHRcdGNhc2UgXCJta05pbFBhaXJEYXRhXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgVXBsY0Fub24odGhpcy5zaXRlLCBydGUsIDEsIChjYWxsU2l0ZSwgXywgYSkgPT4ge1xuXHRcdFx0XHRcdHJ0ZS5jYWxjQW5kSW5jckNvc3QodGhpcywgYSk7XG5cblx0XHRcdFx0XHRhLmFzc2VydFVuaXQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0xpc3QoY2FsbFNpdGUsIFVwbGNUeXBlLm5ld0RhdGFQYWlyVHlwZSgpLCBbXSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2FzZSBcInNlcmlhbGlzZURhdGFcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjQW5vbih0aGlzLnNpdGUsIHJ0ZSwgMSwgKGNhbGxTaXRlLCBfLCBhKSA9PiB7XG5cdFx0XHRcdFx0cnRlLmNhbGNBbmRJbmNyQ29zdCh0aGlzLCBhKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVXBsY0J5dGVBcnJheShjYWxsU2l0ZSwgYS5kYXRhLnRvQ2JvcigpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRjYXNlIFwidmVyaWZ5RWNkc2FTZWNwMjU2azFTaWduYXR1cmVcIjpcblx0XHRcdGNhc2UgXCJ2ZXJpZnlTY2hub3JyU2VjcDI1NmsxU2lnbmF0dXJlXCI6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vIGltbWVkaWF0ZSBuZWVkLCBzbyBkb24ndCBib3RoZXIgeWV0XCIpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBidWlsdGluICR7dGhpcy4jbmFtZX0gbm90IHlldCBpbXBsZW1lbnRlZGApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFwcHJvcHJpYXRlIGNhbGxiYWNrIHdyYXBwZWQgd2l0aCBVcGxjQW5vbiBkZXBlbmRpbmcgb24gYnVpbHRpbiBuYW1lLlxuXHQgKiBFbXVsYXRlcyBldmVyeSBQbHV0dXMtY29yZSB0aGF0IEhlbGlvcyBleHBvc2VzIHRvIHRoZSB1c2VyLlxuXHQgKiBAcGFyYW0ge1VwbGNSdGUgfCBVcGxjU3RhY2t9IHJ0ZSBcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGV2YWwocnRlKSB7XG5cdFx0cnRlLmluY3JCdWlsdGluQ29zdCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1VwbGNWYWx1ZX1cblx0XHQgKi9cblx0XHRsZXQgdiA9IHRoaXMuZXZhbEludGVybmFsKHJ0ZSk7XG5cblx0XHRpZiAgKHR5cGVvZiB0aGlzLiNuYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0bGV0IG5Gb3JjZSA9IFVQTENfQlVJTFRJTlNbZmluZFVwbGNCdWlsdGluKFwiX19jb3JlX19cIiArIHRoaXMuI25hbWUpXS5mb3JjZUNvdW50O1xuXG5cdFx0XHRmb3IgIChsZXQgaSA9IDA7IGkgPCBuRm9yY2U7IGkrKykge1xuXHRcdFx0XHRjb25zdCB2UHJldiA9IHY7XG5cblx0XHRcdFx0diA9IG5ldyBVcGxjRGVsYXllZFZhbHVlKHRoaXMuc2l0ZSwgKCkgPT4gdlByZXYpO1xuXHRcdFx0fVxuXHRcdH1cbiBcblx0XHRyZXR1cm4gdjtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDExOiBVcGxjIHByb2dyYW1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFRoaXMgbGlicmFyeSB1c2VzIHZlcnNpb24gXCIxLjAuMFwiIG9mIFBsdXR1cy1jb3JlXG4gKiBAcGFja2FnZVxuICovXG5jb25zdCBVUExDX1ZFUlNJT05fQ09NUE9ORU5UUyA9IFsxbiwgMG4sIDBuXTtcblxuIC8qKlxuICAqIGkuZS4gXCIxLjAuMFwiXG4gICogQHBhY2thZ2VcbiAgKiBAdHlwZSB7c3RyaW5nfVxuICAqL1xuY29uc3QgVVBMQ19WRVJTSU9OID0gVVBMQ19WRVJTSU9OX0NPTVBPTkVOVFMubWFwKGMgPT4gYy50b1N0cmluZygpKS5qb2luKFwiLlwiKTtcblxuLyoqXG4gKiBUaGlzIGxpYnJhcnkgdXNlcyBWMiBvZiB0aGUgUGx1dHVzIExlZGdlciBBUEksIGFuZCBpcyBubyBsb25nZXIgY29tcGF0aWJsZSB3aXRoIFYxXG4gKiBAcGFja2FnZVxuICovXG5jb25zdCBQTFVUVVNfU0NSSVBUX1ZFUlNJT04gPSBcIlBsdXR1c1NjcmlwdFYyXCI7XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAqL1xuIGNvbnN0IFVQTENfVEFHX1dJRFRIUyA9IHtcblx0dGVybTogICAgICA0LFxuXHR0eXBlOiAgICAgIDMsXG5cdGNvbnN0VHlwZTogNCxcblx0YnVpbHRpbjogICA3LFxuXHRjb25zdGFudDogIDQsXG5cdGtpbmQ6ICAgICAgMVxufTtcblxuLyoqXG4gKiBQbHV0dXMtY29yZSBwcm9ncmFtIGNsYXNzXG4gKi9cbiBleHBvcnQgY2xhc3MgVXBsY1Byb2dyYW0ge1xuXHQjdmVyc2lvbjtcblx0I2V4cHI7XG5cdCNwdXJwb3NlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNUZXJtfSBleHByIFxuXHQgKiBAcGFyYW0gez9udW1iZXJ9IHB1cnBvc2UgLy8gVE9ETzogZW51bSB0eXBlXG5cdCAqIEBwYXJhbSB7VXBsY0ludFtdfSB2ZXJzaW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihleHByLCBwdXJwb3NlID0gbnVsbCwgdmVyc2lvbiA9IFVQTENfVkVSU0lPTl9DT01QT05FTlRTLm1hcCh2ID0+IG5ldyBVcGxjSW50KGV4cHIuc2l0ZSwgdiwgZmFsc2UpKSkge1xuXHRcdHRoaXMuI3ZlcnNpb24gPSB2ZXJzaW9uO1xuXHRcdHRoaXMuI2V4cHIgPSBleHByO1xuXHRcdHRoaXMuI3B1cnBvc2UgPSBwdXJwb3NlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjVGVybX1cblx0ICovXG5cdGdldCBleHByKCkge1xuXHRcdHJldHVybiB0aGlzLiNleHByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTaXRlfVxuXHQgKi9cblx0Z2V0IHNpdGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXRlKHRoaXMuI2V4cHIuc2l0ZS5zcmMsIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIElSIHNvdXJjZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHNyYygpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXRlLnNyYy5yYXc7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB2ZXJzaW9uIG9mIFBsdXR1cy1jb3JlICghPT0gUGx1dHVzIHNjcmlwdCB2ZXJzaW9uISlcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCB2ZXJzaW9uU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiN2ZXJzaW9uLm1hcCh2ID0+IHYudG9TdHJpbmcoKSkuam9pbihcIi5cIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHBsdXR1c1NjcmlwdFZlcnNpb24oKSB7XG5cdFx0Ly8gTm90ZTogb25seSBzdXBwb3J0cyBQbHV0dXNTY3JpcHRWMiBmb3Igbm93XG5cdFx0cmV0dXJuIFBMVVRVU19TQ1JJUFRfVkVSU0lPTjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIDEgZm9yIFBsdXR1c1NjcmlwdFYxLCAyIGZvciBQbHV0dXNTY3JpcHRWMlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0dmVyc2lvblRhZygpIHtcblx0XHRsZXQgdiA9IHRoaXMucGx1dHVzU2NyaXB0VmVyc2lvbigpO1xuXG5cdFx0c3dpdGNoICh2KSB7XG5cdFx0XHRjYXNlIFwiUGx1dHVzU2NyaXB0VjFcIjpcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRjYXNlIFwiUGx1dHVzU2NyaXB0VjJcIjpcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBzY3JpcHQgdmVyc2lvbiAnJHt2fSdgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgKHByb2dyYW0gJHt0aGlzLnZlcnNpb25TdHJpbmd9ICR7dGhpcy4jZXhwci50b1N0cmluZygpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsYXQgZW5jb2RlcyB0aGUgZW50aXJlIFBsdXR1cy1jb3JlIHByb2dyYW0uXG5cdCAqIE5vdGUgdGhhdCBmaW5hbCBwYWRkaW5nIGlzbid0IGFkZGVkIG5vdyBidXQgaXMgaGFuZGxlZCBieSBiaXRXcml0ZXIgdXBvbiBmaW5hbGl6YXRpb24uXG5cdCAqIEBwYXJhbSB7Qml0V3JpdGVyfSBiaXRXcml0ZXIgXG5cdCAqL1xuXHR0b0ZsYXQoYml0V3JpdGVyKSB7XG5cdFx0Zm9yIChsZXQgdiBvZiB0aGlzLiN2ZXJzaW9uKSB7XG5cdFx0XHR2LnRvRmxhdFVuc2lnbmVkKGJpdFdyaXRlcik7XG5cdFx0fVxuXG5cdFx0dGhpcy4jZXhwci50b0ZsYXQoYml0V3JpdGVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNSdGV9IHJ0ZSBcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIGV2YWwocnRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2V4cHIuZXZhbChydGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgdGVybSBjb250YWluZWQgaW4gVXBsY1Byb2dyYW0gKGFzc3VtaW5nIGl0IGlzIGEgbGFtYmRhIHRlcm0pXG5cdCAqIEBwYXJhbSB7P1VwbGNWYWx1ZVtdfSBhcmdzXG5cdCAqIEBwYXJhbSB7VXBsY1JURUNhbGxiYWNrc30gY2FsbGJhY2tzXG5cdCAqIEBwYXJhbSB7P05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICogQHJldHVybnMge1Byb21pc2U8VXBsY1ZhbHVlPn1cblx0ICovXG5cdGFzeW5jIHJ1bkludGVybmFsKGFyZ3MsIGNhbGxiYWNrcyA9IERFRkFVTFRfVVBMQ19SVEVfQ0FMTEJBQ0tTLCBuZXR3b3JrUGFyYW1zID0gbnVsbCkge1xuXHRcdGFzc2VydERlZmluZWQoY2FsbGJhY2tzKTtcblxuXHRcdGxldCBydGUgPSBuZXcgVXBsY1J0ZShjYWxsYmFja3MsIG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0Ly8gYWRkIHRoZSBzdGFydHVwIGNvc3RzXG5cdFx0cnRlLmluY3JTdGFydHVwQ29zdCgpO1xuXG5cdFx0bGV0IGZuID0gYXdhaXQgdGhpcy5ldmFsKHJ0ZSk7XG5cblx0XHQvLyBwcm9ncmFtIHNpdGUgaXMgYXQgcG9zIDAsIGJ1dCBub3cgdGhlIGNhbGwgc2l0ZSBpcyBhY3R1YWxseSBhdCB0aGUgZW5kIFxuXHRcdGxldCBnbG9iYWxDYWxsU2l0ZSA9IG5ldyBTaXRlKHRoaXMuc2l0ZS5zcmMsIHRoaXMuc2l0ZS5zcmMubGVuZ3RoKTtcblx0XHRcblx0XHQvKiogQHR5cGUge1VwbGNWYWx1ZX0gKi9cblx0XHRsZXQgcmVzdWx0ID0gZm47XG5cblx0XHRpZiAoYXJncyAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwICYmIGZuIGluc3RhbmNlb2YgVXBsY0RlbGF5ZWRWYWx1ZSkge1xuXHRcdFx0XHRyZXN1bHQgPSBhd2FpdCBmbi5mb3JjZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcblx0XHRcdFx0XHQvLyBlYWNoIGNhbGwgYWxzbyBhZGRzIHRvIHRoZSB0b3RhbCBjb3N0XG5cdFx0XHRcdFx0cnRlLmluY3JDYWxsQ29zdCgpO1xuXHRcdFx0XHRcdHJ0ZS5pbmNyQ29uc3RDb3N0KCk7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBhd2FpdCByZXN1bHQuY2FsbChydGUsIGdsb2JhbENhbGxTaXRlLCBhcmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcmFwIHRoZSB0b3AtbGV2ZWwgdGVybSB3aXRoIGNvbnNlY3V0aXZlIFVwbGNDYWxsIHRlcm1zXG5cdCAqIE5vIGNoZWNrcyBhcmUgcGVyZm9ybWVkIHdoZXRoZXIgdGhpcyBtYWtlcyBzZW5zZSBvciBub3QsIHNvIGJld2FyZVxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgeW91IGFyZSB0cnlpbmcgdG8gYXBwbHkgYW4gIHdpdGggYW5vbiBmdW5jLlxuXHQgKiBAcGFyYW0geyhVcGxjVmFsdWUgfCBIZWxpb3NEYXRhKVtdfSBhcmdzXG5cdCAqIEByZXR1cm5zIHtVcGxjUHJvZ3JhbX0gLSBhIG5ldyBVcGxjUHJvZ3JhbSBpbnN0YW5jZVxuXHQgKi9cblx0YXBwbHkoYXJncykge1xuXHRcdGxldCBleHByID0gdGhpcy5leHByO1xuXG5cdFx0Zm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBVcGxjVmFsdWUpIHtcblx0XHRcdFx0aWYgKGFyZyBpbnN0YW5jZW9mIFVwbGNBbm9uKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVXBsY0Fub24gY2Fubm90IGJlIGFwcGxpZWQgdG8gVXBsY1Byb2dyYW1cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGV4cHIgPSBuZXcgVXBsY0NhbGwoYXJnLnNpdGUsIGV4cHIsIG5ldyBVcGxjQ29uc3QoYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEhlbGlvc0RhdGEpIHtcblx0XHRcdFx0ZXhwciA9IG5ldyBVcGxjQ2FsbChTaXRlLmR1bW15KCksIGV4cHIsIG5ldyBVcGxjQ29uc3QobmV3IFVwbGNEYXRhVmFsdWUoU2l0ZS5kdW1teSgpLCBhcmcuX3RvVXBsY0RhdGEoKSkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFVwbGNQcm9ncmFtKGV4cHIsIHRoaXMuI3B1cnBvc2UsIHRoaXMuI3ZlcnNpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7P1VwbGNWYWx1ZVtdfSBhcmdzIC0gaWYgbnVsbCB0aGUgdG9wLWxldmVsIHRlcm0gaXMgcmV0dXJuZWQgYXMgYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1VwbGNSVEVDYWxsYmFja3N9IGNhbGxiYWNrcyBcblx0ICogQHBhcmFtIHs/TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxVcGxjVmFsdWUgfCBVc2VyRXJyb3I+fVxuXHQgKi9cblx0YXN5bmMgcnVuKGFyZ3MsIGNhbGxiYWNrcyA9IERFRkFVTFRfVVBMQ19SVEVfQ0FMTEJBQ0tTLCBuZXR3b3JrUGFyYW1zID0gbnVsbCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5ydW5JbnRlcm5hbChhcmdzLCBjYWxsYmFja3MsIG5ldHdvcmtQYXJhbXMpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghKGUgaW5zdGFuY2VvZiBVc2VyRXJyb3IpKSB7XG5cdFx0XHRcdHRocm93IGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHs/VXBsY1ZhbHVlW119IGFyZ3Ncblx0ICogQHJldHVybnMge1Byb21pc2U8WyhVcGxjVmFsdWUgfCBVc2VyRXJyb3IpLCBzdHJpbmdbXV0+fVxuXHQgKi9cblx0YXN5bmMgcnVuV2l0aFByaW50KGFyZ3MpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7c3RyaW5nW119XG5cdFx0ICovXG5cdFx0Y29uc3QgbWVzc2FnZXMgPSBbXTtcblxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVVBMQ19SVEVfQ0FMTEJBQ0tTKTtcblxuXHRcdGNhbGxiYWNrcy5vblByaW50ID0gYXN5bmMgZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRtZXNzYWdlcy5wdXNoKG1zZyk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucnVuKGFyZ3MsIGNhbGxiYWNrcyk7XG5cblx0XHRyZXR1cm4gW3JlcywgbWVzc2FnZXNdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIHt7XG5cdCAqICAgbWVtOiBiaWdpbnQsIFxuXHQgKiAgIGNwdTogYmlnaW50LFxuXHQgKiAgIHNpemU6IG51bWJlcixcblx0ICogICBidWlsdGluczoge1tuYW1lOiBzdHJpbmddOiBDb3N0fSxcblx0ICogICB0ZXJtczoge1tuYW1lOiBzdHJpbmddOiBDb3N0fSxcblx0ICogICByZXN1bHQ6IFVzZXJFcnJvciB8IFVwbGNWYWx1ZSxcblx0ICogICBtZXNzYWdlczogc3RyaW5nW11cblx0ICogfX0gUHJvZmlsZVxuXHQgKiBtZW06ICBpbiA4IGJ5dGUgd29yZHMgKGkuZS4gMSBtZW0gdW5pdCBpcyA2NCBiaXRzKVxuXHQgKiBjcHU6ICBpbiByZWZlcmVuY2UgY3B1IG1pY3Jvc2Vjb25kc1xuXHQgKiBzaXplOiBpbiBieXRlc1xuXHQgKiBidWlsdGluczogYnJlYWtkb3duIHBlciBidWlsdGluXG5cdCAqIHRlcm1zOiBicmVha2Rvd24gcGVyIHRlcm10eXBlXG5cdCAqIHJlc3VsdDogcmVzdWx0IG9mIGV2YWx1YXRpb25cblx0ICogbWVzc2FnZXM6IHByaW50ZWQgbWVzc2FnZXMgKGNhbiBiZSBoZWxwZnVsIHdoZW4gZGVidWdnaW5nKVxuXHQgKi9cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjVmFsdWVbXX0gYXJnc1xuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICogQHJldHVybnMge1Byb21pc2U8UHJvZmlsZT59XG5cdCAqL1xuXHRhc3luYyBwcm9maWxlKGFyZ3MsIG5ldHdvcmtQYXJhbXMpIHtcblx0XHRsZXQgY2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9VUExDX1JURV9DQUxMQkFDS1MpO1xuXG5cdFx0bGV0IG1lbUNvc3QgPSAwbjtcblx0XHRsZXQgY3B1Q29zdCA9IDBuO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3tbbmFtZTogc3RyaW5nXTogQ29zdH19XG5cdFx0ICovXG5cdFx0Y29uc3QgYnVpbHRpbnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHt7W25hbWU6IHN0cmluZ106IENvc3R9fVxuXHRcdCAqL1xuXHRcdGNvbnN0IHRlcm1zID0ge307XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUgeyhuYW1lOiBzdHJpbmcsIGlzVGVybTogYm9vbGVhbiwgY29zdDogQ29zdCkgPT4gdm9pZH1cblx0XHQgKi9cblx0XHRjYWxsYmFja3Mub25JbmNyQ29zdCA9IChuYW1lLCBpc1Rlcm0sIGNvc3QpID0+IHtcblx0XHRcdG1lbUNvc3QgKz0gY29zdC5tZW07XG5cdFx0XHRjcHVDb3N0ICs9IGNvc3QuY3B1O1xuXG5cdFx0XHRpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChpc1Rlcm0pIHtcblx0XHRcdFx0XHRjb25zdCBwcmV2ID0gdGVybXNbbmFtZV07XG5cdFx0XHRcdFx0aWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGVybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHRcdG1lbTogcHJldi5tZW0gKyBjb3N0Lm1lbSxcblx0XHRcdFx0XHRcdFx0Y3B1OiBwcmV2LmNwdSArIGNvc3QuY3B1XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0ZXJtc1tuYW1lXSA9IGNvc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHByZXYgPSBidWlsdGluc1tuYW1lXTtcblxuXHRcdFx0XHRcdGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGJ1aWx0aW5zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0XHRtZW06IHByZXYubWVtICsgY29zdC5tZW0sXG5cdFx0XHRcdFx0XHRcdGNwdTogcHJldi5jcHUgKyBjb3N0LmNwdVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnVpbHRpbnNbbmFtZV0gPSBjb3N0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblx0XHRsZXQgbWVzc2FnZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHsobXNnOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD59XG5cdFx0ICovXG5cdFx0Y2FsbGJhY2tzLm9uUHJpbnQgPSBhc3luYyBmdW5jdGlvbihtc2cpIHtcblx0XHRcdG1lc3NhZ2VzLnB1c2gobXNnKTtcblx0XHR9O1xuXG5cdFx0bGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuKGFyZ3MsIGNhbGxiYWNrcywgbmV0d29ya1BhcmFtcyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWVtOiBtZW1Db3N0LFxuXHRcdFx0Y3B1OiBjcHVDb3N0LFxuXHRcdFx0c2l6ZTogdGhpcy5jYWxjU2l6ZSgpLFxuXHRcdFx0YnVpbHRpbnM6IGJ1aWx0aW5zLFxuXHRcdFx0dGVybXM6IHRlcm1zLFxuXHRcdFx0cmVzdWx0OiByZXN1bHQsXG5cdFx0XHRtZXNzYWdlczogbWVzc2FnZXNcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgZmxhdCBieXRlcyBvZiBzZXJpYWxpemVkIHNjcmlwdFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRzZXJpYWxpemVCeXRlcygpIHtcblx0XHRsZXQgYml0V3JpdGVyID0gbmV3IEJpdFdyaXRlcigpO1xuXG5cdFx0dGhpcy50b0ZsYXQoYml0V3JpdGVyKTtcblxuXHRcdHJldHVybiBiaXRXcml0ZXIuZmluYWxpemUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBvbiBjaGFpbiBzaXplIG9mIHRoZSBwcm9ncmFtIChudW1iZXIgb2YgYnl0ZXMpLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Y2FsY1NpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VyaWFsaXplQnl0ZXMoKS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgQ2JvciBlbmNvZGluZyBvZiBhIHNjcmlwdCAoZmxhdCBieXRlcyB3cmFwcGVkIHR3aWNlIGluIENib3IgYnl0ZWFycmF5KVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZUJ5dGVzKENib3JEYXRhLmVuY29kZUJ5dGVzKHRoaXMuc2VyaWFsaXplQnl0ZXMoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgUGx1dHVzLWNvcmUgc2NyaXB0IGluIEpTT04gZm9ybWF0IChhcyBzdHJpbmcsIG5vdCBhcyBvYmplY3QhKVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0c2VyaWFsaXplKCkge1xuXHRcdGxldCBjYm9ySGV4ID0gYnl0ZXNUb0hleCh0aGlzLnRvQ2JvcigpKTtcblxuXHRcdHJldHVybiBge1widHlwZVwiOiBcIiR7dGhpcy5wbHV0dXNTY3JpcHRWZXJzaW9uKCl9XCIsIFwiZGVzY3JpcHRpb25cIjogXCJcIiwgXCJjYm9ySGV4XCI6IFwiJHtjYm9ySGV4fVwifWA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfSAtIDI4IGJ5dGUgaGFzaFxuXHQgKi9cblx0aGFzaCgpIHtcblx0XHRsZXQgaW5uZXJCeXRlcyA9IENib3JEYXRhLmVuY29kZUJ5dGVzKHRoaXMuc2VyaWFsaXplQnl0ZXMoKSk7XG5cblx0XHRpbm5lckJ5dGVzLnVuc2hpZnQodGhpcy52ZXJzaW9uVGFnKCkpO1xuXG5cdFx0Ly8gdXNlZCBmb3IgYm90aCBzY3JpcHQgYWRkcmVzc2VzIGFuZCBtaW50aW5nIHBvbGljeSBoYXNoZXNcblx0XHRyZXR1cm4gQ3J5cHRvLmJsYWtlMmIoaW5uZXJCeXRlcywgMjgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtWYWxpZGF0b3JIYXNofVxuXHQgKi9cblx0Z2V0IHZhbGlkYXRvckhhc2goKSB7XG5cdFx0YXNzZXJ0KHRoaXMuI3B1cnBvc2UgPT09IG51bGwgfHwgdGhpcy4jcHVycG9zZSA9PT0gU2NyaXB0UHVycG9zZS5TcGVuZGluZyk7XG5cblx0XHRyZXR1cm4gbmV3IFZhbGlkYXRvckhhc2godGhpcy5oYXNoKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtNaW50aW5nUG9saWN5SGFzaH1cblx0ICovXG5cdGdldCBtaW50aW5nUG9saWN5SGFzaCgpIHtcblx0XHRhc3NlcnQodGhpcy4jcHVycG9zZSA9PT0gbnVsbCB8fCB0aGlzLiNwdXJwb3NlID09PSBTY3JpcHRQdXJwb3NlLk1pbnRpbmcpO1xuXG5cdFx0cmV0dXJuIG5ldyBNaW50aW5nUG9saWN5SGFzaCh0aGlzLmhhc2goKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1N0YWtpbmdWYWxpZGF0b3JIYXNofVxuXHQgKi9cblx0Z2V0IHN0YWtpbmdWYWxpZGF0b3JIYXNoKCkge1xuXHRcdGFzc2VydCh0aGlzLiNwdXJwb3NlID09PSBudWxsIHx8IHRoaXMuI3B1cnBvc2UgPT09IFNjcmlwdFB1cnBvc2UuU3Rha2luZyk7XG5cblx0XHRyZXR1cm4gbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoKHRoaXMuaGFzaCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nfSBieXRlcyBcblx0ICogQHJldHVybnMge1VwbGNQcm9ncmFtfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0aWYgKHR5cGVvZiBieXRlcyA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gVXBsY1Byb2dyYW0uZnJvbUNib3IoaGV4VG9CeXRlcyhieXRlcykpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBkZXNlcmlhbGl6ZVVwbGNCeXRlcyhDYm9yRGF0YS5kZWNvZGVCeXRlcyhDYm9yRGF0YS5kZWNvZGVCeXRlcyhieXRlcykpKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQbHV0dXMtY29yZSBkZXNlcmlhbGl6ZXIgY3JlYXRlcyBhIFBsdXR1cy1jb3JlIGZvcm0gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuIGNsYXNzIFVwbGNEZXNlcmlhbGl6ZXIgZXh0ZW5kcyBCaXRSZWFkZXIge1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoYnl0ZXMpIHtcblx0XHRzdXBlcihieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0dGFnV2lkdGgoY2F0ZWdvcnkpIHtcblx0XHRhc3NlcnQoY2F0ZWdvcnkgaW4gVVBMQ19UQUdfV0lEVEhTLCBgdW5rbm93biB0YWcgY2F0ZWdvcnkgJHtjYXRlZ29yeS50b1N0cmluZygpfWApO1xuXG5cdFx0cmV0dXJuIFVQTENfVEFHX1dJRFRIU1tjYXRlZ29yeV07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGtub3duIGJ1aWx0aW5cblx0ICogUmV0dXJucyB0aGUgaW50ZWdlciBpZCBpZiBpZCBpcyBvdXQgb2YgcmFuZ2UgKHRodXMgaWYgdGhlIGJ1aWx0aW4gaXMgdW5rbm93bilcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkXG5cdCAqIEByZXR1cm5zIHtzdHJpbmcgfCBudW1iZXJ9XG5cdCAqL1xuXHRidWlsdGluTmFtZShpZCkge1xuXHRcdGxldCBhbGwgPSBVUExDX0JVSUxUSU5TO1xuXG5cdFx0aWYgKGlkID49IDAgJiYgaWQgPCBhbGwubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gYWxsW2lkXS5uYW1lO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBXYXJuaW5nOiBidWlsdGluIGlkICR7aWQudG9TdHJpbmcoKX0gb3V0IG9mIHJhbmdlYCk7XG5cblx0XHRcdHJldHVybiBpZDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBQbHV0dXMtY29yZSBsaXN0IHdpdGggYSBzcGVjaWZpZWQgc2l6ZSBwZXIgZWxlbWVudFxuXHQgKiBDYWxscyBpdHNlbGYgcmVjdXJzaXZlbHkgdW50aWwgdGhlIGVuZCBvZiB0aGUgbGlzdCBpcyByZWFjaGVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtU2l6ZSBcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0cmVhZExpbmtlZExpc3QoZWxlbVNpemUpIHtcblx0XHQvLyBDb25zIGFuZCBOaWwgY29uc3RydWN0b3JzIGNvbWUgZnJvbSBMaXNwL0hhc2tlbGxcblx0XHQvLyAgY29ucyAnYScgY3JlYXRlcyBhIGxpbmtlZCBsaXN0IG5vZGUsXG5cdFx0Ly8gIG5pbCAgICAgIGNyZWF0ZXMgYW4gZW1wdHkgbGlua2VkIGxpc3Rcblx0XHRsZXQgbmlsT3JDb25zID0gdGhpcy5yZWFkQml0cygxKTtcblxuXHRcdGlmIChuaWxPckNvbnMgPT0gMCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW3RoaXMucmVhZEJpdHMoZWxlbVNpemUpXS5jb25jYXQodGhpcy5yZWFkTGlua2VkTGlzdChlbGVtU2l6ZSkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhIHNpbmdsZSBVcGxjVGVybVxuXHQgKiBAcmV0dXJucyB7VXBsY1Rlcm19XG5cdCAqL1xuXHRyZWFkVGVybSgpIHtcblx0XHRsZXQgdGFnID0gdGhpcy5yZWFkQml0cyh0aGlzLnRhZ1dpZHRoKFwidGVybVwiKSk7XG5cblx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZWFkVmFyaWFibGUoKTtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVhZERlbGF5KCk7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlYWRMYW1iZGEoKTtcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVhZENhbGwoKTsgLy8gYWthIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG5cdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlYWRDb25zdGFudCgpO1xuXHRcdFx0Y2FzZSA1OlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZWFkRm9yY2UoKTtcblx0XHRcdGNhc2UgNjpcblx0XHRcdFx0cmV0dXJuIG5ldyBVcGxjRXJyb3IoU2l0ZS5kdW1teSgpKTtcblx0XHRcdGNhc2UgNzpcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVhZEJ1aWx0aW4oKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInRlcm0gdGFnIFwiICsgdGFnLnRvU3RyaW5nKCkgKyBcIiB1bmhhbmRsZWRcIik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGEgc2luZ2xlIHVuYm91bmRlZCBpbnRlZ2VyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lnbmVkIFxuXHQgKiBAcmV0dXJucyB7VXBsY0ludH1cblx0ICovXG5cdHJlYWRJbnRlZ2VyKHNpZ25lZCA9IGZhbHNlKSB7XG5cdFx0bGV0IGJ5dGVzID0gW107XG5cblx0XHRsZXQgYiA9IHRoaXMucmVhZEJ5dGUoKTtcblx0XHRieXRlcy5wdXNoKGIpO1xuXG5cdFx0d2hpbGUgKCFVcGxjSW50LnJhd0J5dGVJc0xhc3QoYikpIHtcblx0XHRcdGIgPSB0aGlzLnJlYWRCeXRlKCk7XG5cdFx0XHRieXRlcy5wdXNoKGIpO1xuXHRcdH1cblxuXHRcdC8vIHN0cmlwIHRoZSBsZWFkaW5nIGJpdFxuXHRcdGxldCByZXMgPSBuZXcgVXBsY0ludChTaXRlLmR1bW15KCksIFVwbGNJbnQuYnl0ZXNUb0JpZ0ludChieXRlcy5tYXAoYiA9PiBVcGxjSW50LnBhcnNlUmF3Qnl0ZShiKSkpLCBmYWxzZSk7IC8vIHJhdyBpbnQgaXMgdW5zaWduZWRcblxuXHRcdGlmIChzaWduZWQpIHtcblx0XHRcdHJlcyA9IHJlcy50b1NpZ25lZCgpOyAvLyB1bnppZ3phZyBpcyBwZXJmb3JtZWQgaGVyZVxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYnl0ZWFycmF5IG9yIHN0cmluZyBjaGFyYWN0ZXJzXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHJlYWRCeXRlcygpIHtcblx0XHR0aGlzLm1vdmVUb0J5dGVCb3VuZGFyeSh0cnVlKTtcblxuXHRcdGxldCBieXRlcyA9IFtdO1xuXG5cdFx0bGV0IG5DaHVuayA9IHRoaXMucmVhZEJ5dGUoKTtcblxuXHRcdHdoaWxlIChuQ2h1bmsgPiAwKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5DaHVuazsgaSsrKSB7XG5cdFx0XHRcdGJ5dGVzLnB1c2godGhpcy5yZWFkQnl0ZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0bkNodW5rID0gdGhpcy5yZWFkQnl0ZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBieXRlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhIGxpdGVyYWwgYnl0ZWFycmF5XG5cdCAqIEByZXR1cm5zIHtVcGxjQnl0ZUFycmF5fVxuXHQgKi9cblx0cmVhZEJ5dGVBcnJheSgpIHtcblx0XHRsZXQgYnl0ZXMgPSB0aGlzLnJlYWRCeXRlcygpO1xuXG5cdFx0cmV0dXJuIG5ldyBVcGxjQnl0ZUFycmF5KFNpdGUuZHVtbXkoKSwgYnl0ZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGEgbGl0ZXJhbCBzdHJpbmdcblx0ICogQHJldHVybnMge1VwbGNTdHJpbmd9XG5cdCAqL1xuXHRyZWFkU3RyaW5nKCkge1xuXHRcdGxldCBieXRlcyA9IHRoaXMucmVhZEJ5dGVzKCk7XG5cblx0XHRsZXQgcyA9IGJ5dGVzVG9UZXh0KGJ5dGVzKTtcblxuXHRcdHJldHVybiBuZXcgVXBsY1N0cmluZyhTaXRlLmR1bW15KCksIHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7KCkgPT4gVXBsY1ZhbHVlfSB0eXBlZFJlYWRlciBcblx0ICogQHJldHVybnMge1VwbGNWYWx1ZVtdfVxuXHQgKi9cblx0cmVhZExpc3QodHlwZWRSZWFkZXIpIHtcblx0XHQvKiogQHR5cGUge1VwbGNWYWx1ZVtdfSAqL1xuXHRcdGxldCBpdGVtcyA9IFtdO1xuXG5cdFx0d2hpbGUgKHRoaXMucmVhZEJpdHMoMSkgPT0gMSkge1xuXHRcdFx0aXRlbXMucHVzaCh0eXBlZFJlYWRlcigpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBkYXRhIG9iamVjdFxuXHQgKiBAcmV0dXJucyB7VXBsY0RhdGF9XG5cdCAqL1xuXHRyZWFkRGF0YSgpIHtcblx0XHRsZXQgYnl0ZXMgPSB0aGlzLnJlYWRCeXRlcygpO1xuXG5cdFx0cmV0dXJuIFVwbGNEYXRhLmZyb21DYm9yKGJ5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhIHZhcmlhYmxlIHRlcm1cblx0ICogQHJldHVybnMge1VwbGNWYXJpYWJsZX1cblx0ICovXG5cdHJlYWRWYXJpYWJsZSgpIHtcblx0XHRsZXQgaW5kZXggPSB0aGlzLnJlYWRJbnRlZ2VyKClcblxuXHRcdHJldHVybiBuZXcgVXBsY1ZhcmlhYmxlKFNpdGUuZHVtbXkoKSwgaW5kZXgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGEgbGFtYmRhIGV4cHJlc3Npb24gdGVybVxuXHQgKiBAcmV0dXJucyB7VXBsY0xhbWJkYX1cblx0ICovXG5cdHJlYWRMYW1iZGEoKSB7XG5cdFx0bGV0IHJocyA9IHRoaXMucmVhZFRlcm0oKTtcblxuXHRcdHJldHVybiBuZXcgVXBsY0xhbWJkYShTaXRlLmR1bW15KCksIHJocyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBmdW5jdGlvbiBhcHBsaWNhdGlvbiB0ZXJtXG5cdCAqIEByZXR1cm5zIHtVcGxjQ2FsbH1cblx0ICovXG5cdHJlYWRDYWxsKCkge1xuXHRcdGxldCBhID0gdGhpcy5yZWFkVGVybSgpO1xuXHRcdGxldCBiID0gdGhpcy5yZWFkVGVybSgpO1xuXG5cdFx0cmV0dXJuIG5ldyBVcGxjQ2FsbChTaXRlLmR1bW15KCksIGEsIGIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGEgc2luZ2xlIGNvbnN0YW50XG5cdCAqIEByZXR1cm5zIHtVcGxjQ29uc3R9XG5cdCAqL1xuXHRyZWFkQ29uc3RhbnQoKSB7XG5cdFx0bGV0IHR5cGVMaXN0ID0gdGhpcy5yZWFkTGlua2VkTGlzdCh0aGlzLnRhZ1dpZHRoKFwiY29uc3RUeXBlXCIpKTtcblxuXHRcdGxldCByZXMgPSBuZXcgVXBsY0NvbnN0KHRoaXMucmVhZFR5cGVkVmFsdWUodHlwZUxpc3QpKTtcblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBzaW5nbGUgY29uc3RhbnRcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdHlwZUxpc3QgXG5cdCAqIEByZXR1cm5zIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRyZWFkVHlwZWRWYWx1ZSh0eXBlTGlzdCkge1xuXHRcdGNvbnN0IHR5cGVkUmVhZGVyID0gdGhpcy5jb25zdHJ1Y3RUeXBlZFJlYWRlcih0eXBlTGlzdCk7XG5cblx0XHRhc3NlcnRFcSh0eXBlTGlzdC5sZW5ndGgsIDAsIFwiRGlkIG5vdCBjb25zdW1lIGFsbCB0eXBlIHBhcmFtZXRlcnNcIik7XG5cblx0XHRyZXR1cm4gdHlwZWRSZWFkZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgcmVhZGVyIGZvciBhIHNpbmdsZSBjb25zdHJ1Y3QgcmVjdXJzaXZlbHlcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdHlwZUxpc3QgXG5cdCAqIE5PVEU6IHRoZSBpbXBsaWNpdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBmdW5jdGlvbnMgbW9kaWZpZXMgdGhlIHR5cGVMaXN0XG5cdCAqIGJ5IHJlbW92aW5nIGFsbCBlbGVtZW50cyB0aGF0IGl0IFwiY29uc3VtZWRcIiB0byBkZWZpbmUgYSB0eXBlXG5cdCAqIEByZXR1cm5zIHsoKSA9PiBVcGxjVmFsdWV9XG5cdCAqL1xuXHRjb25zdHJ1Y3RUeXBlZFJlYWRlcih0eXBlTGlzdCl7XG5cdFx0Y29uc3QgdHlwZSA9IGFzc2VydERlZmluZWQodHlwZUxpc3Quc2hpZnQoKSk7XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgMDogLy8gc2lnbmVkIEludGVnZXJcblx0XHRcdFx0cmV0dXJuICgpID0+IHRoaXMucmVhZEludGVnZXIodHJ1ZSk7XG5cdFx0XHRjYXNlIDE6IC8vIGJ5dGVhcnJheVxuXHRcdFx0XHRyZXR1cm4gKCkgPT4gdGhpcy5yZWFkQnl0ZUFycmF5KCk7XG5cdFx0XHRjYXNlIDI6IC8vIHV0Zjgtc3RyaW5nXG5cdFx0XHRcdHJldHVybiAoKSA9PiB0aGlzLnJlYWRTdHJpbmcoKTtcblx0XHRcdGNhc2UgMzpcblx0XHRcdFx0cmV0dXJuICgpID0+IG5ldyBVcGxjVW5pdChTaXRlLmR1bW15KCkpOyAvLyBubyByZWFkaW5nIG5lZWRlZFxuXHRcdFx0Y2FzZSA0OiAvLyBCb29sXG5cdFx0XHRcdHJldHVybiAoKSA9PiBuZXcgVXBsY0Jvb2woU2l0ZS5kdW1teSgpLCB0aGlzLnJlYWRCaXRzKDEpID09IDEpO1xuXHRcdFx0Y2FzZSA1OlxuXHRcdFx0Y2FzZSA2OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGUgdGFnIHdpdGhvdXQgdHlwZSBhcHBsaWNhdGlvblwiKTtcblx0XHRcdGNhc2UgNzpcblx0XHRcdFx0bGV0IGNvbnRhaW5lclR5cGUgPSBhc3NlcnREZWZpbmVkKHR5cGVMaXN0LnNoaWZ0KCkpO1xuXHRcdFx0XHRpZiAoY29udGFpbmVyVHlwZSA9PSA1KSB7XG5cdFx0XHRcdFx0Ly8gdHlwZUxpc3QgaXMgY29uc3VtZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLCBzbyBtYWtlIHN1cmUgdG8gcmVhZCBpdCBiZWZvcmUhXG5cdFx0XHRcdFx0Y29uc3QgbGlzdFR5cGUgPSBVcGxjVHlwZS5mcm9tTnVtYmVycyh0eXBlTGlzdCk7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZVJlYWRlciA9IHRoaXMuY29uc3RydWN0VHlwZWRSZWFkZXIodHlwZUxpc3QpO1xuXG5cdFx0XHRcdFx0cmV0dXJuICgpID0+IG5ldyBVcGxjTGlzdChTaXRlLmR1bW15KCksIGxpc3RUeXBlLCB0aGlzLnJlYWRMaXN0KHR5cGVSZWFkZXIpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhc3NlcnRFcShjb250YWluZXJUeXBlLCA3LCBcIlVuZXhwZWN0ZWQgdHlwZSB0YWdcIik7XG5cdFx0XHRcdFx0Y29udGFpbmVyVHlwZSA9IGFzc2VydERlZmluZWQodHlwZUxpc3Quc2hpZnQoKSk7XG5cdFx0XHRcdFx0aWYgKGNvbnRhaW5lclR5cGUgPT0gNikge1xuXHRcdFx0XHRcdFx0Ly8gdHlwZUxpc3QgaXMgY29uc3VtZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLCBzbyBtYWtlIHN1cmUgdG8gcmVhZCBpdCBpbiBjb3JyZWN0IG9yZGVyIVxuXHRcdFx0XHRcdFx0Y29uc3QgbGVmdFJlYWRlciA9IHRoaXMuY29uc3RydWN0VHlwZWRSZWFkZXIodHlwZUxpc3QpO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRSZWFkZXIgPSB0aGlzLmNvbnN0cnVjdFR5cGVkUmVhZGVyKHR5cGVMaXN0KTtcblx0XHRcdFx0XHRcdHJldHVybiAoKSA9PiBuZXcgVXBsY1BhaXIoU2l0ZS5kdW1teSgpLCBsZWZ0UmVhZGVyKCksIHJpZ2h0UmVhZGVyKCkpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIDg6XG5cdFx0XHRcdHJldHVybiAoKSA9PiBuZXcgVXBsY0RhdGFWYWx1ZShTaXRlLmR1bW15KCksIHRoaXMucmVhZERhdGEoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBjb25zdGFudCB0eXBlICR7dHlwZS50b1N0cmluZygpfWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhIGRlbGF5IHRlcm1cblx0ICogQHJldHVybnMge1VwbGNEZWxheX1cblx0ICovXG5cdHJlYWREZWxheSgpIHtcblx0XHRsZXQgZXhwciA9IHRoaXMucmVhZFRlcm0oKTtcblxuXHRcdHJldHVybiBuZXcgVXBsY0RlbGF5KFNpdGUuZHVtbXkoKSwgZXhwcik7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBmb3JjZSB0ZXJtXG5cdCAqIEByZXR1cm5zIHtVcGxjRm9yY2V9XG5cdCAqL1xuXHRyZWFkRm9yY2UoKSB7XG5cdFx0bGV0IGV4cHIgPSB0aGlzLnJlYWRUZXJtKCk7XG5cblx0XHRyZXR1cm4gbmV3IFVwbGNGb3JjZShTaXRlLmR1bW15KCksIGV4cHIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGEgYnVpbHRpbiBmdW5jdGlvbiByZWYgdGVybVxuXHQgKiBAcmV0dXJucyB7VXBsY0J1aWx0aW59XG5cdCAqL1xuXHRyZWFkQnVpbHRpbigpIHtcblx0XHRsZXQgaWQgPSB0aGlzLnJlYWRCaXRzKHRoaXMudGFnV2lkdGgoXCJidWlsdGluXCIpKTtcblxuXHRcdGxldCBuYW1lID0gdGhpcy5idWlsdGluTmFtZShpZCk7XG5cblx0XHRyZXR1cm4gbmV3IFVwbGNCdWlsdGluKFNpdGUuZHVtbXkoKSwgbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogTW92ZSB0byB0aGUgbmV4dCBieXRlYm91bmRhcnlcblx0ICogKGFuZCBjaGVjayB0aGF0IHdlIGFyZSBhdCB0aGUgZW5kKVxuXHQgKi9cblx0ZmluYWxpemUoKSB7XG5cdFx0dGhpcy5tb3ZlVG9CeXRlQm91bmRhcnkodHJ1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcbiAqIEByZXR1cm5zIHtVcGxjUHJvZ3JhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplVXBsY0J5dGVzKGJ5dGVzKSB7XG5cdGxldCByZWFkZXIgPSBuZXcgVXBsY0Rlc2VyaWFsaXplcihieXRlcyk7XG5cblx0bGV0IHZlcnNpb24gPSBbXG5cdFx0cmVhZGVyLnJlYWRJbnRlZ2VyKCksXG5cdFx0cmVhZGVyLnJlYWRJbnRlZ2VyKCksXG5cdFx0cmVhZGVyLnJlYWRJbnRlZ2VyKCksXG5cdF07XG5cblx0bGV0IHZlcnNpb25LZXkgPSB2ZXJzaW9uLm1hcCh2ID0+IHYudG9TdHJpbmcoKSkuam9pbihcIi5cIik7XG5cblx0aWYgKHZlcnNpb25LZXkgIT0gVVBMQ19WRVJTSU9OKSB7XG5cdFx0Y29uc29sZS5lcnJvcihgV2FybmluZzogUGx1dHVzLWNvcmUgc2NyaXB0IGRvZXNuJ3QgbWF0Y2ggdmVyc2lvbiBvZiBIZWxpb3MgKGV4cGVjdGVkICR7VVBMQ19WRVJTSU9OfSwgZ290ICR7dmVyc2lvbktleX0pYCk7XG5cdH1cblxuXHRsZXQgZXhwciA9IHJlYWRlci5yZWFkVGVybSgpO1xuXG5cdHJlYWRlci5maW5hbGl6ZSgpO1xuXG5cdHJldHVybiBuZXcgVXBsY1Byb2dyYW0oZXhwciwgbnVsbCwgdmVyc2lvbik7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgcGx1dHVzIGNvcmUgcHJvZ3JhbS4gUmV0dXJucyBhIFVwbGNQcm9ncmFtIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25TdHJpbmcgXG4gKiBAcmV0dXJucyB7VXBsY1Byb2dyYW19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVVwbGMoanNvblN0cmluZykge1xuXHRsZXQgb2JqID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcblxuXHRpZiAoIShcImNib3JIZXhcIiBpbiBvYmopKSB7XG5cdFx0dGhyb3cgVXNlckVycm9yLnN5bnRheEVycm9yKG5ldyBTb3VyY2UoanNvblN0cmluZyksIDAsIDEsIFwiY2JvckhleCBmaWVsZCBub3QgaW4ganNvblwiKVxuXHR9XG5cblx0bGV0IGNib3JIZXggPSBvYmouY2JvckhleDtcblx0aWYgKHR5cGVvZiBjYm9ySGV4ICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0bGV0IHNyYyA9IG5ldyBTb3VyY2UoanNvblN0cmluZyk7XG5cdFx0bGV0IHJlID0gL2Nib3JIZXgvO1xuXHRcdGxldCBjYm9ySGV4TWF0Y2ggPSBqc29uU3RyaW5nLm1hdGNoKHJlKTtcblx0XHRpZiAoY2JvckhleE1hdGNoID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBVc2VyRXJyb3Iuc3ludGF4RXJyb3Ioc3JjLCAwLCAxLCBcIidjYm9ySGV4JyBrZXkgbm90IGZvdW5kXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBwb3MgPSBqc29uU3RyaW5nLnNlYXJjaChyZSlcblx0XHRcdHRocm93IFVzZXJFcnJvci5zeW50YXhFcnJvcihzcmMsIHBvcywgcG9zKzEsIFwiY2JvckhleCBub3QgYSBzdHJpbmdcIik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFVwbGNQcm9ncmFtLmZyb21DYm9yKGhleFRvQnl0ZXMoY2JvckhleCkpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAxMjogVG9rZW5pemF0aW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIFRva2VuaXplciB7XG5cdCNzcmM7XG5cdCNwb3M7XG5cblx0LyoqXG5cdCAqIFRva2VucyBhcmUgYWNjdW11bGF0ZWQgaW4gJyN0cydcblx0ICogQHR5cGUge1Rva2VuW119IFxuXHQgKi9cblx0I3RzO1xuXHQjY29kZU1hcDtcblx0I2NvZGVNYXBQb3M7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U291cmNlfSBzcmMgXG5cdCAqIEBwYXJhbSB7P0NvZGVNYXB9IGNvZGVNYXAgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzcmMsIGNvZGVNYXAgPSBudWxsKSB7XG5cdFx0YXNzZXJ0KHNyYyBpbnN0YW5jZW9mIFNvdXJjZSk7XG5cblx0XHR0aGlzLiNzcmMgPSBzcmM7XG5cdFx0dGhpcy4jcG9zID0gMDtcblx0XHR0aGlzLiN0cyA9IFtdOyAvLyByZXNldCB0byBlbXB0eSB0byBsaXN0IGF0IHN0YXJ0IG9mIHRva2VuaXplKClcblx0XHR0aGlzLiNjb2RlTWFwID0gY29kZU1hcDsgLy8gY2FuIGJlIGEgbGlzdCBvZiBwYWlycyBbcG9zLCBzaXRlIGluIGFub3RoZXIgc291cmNlXVxuXHRcdHRoaXMuI2NvZGVNYXBQb3MgPSAwOyAvLyBub3QgdXNlZCBpZiBjb2RlTWFwID09PSBudWxsXG5cdH1cblxuXHRpbmNyUG9zKCkge1xuXHRcdHRoaXMuI3BvcyArPSAxO1xuXHR9XG5cblx0ZGVjclBvcygpIHtcblx0XHR0aGlzLiNwb3MgLT0gMTtcblx0XHRhc3NlcnQodGhpcy4jcG9zID49IDApO1xuXHR9XG5cblx0Z2V0IGN1cnJlbnRTaXRlKCkge1xuXHRcdHJldHVybiBuZXcgU2l0ZSh0aGlzLiNzcmMsIHRoaXMuI3Bvcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUb2tlbn0gdCBcblx0ICovXG5cdHB1c2hUb2tlbih0KSB7XG5cdFx0dGhpcy4jdHMucHVzaCh0KTtcblxuXHRcdGlmICh0aGlzLiNjb2RlTWFwICE9PSBudWxsICYmIHRoaXMuI2NvZGVNYXBQb3MgPCB0aGlzLiNjb2RlTWFwLmxlbmd0aCkge1xuXHRcdFx0bGV0IHBhaXIgPSAodGhpcy4jY29kZU1hcFt0aGlzLiNjb2RlTWFwUG9zXSk7XG5cblx0XHRcdGlmIChwYWlyWzBdID09IHQuc2l0ZS5zdGFydFBvcykge1xuXHRcdFx0XHR0LnNpdGUuc2V0Q29kZU1hcFNpdGUocGFpclsxXSk7XG5cdFx0XHRcdHRoaXMuI2NvZGVNYXBQb3MgKz0gMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgYSBzaW5nbGUgY2hhciBmcm9tIHRoZSBzb3VyY2UgYW5kIGFkdmFuY2VzICNwb3MgYnkgb25lXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRyZWFkQ2hhcigpIHtcblx0XHRhc3NlcnQodGhpcy4jcG9zID49IDApO1xuXG5cdFx0bGV0IGM7XG5cdFx0aWYgKHRoaXMuI3BvcyA8IHRoaXMuI3NyYy5sZW5ndGgpIHtcblx0XHRcdGMgPSB0aGlzLiNzcmMuZ2V0Q2hhcih0aGlzLiNwb3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjID0gJ1xcMCc7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbmNyUG9zKCk7XG5cblx0XHRyZXR1cm4gYztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNyZWFzZXMgI3BvcyBieSBvbmVcblx0ICovXG5cdHVucmVhZENoYXIoKSB7XG5cdFx0dGhpcy5kZWNyUG9zKCk7XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnQgcmVhZGluZyBwcmVjaXNlbHkgb25lIHRva2VuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGMgXG5cdCAqL1xuXHRyZWFkVG9rZW4oc2l0ZSwgYykge1xuXHRcdGlmIChjID09ICdfJyB8fCAoYyA+PSAnQScgJiYgYyA8PSAnWicpIHx8IChjID49ICdhJyAmJiBjIDw9ICd6JykpIHtcblx0XHRcdHRoaXMucmVhZFdvcmQoc2l0ZSwgYyk7XG5cdFx0fSBlbHNlIGlmIChjID09ICcvJykge1xuXHRcdFx0dGhpcy5yZWFkTWF5YmVDb21tZW50KHNpdGUpO1xuXHRcdH0gZWxzZSBpZiAoYyA9PSAnMCcpIHtcblx0XHRcdHRoaXMucmVhZFNwZWNpYWxJbnRlZ2VyKHNpdGUpO1xuXHRcdH0gZWxzZSBpZiAoYyA+PSAnMScgJiYgYyA8PSAnOScpIHtcblx0XHRcdHRoaXMucmVhZERlY2ltYWxJbnRlZ2VyKHNpdGUsIGMpO1xuXHRcdH0gZWxzZSBpZiAoYyA9PSAnIycpIHtcblx0XHRcdHRoaXMucmVhZEJ5dGVBcnJheShzaXRlKTtcblx0XHR9IGVsc2UgaWYgKGMgPT0gJ1wiJykge1xuXHRcdFx0dGhpcy5yZWFkU3RyaW5nKHNpdGUpO1xuXHRcdH0gZWxzZSBpZiAoYyA9PSAnPycgfHwgYyA9PSAnIScgfHwgYyA9PSAnJScgfHwgYyA9PSAnJicgfHwgKGMgPj0gJygnICYmIGMgPD0gJy4nKSB8fCAoYyA+PSAnOicgJiYgYyA8PSAnPicpIHx8IGMgPT0gJ1snIHx8IGMgPT0gJ10nIHx8IChjID49ICd7JyAmJiBjIDw9ICd9JykpIHtcblx0XHRcdHRoaXMucmVhZFN5bWJvbChzaXRlLCBjKTtcblx0XHR9IGVsc2UgaWYgKCEoYyA9PSAnICcgfHwgYyA9PSAnXFxuJyB8fCBjID09ICdcXHQnIHx8IGMgPT0gJ1xccicpKSB7XG5cdFx0XHRzaXRlLnN5bnRheEVycm9yKGBpbnZhbGlkIHNvdXJjZSBjaGFyYWN0ZXIgJyR7Y30nICh1dGYtOCBub3QgeWV0IHN1cHBvcnRlZCBvdXRzaWRlIHN0cmluZyBsaXRlcmFscylgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVG9rZW5pemUgdGhlIGNvbXBsZXRlIHNvdXJjZS5cblx0ICogTmVzdHMgZ3JvdXBzIGJlZm9yZSByZXR1cm5pbmcgYSBsaXN0IG9mIHRva2Vuc1xuXHQgKiBAcmV0dXJucyB7VG9rZW5bXSB8IG51bGx9XG5cdCAqL1xuXHR0b2tlbml6ZSgpIHtcblx0XHQvLyByZXNldCAjdHNcblx0XHR0aGlzLiN0cyA9IFtdO1xuXG5cdFx0bGV0IHNpdGUgPSB0aGlzLmN1cnJlbnRTaXRlO1xuXHRcdGxldCBjID0gdGhpcy5yZWFkQ2hhcigpO1xuXG5cdFx0d2hpbGUgKGMgIT0gJ1xcMCcpIHtcblx0XHRcdHRoaXMucmVhZFRva2VuKHNpdGUsIGMpO1xuXG5cdFx0XHRzaXRlID0gdGhpcy5jdXJyZW50U2l0ZTtcblx0XHRcdGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubmVzdEdyb3Vwcyh0aGlzLiN0cyk7XG5cdH1cblxuXHQvKiogXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3Jcblx0ICogVXNlIGdlbi5uZXh0KCkudmFsdWUgdG8gYWNjZXNzIHRvIHRoZSBuZXh0IFRva2VuXG5cdCAqIERvZXNuJ3QgcGVyZm9ybSBhbnkgZ3JvdXBpbmdcblx0ICogVXNlZCBmb3IgcXVpY2tseSBwYXJzaW5nIHRoZSBTY3JpcHRQdXJwb3NlIGhlYWRlciBvZiBhIHNjcmlwdFxuXHQgKiBAcmV0dXJucyB7R2VuZXJhdG9yPFRva2VuPn1cblx0ICovXG5cdCpzdHJlYW1Ub2tlbnMoKSB7XG5cdFx0dGhpcy4jdHMgPSBbXTtcblxuXHRcdGxldCBzaXRlID0gdGhpcy5jdXJyZW50U2l0ZTtcblx0XHRsZXQgYyA9IHRoaXMucmVhZENoYXIoKTtcblxuXHRcdHdoaWxlIChjICE9ICdcXDAnKSB7XG5cdFx0XHR0aGlzLnJlYWRUb2tlbihzaXRlLCBjKTtcblxuXHRcdFx0bGV0IHQgPSB0aGlzLiN0cy5zaGlmdCgpO1xuXHRcdFx0d2hpbGUgKHQgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHlpZWxkIHQ7XG5cdFx0XHRcdHQgPSB0aGlzLiN0cy5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzaXRlID0gdGhpcy5jdXJyZW50U2l0ZTtcblx0XHRcdGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cdFx0fVxuXG5cdFx0YXNzZXJ0KHRoaXMuI3RzLmxlbmd0aCA9PSAwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBvbmUgd29yZCB0b2tlbi5cblx0ICogSW1tZWRpYXRlbHkgdHVybnMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiIGludG8gYSBCb29sTGl0ZXJhbCBpbnN0ZWFkIG9mIGtlZXBpbmcgaXQgYXMgV29yZFxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGMwIC0gZmlyc3QgY2hhcmFjdGVyIFxuXHQgKi9cblx0cmVhZFdvcmQoc2l0ZSwgYzApIHtcblx0XHRsZXQgY2hhcnMgPSBbXTtcblxuXHRcdGxldCBjID0gYzA7XG5cdFx0d2hpbGUgKGMgIT0gJ1xcMCcpIHtcblx0XHRcdGlmIChjID09ICdfJyB8fCAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHx8IChjID49ICdBJyAmJiBjIDw9ICdaJykgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSkge1xuXHRcdFx0XHRjaGFycy5wdXNoKGMpO1xuXHRcdFx0XHRjID0gdGhpcy5yZWFkQ2hhcigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy51bnJlYWRDaGFyKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB2YWx1ZSA9IGNoYXJzLmpvaW4oJycpO1xuXG5cdFx0aWYgKHZhbHVlID09IFwidHJ1ZVwiIHx8IHZhbHVlID09IFwiZmFsc2VcIikge1xuXHRcdFx0dGhpcy5wdXNoVG9rZW4oXG5cdFx0XHRcdG5ldyBCb29sTGl0ZXJhbChcblx0XHRcdFx0XHRuZXcgU2l0ZShzaXRlLnNyYywgc2l0ZS5zdGFydFBvcywgdGhpcy5jdXJyZW50U2l0ZS5zdGFydFBvcyksXG5cdFx0XHRcdFx0dmFsdWUgPT0gXCJ0cnVlXCJcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wdXNoVG9rZW4oXG5cdFx0XHRcdG5ldyBXb3JkKFxuXHRcdFx0XHRcdG5ldyBTaXRlKHNpdGUuc3JjLCBzaXRlLnN0YXJ0UG9zLCB0aGlzLmN1cnJlbnRTaXRlLnN0YXJ0UG9zKSxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhbmQgZGlzY2FyZHMgYSBjb21tZW50IGlmIGN1cnJlbnQgJy8nIGNoYXIgaXMgZm9sbG93ZWQgYnkgJy8nIG9yICcqJy5cblx0ICogT3RoZXJ3aXNlIHB1c2hlcyBTeW1ib2woJy8nKSBvbnRvICN0c1xuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqL1xuXHQvLyBjb21tZW50cyBhcmUgZGlzY2FyZGVkXG5cdHJlYWRNYXliZUNvbW1lbnQoc2l0ZSkge1xuXHRcdGxldCBjID0gdGhpcy5yZWFkQ2hhcigpO1xuXG5cdFx0aWYgKGMgPT0gJ1xcMCcpIHtcblx0XHRcdHRoaXMucHVzaFRva2VuKG5ldyBTeW1ib2xUb2tlbihzaXRlLCAnLycpKTtcblx0XHR9IGVsc2UgaWYgKGMgPT0gJy8nKSB7XG5cdFx0XHR0aGlzLnJlYWRTaW5nbGVMaW5lQ29tbWVudCgpO1xuXHRcdH0gZWxzZSBpZiAoYyA9PSAnKicpIHtcblx0XHRcdHRoaXMucmVhZE11bHRpTGluZUNvbW1lbnQoc2l0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHVzaFRva2VuKG5ldyBTeW1ib2xUb2tlbihzaXRlLCAnLycpKTtcblx0XHRcdHRoaXMudW5yZWFkQ2hhcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhbmQgZGlzY2FyZHMgYSBzaW5nbGUgbGluZSBjb21tZW50IChmcm9tICcvLycgdG8gZW5kLW9mLWxpbmUpXG5cdCAqL1xuXHRyZWFkU2luZ2xlTGluZUNvbW1lbnQoKSB7XG5cdFx0bGV0IGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cblx0XHR3aGlsZSAoYyAhPSAnXFxuJyAmJiBjICE9ICdcXDAnKSB7XG5cdFx0XHRjID0gdGhpcy5yZWFkQ2hhcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyBhbmQgZGlzY2FyZHMgYSBtdWx0aS1saW5lIGNvbW1lbnQgKGZyb20gJy8nICcqJyB0byAnKicgJy8nKVxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqL1xuXHRyZWFkTXVsdGlMaW5lQ29tbWVudChzaXRlKSB7XG5cdFx0bGV0IHByZXYgPSAnJztcblx0XHRsZXQgYyA9IHRoaXMucmVhZENoYXIoKTtcblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRwcmV2ID0gYztcblx0XHRcdGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cblx0XHRcdGlmIChjID09ICcvJyAmJiBwcmV2ID09ICcqJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSBpZiAoYyA9PSAnXFwwJykge1xuXHRcdFx0XHRjb25zdCBlcnJvclNpdGUgPSBuZXcgU2l0ZShzaXRlLnNyYywgc2l0ZS5zdGFydFBvcywgdGhpcy5jdXJyZW50U2l0ZS5zdGFydFBvcyk7XG5cdFx0XHRcdGVycm9yU2l0ZS5zeW50YXhFcnJvcihcInVudGVybWluYXRlZCBtdWx0aWxpbmUgY29tbWVudFwiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSRWFkcyBhIGxpdGVyYWwgaW50ZWdlclxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqL1xuXHRyZWFkU3BlY2lhbEludGVnZXIoc2l0ZSkge1xuXHRcdGxldCBjID0gdGhpcy5yZWFkQ2hhcigpO1xuXG5cdFx0aWYgKGMgPT0gJ1xcMCcpIHtcblx0XHRcdHRoaXMucHVzaFRva2VuKG5ldyBJbnRMaXRlcmFsKHNpdGUsIDBuKSk7XG5cdFx0fSBlbHNlIGlmIChjID09ICdiJykge1xuXHRcdFx0dGhpcy5yZWFkQmluYXJ5SW50ZWdlcihzaXRlKTtcblx0XHR9IGVsc2UgaWYgKGMgPT0gJ28nKSB7XG5cdFx0XHR0aGlzLnJlYWRPY3RhbEludGVnZXIoc2l0ZSk7XG5cdFx0fSBlbHNlIGlmIChjID09ICd4Jykge1xuXHRcdFx0dGhpcy5yZWFkSGV4SW50ZWdlcihzaXRlKTtcblx0XHR9IGVsc2UgaWYgKChjID49ICdBJyAmJiBjIDw9ICdaJykgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSkge1xuXHRcdFx0c2l0ZS5zeW50YXhFcnJvcihgYmFkIGxpdGVyYWwgaW50ZWdlciB0eXBlIDAke2N9YCk7XG5cdFx0fSBlbHNlIGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xuXHRcdFx0dGhpcy5yZWFkRGVjaW1hbEludGVnZXIoc2l0ZSwgYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHVzaFRva2VuKG5ldyBJbnRMaXRlcmFsKHNpdGUsIDBuKSk7XG5cdFx0XHR0aGlzLnVucmVhZENoYXIoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKi9cblx0cmVhZEJpbmFyeUludGVnZXIoc2l0ZSkge1xuXHRcdHRoaXMucmVhZFJhZGl4SW50ZWdlcihzaXRlLCBcIjBiXCIsIGMgPT4gKGMgPT0gJzAnIHx8IGMgPT0gJzEnKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKi9cblx0cmVhZE9jdGFsSW50ZWdlcihzaXRlKSB7XG5cdFx0dGhpcy5yZWFkUmFkaXhJbnRlZ2VyKHNpdGUsIFwiMG9cIiwgYyA9PiAoYyA+PSAnMCcgJiYgYyA8PSAnNycpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqL1xuXHRyZWFkSGV4SW50ZWdlcihzaXRlKSB7XG5cdFx0dGhpcy5yZWFkUmFkaXhJbnRlZ2VyKHNpdGUsIFwiMHhcIixcblx0XHRcdGMgPT4gKChjID49ICcwJyAmJiBjIDw9ICc5JykgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ2YnKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGMwIC0gZmlyc3QgY2hhcmFjdGVyXG5cdCAqL1xuXHRyZWFkRGVjaW1hbEludGVnZXIoc2l0ZSwgYzApIHtcblx0XHRsZXQgY2hhcnMgPSBbXTtcblxuXHRcdGxldCBjID0gYzA7XG5cdFx0d2hpbGUgKGMgIT0gJ1xcMCcpIHtcblx0XHRcdGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xuXHRcdFx0XHRjaGFycy5wdXNoKGMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKChjID49ICcwJyAmJiBjIDw9ICc5JykgfHwgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fCAoYyA+PSAnYScgJiYgYyA8PSAneicpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZXJyb3JTaXRlID0gbmV3IFNpdGUoc2l0ZS5zcmMsIHNpdGUuc3RhcnRQb3MsIHRoaXMuY3VycmVudFNpdGUuc3RhcnRQb3MpO1xuXG5cdFx0XHRcdFx0ZXJyb3JTaXRlLnN5bnRheEVycm9yKFwiaW52YWxpZCBzeW50YXggZm9yIGRlY2ltYWwgaW50ZWdlciBsaXRlcmFsXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy51bnJlYWRDaGFyKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjID0gdGhpcy5yZWFkQ2hhcigpO1xuXHRcdH1cblxuXHRcdHRoaXMucHVzaFRva2VuKFxuXHRcdFx0bmV3IEludExpdGVyYWwoXG5cdFx0XHRcdG5ldyBTaXRlKHNpdGUuc3JjLCBzaXRlLnN0YXJ0UG9zLCB0aGlzLmN1cnJlbnRTaXRlLnN0YXJ0UG9zKSxcblx0XHRcdFx0QmlnSW50KGNoYXJzLmpvaW4oJycpKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFxuXHQgKiBAcGFyYW0geyhjOiBzdHJpbmcpID0+IGJvb2xlYW59IHZhbGlkIC0gY2hlY2tzIGlmIGNoYXJhY3RlciBpcyB2YWxpZCBhcyBwYXJ0IG9mIHRoZSByYWRpeFxuXHQgKi9cblx0cmVhZFJhZGl4SW50ZWdlcihzaXRlLCBwcmVmaXgsIHZhbGlkKSB7XG5cdFx0bGV0IGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cblx0XHRsZXQgY2hhcnMgPSBbXTtcblxuXHRcdGlmICghKHZhbGlkKGMpKSkge1xuXHRcdFx0Y29uc3QgZXJyb3JTaXRlID0gbmV3IFNpdGUoc2l0ZS5zcmMsIHNpdGUuc3RhcnRQb3MsIHRoaXMuY3VycmVudFNpdGUuc3RhcnRQb3MpO1xuXG5cdFx0XHRlcnJvclNpdGUuc3ludGF4RXJyb3IoYGV4cGVjdGVkIGF0IGxlYXN0IG9uZSBjaGFyIGZvciAke3ByZWZpeH0gaW50ZWdlciBsaXRlcmFsYCk7XG5cblx0XHRcdHRoaXMudW5yZWFkQ2hhcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoaWxlIChjICE9ICdcXDAnKSB7XG5cdFx0XHRpZiAodmFsaWQoYykpIHtcblx0XHRcdFx0Y2hhcnMucHVzaChjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHx8IChjID49ICdBJyAmJiBjIDw9ICdaJykgfHwgKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSkge1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yU2l0ZSA9IG5ldyBTaXRlKHNpdGUuc3JjLCBzaXRlLnN0YXJ0UG9zLCB0aGlzLmN1cnJlbnRTaXRlLnN0YXJ0UG9zKTtcblxuXHRcdFx0XHRcdGVycm9yU2l0ZS5zeW50YXhFcnJvcihgaW52YWxpZCBzeW50YXggZm9yICR7cHJlZml4fSBpbnRlZ2VyIGxpdGVyYWxgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudW5yZWFkQ2hhcigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0YyA9IHRoaXMucmVhZENoYXIoKTtcblx0XHR9XG5cblx0XHR0aGlzLnB1c2hUb2tlbihcblx0XHRcdG5ldyBJbnRMaXRlcmFsKFxuXHRcdFx0XHRuZXcgU2l0ZShzaXRlLnNyYywgc2l0ZS5zdGFydFBvcywgdGhpcy5jdXJyZW50U2l0ZS5zdGFydFBvcyksXG5cdFx0XHRcdEJpZ0ludChwcmVmaXggKyBjaGFycy5qb2luKCcnKSlcblx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGxpdGVyYWwgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgQnl0ZUFycmF5XG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdHJlYWRCeXRlQXJyYXkoc2l0ZSkge1xuXHRcdGxldCBjID0gdGhpcy5yZWFkQ2hhcigpO1xuXG5cdFx0bGV0IGNoYXJzID0gW107XG5cblx0XHQvLyBjYXNlIGRvZXNuJ3QgbWF0dGVyXG5cdFx0d2hpbGUgKChjID49ICdhJyAmJiBjIDw9ICdmJykgfHwgKGMgPj0gJzAnICYmIGMgPD0gJzknKSkge1xuXHRcdFx0Y2hhcnMucHVzaChjKTtcblx0XHRcdGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cdFx0fVxuXG5cdFx0Ly8gZW1wdHkgYnl0ZUFycmF5IGlzIGFsbG93ZWQgKGVnLiBmb3IgQWRhIG1pbnRpbmdQb2xpY3lIYXNoKVxuXG5cdFx0Ly8gbGFzdCBjaGFyIGlzIHRoZSBvbmUgdGhhdCBtYWRlIHRoZSB3aGlsZSBsb29wIGJyZWFrLCBzbyBzaG91bGQgYmUgdW5yZWFkXG5cdFx0dGhpcy51bnJlYWRDaGFyKCk7XG5cblx0XHRsZXQgYnl0ZXMgPSBoZXhUb0J5dGVzKGNoYXJzLmpvaW4oJycpKTtcblxuXHRcdHRoaXMucHVzaFRva2VuKFxuXHRcdFx0bmV3IEJ5dGVBcnJheUxpdGVyYWwoXG5cdFx0XHRcdG5ldyBTaXRlKHNpdGUuc3JjLCBzaXRlLnN0YXJ0UG9zLCB0aGlzLmN1cnJlbnRTaXRlLnN0YXJ0UG9zKSxcblx0XHRcdFx0Ynl0ZXNcblx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWRzIGxpdGVyYWwgc3RyaW5nIGRlbGltaXRlZCBieSBkb3VibGUgcXVvdGVzLlxuXHQgKiBBbGxvd3MgZm9yIHRocmVlIGVzY2FwZSBjaGFyYWN0ZXI6ICdcXFxcJywgJ1xcbicgYW5kICdcXHQnXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICovXG5cdHJlYWRTdHJpbmcoc2l0ZSkge1xuXHRcdGxldCBjID0gdGhpcy5yZWFkQ2hhcigpO1xuXG5cdFx0bGV0IGNoYXJzID0gW107XG5cblx0XHRsZXQgZXNjYXBpbmcgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUgez9TaXRlfSAqL1xuXHRcdGxldCBlc2NhcGVTaXRlID0gbnVsbDsgLy8gZm9yIGVzY2FwZSBzeW50YXggZXJyb3JzXG5cblx0XHR3aGlsZSAoISghZXNjYXBpbmcgJiYgYyA9PSAnXCInKSkge1xuXHRcdFx0aWYgKGMgPT0gJ1xcMCcpIHtcblx0XHRcdFx0c2l0ZS5zeW50YXhFcnJvcihcInVubWF0Y2hlZCAnXFxcIidcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXNjYXBpbmcpIHtcblx0XHRcdFx0aWYgKGMgPT0gJ24nKSB7XG5cdFx0XHRcdFx0Y2hhcnMucHVzaCgnXFxuJyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PSAndCcpIHtcblx0XHRcdFx0XHRjaGFycy5wdXNoKCdcXHQnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjID09ICdcXFxcJykge1xuXHRcdFx0XHRcdGNoYXJzLnB1c2goJ1xcXFwnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjID09ICdcIicpIHtcblx0XHRcdFx0XHRjaGFycy5wdXNoKGMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVzY2FwZVNpdGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCBlcnJvclNpdGUgPSBuZXcgU2l0ZShlc2NhcGVTaXRlLnNyYywgZXNjYXBlU2l0ZS5zdGFydFBvcywgdGhpcy5jdXJyZW50U2l0ZS5zdGFydFBvcyk7XG5cblx0XHRcdFx0XHRlcnJvclNpdGUuc3ludGF4RXJyb3IoYGludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7Y31gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlc2NhcGUgc2l0ZSBzaG91bGQgYmUgbm9uLW51bGxcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlc2NhcGluZyA9IGZhbHNlO1xuXHRcdFx0XHRlc2NhcGVTaXRlID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChjID09ICdcXFxcJykge1xuXHRcdFx0XHRcdGVzY2FwZVNpdGUgPSB0aGlzLmN1cnJlbnRTaXRlO1xuXHRcdFx0XHRcdGVzY2FwaW5nID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycy5wdXNoKGMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMgPSB0aGlzLnJlYWRDaGFyKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5wdXNoVG9rZW4oXG5cdFx0XHRuZXcgU3RyaW5nTGl0ZXJhbChcblx0XHRcdFx0bmV3IFNpdGUoc2l0ZS5zcmMsIHNpdGUuc3RhcnRQb3MsIHRoaXMuY3VycmVudFNpdGUuc3RhcnRQb3MpLFxuXHRcdFx0XHRjaGFycy5qb2luKCcnKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgc2luZ2xlIG9yIGRvdWJsZSBjaGFyYWN0ZXIgc3ltYm9sc1xuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjMCAtIGZpcnN0IGNoYXJhY3RlclxuXHQgKi9cblx0cmVhZFN5bWJvbChzaXRlLCBjMCkge1xuXHRcdGxldCBjaGFycyA9IFtjMF07XG5cblx0XHQvKiogQHR5cGUgeyhzZWNvbmQ6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cblx0XHRsZXQgcGFyc2VTZWNvbmRDaGFyID0gKHNlY29uZCkgPT4ge1xuXHRcdFx0bGV0IGQgPSB0aGlzLnJlYWRDaGFyKCk7XG5cblx0XHRcdGlmIChkID09IHNlY29uZCkge1xuXHRcdFx0XHRjaGFycy5wdXNoKGQpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudW5yZWFkQ2hhcigpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGMwID09ICd8Jykge1xuXHRcdFx0cGFyc2VTZWNvbmRDaGFyKCd8Jyk7XG5cdFx0fSBlbHNlIGlmIChjMCA9PSAnJicpIHtcblx0XHRcdHBhcnNlU2Vjb25kQ2hhcignJicpO1xuXHRcdH0gZWxzZSBpZiAoYzAgPT0gJz0nKSB7XG5cdFx0XHRpZiAoIXBhcnNlU2Vjb25kQ2hhcignPScpKSB7XG5cdFx0XHRcdHBhcnNlU2Vjb25kQ2hhcignPicpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoYzAgPT0gJyEnIHx8IGMwID09ICc8JyB8fCBjMCA9PSAnPicpIHsgLy8gY291bGQgYmUgIT0sID09LCA8PSBvciA+PVxuXHRcdFx0cGFyc2VTZWNvbmRDaGFyKCc9Jyk7XG5cdFx0fSBlbHNlIGlmIChjMCA9PSAnOicpIHtcblx0XHRcdHBhcnNlU2Vjb25kQ2hhcignOicpO1xuXHRcdH0gZWxzZSBpZiAoYzAgPT0gJy0nKSB7XG5cdFx0XHRwYXJzZVNlY29uZENoYXIoJz4nKTtcblx0XHR9XG5cblx0XHR0aGlzLnB1c2hUb2tlbihcblx0XHRcdG5ldyBTeW1ib2xUb2tlbihcblx0XHRcdFx0bmV3IFNpdGUoc2l0ZS5zcmMsIHNpdGUuc3RhcnRQb3MsIHNpdGUuZW5kUG9zKSxcblx0XHRcdFx0Y2hhcnMuam9pbignJylcblx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlcGFyYXRlcyB0b2tlbnMgaW4gZmllbGRzIChzZXBhcnRlZCBieSBjb21tYXMpXG5cdCAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG5cdCAqIEByZXR1cm5zIHtHcm91cCB8IG51bGx9XG5cdCAqL1xuXHRidWlsZEdyb3VwKHRzKSB7XG5cdFx0Y29uc3Qgb3BlbiA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0U3ltYm9sKCk7XG5cblx0XHRpZiAoIW9wZW4pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YWNrID0gW29wZW5dOyAvLyBzdGFjayBvZiBzeW1ib2xzXG5cdFx0bGV0IGN1ckZpZWxkID0gW107XG5cdFx0bGV0IGZpZWxkcyA9IFtdO1xuXG5cdFx0LyoqIEB0eXBlIHs/U3ltYm9sVG9rZW59ICovXG5cdFx0bGV0IGZpcnN0Q29tbWEgPSBudWxsO1xuXG5cdFx0LyoqIEB0eXBlIHs/U3ltYm9sVG9rZW59ICovXG5cdFx0bGV0IGxhc3RDb21tYSA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUgez9TaXRlfSAqL1xuXHRcdGxldCBlbmRTaXRlID0gbnVsbDtcblxuXHRcdHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IHQgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBvcGVuLnNpdGUpO1xuXG5cdFx0XHRpZiAoIXQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByZXYgPSBzdGFjay5wb3AoKTtcblxuXHRcdFx0ZW5kU2l0ZSA9IHQuc2l0ZTtcblxuXHRcdFx0aWYgKHQgIT0gdW5kZWZpbmVkICYmIHByZXYgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICghdC5pc1N5bWJvbChHcm91cC5tYXRjaFN5bWJvbChwcmV2KSkpIHtcblx0XHRcdFx0XHRzdGFjay5wdXNoKHByZXYpO1xuXG5cdFx0XHRcdFx0aWYgKEdyb3VwLmlzQ2xvc2VTeW1ib2wodCkpIHtcblx0XHRcdFx0XHRcdHQuc2l0ZS5zeW50YXhFcnJvcihgdW5tYXRjaGVkICcke2Fzc2VydERlZmluZWQodC5hc3NlcnRTeW1ib2woKSkudmFsdWV9J2ApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChHcm91cC5pc09wZW5TeW1ib2wodCkpIHtcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goYXNzZXJ0RGVmaW5lZCh0LmFzc2VydFN5bWJvbCgpKSk7XG5cdFx0XHRcdFx0XHRjdXJGaWVsZC5wdXNoKHQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodC5pc1N5bWJvbChcIixcIikgJiYgc3RhY2subGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHRcdGlmIChmaXJzdENvbW1hID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGZpcnN0Q29tbWEgPSB0LmFzc2VydFN5bWJvbCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsYXN0Q29tbWEgPSB0LmFzc2VydFN5bWJvbCgpO1xuXHRcdFx0XHRcdFx0aWYgKGN1ckZpZWxkLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHQuc2l0ZS5zeW50YXhFcnJvcihcImVtcHR5IGZpZWxkXCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZpZWxkcy5wdXNoKGN1ckZpZWxkKTtcblx0XHRcdFx0XHRcdFx0Y3VyRmllbGQgPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3VyRmllbGQucHVzaCh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGN1ckZpZWxkLnB1c2godCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGxhc3QgPSBzdGFjay5wb3AoKTtcblx0XHRpZiAobGFzdCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdGxhc3Quc3ludGF4RXJyb3IoYEVPRiB3aGlsZSBtYXRjaGluZyAnJHtsYXN0LnZhbHVlfSdgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjdXJGaWVsZC5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBhZGQgcmVtb3ZpbmcgZmllbGRcblx0XHRcdGZpZWxkcy5wdXNoKGN1ckZpZWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RDb21tYSAhPT0gbnVsbCkge1xuXHRcdFx0bGFzdENvbW1hLnN5bnRheEVycm9yKGB0cmFpbGluZyBjb21tYWApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBlZEZpZWxkcyA9IHJlZHVjZU51bGwoZmllbGRzLm1hcChmID0+IHRoaXMubmVzdEdyb3VwcyhmKSkpO1xuXG5cdFx0aWYgKCFncm91cGVkRmllbGRzKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgc2l0ZSA9IG9wZW4uc2l0ZTtcblxuXHRcdGlmIChlbmRTaXRlKSB7XG5cdFx0XHRzaXRlID0gc2l0ZS5tZXJnZShlbmRTaXRlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEdyb3VwKHNpdGUsIG9wZW4udmFsdWUsIGdyb3VwZWRGaWVsZHMsIGZpcnN0Q29tbWEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hdGNoIGdyb3VwIG9wZW4gd2l0aCBncm91cCBjbG9zZSBzeW1ib2xzIGluIG9yZGVyIHRvIGZvcm0gZ3JvdXBzLlxuXHQgKiBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGFwcGxpZWQgdG8gbmVzdGVkIGdyb3Vwcy5cblx0ICogQHBhcmFtIHtUb2tlbltdfSB0cyBcblx0ICogQHJldHVybnMge1Rva2VuW10gfCBudWxsfVxuXHQgKi9cblx0bmVzdEdyb3Vwcyh0cykge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHsoVG9rZW4gfCBudWxsKVtdfVxuXHRcdCAqL1xuXHRcdGxldCByZXMgPSBbXTtcblxuXHRcdGxldCB0ID0gdHMuc2hpZnQoKTtcblx0XHR3aGlsZSAodCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChHcm91cC5pc09wZW5TeW1ib2wodCkpIHtcblx0XHRcdFx0dHMudW5zaGlmdCh0KTtcblxuXHRcdFx0XHRyZXMucHVzaCh0aGlzLmJ1aWxkR3JvdXAodHMpKTtcblx0XHRcdH0gZWxzZSBpZiAoR3JvdXAuaXNDbG9zZVN5bWJvbCh0KSkge1xuXHRcdFx0XHR0LnN5bnRheEVycm9yKGB1bm1hdGNoZWQgJyR7YXNzZXJ0RGVmaW5lZCh0LmFzc2VydFN5bWJvbCgpKS52YWx1ZX0nYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMucHVzaCh0KTtcblx0XHRcdH1cblxuXHRcdFx0dCA9IHRzLnNoaWZ0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlZHVjZU51bGwocmVzKTtcblx0fVxufVxuXG4vKipcbiAqIFRva2VuaXplcyBhIHN0cmluZyAod3JhcHBlZCBpbiBTb3VyY2UpXG4gKiBBbHNvIHVzZWQgYnkgVlNDb2RlIHBsdWdpblxuICogQHBhcmFtIHtTb3VyY2V9IHNyYyBcbiAqIEByZXR1cm5zIHtUb2tlbltdIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuaXplKHNyYykge1xuXHRsZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzcmMpO1xuXG5cdHJldHVybiB0b2tlbml6ZXIudG9rZW5pemUoKTtcbn1cblxuLyoqXG4gKiBUb2tlbml6ZXMgYW4gSVIgc3RyaW5nIHdpdGggYSBjb2RlbWFwIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3U3JjIFxuICogQHBhcmFtIHtDb2RlTWFwfSBjb2RlTWFwIFxuICogQHJldHVybnMge1Rva2VuW119XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplSVIocmF3U3JjLCBjb2RlTWFwKSB7XG5cdGxldCBzcmMgPSBuZXcgU291cmNlKHJhd1NyYyk7XG5cblx0Ly8gdGhlIFRva2VuaXplciBmb3IgSGVsaW9zIGNhbiBzaW1wbHkgYmUgcmV1c2VkIGZvciB0aGUgSVJcblx0bGV0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoc3JjLCBjb2RlTWFwKTtcblxuXHRjb25zdCB0cyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuXG5cdGlmIChzcmMuZXJyb3JzLmxlbmd0aCA+IDApIHtcblx0XHR0aHJvdyBzcmMuZXJyb3JzWzBdO1xuXHR9IGVsc2UgaWYgKHRzID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwic2hvdWxkJ3ZlIGJlZW4gdGhyb3duIGFib3ZlXCIpO1xuXHR9XG5cblx0cmV0dXJuIHRzO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMTM6IEhlbGlvcyBldmFsIGVudGl0aWVzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFdlIGNhbid0IHVzZSBTdHJ1Y3RTdGF0ZW1lbnQgZXRjLiBkaXJlY3RseSBiZWNhdXNlIHRoYXQgd291bGQgZ2l2ZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5hbWU6IFdvcmQsXG4gKiAgIGdldFR5cGVNZW1iZXIoa2V5OiBXb3JkKTogRXZhbEVudGl0eSxcbiAqICAgZ2V0SW5zdGFuY2VNZW1iZXIoa2V5OiBXb3JkKTogSW5zdGFuY2UsXG4gKiAgIG5GaWVsZHMoc2l0ZTogU2l0ZSk6IG51bWJlcixcbiAqICAgaGFzRmllbGQoa2V5OiBXb3JkKTogYm9vbGVhbixcbiAqICAgZ2V0RmllbGRUeXBlKHNpdGU6IFNpdGUsIGk6IG51bWJlcik6IFR5cGUsXG4gKiBcdCBnZXRGaWVsZEluZGV4KHNpdGU6IFNpdGUsIG5hbWU6IHN0cmluZyk6IG51bWJlcixcbiAqICAgZ2V0RmllbGROYW1lKGk6IG51bWJlcik6IHN0cmluZyxcbiAqICAgZ2V0Q29uc3RySW5kZXgoc2l0ZTogU2l0ZSk6IG51bWJlcixcbiAqICAgbkVudW1NZW1iZXJzKHNpdGU6IFNpdGUpOiBudW1iZXIsXG4gKiAgIHBhdGg6IHN0cmluZyxcbiAqICAgdXNlOiAoKSA9PiB2b2lkXG4gKiB9fSBVc2VyVHlwZVN0YXRlbWVudFxuICovXG5cbi8qKlxuICogV2UgY2FuJ3QgdXNlIENvbnN0U3RhdGVtZW50IGRpcmVjdGx5IGJlY2F1c2UgdGhhdCB3b3VsZCBnaXZlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICogQHR5cGVkZWYge3tcbiAqICAgbmFtZTogV29yZCxcbiAqICAgcGF0aDogc3RyaW5nLFxuICogICB1c2U6ICgpID0+IHZvaWRcbiAqIH19IENvbnN0VHlwZVN0YXRlbWVudFxuICovXG5cbi8qKlxuICogV2UgY2FuJ3QgdXNlIEVudW1NZW1iZXIgZGlyZWN0bHkgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gKiBAdHlwZWRlZiB7VXNlclR5cGVTdGF0ZW1lbnQgJiB7XG4gKiBcdCBwYXJlbnQ6IEVudW1UeXBlU3RhdGVtZW50LFxuICogICBnZXRDb25zdHJJbmRleChzaXRlOiBTaXRlKTogbnVtYmVyXG4qICB9fSBFbnVtTWVtYmVyVHlwZVN0YXRlbWVudFxuICovXG5cbi8qKlxuICogV2UgY2FuJ3QgdXNlIEVudW1TdGF0ZW1lbnQgZGlyZWN0bHkgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gKiBAdHlwZWRlZiB7VXNlclR5cGVTdGF0ZW1lbnQgJiB7XG4gKiAgIHR5cGU6IFR5cGUsXG4gKiAgIG5FbnVtTWVtYmVycyhzaXRlOiBTaXRlKTogbnVtYmVyLFxuICogICBnZXRFbnVtTWVtYmVyKHNpdGU6IFNpdGUsIGk6IG51bWJlcik6IEVudW1NZW1iZXJUeXBlU3RhdGVtZW50XG4gKiB9fSBFbnVtVHlwZVN0YXRlbWVudFxuICovXG5cbi8qKlxuICogV2UgY2FuJ3QgdXNlIEZ1bmNTdGF0ZW1lbnQgZGlyZWN0bHkgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gKiBAdHlwZWRlZiB7e1xuICogICBwYXRoOiBzdHJpbmcsXG4gKiAgIHVzZTogKCkgPT4gdm9pZCxcbiAqICAgc2V0UmVjdXJzaXZlOiAoKSA9PiB2b2lkLFxuICogICBpc1JlY3Vyc2l2ZTogKCkgPT4gYm9vbGVhblxuICogfX0gUmVjdXJzZWFibGVTdGF0ZW1lbnRcbiAqL1xuXG4vKipcbiAqIFdlIGNhbid0IHVzZSBTY29wZSBkaXJlY3RseSBiZWNhdXNlIHRoYXQgd291bGQgZ2l2ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzUmVjdXJzaXZlOiAoc3RhdGVtZW50OiBSZWN1cnNlYWJsZVN0YXRlbWVudCkgPT4gYm9vbGVhblxuICogfX0gUmVjdXJzaXZlbmVzc0NoZWNrZXJcbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgSW5zdGFuY2UgYW5kIFR5cGUuXG4gKiBBbnkgbWVtYmVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgJ3NpdGUnIGFzIGl0cyBmaXJzdCBhcmd1bWVudCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgdXNlZCBpbmNvcnJlY3RseSAoZWcuIGNhbGxpbmcgYSBub24tRnVuY1R5cGUpLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRXZhbEVudGl0eSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudXNlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRhc3NlcnRUeXBlKHNpdGUpIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcIm5vdCBhIHR5cGVcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1R5cGUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0YXNzZXJ0VmFsdWUoc2l0ZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwibm90IGEgdmFsdWVcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1ZhbHVlKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1VzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudXNlZF87XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBieSBTY29wZSB0byBtYXJrIG5hbWVkIFZhbHVlcy9UeXBlcyBhcyB1c2VkLlxuXHQgKiBBdCB0aGUgZW5kIG9mIHRoZSBTY29wZSBhbiBlcnJvciBpcyB0aHJvd24gaWYgYW55IG5hbWVkIFZhbHVlcy9UeXBlcyBhcmVuJ3QgdXNlZC5cblx0ICovXG5cdG1hcmtBc1VzZWQoKSB7XG5cdFx0dGhpcy51c2VkXyA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0eXBlIG9mIGEgdmFsdWUuIFRocm93cyBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdHlwZSBvZiB0eXBlLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRnZXRUeXBlKHNpdGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgJ3RydWUnIGlmICd0aGlzJyBpcyBhIGJhc2UtdHlwZSBvZiAndHlwZScuIFRocm93cyBhbiBlcnJvciBpZiAndGhpcycgaXNuJ3QgYSBUeXBlLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyAndHJ1ZScgaWYgJ3RoaXMnIGlzIGFuIGluc3RhbmNlIG9mICd0eXBlJy4gVGhyb3dzIGFuIGVycm9yIGlmICd0aGlzJyBpc24ndCBhIEluc3RhbmNlLlxuXHQgKiAndHlwZScgY2FuIGJlIGEgY2xhc3MsIG9yIGEgY2xhc3MgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlIHwgVHlwZUNsYXNzfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSW5zdGFuY2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZXR1cm4gdHlwZSBvZiBhIGZ1bmN0aW9uICh3cmFwcGVkIGFzIGEgSW5zdGFuY2UpIGlmIHRoZSBhcmdzIGhhdmUgdGhlIGNvcnJlY3QgdHlwZXMuIFxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgJ3RoaXMnIGlzbid0IGEgZnVuY3Rpb24gdmFsdWUsIG9yIGlmIHRoZSBhcmdzIGRvbid0IGNvcnJlc3BvbmQuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtJbnN0YW5jZVtdfSBhcmdzXG5cdCAqIEBwYXJhbSB7e1tuYW1lOiBzdHJpbmddOiBJbnN0YW5jZX19IG5hbWVkQXJnc1xuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRjYWxsKHNpdGUsIGFyZ3MsIG5hbWVkQXJncyA9IHt9KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgbWVtYmVyIG9mIGEgVHlwZSAoaS5lLiB0aGUgJzo6JyBvcGVyYXRvcikuXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWVtYmVyIGRvZXNuJ3QgZXhpc3Qgb3IgaWYgJ3RoaXMnIGlzbid0IGEgRGF0YVR5cGUuXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX0gLSBjYW4gYmUgSW5zdGFuY2Ugb3IgVHlwZVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgbWVtYmVyIG9mIGEgSW5zdGFuY2UgKGkuZS4gdGhlICcuJyBvcGVyYXRvcikuXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWVtYmVyIGRvZXNuJ3QgZXhpc3Qgb3IgaWYgJ3RoaXMnIGlzbid0IGEgRGF0YUluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWVcblx0ICogQHJldHVybnMge0luc3RhbmNlfSAtIGNhbiBiZSBGdW5jSW5zdGFuY2Ugb3IgRGF0YUluc3RhbmNlXG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZmllbGRzIGluIGEgc3RydWN0LlxuXHQgKiBVc2VkIHRvIGNoZWNrIGlmIGEgbGl0ZXJhbCBzdHJ1Y3QgY29uc3RydWN0b3IgaXMgY29ycmVjdC5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRmllbGRzKHNpdGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHR5cGUgb2Ygc3RydWN0IG9yIGVudW1NZW1iZXIgZmllbGRzLlxuXHQgKiBVc2VkIHRvIGNoZWNrIGlmIGxpdGVyYWwgc3RydWN0IGNvbnN0cnVjdG9yIGlzIGNvcnJlY3QuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBzdHJ1Y3Qgb3IgZW51bU1lbWJlciBmaWVsZHMuXG5cdCAqIFVzZWQgdG8gb3JkZXIgbGl0ZXJhbCBzdHJ1Y3QgZmllbGRzLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldEZpZWxkSW5kZXgoc2l0ZSwgbmFtZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29uc3RydWN0b3IgaW5kZXggc28gUGx1dHVzLWNvcmUgZGF0YSBjYW4gYmUgY3JlYXRlZCBjb3JyZWN0bHkuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG59XG5cbi8qKlxuICogVHlwZXMgYXJlIHVzZWQgZHVyaW5nIHR5cGUtY2hlY2tpbmcgb2YgSGVsaW9zXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBUeXBlIGV4dGVuZHMgRXZhbEVudGl0eSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcGFyZXMgdHdvIHR5cGVzLiBUaHJvd3MgYW4gZXJyb3IgaWYgbmVpdGhlciBpcyBhIFR5cGUuXG5cdCAqIEBleGFtcGxlXG5cdCAqIFR5cGUuc2FtZShTaXRlLmR1bW15KCksIG5ldyBJbnRUeXBlKCksIG5ldyBJbnRUeXBlKCkpID0+IHRydWVcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IGEgXG5cdCAqIEBwYXJhbSB7VHlwZX0gYiBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgc2FtZShzaXRlLCBhLCBiKSB7XG5cdFx0cmV0dXJuIGEuaXNCYXNlT2Yoc2l0ZSwgYikgJiYgYi5pc0Jhc2VPZihzaXRlLCBhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzVHlwZSgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRhc3NlcnRUeXBlKHNpdGUpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzVmFsdWUoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgVHlwZS4gVGhyb3dzIGFuIGVycm9yIGluIHRoaXMgY2FzZSBiZWNhdXNlIGEgVHlwZSBjYW4ndCByZXR1cm4gYW5vdGhlciBUeXBlLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0Z2V0VHlwZShzaXRlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGNhbid0IHVzZSBnZXRUeXBlKCksICcke3RoaXMudG9TdHJpbmcoKX0nIGlzbid0IGFuIGluc3RhbmNlYCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgYSBUeXBlIGNhbid0IGJlIGFuIGluc3RhbmNlIG9mIGFub3RoZXIgVHlwZS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGUgfCBUeXBlQ2xhc3N9IHR5cGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0luc3RhbmNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBjYW4ndCB1c2UgaXNJbnN0YW5jZU9mKCksICcke3RoaXMudG9TdHJpbmcoKX0nIGlzbid0IGFuIGluc3RhbmNlYCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgYSBUeXBlIGlzbid0IGNhbGxhYmxlLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7SW5zdGFuY2VbXX0gYXJncyBcblx0ICogQHBhcmFtIHt7W25hbWU6IHN0cmluZ106IEluc3RhbmNlfX0gbmFtZWRBcmdzXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGNhbGwoc2l0ZSwgYXJncywgbmFtZWRBcmdzID0ge30pIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcIm5vdCBjYWxsYWJsZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRW51bU1lbWJlcigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGVycm9yIGZvciBub24tZW51bSBtZW1iZXJzXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRwYXJlbnRUeXBlKHNpdGUpIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgJyR7dGhpcy50b1N0cmluZ30nIGlzbid0IGFuIGVudW0gbWVtYmVyYCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBudW1iZXIgb2YgbWVtYmVycyBvZiBhbiBlbnVtIHR5cGVcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIG5vdCBhbiBlbnVtIHR5cGVcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRW51bU1lbWJlcnMoc2l0ZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKGAnJHt0aGlzLnRvU3RyaW5nKCl9JyBpc24ndCBhbiBlbnVtIHR5cGVgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBiYXNlIHBhdGggaW4gdGhlIElSIChlZy4gX19oZWxpb3NfX2Jvb2wsIF9faGVsaW9zX19lcnJvciwgZXRjLilcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy50b1N0cmluZygpfSBkb2Vzbid0IGhhdmUgYSBjb3JyZXNwb25kaW5nIHVzZXJUeXBlYCk7XG5cdH1cbn1cblxuXG4vKipcbiAqIEFueVR5cGUgbWF0Y2hlcyBhbnkgb3RoZXIgdHlwZSBpbiB0aGUgdHlwZSBjaGVja2VyLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQW55VHlwZSBleHRlbmRzIFR5cGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSBvdGhlciBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJBbnlcIjtcblx0fVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3Mgb2Ygbm9uLUZ1bmNUeXBlcy5cbiAqL1xuY2xhc3MgRGF0YVR5cGUgZXh0ZW5kcyBUeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0dHlwZSA9IFBhcmFtVHlwZS51bndyYXAodHlwZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpID09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlKTtcblx0fVxufVxuXG4vKipcbiAqIE1hdGNoZXMgZXZlcnl0aGluZyBleGNlcHQgRnVuY1R5cGUuXG4gKiBVc2VkIGJ5IGZpbmRfZGF0dW1faGFzaC5cbiAqL1xuY2xhc3MgQW55RGF0YVR5cGUgZXh0ZW5kcyBUeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHJldHVybiAhKHR5cGUgaW5zdGFuY2VvZiBGdW5jVHlwZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGFsbCBidWlsdGluIHR5cGVzIChlZy4gSW50VHlwZSlcbiAqIE5vdGU6IGFueSBidWlsdGluIHR5cGUgdGhhdCBpbmhlcml0cyBmcm9tIEJ1aWx0aW5UeXBlIG11c3QgaW1wbGVtZW50IGdldCBwYXRoKClcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEJ1aWx0aW5UeXBlIGV4dGVuZHMgRGF0YVR5cGUge1xuXHQjbWFjcm9zQWxsb3dlZDsgLy8gbWFjcm9zIGFyZSBhbGxvd2VkIGFmdGVyIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBtYWluIGZ1bmN0aW9uXG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNtYWNyb3NBbGxvd2VkID0gZmFsc2U7XG5cdH1cblxuXHRhbGxvd01hY3JvcygpIHtcblx0XHR0aGlzLiNtYWNyb3NBbGxvd2VkID0gdHJ1ZTtcblx0fVxuXG5cdGdldCBtYWNyb3NBbGxvd2VkKCkge1xuXHRcdHJldHVybiB0aGlzLiNtYWNyb3NBbGxvd2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgVHlwZSBtZW1iZXIgKGkuZS4gJzo6JyBvcGVyYXRvcikuXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIl9fZXFcIjpcblx0XHRcdGNhc2UgXCJfX25lcVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgdGhpc10sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZnJvbV9kYXRhXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgUmF3RGF0YVR5cGUoKV0sIHRoaXMpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoYCR7dGhpcy50b1N0cmluZygpfTo6JHtuYW1lLnZhbHVlfSB1bmRlZmluZWRgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBvbmUgb2YgZGVmYXVsdCBpbnN0YW5jZSBtZW1iZXJzLCBvciB0aHJvd3MgYW4gZXJyb3IuXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInNlcmlhbGl6ZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEJ5dGVBcnJheVR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJHt0aGlzLnRvU3RyaW5nKCl9LiR7bmFtZS52YWx1ZX0gdW5kZWZpbmVkYCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGZpZWxkcyBpbiBhIGJ1aWx0aW4gdHlwZSAobm90IHlldCB1c2VkKVxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRmllbGRzKHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBpbmRleCBvZiBhIGJ1aWx0aW4gdHlwZSAoZWcuIDEgZm9yIE9wdGlvbjo6Tm9uZSkuXG5cdCAqIEJ5IGRlZmF1bHQgbm9uLWVudW0gYnVpbHRpbiB0eXBlcyB0aGF0IGFyZSBlbmNvZGVkIGFzIFBsdXR1cy1jb3JlIGRhdGEgdXNlIHRoZSAnMCcgY29uc3RydWN0b3IgaW5kZXguXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2UgJ3BhdGgnIGdldHRlciBpbnN0ZWFkIG9mICd0b0lSKCknIGluIG9yZGVyIHRvIGdldCB0aGUgYmFzZSBwYXRoLlxuXHQgKi9cblx0dG9JUigpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1c2UgcGF0aCBnZXR0ZXIgaW5zdGVhZFwiKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEJ1aWx0aW5FbnVtTWVtYmVyIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHQjcGFyZW50VHlwZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtCdWlsdGluVHlwZX0gcGFyZW50VHlwZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmVudFR5cGUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI3BhcmVudFR5cGUgPSBwYXJlbnRUeXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNFbnVtTWVtYmVyKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRwYXJlbnRUeXBlKHNpdGUpIHtcblx0XHRyZXR1cm4gdGhpcy4jcGFyZW50VHlwZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19lcVwiOlxuXHRcdFx0Y2FzZSBcIl9fbmVxXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLiNwYXJlbnRUeXBlLCB0aGlzLiNwYXJlbnRUeXBlXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJmcm9tX2RhdGFcIjpcblx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7dGhpcy50b1N0cmluZygpfTo6ZnJvbV9kYXRhJyB1bmRlZmluZWRgKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFR5cGUgd3JhcHBlciBmb3IgU3RydWN0IHN0YXRlbWVudHMgYW5kIEVudW1zIGFuZCBFbnVtIG1lbWJlcnMuXG4gKiBAcGFja2FnZVxuICogQHRlbXBsYXRlIHtVc2VyVHlwZVN0YXRlbWVudH0gVFxuICovXG5jbGFzcyBTdGF0ZW1lbnRUeXBlIGV4dGVuZHMgRGF0YVR5cGUge1xuXHQjc3RhdGVtZW50O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R9IHN0YXRlbWVudCBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHN0YXRlbWVudCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jc3RhdGVtZW50ID0gc3RhdGVtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc3RhdGVtZW50Lm5hbWUudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1R9XG5cdCAqL1xuXHRnZXQgc3RhdGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHR5cGUgPSBQYXJhbVR5cGUudW53cmFwKHR5cGUsIHRoaXMpO1xuXG5cdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0ZW1lbnRUeXBlKSB7XG5cdFx0XHRyZXR1cm4gdHlwZS5wYXRoLnN0YXJ0c1dpdGgodGhpcy5wYXRoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3N0YXRlbWVudC5uYW1lLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy4jc3RhdGVtZW50LmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBmaWVsZHMgaW4gYSBTdHJ1Y3Qgb3IgaW4gYW4gRW51bU1lbWJlci5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkZpZWxkcyhzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3N0YXRlbWVudC5uRmllbGRzKHNpdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGktdGggZmllbGQgb2YgYSBTdHJ1Y3Qgb3IgYW4gRW51bU1lbWJlclxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRnZXRGaWVsZFR5cGUoc2l0ZSwgaSkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQuZ2V0RmllbGRUeXBlKHNpdGUsIGkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgbmFtZWQgZmllbGQgb2YgYSBTdHJ1Y3Qgb3IgYW4gRW51bU1lbWJlclxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldEZpZWxkSW5kZXgoc2l0ZSwgbmFtZSkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQuZ2V0RmllbGRJbmRleChzaXRlLCBuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBpbmRleCBzbyB0aGF0IF9fY29yZV9fY29uc3RyRGF0YSBjYW4gYmUgY2FsbGVkIGNvcnJlY3RseS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQuZ2V0Q29uc3RySW5kZXgoc2l0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1lbWJlcnMgb2YgYW4gRW51bVN0YXRlbWVudFxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3N0YXRlbWVudC5uRW51bU1lbWJlcnMoc2l0ZSk7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc3RhdGVtZW50LnBhdGg7XG5cdH1cblxuXHQvKipcblx0ICogQSBTdGF0ZW1lbnRUeXBlIGNhbiBpbnN0YW50aWF0ZSBpdHNlbGYgaWYgdGhlIHVuZGVybHlpbmcgc3RhdGVtZW50IGlzIGFuIGVudW0gbWVtYmVyIHdpdGggbm8gZmllbGRzXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRhc3NlcnRWYWx1ZShzaXRlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGEgdmFsdWUsIGdvdCBhIHR5cGVgKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50VHlwZTxVc2VyVHlwZVN0YXRlbWVudD59XG4gKi9cbmNsYXNzIFN0cnVjdFN0YXRlbWVudFR5cGUgZXh0ZW5kcyBTdGF0ZW1lbnRUeXBlIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7VXNlclR5cGVTdGF0ZW1lbnR9IHN0YXRlbWVudCAtIGNhbid0IHVzZSBTdHJ1Y3RTdGF0ZW1lbnQgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzdGF0ZW1lbnQpIHtcblx0XHRzdXBlcihzdGF0ZW1lbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0Y29uc3Qgc3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnQ7XG5cblx0XHRjb25zdCBuRmllbGRzID0gdGhpcy5uRmllbGRzKFNpdGUuZHVtbXkoKSk7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7W3N0cmluZywgVHlwZV1bXX0gLSBbbmFtZSwgdHlwZV1cblx0XHQgKi9cblx0XHRjb25zdCBmaWVsZHMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbkZpZWxkczsgaSsrKSB7XG5cdFx0XHRmaWVsZHMucHVzaChbc3RhdGVtZW50LmdldEZpZWxkTmFtZShpKSwgc3RhdGVtZW50LmdldEZpZWxkVHlwZShTaXRlLmR1bW15KCksIGkpXSk7XG5cdFx0fVxuXG5cdFx0Y2xhc3MgU3RydWN0IGV4dGVuZHMgSGVsaW9zRGF0YSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFNvIHdlIGNhbiBhY2Nlc3MgZmllbGRzIGJ5IGluZGV4XG5cdFx0XHQgKiBAdHlwZSB7SGVsaW9zRGF0YVtdfVxuXHRcdFx0ICovXG5cdFx0XHQjZmllbGRzO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHRcdFx0ICovXG5cdFx0XHRjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG5cdFx0XHRcdHN1cGVyKCk7XG5cdFx0XHRcdGlmIChhcmdzLmxlbmd0aCAhPSBuRmllbGRzKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke25GaWVsZHN9IGFyZ3MsIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy4jZmllbGRzID0gW107XG5cblx0XHRcdFx0YXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcblx0XHRcdFx0XHRjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gZmllbGRzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IEZpZWxkQ2xhc3MgPSBmaWVsZFR5cGUudXNlclR5cGU7XG5cblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZSA9IGFyZyBpbnN0YW5jZW9mIEZpZWxkQ2xhc3MgPyBhcmcgOiBuZXcgRmllbGRDbGFzcyhhcmcpO1xuXG5cdFx0XHRcdFx0dGhpcy4jZmllbGRzLnB1c2goaW5zdGFuY2UpO1xuXHRcdFx0XHRcdHRoaXNbZmllbGROYW1lXSA9IGluc3RhbmNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBPdmVybG9hZCAnaW5zdGFuY2VvZicgb3BlcmF0b3Jcblx0XHRcdCAqIEBwYXJhbSB7YW55fSBvdGhlciBcblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0ob3RoZXIpIHtcblx0XHRcdFx0cmV0dXJuIChvdGhlci5fc3RydWN0U3RhdGVtZW50ID09PSBzdGF0ZW1lbnQpICYmIChvdGhlciBpbnN0YW5jZW9mIEhlbGlvc0RhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtVc2VyVHlwZVN0YXRlbWVudH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0IF9zdHJ1Y3RTdGF0ZW1lbnQoKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMge1VwbGNEYXRhfVxuXHRcdFx0ICovXG5cdFx0XHRfdG9VcGxjRGF0YSgpIHtcblx0XHRcdFx0aWYgKHRoaXMuI2ZpZWxkcy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLiNmaWVsZHNbMF0uX3RvVXBsY0RhdGEoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IExpc3REYXRhKHRoaXMuI2ZpZWxkcy5tYXAoZiA9PiBmLl90b1VwbGNEYXRhKCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuXHRcdFx0ICogQHJldHVybnMge1N0cnVjdH1cblx0XHRcdCAqL1xuXHRcdFx0c3RhdGljIGZyb21VcGxjQ2JvcihieXRlcykge1xuXHRcdFx0XHRyZXR1cm4gU3RydWN0LmZyb21VcGxjRGF0YShVcGxjRGF0YS5mcm9tQ2JvcihieXRlcykpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGEgXG5cdFx0XHQgKiBAcmV0dXJucyB7U3RydWN0fVxuXHRcdFx0ICovXG5cdFx0XHRzdGF0aWMgZnJvbVVwbGNEYXRhKGRhdGEpIHtcblx0XHRcdFx0Y29uc3QgZGF0YUl0ZW1zID0gZGF0YS5saXN0O1xuXG5cdFx0XHRcdGlmIChkYXRhSXRlbXMubGVuZ3RoICE9IG5GaWVsZHMpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG51bWJlciBvZiBmaWVsZHNcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBhcmdzID0gZGF0YUl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBmaWVsZHNbaV1bMV0udXNlclR5cGUuZnJvbVVwbGNEYXRhKGl0ZW0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFN0cnVjdCguLi5hcmdzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RydWN0LCBcIm5hbWVcIiwge3ZhbHVlOiB0aGlzLm5hbWUsIHdyaXRhYmxlOiBmYWxzZX0pO1x0XHRcblxuXHRcdHJldHVybiBTdHJ1Y3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQGV4dGVuZHMge1N0YXRlbWVudFR5cGU8RW51bVR5cGVTdGF0ZW1lbnQ+fVxuICovXG5jbGFzcyBFbnVtU3RhdGVtZW50VHlwZSBleHRlbmRzIFN0YXRlbWVudFR5cGUge1xuXHQvKipcblx0ICogQHBhcmFtIHtFbnVtVHlwZVN0YXRlbWVudH0gc3RhdGVtZW50IC0gY2FuJ3QgdXNlIEVudW1TdGF0ZW1lbnQgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzdGF0ZW1lbnQpIHtcblx0XHRzdXBlcihzdGF0ZW1lbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0Y29uc3Qgc3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnQ7XG5cblx0XHRjb25zdCBuVmFyaWFudHMgPSBzdGF0ZW1lbnQubkVudW1NZW1iZXJzKFNpdGUuZHVtbXkoKSk7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+W119XG5cdFx0ICovXG5cdFx0Y29uc3QgdmFyaWFudHMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgblZhcmlhbnRzOyBpKyspIHtcblx0XHRcdHZhcmlhbnRzLnB1c2goXG5cdFx0XHRcdChuZXcgRW51bU1lbWJlclN0YXRlbWVudFR5cGUoc3RhdGVtZW50LmdldEVudW1NZW1iZXIoU2l0ZS5kdW1teSgpLCBpKSkpLnVzZXJUeXBlXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNsYXNzIEVudW0gZXh0ZW5kcyBIZWxpb3NEYXRhIHtcblx0XHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0XHRzdXBlcigpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBiZSBjb25zdHJ1Y3RlZCAoaGludDogY29uc3RydWN0IGFuIGVudW0pXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIE92ZXJsb2FkICdpbnN0YW5jZW9mJyBvcGVyYXRvclxuXHRcdFx0ICogQHBhcmFtIHthbnl9IG90aGVyIFxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShvdGhlcikge1xuXHRcdFx0XHRyZXR1cm4gKG90aGVyLl9lbnVtU3RhdGVtZW50ID09PSBzdGF0ZW1lbnQpICYmIChvdGhlciBpbnN0YW5jZW9mIEhlbGlvc0RhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtFbnVtVHlwZVN0YXRlbWVudH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0IF9lbnVtU3RhdGVtZW50KCkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzXG5cdFx0XHQgKiBAcmV0dXJucyB7SGVsaW9zRGF0YX1cblx0XHRcdCAqL1xuXHRcdFx0c3RhdGljIGZyb21VcGxjQ2JvcihieXRlcykge1xuXHRcdFx0XHRyZXR1cm4gRW51bS5mcm9tVXBsY0RhdGEoVXBsY0RhdGEuZnJvbUNib3IoYnl0ZXMpKTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuXHRcdFx0ICogQHJldHVybnMge0hlbGlvc0RhdGF9XG5cdFx0XHQgKi9cblx0XHRcdHN0YXRpYyBmcm9tVXBsY0RhdGEoZGF0YSkge1xuXHRcdFx0XHRjb25zdCB2YXJpYW50ID0gYXNzZXJ0RGVmaW5lZCh2YXJpYW50c1tkYXRhLmluZGV4XSwgXCJpbmRleCBvdXQgb2YgcmFuZ2VcIik7XG5cblx0XHRcdFx0cmV0dXJuIHZhcmlhbnQuZnJvbVVwbGNEYXRhKGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnVtLCBcIm5hbWVcIiwge3ZhbHVlOiB0aGlzLm5hbWUsIHdyaXRhYmxlOiBmYWxzZX0pO1xuXG5cdFx0Zm9yIChsZXQgdiBvZiB2YXJpYW50cykge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEVudW0sIHYubmFtZSwge3ZhbHVlOiB2LCB3cml0YWJsZTogZmFsc2V9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gRW51bTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50VHlwZTxFbnVtTWVtYmVyVHlwZVN0YXRlbWVudD59XG4gKi9cbmNsYXNzIEVudW1NZW1iZXJTdGF0ZW1lbnRUeXBlIGV4dGVuZHMgU3RhdGVtZW50VHlwZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbnVtTWVtYmVyVHlwZVN0YXRlbWVudH0gc3RhdGVtZW50IC0gY2FuJ3QgdXNlIEVudW1NZW1iZXIgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhdGVtZW50KSB7XG4gICAgICAgIHN1cGVyKHN0YXRlbWVudCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRW51bU1lbWJlcigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0cGFyZW50VHlwZShzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50LnBhcmVudC50eXBlO1xuXHR9XG5cbiAgICAvKipcblx0ICogQSBTdGF0ZW1lbnRUeXBlIGNhbiBpbnN0YW50aWF0ZSBpdHNlbGYgaWYgdGhlIHVuZGVybHlpbmcgc3RhdGVtZW50IGlzIGFuIGVudW0gbWVtYmVyIHdpdGggbm8gZmllbGRzXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuICAgIGFzc2VydFZhbHVlKHNpdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVtZW50Lm5GaWVsZHMoc2l0ZSkgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluc3RhbmNlLm5ldyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCAney4uLn0nIGFmdGVyICcke3RoaXMuc3RhdGVtZW50Lm5hbWUudG9TdHJpbmcoKX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0Y29uc3Qgc3RhdGVtZW50ID0gdGhpcy5zdGF0ZW1lbnQ7XG5cblx0XHRjb25zdCBlbnVtU3RhdGVtZW50ID0gc3RhdGVtZW50LnBhcmVudDtcblxuXHRcdGNvbnN0IGluZGV4ID0gc3RhdGVtZW50LmdldENvbnN0ckluZGV4KFNpdGUuZHVtbXkoKSk7XG5cblx0XHRjb25zdCBuRmllbGRzID0gdGhpcy5uRmllbGRzKFNpdGUuZHVtbXkoKSk7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7W3N0cmluZywgVHlwZV1bXX0gLSBbbmFtZSwgdHlwZV1cblx0XHQgKi9cblx0XHRjb25zdCBmaWVsZHMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbkZpZWxkczsgaSsrKSB7XG5cdFx0XHRmaWVsZHMucHVzaChbc3RhdGVtZW50LmdldEZpZWxkTmFtZShpKSwgc3RhdGVtZW50LmdldEZpZWxkVHlwZShTaXRlLmR1bW15KCksIGkpXSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltaWxhciB0byBTdHJ1Y3Rcblx0XHRjbGFzcyBFbnVtVmFyaWFudCBleHRlbmRzIEhlbGlvc0RhdGEge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBTbyB3ZSBjYW4gYWNjZXNzIGZpZWxkcyBieSBpbmRleFxuXHRcdFx0ICogQHR5cGUge0hlbGlvc0RhdGFbXX1cblx0XHRcdCAqL1xuXHRcdFx0I2ZpZWxkcztcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0XHRcdCAqL1xuXHRcdFx0Y29uc3RydWN0b3IoLi4uYXJncykge1xuXHRcdFx0XHRzdXBlcigpO1xuXHRcdFx0XHRpZiAoYXJncy5sZW5ndGggIT0gbkZpZWxkcykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtuRmllbGRzfSBhcmdzLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcblx0XHRcdFx0fVxuIFxuXHRcdFx0XHR0aGlzLiNmaWVsZHMgPSBbXTtcbiBcblx0XHRcdFx0YXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcblx0XHRcdFx0XHRjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gZmllbGRzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IEZpZWxkQ2xhc3MgPSBmaWVsZFR5cGUudXNlclR5cGU7XG4gXG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBhcmcgaW5zdGFuY2VvZiBGaWVsZENsYXNzID8gYXJnIDogbmV3IEZpZWxkQ2xhc3MoYXJnKTtcblxuIFx0XHRcdFx0XHR0aGlzLiNmaWVsZHMucHVzaChpbnN0YW5jZSk7XG5cdFx0XHRcdFx0dGhpc1tmaWVsZE5hbWVdID0gaW5zdGFuY2U7XG5cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG4gXG5cdFx0XHQvKipcblx0XHRcdCAqIE92ZXJsb2FkICdpbnN0YW5jZW9mJyBvcGVyYXRvclxuXHRcdFx0ICogQHBhcmFtIHthbnl9IG90aGVyIFxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShvdGhlcikge1xuXHRcdFx0XHRyZXR1cm4gKG90aGVyLl9lbnVtVmFyaWFudFN0YXRlbWVudCA9PT0gc3RhdGVtZW50KSAmJiAob3RoZXIgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKTtcblx0XHRcdH1cbiBcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge0VudW1UeXBlU3RhdGVtZW50fVxuXHRcdFx0ICovXG5cdFx0XHRnZXQgX2VudW1TdGF0ZW1lbnQoKSB7XG5cdFx0XHRcdHJldHVybiBlbnVtU3RhdGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtFbnVtTWVtYmVyVHlwZVN0YXRlbWVudH1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0IF9lbnVtVmFyaWFudFN0YXRlbWVudCgpIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlbWVudDtcblx0XHRcdH1cbiBcblx0XHRcdC8qKlxuXHRcdFx0ICogQHJldHVybnMge1VwbGNEYXRhfVxuXHRcdFx0ICovXG5cdFx0XHRfdG9VcGxjRGF0YSgpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKGluZGV4LCB0aGlzLiNmaWVsZHMubWFwKGYgPT4gZi5fdG9VcGxjRGF0YSgpKSk7XG5cdFx0XHR9XG4gXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyW119IGJ5dGVzIFxuXHRcdFx0ICogQHJldHVybnMge0VudW1WYXJpYW50fVxuXHRcdFx0ICovXG5cdFx0XHRzdGF0aWMgZnJvbVVwbGNDYm9yKGJ5dGVzKSB7XG5cdFx0XHRcdHJldHVybiBFbnVtVmFyaWFudC5mcm9tVXBsY0RhdGEoVXBsY0RhdGEuZnJvbUNib3IoYnl0ZXMpKTtcblx0XHRcdH1cbiBcblx0XHRcdC8qKlxuXHRcdFx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcblx0XHRcdCAqIEByZXR1cm5zIHtFbnVtVmFyaWFudH1cblx0XHRcdCAqL1xuXHRcdFx0c3RhdGljIGZyb21VcGxjRGF0YShkYXRhKSB7XG5cdFx0XHRcdGFzc2VydChkYXRhLmluZGV4ID09IGluZGV4LCBcIndyb25nIGluZGV4XCIpO1xuXG5cdFx0XHRcdGNvbnN0IGRhdGFJdGVtcyA9IGRhdGEubGlzdDtcbiBcblx0XHRcdFx0aWYgKGRhdGFJdGVtcy5sZW5ndGggIT0gbkZpZWxkcykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgbnVtYmVyIG9mIGZpZWxkc1wiKTtcblx0XHRcdFx0fVxuIFxuXHRcdFx0XHRjb25zdCBhcmdzID0gZGF0YUl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBmaWVsZHNbaV1bMV0udXNlclR5cGUuZnJvbVVwbGNEYXRhKGl0ZW0pO1xuXHRcdFx0XHR9KTtcbiBcblx0XHRcdFx0cmV0dXJuIG5ldyBFbnVtVmFyaWFudCguLi5hcmdzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRW51bVZhcmlhbnQsIFwibmFtZVwiLCB7dmFsdWU6IHRoaXMubmFtZSwgd3JpdGFibGU6IGZhbHNlfSk7XG5cblx0XHRyZXR1cm4gRW51bVZhcmlhbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBBcmdUeXBlIHtcblx0I25hbWU7XG5cdCN0eXBlO1xuXHQjb3B0aW9uYWw7XG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge251bGwgfCBXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uYWwgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBvcHRpb25hbCA9IGZhbHNlKSB7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jdHlwZSA9IHR5cGU7XG5cdFx0dGhpcy4jb3B0aW9uYWwgPSBvcHRpb25hbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IG5hbWUoKSB7XG5cdFx0aWYgKHRoaXMuI25hbWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jbmFtZS50b1N0cmluZygpO1xuXHRcdH1cblx0fVxuXHQvKipcblx0ICogQHR5cGUge1R5cGV9XG5cdCAqL1xuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzTmFtZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUgIT09IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc09wdGlvbmFsKCkge1xuXHRcdHJldHVybiB0aGlzLiNvcHRpb25hbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHRoaXMuI25hbWUgIT0gbnVsbCA/IGAke3RoaXMuI25hbWUudG9TdHJpbmcoKX06IGAgOiBcIlwiLFxuXHRcdFx0dGhpcy4jb3B0aW9uYWwgPyBcIj9cIiA6IFwiXCIsXG5cdFx0XHR0aGlzLiN0eXBlLnRvU3RyaW5nKClcblx0XHRdLmpvaW4oXCJcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge0FyZ1R5cGV9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIG90aGVyKSB7XG5cdFx0Ly8gaWYgdGhpcyBhcmcgaGFzIGEgZGVmYXVsdCB2YWx1ZSwgdGhlIG90aGVyIGFyZyBtdXN0IGFsc28gaGF2ZSBhIGRlZmF1bHQgdmFsdWVcblx0XHRpZiAodGhpcy4jb3B0aW9uYWwgJiYgIW90aGVyLiNvcHRpb25hbCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoaXMgaXMgbmFtZWQsIHRoZSBvdGhlciBtdXN0IGJlIG5hbWVkIGFzIHdlbGxcblx0XHRpZiAodGhpcy4jbmFtZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jbmFtZS50b1N0cmluZygpID09IChvdGhlci4jbmFtZT8udG9TdHJpbmcoKSA/PyBcIlwiKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jdHlwZSBpbnN0YW5jZW9mIFBhcmFtVHlwZSkge1xuXHRcdFx0dGhpcy4jdHlwZS5zZXRUeXBlKHNpdGUsIG90aGVyLiN0eXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFvdGhlci4jdHlwZS5pc0Jhc2VPZihzaXRlLCB0aGlzLiN0eXBlKSkgeyAvLyBub3RlIHRoZSByZXZlcnNhbCBvZiB0aGUgY2hlY2tcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdHlwZSB3aXRoIGFyZyB0eXBlcyBhbmQgYSByZXR1cm4gdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRnVuY1R5cGUgZXh0ZW5kcyBUeXBlIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtBcmdUeXBlW119XG5cdCAqL1xuXHQjYXJnVHlwZXM7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlW119XG5cdCAqL1xuXHQjcmV0VHlwZXM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZVtdIHwgQXJnVHlwZVtdfSBhcmdUeXBlcyBcblx0ICogQHBhcmFtIHtUeXBlIHwgVHlwZVtdfSByZXRUeXBlcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGFyZ1R5cGVzLCByZXRUeXBlcykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jYXJnVHlwZXMgPSBhcmdUeXBlcy5tYXAoYXQgPT4ge1xuXHRcdFx0aWYgKGF0IGluc3RhbmNlb2YgVHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFyZ1R5cGUobnVsbCwgYXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGF0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHJldFR5cGVzKSkge1xuXHRcdFx0cmV0VHlwZXMgPSBbcmV0VHlwZXNdO1xuXHRcdH1cblxuXHRcdHRoaXMuI3JldFR5cGVzID0gcmV0VHlwZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBuQXJncygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJnVHlwZXMubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgbk5vbk9wdEFyZ3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2FyZ1R5cGVzLmZpbHRlcihhdCA9PiAhYXQuaXNPcHRpb25hbCgpKS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdGdldCBuT3B0QXJncygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJnVHlwZXMuZmlsdGVyKGF0ID0+IGF0LmlzT3B0aW9uYWwoKSkubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlW119XG5cdCAqL1xuXHRnZXQgYXJnVHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2FyZ1R5cGVzLnNsaWNlKCkubWFwKGF0ID0+IGF0LnR5cGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlW119XG5cdCAqL1xuXHRnZXQgcmV0VHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3JldFR5cGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRpZiAodGhpcy4jcmV0VHlwZXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gYCgke3RoaXMuI2FyZ1R5cGVzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSkgLT4gJHt0aGlzLiNyZXRUeXBlcy50b1N0cmluZygpfWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBgKCR7dGhpcy4jYXJnVHlwZXMubWFwKGEgPT4gYS50b1N0cmluZygpKS5qb2luKFwiLCBcIil9KSAtPiAoJHt0aGlzLiNyZXRUeXBlcy5tYXAodCA9PiB0LnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0pYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSB0eXBlIG9mIHRoZSBmaXJzdCBhcmcgaXMgdGhlIHNhbWUgYXMgJ3R5cGUnXG5cdCAqIEFsc28gcmV0dXJucyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gYXJncy5cblx0ICogRm9yIGEgbWV0aG9kIHRvIGJlIGEgdmFsaWQgaW5zdGFuY2UgbWVtYmVyIGl0cyBmaXJzdCBhcmd1bWVudCBtdXN0IGFsc28gYmUgbmFtZWQgJ3NlbGYnLCBidXQgdGhhdCBpcyBjaGVja2VkIGVsc2V3aGVyZVxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc01heWJlTWV0aG9kKHNpdGUsIHR5cGUpIHtcblx0XHRpZiAodGhpcy4jYXJnVHlwZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0cmV0dXJuIFR5cGUuc2FtZShzaXRlLCB0aGlzLiNhcmdUeXBlc1swXS50eXBlLCB0eXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBcblx0ICogQ2hlY2tzIGlmIGFueSBvZiAndGhpcycgYXJnVHlwZXMgb3IgcmV0VHlwZSBpcyBzYW1lIGFzIFR5cGUuXG5cdCAqIE9ubHkgaWYgdGhpcyBjaGVja3MgcmV0dXJuIHRydWUgaXMgdGhlIGFzc29jaWF0aW9uIGFsbG93ZWQuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Fzc29jaWF0ZWQoc2l0ZSwgdHlwZSkge1xuXHRcdGZvciAobGV0IGFyZyBvZiB0aGlzLiNhcmdUeXBlcykge1xuXHRcdFx0aWYgKFR5cGUuc2FtZShzaXRlLCBhcmcudHlwZSwgdHlwZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgcnQgb2YgdGhpcy4jcmV0VHlwZXMpIHtcblx0XHRcdGlmIChUeXBlLnNhbWUoc2l0ZSwgdHlwZSwgcnQpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgJ3RoaXMnIGlzIGEgYmFzZSB0eXBlIG9mIGFub3RoZXIgRnVuY1R5cGUuXG5cdCAqIFRoZSBudW1iZXIgb2YgYXJncyBuZWVkcyB0byBiZSB0aGUgc2FtZS5cblx0ICogRWFjaCBhcmdUeXBlIG9mIHRoZSBGdW5jVHlwZSB3ZSBhcmUgY2hlY2tpbmcgYWdhaW5zdCBuZWVkcyB0byBiZSB0aGUgc2FtZSBvciBsZXNzIHNwZWNpZmljIChpLmUuIGlzQmFzZU9mKHRoaXMuI2FyZ1R5cGVzW2ldKSlcblx0ICogVGhlIHJldFR5cGUgb2YgJ3RoaXMnIG5lZWRzIHRvIGJlIHRoZSBzYW1lIG9yIG1vcmUgc3BlY2lmaWNcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IG90aGVyIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIG90aGVyKSB7XG5cdFx0aWYgKG90aGVyIGluc3RhbmNlb2YgRnVuY1R5cGUpIHtcblx0XHRcdGlmICh0aGlzLm5Ob25PcHRBcmdzICE9IG90aGVyLm5Ob25PcHRBcmdzKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uTm9uT3B0QXJnczsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLiNhcmdUeXBlc1tpXS5pc0Jhc2VPZihzaXRlLCBvdGhlci4jYXJnVHlwZXNbaV0pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuI3JldFR5cGVzLmxlbmd0aCA9PT0gb3RoZXIuI3JldFR5cGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcmV0VHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICghdGhpcy4jcmV0VHlwZXNbaV0uaXNCYXNlT2Yoc2l0ZSwgb3RoZXIuI3JldFR5cGVzW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiBuYW1lIGlzbid0IGZvdW5kXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXROYW1lZEluZGV4KHNpdGUsIG5hbWUpIHtcblx0XHRjb25zdCBpID0gdGhpcy4jYXJnVHlwZXMuZmluZEluZGV4KGF0ID0+IGF0Lm5hbWUgPT0gbmFtZSk7XG5cblx0XHRpZiAoaSA9PSAtMSkge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGFyZyBuYW1lICR7bmFtZX0gbm90IGZvdW5kYCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYXJnIHR5cGVzIGFyZSB2YWxpZC5cblx0ICogVGhyb3dzIGVycm9ycyBpZiBub3QgdmFsaWQuIFJldHVybnMgdGhlIHJldHVybiB0eXBlIGlmIHZhbGlkLiBcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge0luc3RhbmNlW119IHBvc0FyZ3Ncblx0ICogQHBhcmFtIHt7W25hbWU6IHN0cmluZ106IEluc3RhbmNlfX0gbmFtZWRBcmdzXG5cdCAqIEByZXR1cm5zIHtUeXBlW119XG5cdCAqL1xuXHRjaGVja0NhbGwoc2l0ZSwgcG9zQXJncywgbmFtZWRBcmdzID0ge30pIHtcblx0XHRpZiAocG9zQXJncy5sZW5ndGggPCB0aGlzLm5Ob25PcHRBcmdzKSB7XG5cdFx0XHQvLyBjaGVjayBpZiBlYWNoIG5vbk9wdEFyZyBpcyBjb3ZlcmVkIGJ5IHRoZSBuYW1lZCBhcmdzXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubk5vbk9wdEFyZ3M7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuI2FyZ1R5cGVzW2ldLmlzTmFtZWQoKSkge1xuXHRcdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhdCBsZWFzdCAke3RoaXMuI2FyZ1R5cGVzLmZpbHRlcihhdCA9PiAhYXQuaXNOYW1lZCgpKS5sZW5ndGh9IHBvc2l0aW9uYWwgYXJnKHMpLCBnb3QgJHtwb3NBcmdzLmxlbmd0aH0gcG9zaXRpb25hbCBhcmcocylgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoISh0aGlzLiNhcmdUeXBlc1tpXS5uYW1lIGluIG5hbWVkQXJncykpIHtcblx0XHRcdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBuYW1lZCBhcmcgJHt0aGlzLiNhcmdUeXBlc1tpXS5uYW1lfSBtaXNzaW5nIGZyb20gY2FsbGApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmIChwb3NBcmdzLmxlbmd0aCA+IHRoaXMuI2FyZ1R5cGVzLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGF0IG1vc3QgJHt0aGlzLiNhcmdUeXBlcy5sZW5ndGh9IGFyZyhzKSwgZ290ICR7cG9zQXJncy5sZW5ndGh9IGFyZyhzKWApO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcG9zQXJncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFwb3NBcmdzW2ldLmlzSW5zdGFuY2VPZihzaXRlLCB0aGlzLiNhcmdUeXBlc1tpXS50eXBlKSkge1xuXHRcdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgJyR7dGhpcy4jYXJnVHlwZXNbaV0udHlwZS50b1N0cmluZygpfScgZm9yIGFyZyAke2kgKyAxfSwgZ290ICcke3Bvc0FyZ3NbaV0udG9TdHJpbmcoKX0nYCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQga2V5IGluIG5hbWVkQXJncykge1xuXHRcdFx0Y29uc3QgaSA9IHRoaXMuI2FyZ1R5cGVzLmZpbmRJbmRleChhdCA9PiBhdC5uYW1lID09IGtleSk7XG5cblx0XHRcdGlmIChpID09IC0xKSB7XG5cdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBhcmcgbmFtZWQgJHtrZXl9IG5vdCBmb3VuZCBpbiBmdW5jdGlvbiB0eXBlICR7dGhpcy50b1N0cmluZygpfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA8IHBvc0FyZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBuYW1lZCBhcmcgJyR7a2V5fScgYWxyZWFkeSBjb3ZlcmVkIGJ5IHBvc2l0aW9uYWwgYXJnICR7aSsxfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0aGlzQXJnID0gdGhpcy4jYXJnVHlwZXNbaV07XG5cblx0XHRcdGlmICghbmFtZWRBcmdzW2tleV0uaXNJbnN0YW5jZU9mKHNpdGUsIHRoaXNBcmcudHlwZSkpIHtcblx0XHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkICcke3RoaXNBcmcudHlwZS50b1N0cmluZygpfScgZm9yIGFyZyAnJHtrZXl9JywgZ290ICcke25hbWVkQXJnc1trZXldLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuI3JldFR5cGVzO1xuXHR9XG59XG5cbmNsYXNzIE5vdFR5cGUgZXh0ZW5kcyBFdmFsRW50aXR5IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNUeXBlKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgYmVjYXVzZSBOb3RUeXBlIGNhbid0IGJlIGEgYmFzZS1UeXBlIG9mIGFueXRoaW5nLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoXCJub3QgYSB0eXBlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX0gLSBjYW4gYmUgSW5zdGFuY2Ugb3IgVHlwZVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGEgdHlwZVwiKTtcblx0fVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIERhdGFJbnN0YW5jZSBhbmQgRnVuY0luc3RhbmNlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJbnN0YW5jZSBleHRlbmRzIE5vdFR5cGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZSB8IFR5cGVbXX0gdHlwZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0c3RhdGljIG5ldyh0eXBlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcblx0XHRcdGlmICh0eXBlLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHR5cGVbMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBNdWx0aUluc3RhbmNlKHR5cGUubWFwKHQgPT4gSW5zdGFuY2UubmV3KHQpKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgRnVuY1R5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgRnVuY0luc3RhbmNlKHR5cGUpO1xuXHRcdH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFBhcmFtVHlwZSkge1xuXHRcdFx0Y29uc3QgdCA9IHR5cGUudHlwZTtcblx0XHRcdGlmICh0ID09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbm9uLW51bGwgdHlwZVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcodCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgRXJyb3JUeXBlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEVycm9ySW5zdGFuY2UoKTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBWb2lkVHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBWb2lkSW5zdGFuY2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRhSW5zdGFuY2UodHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0YXNzZXJ0VmFsdWUoc2l0ZSkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cblxuLyoqXG4gKiBBIHJlZ3VsYXIgbm9uLUZ1bmMgSW5zdGFuY2UuIERhdGFWYWx1ZXMgY2FuIGFsd2F5cyBiZSBjb21wYXJlZCwgc2VyaWFsaXplZCwgdXNlZCBpbiBjb250YWluZXJzLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRGF0YUluc3RhbmNlIGV4dGVuZHMgSW5zdGFuY2Uge1xuXHQjdHlwZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtEYXRhVHlwZX0gdHlwZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHR5cGUpIHtcblx0XHRhc3NlcnQoISh0eXBlIGluc3RhbmNlb2YgRnVuY1R5cGUpKTtcblxuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jdHlwZSA9IHR5cGU7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiN0eXBlLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdW5kZXJseWluZyBUeXBlLlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0Z2V0VHlwZShzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYge25ldyguLi5hbnkpID0+IFR5cGV9IFR5cGVDbGFzc1xuXHQgKi9cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmICd0aGlzJyBpcyBpbnN0YW5jZSBvZiAndHlwZScuXG5cdCAqICd0eXBlJyBjYW4gYmUgYSBjbGFzcywgb3IgYSBjbGFzcyBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGUgfCBUeXBlQ2xhc3N9IHR5cGUgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0aXNJbnN0YW5jZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3R5cGUgaW5zdGFuY2VvZiB0eXBlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdHlwZS5pc0Jhc2VPZihzaXRlLCB0aGlzLiN0eXBlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZpZWxkcyBvZiBhIHN0cnVjdCwgZW51bSBtZW1iZXIsIG9yIGJ1aWx0aW4gdHlwZS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkZpZWxkcyhzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGUubkZpZWxkcyhzaXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpLXRoIGZpZWxkIG9mIGEgU3RydWN0IG9yIGFuIEVudW1NZW1iZXJcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0Z2V0RmllbGRUeXBlKHNpdGUsIGkpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZS5nZXRGaWVsZFR5cGUoc2l0ZSwgaSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgYSBuYW1lZCBmaWVsZFxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0RmllbGRJbmRleChzaXRlLCBuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGUuZ2V0RmllbGRJbmRleChzaXRlLCBuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZS5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgYmVjXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtJbnN0YW5jZVtdfSBhcmdzIFxuXHQgKiBAcGFyYW0ge3tbbmFtZTogc3RyaW5nXTogSW5zdGFuY2V9fSBuYW1lZEFyZ3Ncblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Y2FsbChzaXRlLCBhcmdzLCBuYW1lZEFyZ3MgPSB7fSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwibm90IGNhbGxhYmxlXCIpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQ29uc3RTdGF0ZW1lbnRJbnN0YW5jZSBleHRlbmRzIERhdGFJbnN0YW5jZSB7XG5cdCNzdGF0ZW1lbnQ7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RGF0YVR5cGV9IHR5cGUgXG5cdCAqIEBwYXJhbSB7Q29uc3RUeXBlU3RhdGVtZW50fSBzdGF0ZW1lbnQgLSBjYW4ndCB1c2UgQ29uc3RTdGF0ZW1lbnQgYmVjYXVzZSB0aGF0IHdvdWxkIGdpdmUgY2lyY3VsYXIgZGVwZW5kZW5jeVxuXHQgKi9cblx0Y29uc3RydWN0b3IodHlwZSwgc3RhdGVtZW50KSB7XG5cdFx0c3VwZXIodHlwZSk7XG5cdFx0dGhpcy4jc3RhdGVtZW50ID0gc3RhdGVtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtDb25zdFR5cGVTdGF0ZW1lbnR9XG5cdCAqL1xuXHRnZXQgc3RhdGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnRcblx0fVxufVxuXG4vKipcbiAqIEEgY2FsbGFibGUgSW5zdGFuY2UuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBGdW5jSW5zdGFuY2UgZXh0ZW5kcyBJbnN0YW5jZSB7XG5cdCN0eXBlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0Z1bmNUeXBlfSB0eXBlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IodHlwZSkge1xuXHRcdGFzc2VydCh0eXBlIGluc3RhbmNlb2YgRnVuY1R5cGUpO1xuXG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiN0eXBlID0gdHlwZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlY3Vyc2l2ZW5lc3NDaGVja2VyfSBzY29wZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzUmVjdXJzaXZlKHNjb3BlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3R5cGUudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIEZ1bmNUeXBlIGFzIFR5cGUuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldFR5cGUoc2l0ZSkge1xuXHRcdHJldHVybiB0aGlzLiN0eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgRnVuY1R5cGUgZGlyZWN0bHkuXG5cdCAqIEByZXR1cm5zIHtGdW5jVHlwZX1cblx0ICovXG5cdGdldEZ1bmNUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLiN0eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiAndGhpcycgaXMgYW4gaW5zdGFuY2Ugb2YgJ3R5cGUnLlxuXHQgKiBUeXBlIGNhbiBiZSBhIGNsYXNzIG9yIGEgY2xhc3MgaW5zdGFuY2UuIFxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZSB8IFR5cGVDbGFzc30gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0luc3RhbmNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZSBpbnN0YW5jZW9mIHR5cGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0eXBlLmlzQmFzZU9mKHNpdGUsIHRoaXMuI3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7SW5zdGFuY2VbXX0gYXJncyBcblx0ICogQHBhcmFtIHt7W25hbWU6IHN0cmluZ106IEluc3RhbmNlfX0gbmFtZWRBcmdzXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGNhbGwoc2l0ZSwgYXJncywgbmFtZWRBcmdzID0ge30pIHtcblx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMuI3R5cGUuY2hlY2tDYWxsKHNpdGUsIGFyZ3MsIG5hbWVkQXJncykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIGEgZnVuY3Rpb24gdmFsdWUgZG9lc24ndCBoYXZlIGFueSBmaWVsZHMuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5GaWVsZHMoc2l0ZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwiYSBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgZmllbGRzXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIGEgZnVuY3Rpb24gdmFsdWUgZG9lc24ndCBoYXZlIGFueSBmaWVsZHMuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoXCJhIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSBmaWVsZHNcIik7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgYSBmdW5jdGlvbiB2YWx1ZSBoYXZlIGFueSBmaWVsZHMuXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRGaWVsZEluZGV4KHNpdGUsIG5hbWUpIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImEgZnVuY3Rpb24gZG9lc24ndCBoYXZlIGZpZWxkc1wiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgYmVjYXVzZSBhIGZ1bmN0aW9uIHZhbHVlIGRvZXNuJ3QgaGF2ZSBtZW1iZXJzLlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHR0aHJvdyBuYW1lLnR5cGVFcnJvcihcImEgZnVuY3Rpb24gZG9lc24ndCBoYXZlIGFueSBtZW1iZXJzXCIpO1xuXHR9XG59XG5cbi8qKlxuICogU3BlY2lhbCBmdW5jdGlvbiB2YWx1ZSBjbGFzcyBmb3IgdG9wIGxldmVsIGZ1bmN0aW9ucyBiZWNhdXNlIHRoZXkgY2FuIGJlIHVzZWQgcmVjdXJzaXZlbHkuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBGdW5jU3RhdGVtZW50SW5zdGFuY2UgZXh0ZW5kcyBGdW5jSW5zdGFuY2Uge1xuXHQjc3RhdGVtZW50XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RnVuY1R5cGV9IHR5cGUgXG5cdCAqIEBwYXJhbSB7UmVjdXJzZWFibGVTdGF0ZW1lbnR9IHN0YXRlbWVudCAtIGNhbid0IHVzZSBGdW5jU3RhdGVtZW50IGJlY2F1c2UgdGhhdCB3b3VsZCBnaXZlIGNpcmN1bGFyIGRlcGVuZGVuY3lcblx0ICovXG5cdGNvbnN0cnVjdG9yKHR5cGUsIHN0YXRlbWVudCkge1xuXHRcdHN1cGVyKHR5cGUpO1xuXHRcdHRoaXMuI3N0YXRlbWVudCA9IHN0YXRlbWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UmVjdXJzZWFibGVTdGF0ZW1lbnR9XG5cdCAqL1xuXHRnZXQgc3RhdGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWN1cnNpdmVuZXNzQ2hlY2tlcn0gc2NvcGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1JlY3Vyc2l2ZShzY29wZSkge1xuXHRcdGlmICh0aGlzLiNzdGF0ZW1lbnQuaXNSZWN1cnNpdmUoKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBzY29wZS5pc1JlY3Vyc2l2ZSh0aGlzLiNzdGF0ZW1lbnQpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFdyYXBzIG11bHRpcGxlIHJldHVybiB2YWx1ZXNcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE11bHRpSW5zdGFuY2UgZXh0ZW5kcyBJbnN0YW5jZSB7XG5cdCN2YWx1ZXM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SW5zdGFuY2VbXX0gdmFsdWVzIFxuXHQgKi9cblx0Y29uc3RydWN0b3IodmFsdWVzKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiN2YWx1ZXMgPSB2YWx1ZXM7XG5cdH1cblxuXHRnZXQgdmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgKCR7dGhpcy4jdmFsdWVzLm1hcCh2ID0+IHYudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SW5zdGFuY2VbXX0gdmFsc1xuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2VbXX1cblx0ICovXG5cdHN0YXRpYyBmbGF0dGVuKHZhbHMpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7SW5zdGFuY2VbXX1cblx0XHQgKi9cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cblx0XHRmb3IgKGxldCB2IG9mIHZhbHMpIHtcblx0XHRcdGlmICh2IGluc3RhbmNlb2YgTXVsdGlJbnN0YW5jZSkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQuY29uY2F0KHYudmFsdWVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHYpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5lZCBieSBmdW5jdGlvbnMgdGhhdCBkb24ndCByZXR1cm4gYW55dGhpbmcgKGVnLiBhc3NlcnQsIGVycm9yLCBwcmludClcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFZvaWRJbnN0YW5jZSBleHRlbmRzIEluc3RhbmNlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiKClcIlxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlIHwgVHlwZUNsYXNzfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSW5zdGFuY2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0cmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBWb2lkVHlwZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0Z2V0VHlwZShzaXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBWb2lkVHlwZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtJbnN0YW5jZVtdfSBhcmdzXG5cdCAqIEBwYXJhbSB7e1tuYW1lOiBzdHJpbmddOiBJbnN0YW5jZX19IG5hbWVkQXJnc1xuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRjYWxsKHNpdGUsIGFyZ3MsIG5hbWVkQXJncyA9IHt9KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgY2FsbCB2b2lkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9IC0gY2FuIGJlIEZ1bmNJbnN0YW5jZSBvciBEYXRhSW5zdGFuY2Vcblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBnZXQgbWVtYmVyIG9mIHZvaWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRmllbGRzKHNpdGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBnZXQgbkZpZWxkcyBvZiB2b2lkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgZ2V0IGZpZWxkLXR5cGUgb2Ygdm9pZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldEZpZWxkSW5kZXgoc2l0ZSwgbmFtZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImNhbid0IGdldCBmaWVsZC10eXBlIG9mIHZvaWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImNhbid0IGdldCBjb25zdHIgaW5kZXggb2Ygdm9pZFwiKTtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybmVkIGJ5IGFuIGVycm9yKClcbiAqIFNwZWNpYWwgY2FzZSBvZiBuby1yZXR1cm4tdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhhdCBleGVjdXRpb24gY2FuJ3QgcHJvY2VlZC5cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEVycm9ySW5zdGFuY2UgZXh0ZW5kcyBWb2lkSW5zdGFuY2Uge1xuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdCBnZXRUeXBlKHNpdGUpIHtcblx0XHRyZXR1cm4gbmV3IEVycm9yVHlwZSgpO1xuXHR9XG59XG5cbi8qKlxuICogUGFyZW50LWNsYXNzIGZvciBBc3NlcnRGdW5jLCBFcnJvckZ1bmMgYW5kIFByaW50RnVuY1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQnVpbHRpbkZ1bmNJbnN0YW5jZSBleHRlbmRzIEZ1bmNJbnN0YW5jZSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBiYXNlIHBhdGggaW4gdGhlIElSIChlZy4gX19oZWxpb3NfX2Jvb2wsIF9faGVsaW9zX19lcnJvciwgZXRjLilcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKVxuXHR9XG59XG5cbi8qKlxuICogU3BlY2lhbCBidWlsdGluIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGFuIGVycm9yIGlmIGNvbmRpdGlvbiBpcyBmYWxzZSBhbmQgcmV0dXJucyBWb2lkXG4gKiBAcGFja2FnZVxuICovXG4gY2xhc3MgQXNzZXJ0RnVuYyBleHRlbmRzIEJ1aWx0aW5GdW5jSW5zdGFuY2Uge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgRnVuY1R5cGUoW25ldyBCb29sVHlwZSgpLCBuZXcgU3RyaW5nVHlwZSgpXSwgbmV3IFZvaWRUeXBlKCkpKTtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19hc3NlcnRcIjtcblx0fVxufVxuXG4vKipcbiAqIFNwZWNpYWwgYnVpbHRpbiBmdW5jdGlvbiB0aGF0IHRocm93cyBhbiBlcnJvciBhbmQgcmV0dXJucyBFcnJvckluc3RhbmNlIChzcGVjaWFsIGNhc2Ugb2YgVm9pZClcbiAqIEBwYWNrYWdlXG4gKi9cbiBjbGFzcyBFcnJvckZ1bmMgZXh0ZW5kcyBCdWlsdGluRnVuY0luc3RhbmNlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IEZ1bmNUeXBlKFtuZXcgU3RyaW5nVHlwZSgpXSwgbmV3IEVycm9yVHlwZSgpKSk7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fZXJyb3JcIjtcblx0fVxufVxuXG4vKipcbiAqIFNwZWNpYWwgYnVpbHRpbiBmdW5jdGlvbiB0aGF0IHByaW50cyBhIG1lc3NhZ2UgYW5kIHJldHVybnMgdm9pZFxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgUHJpbnRGdW5jIGV4dGVuZHMgQnVpbHRpbkZ1bmNJbnN0YW5jZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBGdW5jVHlwZShbbmV3IFN0cmluZ1R5cGUoKV0sIG5ldyBWb2lkVHlwZSgpKSk7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fcHJpbnRcIjtcblx0fVxufVxuXG4vKipcbiAqIFR5cGUgb2YgcmV0dXJuLXZhbHVlIG9mIGZ1bmN0aW9ucyB0aGF0IGRvbid0IHJldHVybiBhbnl0aGluZyAoZWcuIGFzc2VydCwgcHJpbnQsIGVycm9yKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVm9pZFR5cGUgZXh0ZW5kcyBUeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIigpXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHJldHVybiB0eXBlIGluc3RhbmNlb2YgVm9pZFR5cGU7XG5cdH1cbn1cblxuLyoqXG4gKiBUeXBlIG9mIHNwZWNpYWwgY2FzZSBvZiBuby1yZXR1cm4gdmFsdWUgd2hlcmUgZXhlY3V0aW9uIGNhbid0IGNvbnRpbnVlLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRXJyb3JUeXBlIGV4dGVuZHMgVm9pZFR5cGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRyZXR1cm4gdHlwZSBpbnN0YW5jZW9mIEVycm9yVHlwZTtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gSW50IHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEludFR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJJbnRcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19uZWdcIjpcblx0XHRcdGNhc2UgXCJfX3Bvc1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpc10sIG5ldyBJbnRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJfX2FkZFwiOlxuXHRcdFx0Y2FzZSBcIl9fc3ViXCI6XG5cdFx0XHRjYXNlIFwiX19tdWxcIjpcblx0XHRcdGNhc2UgXCJfX2RpdlwiOlxuXHRcdFx0Y2FzZSBcIl9fbW9kXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgSW50VHlwZSgpXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIl9fZ2VxXCI6XG5cdFx0XHRjYXNlIFwiX19ndFwiOlxuXHRcdFx0Y2FzZSBcIl9fbGVxXCI6XG5cdFx0XHRjYXNlIFwiX19sdFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IEludFR5cGUoKV0sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZnJvbV9iaWdfZW5kaWFuXCI6XG5cdFx0XHRjYXNlIFwiZnJvbV9saXR0bGVfZW5kaWFuXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgQnl0ZUFycmF5VHlwZSgpXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm1heFwiOlxuXHRcdFx0Y2FzZSBcIm1pblwiOiBcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBJbnRUeXBlKCksIG5ldyBJbnRUeXBlKCldLCBuZXcgSW50VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZnJvbV9iYXNlNThcIjpcblx0XHRcdGNhc2UgXCJwYXJzZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFN0cmluZ1R5cGUoKV0sIG5ldyBJbnRUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJkZWNvZGVfemlnemFnXCI6XG5cdFx0XHRjYXNlIFwiZW5jb2RlX3ppZ3phZ1wiOlxuXHRcdFx0Y2FzZSBcImFic1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImJvdW5kXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpLCBuZXcgSW50VHlwZSgpXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImJvdW5kX21pblwiOlxuXHRcdFx0Y2FzZSBcImJvdW5kX21heFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEludFR5cGUoKV0sIG5ldyBJbnRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJ0b19ib29sXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInRvX2JpZ19lbmRpYW5cIjpcblx0XHRcdGNhc2UgXCJ0b19saXR0bGVfZW5kaWFuXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgQnl0ZUFycmF5VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwidG9fYmFzZTU4XCI6XG5cdFx0XHRjYXNlIFwidG9faGV4XCI6XG5cdFx0XHRjYXNlIFwic2hvd1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFN0cmluZ1R5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19pbnRcIjtcblx0fVxuXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gSEludDtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gYm9vbCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBCb29sVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiQm9vbFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJfX25vdFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpc10sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiX19hbmRcIjpcblx0XHRcdGNhc2UgXCJfX29yXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgQm9vbFR5cGUoKV0sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiYW5kXCI6XG5cdFx0XHRjYXNlIFwib3JcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbXSwgbmV3IEJvb2xUeXBlKCkpLCBuZXcgRnVuY1R5cGUoW10sIG5ldyBCb29sVHlwZSgpKV0sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwidG9faW50XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgSW50VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwic2hvd1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFN0cmluZ1R5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInRyYWNlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgU3RyaW5nVHlwZSgpXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19ib29sXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gQm9vbDtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gc3RyaW5nIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0cmluZ1R5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTdHJpbmdcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19hZGRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW3RoaXMsIG5ldyBTdHJpbmdUeXBlKCldLCBuZXcgU3RyaW5nVHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwic3RhcnRzX3dpdGhcIjpcblx0XHRcdGNhc2UgXCJlbmRzX3dpdGhcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTdHJpbmdUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImVuY29kZV91dGY4XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgQnl0ZUFycmF5VHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc3RyaW5nXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gSFN0cmluZztcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gYnl0ZWFycmF5IHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEJ5dGVBcnJheVR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdCNzaXplO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gez9udW1iZXJ9IHNpemUgLSBjYW4gYmUgbnVsbCBvciAzMiAocmVzdWx0IG9mIGhhc2hpbmcpXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXplID0gbnVsbCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLiNzaXplID0gc2l6ZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkJ5dGVBcnJheVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJfX2FkZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IEJ5dGVBcnJheVR5cGUoKV0sIG5ldyBCeXRlQXJyYXlUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJfX2dlcVwiOlxuXHRcdFx0Y2FzZSBcIl9fZ3RcIjpcblx0XHRcdGNhc2UgXCJfX2xlcVwiOlxuXHRcdFx0Y2FzZSBcIl9fbHRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW3RoaXMsIG5ldyBCeXRlQXJyYXlUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImxlbmd0aFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBJbnRUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcInNsaWNlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpLCBuZXcgSW50VHlwZSgpXSwgbmV3IEJ5dGVBcnJheVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInN0YXJ0c193aXRoXCI6XG5cdFx0XHRjYXNlIFwiZW5kc193aXRoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgQnl0ZUFycmF5VHlwZSgpXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJwcmVwZW5kXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpXSwgbmV3IEJ5dGVBcnJheVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInNoYTJcIjpcblx0XHRcdGNhc2UgXCJzaGEzXCI6XG5cdFx0XHRjYXNlIFwiYmxha2UyYlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEJ5dGVBcnJheVR5cGUoMzIpKSk7XG5cdFx0XHRjYXNlIFwiZGVjb2RlX3V0ZjhcIjpcblx0XHRcdGNhc2UgXCJzaG93XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgU3RyaW5nVHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gYF9faGVsaW9zX19ieXRlYXJyYXkke3RoaXMuI3NpemUgPT09IG51bGwgPyBcIlwiIDogdGhpcy4jc2l6ZX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIEJ5dGVBcnJheTtcblx0fVxufVxuXG5cbmNsYXNzIFBhcmFtVHlwZSBleHRlbmRzIFR5cGUge1xuXHQvKiogQHR5cGUgez9UeXBlfSAqL1xuXHQjdHlwZTtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0I25hbWU7XG5cblx0I2NoZWNrVHlwZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0eXBpY2FsbHkgXCJhXCIgb3IgXCJiXCJcblx0ICogQHBhcmFtIHs/KHNpdGU6IFNpdGUsIHR5cGU6IFR5cGUpID0+IHZvaWR9IGNoZWNrVHlwZVxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSwgY2hlY2tUeXBlID0gbnVsbCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jdHlwZSA9IG51bGw7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jY2hlY2tUeXBlID0gY2hlY2tUeXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNJbmZlcnJlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZSAhPT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKi9cblx0c2V0VHlwZShzaXRlLCB0eXBlKSB7XG5cdFx0aWYgKHRoaXMuI2NoZWNrVHlwZSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jY2hlY2tUeXBlKHNpdGUsIHR5cGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuI3R5cGUgPSB0eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHBhcmFtIHs/VHlwZX0gZXhwZWN0ZWRcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRzdGF0aWMgdW53cmFwKHR5cGUsIGV4cGVjdGVkID0gbnVsbCkge1xuXHRcdGlmICh0eXBlIGluc3RhbmNlb2YgQW55VHlwZSkge1xuXHRcdFx0aWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBleHBlY3RlZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBpbmZlciB0eXBlIG9mIEFueVR5cGVcIik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgUGFyYW1UeXBlKSB7XG5cdFx0XHRsZXQgb3JpZ1R5cGUgPSB0eXBlLnR5cGU7XG5cblx0XHRcdGlmIChvcmlnVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcblx0XHRcdFx0XHR0eXBlLnNldFR5cGUoU2l0ZS5kdW1teSgpLCBleHBlY3RlZCk7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cGVjdGVkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBpbmZlciBQYXJhbVR5cGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBvcmlnVHlwZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/VHlwZX1cblx0ICovXG5cdGdldCB0eXBlKCkge1xuXHRcdGlmICh0aGlzLiN0eXBlIGluc3RhbmNlb2YgUGFyYW1UeXBlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZS50eXBlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI25hbWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgbnVtYmVyIG9mIG1lbWJlcnMgb2YgYW4gZW51bSB0eXBlXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiBub3QgYW4gZW51bSB0eXBlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkVudW1NZW1iZXJzKHNpdGUpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGFyYW0gdHlwZSBub3QgeWV0IGluZmVyZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlLm5FbnVtTWVtYmVycyhzaXRlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZpZWxkcyBvZiBhIHN0cnVjdCwgZW51bSBtZW1iZXIsIG9yIGJ1aWx0aW4gdHlwZS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkZpZWxkcyhzaXRlKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGUgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCd2ZSBiZWVuIHNldFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3R5cGUubkZpZWxkcyhzaXRlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaS10aCBmaWVsZCBvZiBhIFN0cnVjdCBvciBhbiBFbnVtTWVtYmVyXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGUgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCd2ZSBiZWVuIHNldFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3R5cGUuZ2V0RmllbGRUeXBlKHNpdGUsIGkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBpLXRoIGZpZWxkIG9mIGEgU3RydWN0IG9yIGFuIEVudW1NZW1iZXJcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRGaWVsZEluZGV4KHNpdGUsIG5hbWUpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2hvdWxkJ3ZlIGJlZW4gc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZS5nZXRGaWVsZEluZGV4KHNpdGUsIG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2hvdWxkJ3ZlIGJlZW4gc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZS5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zICd0cnVlJyBpZiAndGhpcycgaXMgYSBiYXNlLXR5cGUgb2YgJ3R5cGUnLiBUaHJvd3MgYW4gZXJyb3IgaWYgJ3RoaXMnIGlzbid0IGEgVHlwZS5cblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zZXRUeXBlKHNpdGUsIHR5cGUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlLmlzQmFzZU9mKHNpdGUsIHR5cGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBiYXNlIHBhdGggb2YgdHlwZSAoZWcuIF9faGVsaW9zX19ib29sKS5cblx0ICogVGhpcyBpcyB1c2VkIGV4dGVuc2l2ZWx5IGluIHRoZSBJbnRlcm1lZGlhdGUgUmVwcmVzZW50YXRpb24uXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRpZiAodGhpcy4jdHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGFyYW0gdHlwZSBub3QgeWV0IGluZmVyZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlLnBhdGg7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgUGFyYW1GdW5jVmFsdWUgZXh0ZW5kcyBGdW5jSW5zdGFuY2Uge1xuXHQjcGFyYW1zO1xuXHQjZm5UeXBlO1xuXHQjY29ycmVjdE1lbWJlck5hbWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGFyYW1UeXBlW119IHBhcmFtc1xuXHQgKiBAcGFyYW0ge0Z1bmNUeXBlfSBmblR5cGUgXG5cdCAqIEBwYXJhbSB7PygpID0+IHN0cmluZ30gY29ycmVjdE1lbWJlck5hbWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmFtcywgZm5UeXBlLCBjb3JyZWN0TWVtYmVyTmFtZSA9IG51bGwpIHtcblx0XHRzdXBlcihmblR5cGUpO1xuXHRcdHRoaXMuI3BhcmFtcyA9IHBhcmFtcztcblx0XHR0aGlzLiNmblR5cGUgPSBmblR5cGU7XG5cdFx0dGhpcy4jY29ycmVjdE1lbWJlck5hbWUgPSBjb3JyZWN0TWVtYmVyTmFtZTtcblx0fVxuXG5cdGdldCBjb3JyZWN0TWVtYmVyTmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jY29ycmVjdE1lbWJlck5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhbGxJbmZlcnJlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jcGFyYW1zLmV2ZXJ5KHAgPT4gcC5pc0luZmVycmVkKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZuVHlwZS50b1N0cmluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRnZXRUeXBlKHNpdGUpIHtcblx0XHRpZiAodGhpcy5hbGxJbmZlcnJlZCgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jZm5UeXBlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImNhbid0IGdldCB0eXBlIG9mIHR5cGUgcGFyYW1ldHJpYyBmdW5jdGlvblwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNJbnN0YW5jZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRpZiAodGhpcy5hbGxJbmZlcnJlZCgpKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBGdW5jSW5zdGFuY2UodGhpcy4jZm5UeXBlKSkuaXNJbnN0YW5jZU9mKHNpdGUsIHR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImNhbid0IGRldGVybWluZSBpZiB0eXBlIHBhcmFtZXRyaWMgZnVuY3Rpb24gaXMgaW5zdGFuY2VvZiBhIHR5cGVcIik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtJbnN0YW5jZVtdfSBhcmdzXG5cdCAqIEBwYXJhbSB7e1tuYW1lOiBzdHJpbmddOiBJbnN0YW5jZX19IG5hbWVkQXJnc1xuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRjYWxsKHNpdGUsIGFyZ3MsIG5hbWVkQXJncyA9IHt9KSB7XG5cdFx0cmV0dXJuIChuZXcgRnVuY0luc3RhbmNlKHRoaXMuI2ZuVHlwZSkpLmNhbGwoc2l0ZSwgYXJncywgbmFtZWRBcmdzKTtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gbGlzdCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBMaXN0VHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0I2l0ZW1UeXBlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R5cGV9IGl0ZW1UeXBlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoaXRlbVR5cGUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI2l0ZW1UeXBlID0gaXRlbVR5cGU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge1R5cGV9XG5cdCAqL1xuXHRnZXQgaXRlbVR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2l0ZW1UeXBlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBbXSR7dGhpcy4jaXRlbVR5cGUudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHR0eXBlID0gUGFyYW1UeXBlLnVud3JhcCh0eXBlLCB0aGlzKTtcblxuXHRcdGlmICh0eXBlIGluc3RhbmNlb2YgTGlzdFR5cGUpIHtcblx0XHRcdHJldHVybiB0aGlzLiNpdGVtVHlwZS5pc0Jhc2VPZihzaXRlLCB0eXBlLml0ZW1UeXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19hZGRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW3RoaXMsIHRoaXNdLCB0aGlzKSk7XG5cdFx0XHRjYXNlIFwibmV3XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpLCBuZXcgRnVuY1R5cGUoW25ldyBJbnRUeXBlKCldLCB0aGlzLiNpdGVtVHlwZSldLCB0aGlzKSk7XG5cdFx0XHRjYXNlIFwibmV3X2NvbnN0XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpLCB0aGlzLiNpdGVtVHlwZV0sIHRoaXMpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJsZW5ndGhcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgSW50VHlwZSgpKTtcblx0XHRcdGNhc2UgXCJoZWFkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcodGhpcy4jaXRlbVR5cGUpO1xuXHRcdFx0Y2FzZSBcInRhaWxcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgTGlzdFR5cGUodGhpcy4jaXRlbVR5cGUpKTtcblx0XHRcdGNhc2UgXCJpc19lbXB0eVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJnZXRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBJbnRUeXBlKCldLCB0aGlzLiNpdGVtVHlwZSkpO1xuXHRcdFx0Y2FzZSBcInByZXBlbmRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW3RoaXMuI2l0ZW1UeXBlXSwgbmV3IExpc3RUeXBlKHRoaXMuI2l0ZW1UeXBlKSkpO1xuXHRcdFx0Y2FzZSBcImFueVwiOlxuXHRcdFx0Y2FzZSBcImFsbFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNpdGVtVHlwZV0sIG5ldyBCb29sVHlwZSgpKV0sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZmluZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNpdGVtVHlwZV0sIG5ldyBCb29sVHlwZSgpKV0sIHRoaXMuI2l0ZW1UeXBlKSk7XG5cdFx0XHRjYXNlIFwiZmluZF9zYWZlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI2l0ZW1UeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgbmV3IE9wdGlvblR5cGUodGhpcy4jaXRlbVR5cGUpKSk7XG5cdFx0XHRjYXNlIFwiZmlsdGVyXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI2l0ZW1UeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgbmV3IExpc3RUeXBlKHRoaXMuI2l0ZW1UeXBlKSkpO1xuXHRcdFx0Y2FzZSBcImZvcl9lYWNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI2l0ZW1UeXBlXSwgbmV3IFZvaWRUeXBlKCkpXSwgbmV3IFZvaWRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJmb2xkXCI6IHtcblx0XHRcdFx0bGV0IGEgPSBuZXcgUGFyYW1UeXBlKFwiYVwiKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBQYXJhbUZ1bmNWYWx1ZShbYV0sIG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFthLCB0aGlzLiNpdGVtVHlwZV0sIGEpLCBhXSwgYSkpO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBcImZvbGRfbGF6eVwiOiB7XG5cdFx0XHRcdGxldCBhID0gbmV3IFBhcmFtVHlwZShcImFcIik7XG5cdFx0XHRcdHJldHVybiBuZXcgUGFyYW1GdW5jVmFsdWUoW2FdLCBuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4jaXRlbVR5cGUsIG5ldyBGdW5jVHlwZShbXSwgYSldLCBhKSwgYV0sIGEpKTtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJtYXBcIjoge1xuXHRcdFx0XHRsZXQgYSA9IG5ldyBQYXJhbVR5cGUoXCJhXCIpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IFBhcmFtRnVuY1ZhbHVlKFthXSwgbmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI2l0ZW1UeXBlXSwgYSldLCBuZXcgTGlzdFR5cGUoYSkpLCAoKSA9PiB7XG5cdFx0XHRcdFx0bGV0IHR5cGUgPSBhLnR5cGU7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCd2ZSBiZWVuIGluZmVycmVkIGJ5IG5vd1wiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKChuZXcgQm9vbFR5cGUoKSkuaXNCYXNlT2YoU2l0ZS5kdW1teSgpLCB0eXBlKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJtYXBfdG9fYm9vbFwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwibWFwXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJnZXRfc2luZ2xldG9uXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCB0aGlzLiNpdGVtVHlwZSkpO1xuXHRcdFx0Y2FzZSBcInNvcnRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4jaXRlbVR5cGUsIHRoaXMuI2l0ZW1UeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgbmV3IExpc3RUeXBlKHRoaXMuI2l0ZW1UeXBlKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIGBfX2hlbGlvc19fJHt0aGlzLiNpdGVtVHlwZSBpbnN0YW5jZW9mIEJvb2xUeXBlID8gXCJib29sXCIgOiBcIlwifWxpc3RgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIEhMaXN0KHRoaXMuI2l0ZW1UeXBlLnVzZXJUeXBlKTtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gbWFwIHR5cGUgKGluIHJlYWxpdHkgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBNYXBUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHQja2V5VHlwZTtcblx0I3ZhbHVlVHlwZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtUeXBlfSBrZXlUeXBlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHZhbHVlVHlwZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGtleVR5cGUsIHZhbHVlVHlwZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4ja2V5VHlwZSA9IGtleVR5cGU7XG5cdFx0dGhpcy4jdmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtUeXBlfVxuXHQgKi9cblx0Z2V0IGtleVR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2tleVR5cGU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge1R5cGV9XG5cdCAqL1xuXHRnZXQgdmFsdWVUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZVR5cGU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYE1hcFske3RoaXMuI2tleVR5cGUudG9TdHJpbmcoKX1dJHt0aGlzLiN2YWx1ZVR5cGUudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHR0eXBlID0gUGFyYW1UeXBlLnVud3JhcCh0eXBlLCB0aGlzKTtcblxuXHRcdGlmICh0eXBlIGluc3RhbmNlb2YgTWFwVHlwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2tleVR5cGUuaXNCYXNlT2Yoc2l0ZSwgdHlwZS4ja2V5VHlwZSkgJiYgdGhpcy4jdmFsdWVUeXBlLmlzQmFzZU9mKHNpdGUsIHR5cGUuI3ZhbHVlVHlwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIl9fYWRkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCB0aGlzXSwgdGhpcykpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImFsbFwiOlxuXHRcdFx0Y2FzZSBcImFueVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGVdLCBuZXcgQm9vbFR5cGUoKSldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImRlbGV0ZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZV0sIHRoaXMpKTtcblx0XHRcdGNhc2UgXCJmaWx0ZXJcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgdGhpcykpO1xuXHRcdFx0Y2FzZSBcImZpbmRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgW3RoaXMuI2tleVR5cGUsIHRoaXMuI3ZhbHVlVHlwZV0pKTtcblx0XHRcdGNhc2UgXCJmaW5kX3NhZmVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgW25ldyBGdW5jVHlwZShbXSwgW3RoaXMuI2tleVR5cGUsIHRoaXMuI3ZhbHVlVHlwZV0pLCBuZXcgQm9vbFR5cGUoKV0pKVxuXHRcdFx0Y2FzZSBcImZpbmRfa2V5XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI2tleVR5cGVdLCBuZXcgQm9vbFR5cGUoKSldLCB0aGlzLiNrZXlUeXBlKSk7XG5cdFx0XHRjYXNlIFwiZmluZF9rZXlfc2FmZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNrZXlUeXBlXSwgbmV3IEJvb2xUeXBlKCkpXSwgbmV3IE9wdGlvblR5cGUodGhpcy4ja2V5VHlwZSkpKTtcblx0XHRcdGNhc2UgXCJmaW5kX3ZhbHVlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgRnVuY1R5cGUoW3RoaXMuI3ZhbHVlVHlwZV0sIG5ldyBCb29sVHlwZSgpKV0sIHRoaXMuI3ZhbHVlVHlwZSkpO1xuXHRcdFx0Y2FzZSBcImZpbmRfdmFsdWVfc2FmZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiN2YWx1ZVR5cGVdLCBuZXcgQm9vbFR5cGUoKSldLCBuZXcgT3B0aW9uVHlwZSh0aGlzLiN2YWx1ZVR5cGUpKSk7XG5cdFx0XHRjYXNlIFwiZm9sZFwiOiB7XG5cdFx0XHRcdGxldCBhID0gbmV3IFBhcmFtVHlwZShcImFcIik7XG5cdFx0XHRcdHJldHVybiBuZXcgUGFyYW1GdW5jVmFsdWUoW2FdLCBuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbYSwgdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgYSksIGFdLCBhKSk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiZm9sZF9sYXp5XCI6IHtcblx0XHRcdFx0bGV0IGEgPSBuZXcgUGFyYW1UeXBlKFwiYVwiKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBQYXJhbUZ1bmNWYWx1ZShbYV0sIG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGUsIG5ldyBGdW5jVHlwZShbXSwgYSldLCBhKSwgYV0sIGEpKTtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJmb3JfZWFjaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGVdLCBuZXcgVm9pZFR5cGUoKSldLCBuZXcgVm9pZFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZV0sIHRoaXMuI3ZhbHVlVHlwZSkpO1xuXHRcdFx0Y2FzZSBcImdldF9zYWZlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLiNrZXlUeXBlXSwgbmV3IE9wdGlvblR5cGUodGhpcy4jdmFsdWVUeXBlKSkpO1xuXHRcdFx0Y2FzZSBcImhlYWRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIFt0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGVdKSk7XG5cdFx0XHRjYXNlIFwiaGVhZF9rZXlcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyh0aGlzLiNrZXlUeXBlKTtcblx0XHRcdGNhc2UgXCJoZWFkX3ZhbHVlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcodGhpcy4jdmFsdWVUeXBlKTtcblx0XHRcdGNhc2UgXCJpc19lbXB0eVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJsZW5ndGhcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgSW50VHlwZSgpKTtcblx0XHRcdGNhc2UgXCJtYXBcIjoge1xuXHRcdFx0XHRsZXQgYSA9IG5ldyBQYXJhbVR5cGUoXCJhXCIsIChzaXRlLCB0eXBlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKChuZXcgQm9vbFR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkpIHtcblx0XHRcdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwiTWFwIGtleXMgY2FuJ3QgYmUgb2YgJ0Jvb2wnIHR5cGVcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRsZXQgYiA9IG5ldyBQYXJhbVR5cGUoXCJiXCIpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgUGFyYW1GdW5jVmFsdWUoW2EsIGJdLCBuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgW2EsIGJdKV0sIG5ldyBNYXBUeXBlKGEsIGIpKSwgKCkgPT4ge1xuXHRcdFx0XHRcdGxldCB0eXBlID0gYi50eXBlO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQndmUgYmVlbiBpbmZlcnJlZCBieSBub3dcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgobmV3IEJvb2xUeXBlKCkpLmlzQmFzZU9mKFNpdGUuZHVtbXkoKSwgdHlwZSkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwibWFwX3RvX2Jvb2xcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBcIm1hcFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwicHJlcGVuZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgdGhpcykpO1xuXHRcdFx0Y2FzZSBcInNldFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlXSwgdGhpcykpO1xuXHRcdFx0Y2FzZSBcInNvcnRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBGdW5jVHlwZShbdGhpcy4ja2V5VHlwZSwgdGhpcy4jdmFsdWVUeXBlLCB0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGVdLCBuZXcgQm9vbFR5cGUoKSldLCBuZXcgTWFwVHlwZSh0aGlzLiNrZXlUeXBlLCB0aGlzLiN2YWx1ZVR5cGUpKSk7XG5cdFx0XHRjYXNlIFwidGFpbFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIGBfX2hlbGlvc19fJHt0aGlzLiN2YWx1ZVR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZSA/IFwiYm9vbFwiIDogXCJcIn1tYXBgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIEhNYXAodGhpcy4ja2V5VHlwZS51c2VyVHlwZSwgdGhpcy4jdmFsdWVUeXBlLnVzZXJUeXBlKTtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gb3B0aW9uIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE9wdGlvblR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdCNzb21lVHlwZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtUeXBlfSBzb21lVHlwZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNvbWVUeXBlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNzb21lVHlwZSA9IHNvbWVUeXBlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBPcHRpb25bJHt0aGlzLiNzb21lVHlwZS50b1N0cmluZygpfV1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHR5cGUgPSBQYXJhbVR5cGUudW53cmFwKHR5cGUsIHRoaXMpO1xuXG5cdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBPcHRpb25UeXBlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jc29tZVR5cGUuaXNCYXNlT2Yoc2l0ZSwgdHlwZS4jc29tZVR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBPcHRpb25Tb21lVHlwZSh0aGlzLiNzb21lVHlwZSkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8IFxuXHRcdFx0XHQobmV3IE9wdGlvbk5vbmVUeXBlKHRoaXMuI3NvbWVUeXBlKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJTb21lXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgT3B0aW9uU29tZVR5cGUodGhpcy4jc29tZVR5cGUpO1xuXHRcdFx0Y2FzZSBcIk5vbmVcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBPcHRpb25Ob25lVHlwZSh0aGlzLiNzb21lVHlwZSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwibWFwXCI6IHtcblx0XHRcdFx0bGV0IGEgPSBuZXcgUGFyYW1UeXBlKFwiYVwiKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBQYXJhbUZ1bmNWYWx1ZShbYV0sIG5ldyBGdW5jVHlwZShbbmV3IEZ1bmNUeXBlKFt0aGlzLiNzb21lVHlwZV0sIGEpXSwgbmV3IE9wdGlvblR5cGUoYSkpLCAoKSA9PiB7XG5cdFx0XHRcdFx0bGV0IHR5cGUgPSBhLnR5cGU7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCd2ZSBiZWVuIGluZmVycmVkIGJ5IG5vd1wiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKChuZXcgQm9vbFR5cGUoKSkuaXNCYXNlT2YoU2l0ZS5kdW1teSgpLCB0eXBlKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJtYXBfdG9fYm9vbFwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwibWFwXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJ1bndyYXBcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIHRoaXMuI3NvbWVUeXBlKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gYF9faGVsaW9zX18ke3RoaXMuI3NvbWVUeXBlIGluc3RhbmNlb2YgQm9vbFR5cGUgPyBcImJvb2xcIiA6IFwiXCJ9b3B0aW9uYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0Z2V0IHVzZXJUeXBlKCkge1xuXHRcdHJldHVybiBPcHRpb24odGhpcy4jc29tZVR5cGUudXNlclR5cGUpO1xuXHR9XG59XG5cbi8qKlxuICogTWVtYmVyIHR5cGUgb2YgT3B0aW9uVHlwZSB3aXRoIHNvbWUgY29udGVudFxuICovXG5jbGFzcyBPcHRpb25Tb21lVHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0I3NvbWVUeXBlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R5cGV9IHNvbWVUeXBlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc29tZVR5cGUpIHtcblx0XHRzdXBlcihuZXcgT3B0aW9uVHlwZShzb21lVHlwZSkpO1xuXHRcdHRoaXMuI3NvbWVUeXBlID0gc29tZVR5cGU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYE9wdGlvblske3RoaXMuI3NvbWVUeXBlLnRvU3RyaW5nKCl9XTo6U29tZWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdHR5cGUgPSBQYXJhbVR5cGUudW53cmFwKHR5cGUsIHRoaXMpO1xuXG5cdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBPcHRpb25Tb21lVHlwZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3NvbWVUeXBlLmlzQmFzZU9mKHNpdGUsIHR5cGUuI3NvbWVUeXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5GaWVsZHMoc2l0ZSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0YXNzZXJ0KGkgPT0gMCk7XG5cdFx0cmV0dXJuIHRoaXMuI3NvbWVUeXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0RmllbGRJbmRleChzaXRlLCBuYW1lKSB7XG5cdFx0YXNzZXJ0KG5hbWUgPT0gXCJzb21lXCIpO1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInNvbWVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyh0aGlzLiNzb21lVHlwZSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBgX19oZWxpb3NfXyR7dGhpcy4jc29tZVR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZSA/IFwiYm9vbFwiIDogXCJcIn1vcHRpb25fX3NvbWVgO1xuXHR9XG59XG5cbi8qKlxuICogTWVtYmVyIHR5cGUgb2YgT3B0aW9uVHlwZSB3aXRoIG5vIGNvbnRlbnRcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE9wdGlvbk5vbmVUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHQjc29tZVR5cGU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZX0gc29tZVR5cGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihzb21lVHlwZSkge1xuXHRcdHN1cGVyKG5ldyBPcHRpb25UeXBlKHNvbWVUeXBlKSk7XG5cdFx0dGhpcy4jc29tZVR5cGUgPSBzb21lVHlwZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgT3B0aW9uWyR7dGhpcy4jc29tZVR5cGUudG9TdHJpbmcoKX1dOjpOb25lYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0dHlwZSA9IFBhcmFtVHlwZS51bndyYXAodHlwZSwgdGhpcyk7XG5cblx0XHRpZiAodHlwZSBpbnN0YW5jZW9mIE9wdGlvbk5vbmVUeXBlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jc29tZVR5cGUuaXNCYXNlT2Yoc2l0ZSwgdHlwZS4jc29tZVR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBgX19oZWxpb3NfXyR7dGhpcy4jc29tZVR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZSA/IFwiYm9vbFwiIDogXCJcIn1vcHRpb25fX25vbmVgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBzZWxmIGFzIHZhbHVlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRhc3NlcnRWYWx1ZShzaXRlKSB7XG5cdFx0cmV0dXJuIEluc3RhbmNlLm5ldyh0aGlzKTtcblx0fVxufVxuXG4vKipcbiAqIEJhc2UgdHlwZSBvZiBvdGhlciBWYWxpZGF0b3JIYXNoIGV0Yy4gKGFsbCBmdW5jdGlvbmFsaXR5IGlzIGFjdHVhbGx5IGltcGxlbWVudGVkIGhlcmUpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBIYXNoVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19nZXFcIjpcblx0XHRcdGNhc2UgXCJfX2d0XCI6XG5cdFx0XHRjYXNlIFwiX19sZXFcIjpcblx0XHRcdGNhc2UgXCJfX2x0XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCB0aGlzXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJuZXdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBCeXRlQXJyYXlUeXBlKCldLCB0aGlzKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwic2hvd1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFN0cmluZ1R5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19oYXNoXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFB1YktleUhhc2ggdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgUHViS2V5SGFzaFR5cGUgZXh0ZW5kcyBIYXNoVHlwZSB7XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlB1YktleUhhc2hcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0Z2V0IHVzZXJUeXBlKCkge1xuXHRcdHJldHVybiBQdWJLZXlIYXNoO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFrZUtleUhhc2ggdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgU3Rha2VLZXlIYXNoVHlwZSBleHRlbmRzIEhhc2hUeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2VLZXlIYXNoXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gU3Rha2VLZXlIYXNoO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBQdWJLZXkgdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgUHViS2V5VHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiUHViS2V5XCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEJ5dGVBcnJheVR5cGUoKV0sIHRoaXMpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInNob3dcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTdHJpbmdUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJ2ZXJpZnlcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBCeXRlQXJyYXlUeXBlKCksIG5ldyBCeXRlQXJyYXlUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3B1YmtleVwiO1xuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhbGl6YXRpb24gb2YgVmFsaWRhdG9ySGFzaCB0eXBlIGFuZCBNaW50aW5nUG9saWN5SGFzaCB0eXBlXG4gKiBNdXN0IGJlIGNhc3QgYmVmb3JlIGJlaW5nIGFibGUgdG8gdXNlIHRoZSBIYXNoIHR5cGUgbWV0aG9kc1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgU2NyaXB0SGFzaFR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTY3JpcHRIYXNoXCI7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc2NyaXB0aGFzaFwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBWYWxpZGF0b3JIYXNoIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFZhbGlkYXRvckhhc2hUeXBlIGV4dGVuZHMgSGFzaFR5cGUge1xuXHQjcHVycG9zZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHB1cnBvc2UgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwdXJwb3NlID0gLTEpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI3B1cnBvc2UgPSBwdXJwb3NlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJDVVJSRU5UXCI6XG5cdFx0XHRcdGlmICh0aGlzLm1hY3Jvc0FsbG93ZWQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlNwZW5kaW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5UZXN0aW5nKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1ZhbGlkYXRvckhhc2g6OkNVUlJFTlQnIG9ubHkgYXZhaWxhYmxlIGluIHNwZW5kaW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidWYWxpZGF0b3JIYXNoOjpDVVJSRU5UJyBjYW4gb25seSBiZSB1c2VkIGFmdGVyICdtYWluJ1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcImZyb21fc2NyaXB0X2hhc2hcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTY3JpcHRIYXNoVHlwZSgpXSwgbmV3IFZhbGlkYXRvckhhc2hUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlZhbGlkYXRvckhhc2hcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0Z2V0IHVzZXJUeXBlKCkge1xuXHRcdHJldHVybiBWYWxpZGF0b3JIYXNoO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBNaW50aW5nUG9saWN5SGFzaCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBNaW50aW5nUG9saWN5SGFzaFR5cGUgZXh0ZW5kcyBIYXNoVHlwZSB7XG5cdCNwdXJwb3NlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcHVycG9zZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHB1cnBvc2UgPSAtMSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jcHVycG9zZSA9IHB1cnBvc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIkNVUlJFTlRcIjpcblx0XHRcdFx0aWYgKHRoaXMubWFjcm9zQWxsb3dlZCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuTWludGluZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyh0aGlzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidNaW50aW5nUG9saWN5SGFzaDo6Q1VSUkVOVCcgb25seSBhdmFpbGFibGUgaW4gbWludGluZyBzY3JpcHRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInTWludGluZ1BvbGljeUhhc2g6OkNVUlJFTlQnIGNhbiBvbmx5IGJlIHVzZWQgYWZ0ZXIgJ21haW4nXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwiZnJvbV9zY3JpcHRfaGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFNjcmlwdEhhc2hUeXBlKCldLCBuZXcgTWludGluZ1BvbGljeUhhc2hUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIk1pbnRpbmdQb2xpY3lIYXNoXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gTWludGluZ1BvbGljeUhhc2g7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFN0YWtpbmdWYWxpZGF0b3JIYXNoIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0YWtpbmdWYWxpZGF0b3JIYXNoVHlwZSBleHRlbmRzIEhhc2hUeXBlIHtcblx0I3B1cnBvc2U7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwdXJwb3NlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IocHVycG9zZSA9IC0xKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNwdXJwb3NlID0gcHVycG9zZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiQ1VSUkVOVFwiOlxuXHRcdFx0XHRpZiAodGhpcy5tYWNyb3NBbGxvd2VkKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TdGFraW5nKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1N0YWtpbmdWYWxpZGF0b3JIYXNoOjpDVVJSRU5UJyBvbmx5IGF2YWlsYWJsZSBpbiBtaW50aW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidTdGFraW5nVmFsaWRhdG9ySGFzaDo6Q1VSUkVOVCcgY2FuIG9ubHkgYmUgdXNlZCBhZnRlciAnbWFpbidcIik7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJmcm9tX3NjcmlwdF9oYXNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgU2NyaXB0SGFzaFR5cGUoKV0sIG5ldyBTdGFraW5nVmFsaWRhdG9ySGFzaFR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2luZ1ZhbGlkYXRvckhhc2hcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0Z2V0IHVzZXJUeXBlKCkge1xuXHRcdHJldHVybiBTdGFraW5nVmFsaWRhdG9ySGFzaDtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gRGF0dW1IYXNoIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIERhdHVtSGFzaFR5cGUgZXh0ZW5kcyBIYXNoVHlwZSB7XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkRhdHVtSGFzaFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIERhdHVtSGFzaDtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU2NyaXB0Q29udGV4dCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTY3JpcHRDb250ZXh0VHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0I3B1cnBvc2U7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwdXJwb3NlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IocHVycG9zZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jcHVycG9zZSA9IHB1cnBvc2U7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTY3JpcHRDb250ZXh0XCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIm5ld19zcGVuZGluZ1wiOlxuXHRcdFx0XHRpZiAodGhpcy5tYWNyb3NBbGxvd2VkKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TcGVuZGluZyB8fCB0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuVGVzdGluZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBUeFR5cGUoKSwgbmV3IFR4T3V0cHV0SWRUeXBlKCldLCB0aGlzKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInU2NyaXB0Q29udGV4dDo6bmV3X3NwZW5kaW5nJyBvbmx5IGF2YWlhYmxlIGZvciBzcGVuZGluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TdGFraW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5NaW50aW5nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1NjcmlwdENvbnRleHQ6Om5ld19zcGVuZGluZycgb25seSBhdmFpYWJsZSBmb3Igc3BlbmRpbmcgIHNjcmlwdHNcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInU2NyaXB0Q29udGV4dDo6bmV3X3NwZW5kaW5nJyBjYW4gb25seSBiZSB1c2VkIGFmdGVyICdtYWluJ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJuZXdfbWludGluZ1wiOlxuXHRcdFx0XHRpZiAodGhpcy5tYWNyb3NBbGxvd2VkKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5NaW50aW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5UZXN0aW5nKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFR4VHlwZSgpLCBuZXcgTWludGluZ1BvbGljeUhhc2hUeXBlKCldLCB0aGlzKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInU2NyaXB0Q29udGV4dDo6bmV3X21pbnRpbmcnIG9ubHkgYXZhaWFibGUgZm9yIG1pbnRpbmcgc2NyaXB0c1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TdGFraW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TcGVuZGluZykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidTY3JpcHRDb250ZXh0OjpuZXdfbWludGluZycgb25seSBhdmFpYWJsZSBmb3IgbWludGluZyBzY3JpcHRzXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1NjcmlwdENvbnRleHQ6Om5ld19taW50aW5nJyBjYW4gb25seSBiZSB1c2VkIGFmdGVyICdtYWluJ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJuZXdfcmV3YXJkaW5nXCI6XG5cdFx0XHRcdGlmICh0aGlzLm1hY3Jvc0FsbG93ZWQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlN0YWtpbmcgfHwgdGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlRlc3RpbmcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgVHhUeXBlKCksIG5ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKV0sIHRoaXMpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidTY3JpcHRDb250ZXh0OjpuZXdfcmV3YXJkaW5nJyBvbmx5IGF2YWlhYmxlIGZvciBzdGFraW5nIHNjcmlwdHNcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuU3BlbmRpbmcgfHwgdGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLk1pbnRpbmcpIHtcblx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInU2NyaXB0Q29udGV4dDo6bmV3X3Jld2FyZGluZycgb25seSBhdmFpYWJsZSBmb3Igc3Rha2luZyBzY3JpcHRzXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1NjcmlwdENvbnRleHQ6Om5ld19yZXdhcmRpbmcnIGNhbiBvbmx5IGJlIHVzZWQgYWZ0ZXIgJ21haW4nXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcIm5ld19jZXJ0aWZ5aW5nXCI6XG5cdFx0XHRcdGlmICh0aGlzLm1hY3Jvc0FsbG93ZWQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlN0YWtpbmcgfHwgdGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlRlc3RpbmcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgVHhUeXBlKCksIG5ldyBEQ2VydFR5cGUoKV0sIHRoaXMpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidTY3JpcHRDb250ZXh0OjpuZXdfY2VydGlmeWluZycgb25seSBhdmFpYWJsZSBmb3Igc3Rha2luZyBzY3JpcHRzXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlNwZW5kaW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5NaW50aW5nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwiJ1NjcmlwdENvbnRleHQ6Om5ld19jZXJ0aWZ5aW5nJyBvbmx5IGF2YWlhYmxlIGZvciBzdGFraW5nIHNjcmlwdHNcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInU2NyaXB0Q29udGV4dDo6bmV3X2NlcnRpZnlpbmcnIGNhbiBvbmx5IGJlIHVzZWQgYWZ0ZXIgJ21haW4nXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInR4XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFR4VHlwZSgpKTtcblx0XHRcdGNhc2UgXCJnZXRfc3BlbmRpbmdfcHVycG9zZV9vdXRwdXRfaWRcIjpcblx0XHRcdFx0aWYgKHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5NaW50aW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TdGFraW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIm5vdCBhdmFpbGFibGUgaW4gbWludGluZy9zdGFraW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFR4T3V0cHV0SWRUeXBlKCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcImdldF9jdXJyZW50X3ZhbGlkYXRvcl9oYXNoXCI6XG5cdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuTWludGluZyB8fCB0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuU3Rha2luZykge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCJub3QgYXZhaWxhYmxlIGluIG1pbnRpbmcvc3Rha2luZyBzY3JpcHRcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBWYWxpZGF0b3JIYXNoVHlwZSh0aGlzLiNwdXJwb3NlKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwiZ2V0X2N1cnJlbnRfbWludGluZ19wb2xpY3lfaGFzaFwiOlxuXHRcdFx0XHRpZiAodGhpcy4jcHVycG9zZSA9PSBTY3JpcHRQdXJwb3NlLlNwZW5kaW5nIHx8IHRoaXMuI3B1cnBvc2UgPT0gU2NyaXB0UHVycG9zZS5TdGFraW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIm5vdCBhdmFpbGFibGUgaW4gc3BlbmRpbmcvc3Rha2luZyBzY3JpcHRcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBNaW50aW5nUG9saWN5SGFzaFR5cGUodGhpcy4jcHVycG9zZSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcImdldF9jdXJyZW50X2lucHV0XCI6XG5cdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuTWludGluZyB8fCB0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuU3Rha2luZykge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCJub3QgYXZhaWxhYmxlIGluIG1pbnRpbmcvc3Rha2luZyBzY3JpcHRcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBUeElucHV0VHlwZSgpKSk7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJnZXRfY29udF9vdXRwdXRzXCI6XG5cdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuTWludGluZyB8fCB0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuU3Rha2luZykge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCJub3QgYXZhaWxhYmxlIGluIG1pbnRpbmcvc3Rha2luZyBzY3JpcHRcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBMaXN0VHlwZShuZXcgVHhPdXRwdXRUeXBlKCkpKSk7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJnZXRfc3Rha2luZ19wdXJwb3NlXCI6XG5cdFx0XHRcdGlmICh0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuTWludGluZyB8fCB0aGlzLiNwdXJwb3NlID09IFNjcmlwdFB1cnBvc2UuU3BlbmRpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKFwibm90IGF2YWlsYWJsZSBpbiBtaW50aW5nL3NwZW5kaW5nIHNjcmlwdFwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFN0YWtpbmdQdXJwb3NlVHlwZSgpKSk7XG5cdFx0XHRcdH1cblx0XHRcdGNhc2UgXCJnZXRfc2NyaXB0X3B1cnBvc2VcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTY3JpcHRQdXJwb3NlVHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU2NyaXB0UHVycG9zZSB0eXBlIChNaW50aW5nfCBTcGVuZGluZ3wgUmV3YXJkaW5nIHwgQ2VydGlmeWluZylcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFNjcmlwdFB1cnBvc2VUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTY3JpcHRQdXJwb3NlXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdGxldCBiID0gc3VwZXIuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHxcblx0XHRcdFx0KG5ldyBNaW50aW5nU2NyaXB0UHVycG9zZVR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHwgXG5cdFx0XHRcdChuZXcgU3BlbmRpbmdTY3JpcHRQdXJwb3NlVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBSZXdhcmRpbmdTY3JpcHRQdXJwb3NlVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBDZXJ0aWZ5aW5nU2NyaXB0UHVycG9zZVR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSk7IFxuXG5cdFx0cmV0dXJuIGI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIm5ld19taW50aW5nXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgTWludGluZ1BvbGljeUhhc2hUeXBlKCldLCBuZXcgTWludGluZ1NjcmlwdFB1cnBvc2VUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJuZXdfc3BlbmRpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBUeE91dHB1dElkVHlwZSgpXSwgbmV3IFNwZW5kaW5nU2NyaXB0UHVycG9zZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld19yZXdhcmRpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKV0sIG5ldyBSZXdhcmRpbmdTY3JpcHRQdXJwb3NlVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3X2NlcnRpZnlpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBEQ2VydFR5cGUoKV0sIG5ldyBDZXJ0aWZ5aW5nU2NyaXB0UHVycG9zZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIk1pbnRpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBNaW50aW5nU2NyaXB0UHVycG9zZVR5cGUoKTtcblx0XHRcdGNhc2UgXCJTcGVuZGluZ1wiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFNwZW5kaW5nU2NyaXB0UHVycG9zZVR5cGUoKTtcblx0XHRcdGNhc2UgXCJSZXdhcmRpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBSZXdhcmRpbmdTY3JpcHRQdXJwb3NlVHlwZSgpO1xuXHRcdFx0Y2FzZSBcIkNlcnRpZnlpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBDZXJ0aWZ5aW5nU2NyaXB0UHVycG9zZVR5cGUoKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRW51bU1lbWJlcnMoc2l0ZSkge1xuXHRcdHJldHVybiA0O1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU2NyaXB0UHVycG9zZTo6TWludGluZ1xuICovXG5jbGFzcyBNaW50aW5nU2NyaXB0UHVycG9zZVR5cGUgZXh0ZW5kcyBCdWlsdGluRW51bU1lbWJlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBTY3JpcHRQdXJwb3NlVHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlNjcmlwdFB1cnBvc2U6Ok1pbnRpbmdcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJwb2xpY3lfaGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBNaW50aW5nUG9saWN5SGFzaFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19taW50aW5nXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFNjcmlwdFB1cnBvc2U6OlNwZW5kaW5nXG4gKi9cbmNsYXNzIFNwZW5kaW5nU2NyaXB0UHVycG9zZVR5cGUgZXh0ZW5kcyBCdWlsdGluRW51bU1lbWJlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBTY3JpcHRQdXJwb3NlVHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlNjcmlwdFB1cnBvc2U6OlNwZW5kaW5nXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwib3V0cHV0X2lkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFR4T3V0cHV0SWRUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc2NyaXB0cHVycG9zZV9fc3BlbmRpbmdcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU2NyaXB0UHVycG9zZTo6UmV3YXJkaW5nXG4gKi9cbmNsYXNzIFJld2FyZGluZ1NjcmlwdFB1cnBvc2VUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHs/QnVpbHRpblR5cGV9IHBhcmVudFR5cGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXJlbnRUeXBlID0gbnVsbCkge1xuXHRcdHN1cGVyKHBhcmVudFR5cGUgPT09IG51bGwgPyBuZXcgU2NyaXB0UHVycG9zZVR5cGUoKSA6IHBhcmVudFR5cGUpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU2NyaXB0UHVycG9zZTo6UmV3YXJkaW5nXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiY3JlZGVudGlhbFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19yZXdhcmRpbmdcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU2NyaXB0UHVycG9zZTo6Q2VydGlmeWluZyB0eXBlXG4gKi9cbmNsYXNzIENlcnRpZnlpbmdTY3JpcHRQdXJwb3NlVHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7P0J1aWx0aW5UeXBlfSBwYXJlbnRUeXBlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXJlbnRUeXBlID0gbnVsbCkge1xuXHRcdHN1cGVyKHBhcmVudFR5cGUgPT09IG51bGwgPyBuZXcgU2NyaXB0UHVycG9zZVR5cGUoKSA6IHBhcmVudFR5cGUpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU2NyaXB0UHVycG9zZTo6Q2VydGlmeWluZ1wiO1xuXHR9XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiZGNlcnRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRENlcnRUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc2NyaXB0cHVycG9zZV9fY2VydGlmeWluZ1wiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nUHVycG9zZSB0eXBlIChSZXdhcmRpbmcgb3IgQ2VydGlmeWluZylcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0YWtpbmdQdXJwb3NlVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2luZ1B1cnBvc2VcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0bGV0IGIgPSBzdXBlci5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fFxuXHRcdFx0XHQobmV3IFN0YWtpbmdSZXdhcmRpbmdQdXJwb3NlVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBTdGFraW5nQ2VydGlmeWluZ1B1cnBvc2VUeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpOyBcblxuXHRcdHJldHVybiBiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJSZXdhcmRpbmdcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBTdGFraW5nUmV3YXJkaW5nUHVycG9zZVR5cGUoKTtcblx0XHRcdGNhc2UgXCJDZXJ0aWZ5aW5nXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgU3Rha2luZ0NlcnRpZnlpbmdQdXJwb3NlVHlwZSgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc3Rha2luZ3B1cnBvc2VcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gU3Rha2luZ1B1cnBvc2U6OlJld2FyZGluZ1xuICovXG5jbGFzcyBTdGFraW5nUmV3YXJkaW5nUHVycG9zZVR5cGUgZXh0ZW5kcyBSZXdhcmRpbmdTY3JpcHRQdXJwb3NlVHlwZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBTdGFraW5nUHVycG9zZVR5cGUoKSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTdGFraW5nUHVycG9zZTo6UmV3YXJkaW5nXCI7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc3Rha2luZ3B1cnBvc2VfX3Jld2FyZGluZ1wiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nUHVycG9zZTo6Q2VydGlmeWluZyB0eXBlXG4gKi9cbmNsYXNzIFN0YWtpbmdDZXJ0aWZ5aW5nUHVycG9zZVR5cGUgZXh0ZW5kcyBDZXJ0aWZ5aW5nU2NyaXB0UHVycG9zZVR5cGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgU3Rha2luZ1B1cnBvc2VUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2luZ1B1cnBvc2U6OkNlcnRpZnlpbmdcIjtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19zdGFraW5ncHVycG9zZV9fY2VydGlmeWluZ1wiO1xuXHR9XG59XG5cbi8qKlxuICogU3Rha2luZyBhY3Rpb24gdHlwZSAoY29uZnVzaW5nbHkgbmFtZWQgRChpZ2VzdCkob2YpP0NlcnQoaWZpY2F0ZSkpXG4gKiBUT0RPOiB0aGluayBvZiBiZXR0ZXIgbmFtZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRENlcnRUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJEQ2VydFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRsZXQgYiA9IHN1cGVyLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8XG5cdFx0XHRcdChuZXcgUmVnaXN0ZXJEQ2VydFR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHwgXG5cdFx0XHRcdChuZXcgRGVyZWdpc3RlckRDZXJ0VHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBEZWxlZ2F0ZURDZXJ0VHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBSZWdpc3RlclBvb2xEQ2VydFR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHxcblx0XHRcdFx0KG5ldyBSZXRpcmVQb29sRENlcnRUeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpOyBcblxuXHRcdHJldHVybiBiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdfcmVnaXN0ZXJcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKV0sIG5ldyBSZWdpc3RlckRDZXJ0VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3X2RlcmVnaXN0ZXJcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKV0sIG5ldyBEZXJlZ2lzdGVyRENlcnRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJuZXdfZGVsZWdhdGVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKSwgbmV3IFB1YktleUhhc2hUeXBlKCldLCBuZXcgRGVsZWdhdGVEQ2VydFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld19yZWdpc3Rlcl9wb29sXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgUHViS2V5SGFzaFR5cGUoKSwgbmV3IFB1YktleUhhc2hUeXBlKCldLCBuZXcgUmVnaXN0ZXJQb29sRENlcnRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJuZXdfcmV0aXJlX3Bvb2xcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBQdWJLZXlIYXNoVHlwZSgpLCBuZXcgSW50VHlwZSgpXSwgbmV3IFJldGlyZVBvb2xEQ2VydFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIlJlZ2lzdGVyXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0ZXJEQ2VydFR5cGUoKTtcblx0XHRcdGNhc2UgXCJEZXJlZ2lzdGVyXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgRGVyZWdpc3RlckRDZXJ0VHlwZSgpO1xuXHRcdFx0Y2FzZSBcIkRlbGVnYXRlXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgRGVsZWdhdGVEQ2VydFR5cGUoKTtcblx0XHRcdGNhc2UgXCJSZWdpc3RlclBvb2xcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdpc3RlclBvb2xEQ2VydFR5cGUoKTtcblx0XHRcdGNhc2UgXCJSZXRpcmVQb29sXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgUmV0aXJlUG9vbERDZXJ0VHlwZSgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIDU7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fZGNlcnRcIjtcblx0fVxufVxuXG5jbGFzcyBSZWdpc3RlckRDZXJ0VHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IERDZXJ0VHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkRDZXJ0OjpSZWdpc3RlclwiO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiY3JlZGVudGlhbFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19kY2VydF9fcmVnaXN0ZXJcIjtcblx0fVxufVxuXG5jbGFzcyBEZXJlZ2lzdGVyRENlcnRUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgRENlcnRUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiRENlcnQ6OkRlcmVnaXN0ZXJcIjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImNyZWRlbnRpYWxcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgU3Rha2luZ0NyZWRlbnRpYWxUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fZGNlcnRfX2RlcmVnaXN0ZXJcIjtcblx0fVxufVxuXG5jbGFzcyBEZWxlZ2F0ZURDZXJ0VHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IERDZXJ0VHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkRDZXJ0OjpEZWxlZ2F0ZVwiO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiZGVsZWdhdG9yXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJwb29sX2lkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFB1YktleUhhc2hUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fZGNlcnRfX2RlbGVnYXRlXCI7XG5cdH1cbn1cblxuY2xhc3MgUmVnaXN0ZXJQb29sRENlcnRUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgRENlcnRUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiRENlcnQ6OlJlZ2lzdGVyUG9vbFwiO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwicG9vbF9pZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBQdWJLZXlIYXNoVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJwb29sX3ZyZlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBQdWJLZXlIYXNoVHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHJldHVybiAzO1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX2RjZXJ0X19yZWdpc3RlcnBvb2xcIjtcblx0fVxufVxuXG5jbGFzcyBSZXRpcmVQb29sRENlcnRUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgRENlcnRUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiRENlcnQ6OlJldGlyZVBvb2xcIjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInBvb2xfaWRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgUHViS2V5SGFzaFR5cGUoKSk7XG5cdFx0XHRjYXNlIFwiZXBvY2hcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgSW50VHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHJldHVybiA0O1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX2RjZXJ0X19yZXRpcmVwb29sXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFR4IHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFR4VHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlR4XCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRpZiAodGhpcy5tYWNyb3NBbGxvd2VkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW1xuXHRcdFx0XHRcdFx0bmV3IExpc3RUeXBlKG5ldyBUeElucHV0VHlwZSgpKSwgLy8gMFxuXHRcdFx0XHRcdFx0bmV3IExpc3RUeXBlKG5ldyBUeElucHV0VHlwZSgpKSwgLy8gMVxuXHRcdFx0XHRcdFx0bmV3IExpc3RUeXBlKG5ldyBUeE91dHB1dFR5cGUoKSksIC8vIDJcblx0XHRcdFx0XHRcdG5ldyBWYWx1ZVR5cGUoKSwgLy8gM1xuXHRcdFx0XHRcdFx0bmV3IFZhbHVlVHlwZSgpLCAvLyA0XG5cdFx0XHRcdFx0XHRuZXcgTGlzdFR5cGUobmV3IERDZXJ0VHlwZSgpKSwgLy8gNVxuXHRcdFx0XHRcdFx0bmV3IE1hcFR5cGUobmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpLCBuZXcgSW50VHlwZSgpKSwgLy8gNlxuXHRcdFx0XHRcdFx0bmV3IFRpbWVSYW5nZVR5cGUoKSwgLy8gN1xuXHRcdFx0XHRcdFx0bmV3IExpc3RUeXBlKG5ldyBQdWJLZXlIYXNoVHlwZSgpKSwgLy8gOFxuXHRcdFx0XHRcdFx0bmV3IE1hcFR5cGUobmV3IFNjcmlwdFB1cnBvc2VUeXBlKCksIG5ldyBBbnlEYXRhVHlwZSgpKSwgLy8gOVxuXHRcdFx0XHRcdFx0bmV3IE1hcFR5cGUobmV3IERhdHVtSGFzaFR5cGUoKSwgbmV3IEFueURhdGFUeXBlKCkpIC8vIDEwXG5cdFx0XHRcdFx0XSwgdGhpcykpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoXCInVHg6Om5ldycgY2FuIG9ubHkgYmUgdXNlZCBhZnRlciAnbWFpbidcIik7XG5cdFx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJpbnB1dHNcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgTGlzdFR5cGUobmV3IFR4SW5wdXRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJyZWZfaW5wdXRzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IExpc3RUeXBlKG5ldyBUeElucHV0VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwib3V0cHV0c1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBMaXN0VHlwZShuZXcgVHhPdXRwdXRUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJmZWVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgVmFsdWVUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcIm1pbnRlZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBWYWx1ZVR5cGUoKSk7XG5cdFx0XHRjYXNlIFwiZGNlcnRzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IExpc3RUeXBlKG5ldyBEQ2VydFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIndpdGhkcmF3YWxzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IE1hcFR5cGUobmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpLCBuZXcgSW50VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwidGltZV9yYW5nZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBUaW1lUmFuZ2VUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcInNpZ25hdG9yaWVzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IExpc3RUeXBlKG5ldyBQdWJLZXlIYXNoVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwicmVkZWVtZXJzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IE1hcFR5cGUobmV3IFNjcmlwdFB1cnBvc2VUeXBlKCksIG5ldyBSYXdEYXRhVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZGF0dW1zXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IE1hcFR5cGUobmV3IERhdHVtSGFzaFR5cGUoKSwgbmV3IFJhd0RhdGFUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJpZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBUeElkVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJmaW5kX2RhdHVtX2hhc2hcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBBbnlEYXRhVHlwZSgpXSwgbmV3IERhdHVtSGFzaFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldF9kYXR1bV9kYXRhXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgVHhPdXRwdXRUeXBlKCldLCBuZXcgUmF3RGF0YVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm91dHB1dHNfc2VudF90b1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFB1YktleUhhc2hUeXBlKCldLCBuZXcgTGlzdFR5cGUobmV3IFR4T3V0cHV0VHlwZSgpKSkpO1xuXHRcdFx0Y2FzZSBcIm91dHB1dHNfc2VudF90b19kYXR1bVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFB1YktleUhhc2hUeXBlKCksIG5ldyBBbnlEYXRhVHlwZSgpLCBuZXcgQm9vbFR5cGUoKV0sIG5ldyBMaXN0VHlwZShuZXcgVHhPdXRwdXRUeXBlKCkpKSk7XG5cdFx0XHRjYXNlIFwib3V0cHV0c19sb2NrZWRfYnlcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBWYWxpZGF0b3JIYXNoVHlwZSgpXSwgbmV3IExpc3RUeXBlKG5ldyBUeE91dHB1dFR5cGUoKSkpKTtcblx0XHRcdGNhc2UgXCJvdXRwdXRzX2xvY2tlZF9ieV9kYXR1bVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFZhbGlkYXRvckhhc2hUeXBlKCksIG5ldyBBbnlEYXRhVHlwZSgpLCBuZXcgQm9vbFR5cGUoKV0sIG5ldyBMaXN0VHlwZShuZXcgVHhPdXRwdXRUeXBlKCkpKSk7XG5cdFx0XHRjYXNlIFwidmFsdWVfc2VudF90b1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFB1YktleUhhc2hUeXBlKCldLCBuZXcgVmFsdWVUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJ2YWx1ZV9zZW50X3RvX2RhdHVtXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgUHViS2V5SGFzaFR5cGUoKSwgbmV3IEFueURhdGFUeXBlKCksIG5ldyBCb29sVHlwZSgpXSwgbmV3IFZhbHVlVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwidmFsdWVfbG9ja2VkX2J5XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgVmFsaWRhdG9ySGFzaFR5cGUoKV0sIG5ldyBWYWx1ZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInZhbHVlX2xvY2tlZF9ieV9kYXR1bVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFZhbGlkYXRvckhhc2hUeXBlKCksIG5ldyBBbnlEYXRhVHlwZSgpLCBuZXcgQm9vbFR5cGUoKV0sIG5ldyBWYWx1ZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImlzX3NpZ25lZF9ieVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFB1YktleUhhc2hUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX190eFwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBUeElkIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFR4SWRUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJUeElkXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIl9fZ2VxXCI6XG5cdFx0XHRjYXNlIFwiX19ndFwiOlxuXHRcdFx0Y2FzZSBcIl9fbGVxXCI6XG5cdFx0XHRjYXNlIFwiX19sdFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgdGhpc10sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgQnl0ZUFycmF5VHlwZSgpXSwgdGhpcykpO1xuXHRcdFx0Y2FzZSBcIkNVUlJFTlRcIjpcblx0XHRcdFx0aWYgKHRoaXMubWFjcm9zQWxsb3dlZCkge1xuXHRcdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcodGhpcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidUeElkOjpDVVJSRU5UJyBjYW4gb25seSBiZSB1c2VkIGFmdGVyICdtYWluJ1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInNob3dcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTdHJpbmdUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX190eGlkXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gVHhJZDtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gVHhJbnB1dCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBUeElucHV0VHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiVHhJbnB1dFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdcIjpcblx0XHRcdFx0aWYgKHRoaXMubWFjcm9zQWxsb3dlZCkge1xuXHRcdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtcblx0XHRcdFx0XHRcdG5ldyBUeE91dHB1dElkVHlwZSgpLCAvLyAwXG5cdFx0XHRcdFx0XHRuZXcgVHhPdXRwdXRUeXBlKCksIC8vIDFcblx0XHRcdFx0XHRdLCB0aGlzKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihcIidUeElucHV0OjpuZXcnIGNhbiBvbmx5IGJlIHVzZWQgYWZ0ZXIgJ21haW4nXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwib3V0cHV0X2lkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFR4T3V0cHV0SWRUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcIm91dHB1dFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBUeE91dHB1dFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3R4aW5wdXRcIjtcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gVHhPdXRwdXQgdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVHhPdXRwdXRUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJUeE91dHB1dFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW1xuXHRcdFx0XHRcdG5ldyBBZGRyZXNzVHlwZSgpLCAvLyAwXG5cdFx0XHRcdFx0bmV3IFZhbHVlVHlwZSgpLCAvLyAxXG5cdFx0XHRcdFx0bmV3IE91dHB1dERhdHVtVHlwZSgpLCAvLyAyXG5cdFx0XHRcdF0sIHRoaXMpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJhZGRyZXNzXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEFkZHJlc3NUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcInZhbHVlXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFZhbHVlVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJkYXR1bVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBPdXRwdXREYXR1bVR5cGUoKSk7XG5cdFx0XHRjYXNlIFwicmVmX3NjcmlwdF9oYXNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IE9wdGlvblR5cGUobmV3IFNjcmlwdEhhc2hUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fdHhvdXRwdXRcIjtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE91dHB1dERhdHVtVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiT3V0cHV0RGF0dW1cIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0bGV0IGIgPSBzdXBlci5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fFxuXHRcdFx0XHQobmV3IE5vT3V0cHV0RGF0dW1UeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8IFxuXHRcdFx0XHQobmV3IEhhc2hlZE91dHB1dERhdHVtVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fCBcblx0XHRcdFx0KG5ldyBJbmxpbmVPdXRwdXREYXR1bVR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSk7OyBcblxuXHRcdHJldHVybiBiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdfbm9uZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IE5vT3V0cHV0RGF0dW1UeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJuZXdfaGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IERhdHVtSGFzaFR5cGUoKV0sIG5ldyBIYXNoZWRPdXRwdXREYXR1bVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld19pbmxpbmVcIjoge1xuXHRcdFx0XHRsZXQgYSA9IG5ldyBQYXJhbVR5cGUoXCJhXCIpO1xuXHRcdFx0XHRyZXR1cm4gbmV3IFBhcmFtRnVuY1ZhbHVlKFthXSwgbmV3IEZ1bmNUeXBlKFthXSwgbmV3IElubGluZU91dHB1dERhdHVtVHlwZSgpKSwgKCkgPT4ge1xuXHRcdFx0XHRcdGxldCB0eXBlID0gYS50eXBlO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQndmUgYmVlbiBpbmZlcnJlZCBieSBub3dcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChhLnR5cGUgaW5zdGFuY2VvZiBGdW5jVHlwZSkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuYW1lLnNpdGUudHlwZUVycm9yKFwiY2FuJ3QgdXNlIGZ1bmN0aW9uIGFzIGFyZ3VtZW50IHRvIE91dHB1dERhdHVtOjpuZXdfaW5saW5lKClcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChuZXcgQm9vbFR5cGUoKSkuaXNCYXNlT2YoU2l0ZS5kdW1teSgpLCB0eXBlKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJuZXdfaW5saW5lX2Zyb21fYm9vbFwiO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwibmV3X2lubGluZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiTm9uZVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IE5vT3V0cHV0RGF0dW1UeXBlKCk7XG5cdFx0XHRjYXNlIFwiSGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEhhc2hlZE91dHB1dERhdHVtVHlwZSgpO1xuXHRcdFx0Y2FzZSBcIklubGluZVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IElubGluZU91dHB1dERhdHVtVHlwZSgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImdldF9pbmxpbmVfZGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IFJhd0RhdGFUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkVudW1NZW1iZXJzKHNpdGUpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19vdXRwdXRkYXR1bVwiO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgTm9PdXRwdXREYXR1bVR5cGUgZXh0ZW5kcyBCdWlsdGluRW51bU1lbWJlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBPdXRwdXREYXR1bVR5cGUpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiT3V0cHV0RGF0dW06Ok5vbmVcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX25vbmVcIjtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEhhc2hlZE91dHB1dERhdHVtVHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IE91dHB1dERhdHVtVHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIk91dHB1dERhdHVtOjpIYXNoXCI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJoYXNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IERhdHVtSGFzaFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19vdXRwdXRkYXR1bV9faGFzaFwiO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSW5saW5lT3V0cHV0RGF0dW1UeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgT3V0cHV0RGF0dW1UeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiT3V0cHV0RGF0dW06OklubGluZVwiO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiZGF0YVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBSYXdEYXRhVHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19pbmxpbmVcIjtcblx0fVxufVxuXG4vKipcbiAqIFR5cGUgb2YgZXh0ZXJuYWwgZGF0YSB0aGF0IG11c3QgYmUgY2FzdC90eXBlLWNoZWNrZWQgYmVmb3JlIHVzaW5nXG4gKiBOb3QgbmFtZWQgJ0RhdGEnIGluIEpzIGJlY2F1c2UgaXQncyB0b28gZ2VuZXJpY1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgUmF3RGF0YVR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkRhdGFcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiZnJvbV9kYXRhXCI6XG5cdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoYGNhbGxpbmcgRGF0YTo6ZnJvbV9kYXRhKGRhdGEpIGlzIHVzZWxlc3NgKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJ0YWdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgSW50VHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fZGF0YVwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBUeE91dHB1dElkIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFR4T3V0cHV0SWRUeXBlIGV4dGVuZHMgQnVpbHRpblR5cGUge1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJUeE91dHB1dElkXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIl9fbHRcIjpcblx0XHRcdGNhc2UgXCJfX2xlcVwiOlxuXHRcdFx0Y2FzZSBcIl9fZ3RcIjpcblx0XHRcdGNhc2UgXCJfX2dlcVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IFR4T3V0cHV0SWRUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFR4SWRUeXBlKCksIG5ldyBJbnRUeXBlKCldLCBuZXcgVHhPdXRwdXRJZFR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInR4X2lkXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFR4SWRUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcImluZGV4XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEludFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fdHhvdXRwdXRpZFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIFR4T3V0cHV0SWQ7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWl0aW4gQWRkcmVzcyB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBBZGRyZXNzVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiQWRkcmVzc1wiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW1xuXHRcdFx0XHRcdG5ldyBDcmVkZW50aWFsVHlwZSgpLCAvLyAwXG5cdFx0XHRcdFx0bmV3IE9wdGlvblR5cGUobmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpKSwgLy8gMVxuXHRcdFx0XHRdLCB0aGlzKSk7XG5cdFx0XHRjYXNlIFwibmV3X2VtcHR5XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCB0aGlzKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiY3JlZGVudGlhbFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBDcmVkZW50aWFsVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJzdGFraW5nX2NyZWRlbnRpYWxcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgT3B0aW9uVHlwZShuZXcgU3Rha2luZ0NyZWRlbnRpYWxUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19hZGRyZXNzXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0hlbGlvc0RhdGFDbGFzczxIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCB1c2VyVHlwZSgpIHtcblx0XHRyZXR1cm4gQWRkcmVzcztcblx0fVxufVxuXG4vKipcbiAqIEJ1aWx0aW4gQ3JlZGVudGlhbCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBDcmVkZW50aWFsVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiQ3JlZGVudGlhbFwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQmFzZU9mKHNpdGUsIHR5cGUpIHtcblx0XHRsZXQgYiA9IHN1cGVyLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8XG5cdFx0XHRcdChuZXcgQ3JlZGVudGlhbFB1YktleVR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHwgXG5cdFx0XHRcdChuZXcgQ3JlZGVudGlhbFZhbGlkYXRvclR5cGUoKSkuaXNCYXNlT2Yoc2l0ZSwgdHlwZSk7IFxuXG5cdFx0cmV0dXJuIGI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcIlB1YktleVwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IENyZWRlbnRpYWxQdWJLZXlUeXBlKCk7XG5cdFx0XHRjYXNlIFwiVmFsaWRhdG9yXCI6XG5cdFx0XHRcdHJldHVybiBuZXcgQ3JlZGVudGlhbFZhbGlkYXRvclR5cGUoKTtcblx0XHRcdGNhc2UgXCJuZXdfcHVia2V5XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgUHViS2V5SGFzaFR5cGUoKV0sIG5ldyBDcmVkZW50aWFsUHViS2V5VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3X3ZhbGlkYXRvclwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFZhbGlkYXRvckhhc2hUeXBlKCldLCBuZXcgQ3JlZGVudGlhbFZhbGlkYXRvclR5cGUoKSkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19jcmVkZW50aWFsXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIENyZWRlbnRpYWw6OlB1YktleVxuICovXG5jbGFzcyBDcmVkZW50aWFsUHViS2V5VHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IENyZWRlbnRpYWxUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiQ3JlZGVudGlhbDo6UHViS2V5XCI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJoYXNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFB1YktleUhhc2hUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fcHVia2V5XCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIENyZWRlbnRpYWw6OlZhbGlkYXRvciB0eXBlXG4gKi9cbmNsYXNzIENyZWRlbnRpYWxWYWxpZGF0b3JUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgQ3JlZGVudGlhbFR5cGUoKSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJDcmVkZW50aWFsOjpWYWxpZGF0b3JcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJoYXNoXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFZhbGlkYXRvckhhc2hUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFN0YWtpbmdIYXNoIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0YWtpbmdIYXNoVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2luZ0hhc2hcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdHlwZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Jhc2VPZihzaXRlLCB0eXBlKSB7XG5cdFx0bGV0IGIgPSBzdXBlci5pc0Jhc2VPZihzaXRlLCB0eXBlKSB8fFxuXHRcdFx0XHQobmV3IFN0YWtpbmdIYXNoU3Rha2VLZXlUeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8IFxuXHRcdFx0XHQobmV3IFN0YWtpbmdIYXNoVmFsaWRhdG9yVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKTsgXG5cblx0XHRyZXR1cm4gYjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiU3Rha2VLZXlcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBTdGFraW5nSGFzaFN0YWtlS2V5VHlwZSgpO1xuXHRcdFx0Y2FzZSBcIlZhbGlkYXRvclwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFN0YWtpbmdIYXNoVmFsaWRhdG9yVHlwZSgpO1xuXHRcdFx0Y2FzZSBcIm5ld19zdGFrZWtleVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFN0YWtlS2V5SGFzaFR5cGUoKV0sIG5ldyBTdGFraW5nSGFzaFN0YWtlS2V5VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3X3ZhbGlkYXRvclwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoVHlwZSgpXSwgbmV3IFN0YWtpbmdIYXNoVmFsaWRhdG9yVHlwZSgpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkVudW1NZW1iZXJzKHNpdGUpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19zdGFraW5naGFzaFwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nSGFzaDo6U3Rha2VLZXlcbiAqL1xuY2xhc3MgU3Rha2luZ0hhc2hTdGFrZUtleVR5cGUgZXh0ZW5kcyBCdWlsdGluRW51bU1lbWJlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBTdGFraW5nSGFzaFR5cGUoKSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTdGFraW5nSGFzaDo6U3Rha2VLZXlcIjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImhhc2hcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgU3Rha2VLZXlIYXNoVHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0Q29uc3RySW5kZXgoc2l0ZSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX19zdGFrZWtleVwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nSGFzaDo6VmFsaWRhdG9yIHR5cGVcbiAqL1xuY2xhc3MgU3Rha2luZ0hhc2hWYWxpZGF0b3JUeXBlIGV4dGVuZHMgQnVpbHRpbkVudW1NZW1iZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihuZXcgU3Rha2luZ0hhc2hUeXBlKCkpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiU3Rha2luZ0hhc2g6OlZhbGlkYXRvclwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcImhhc2hcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgU3Rha2luZ1ZhbGlkYXRvckhhc2hUeXBlKCkpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc3Rha2luZ2hhc2hfX3ZhbGlkYXRvclwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nQ3JlZGVudGlhbCB0eXBlXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTdGFraW5nQ3JlZGVudGlhbFR5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlN0YWtpbmdDcmVkZW50aWFsXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNCYXNlT2Yoc2l0ZSwgdHlwZSkge1xuXHRcdGxldCBiID0gc3VwZXIuaXNCYXNlT2Yoc2l0ZSwgdHlwZSkgfHxcblx0XHRcdFx0KG5ldyBTdGFraW5nSGFzaENyZWRlbnRpYWxUeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpIHx8IFxuXHRcdFx0XHQobmV3IFN0YWtpbmdQdHJDcmVkZW50aWFsVHlwZSgpKS5pc0Jhc2VPZihzaXRlLCB0eXBlKTsgXG5cblx0XHRyZXR1cm4gYjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiSGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFN0YWtpbmdIYXNoQ3JlZGVudGlhbFR5cGUoKTtcblx0XHRcdGNhc2UgXCJQdHJcIjpcblx0XHRcdFx0cmV0dXJuIG5ldyBTdGFraW5nUHRyQ3JlZGVudGlhbFR5cGUoKTtcblx0XHRcdGNhc2UgXCJuZXdfaGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFN0YWtpbmdIYXNoVHlwZSgpXSwgbmV3IFN0YWtpbmdIYXNoQ3JlZGVudGlhbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld19wdHJcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBJbnRUeXBlKCksIG5ldyBJbnRUeXBlKCksIG5ldyBJbnRUeXBlKCldLCBuZXcgU3Rha2luZ1B0ckNyZWRlbnRpYWxUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRW51bU1lbWJlcnMoc2l0ZSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX3N0YWtpbmdjcmVkZW50aWFsXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIFN0YWtpbmdDcmVkZW50aWFsOjpIYXNoXG4gKi9cbmNsYXNzIFN0YWtpbmdIYXNoQ3JlZGVudGlhbFR5cGUgZXh0ZW5kcyBCdWlsdGluRW51bU1lbWJlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKG5ldyBTdGFraW5nQ3JlZGVudGlhbFR5cGUoKSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCJTdGFraW5nQ3JlZGVudGlhbDo6SGFzaFwiO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiaGFzaFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBTdGFraW5nSGFzaFR5cGUoKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiBcIl9faGVsaW9zX19zdGFraW5nY3JlZGVudGlhbF9faGFzaFwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBTdGFraW5nQ3JlZGVudGlhbDo6UHRyXG4gKi9cbmNsYXNzIFN0YWtpbmdQdHJDcmVkZW50aWFsVHlwZSBleHRlbmRzIEJ1aWx0aW5FbnVtTWVtYmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIobmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIlN0YWtpbmdDcmVkZW50aWFsOjpQdHJcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fc3Rha2luZ2NyZWRlbnRpYWxfX3B0clwiO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBUaW1lIHR5cGUuIE9wYXF1ZSBhbGlhcyBvZiBJbnQgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiVGltZVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJfX2FkZFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IER1cmF0aW9uVHlwZSgpXSwgbmV3IFRpbWVUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJfX3N1YlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IFRpbWVUeXBlKCldLCBuZXcgRHVyYXRpb25UeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJfX3N1Yl9hbHRcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW3RoaXMsIG5ldyBEdXJhdGlvblR5cGUoKV0sIG5ldyBUaW1lVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiX19nZXFcIjpcblx0XHRcdGNhc2UgXCJfX2d0XCI6XG5cdFx0XHRjYXNlIFwiX19sZXFcIjpcblx0XHRcdGNhc2UgXCJfX2x0XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgVGltZVR5cGUoKV0sIG5ldyBCb29sVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwibmV3XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgSW50VHlwZSgpXSwgdGhpcykpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHN1cGVyLmdldFR5cGVNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSkge1xuXHRcdHN3aXRjaCAobmFtZS52YWx1ZSkge1xuXHRcdFx0Y2FzZSBcInNob3dcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTdHJpbmdUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fdGltZVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIFRpbWU7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIER1cmF0aW9uIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIER1cmF0aW9uVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiRHVyYXRpb25cIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19hZGRcIjpcblx0XHRcdGNhc2UgXCJfX3N1YlwiOlxuXHRcdFx0Y2FzZSBcIl9fbW9kXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgRHVyYXRpb25UeXBlKCldLCBuZXcgRHVyYXRpb25UeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJfX211bFwiOlxuXHRcdFx0Y2FzZSBcIl9fZGl2XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgSW50VHlwZSgpXSwgbmV3IER1cmF0aW9uVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiX19kaXZfYWx0XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgRHVyYXRpb25UeXBlKCldLCBuZXcgSW50VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiX19nZXFcIjpcblx0XHRcdGNhc2UgXCJfX2d0XCI6XG5cdFx0XHRjYXNlIFwiX19sZXFcIjpcblx0XHRcdGNhc2UgXCJfX2x0XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLCBuZXcgRHVyYXRpb25UeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEludFR5cGUoKV0sIHRoaXMpKTtcblx0XHRcdGNhc2UgXCJTRUNPTkRcIjpcblx0XHRcdGNhc2UgXCJNSU5VVEVcIjpcblx0XHRcdGNhc2UgXCJIT1VSXCI6XG5cdFx0XHRjYXNlIFwiREFZXCI6XG5cdFx0XHRjYXNlIFwiV0VFS1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMpXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0VHlwZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXRJbnN0YW5jZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIFwiX19oZWxpb3NfX2R1cmF0aW9uXCI7XG5cdH1cblxuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIER1cmF0aW9uO1xuXHR9XG59XG5cbi8qKlxuICogQnVpbHRpbiBUaW1lUmFuZ2UgdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVGltZVJhbmdlVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiVGltZVJhbmdlXCI7XG5cdH1cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJuZXdcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBUaW1lVHlwZSgpLCBuZXcgVGltZVR5cGUoKV0sIG5ldyBUaW1lUmFuZ2VUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJBTFdBWVNcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgVGltZVJhbmdlVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJORVZFUlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBUaW1lUmFuZ2VUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcImZyb21cIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBUaW1lVHlwZSgpXSwgbmV3IFRpbWVSYW5nZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInRvXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgVGltZVR5cGUoKV0sIG5ldyBUaW1lUmFuZ2VUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJpc19iZWZvcmVcIjogLy8gaXNfYmVmb3JlIGNvbmRpdGlvbiBuZXZlciBvdmVybGFwcyB3aXRoIGNvbnRhaW5zXG5cdFx0XHRjYXNlIFwiaXNfYWZ0ZXJcIjogLy8gaXNfYWZ0ZXIgY29uZGl0aW9uIG5ldmVyIG92ZXJsYXBzIHdpdGggY29udGFpbnNcblx0XHRcdGNhc2UgXCJjb250YWluc1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFRpbWVUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInN0YXJ0XCI6XG5cdFx0XHRjYXNlIFwiZW5kXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFRpbWVUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcInNob3dcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTdHJpbmdUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fdGltZXJhbmdlXCI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIEFzc2V0Q2xhc3MgdHlwZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQXNzZXRDbGFzc1R5cGUgZXh0ZW5kcyBCdWlsdGluVHlwZSB7XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcIkFzc2V0Q2xhc3NcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiQURBXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEFzc2V0Q2xhc3NUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IE1pbnRpbmdQb2xpY3lIYXNoVHlwZSgpLCBuZXcgQnl0ZUFycmF5VHlwZSgpXSwgbmV3IEFzc2V0Q2xhc3NUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJtcGhcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgTWludGluZ1BvbGljeUhhc2hUeXBlKCkpO1xuXHRcdFx0Y2FzZSBcInRva2VuX25hbWVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgQnl0ZUFycmF5VHlwZSgpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRJbnN0YW5jZU1lbWJlcihuYW1lKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fYXNzZXRjbGFzc1wiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtIZWxpb3NEYXRhQ2xhc3M8SGVsaW9zRGF0YT59XG5cdCAqL1xuXHRnZXQgdXNlclR5cGUoKSB7XG5cdFx0cmV0dXJuIEFzc2V0Q2xhc3M7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsdGluIG1vbmV5IFZhbHVlIHR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFZhbHVlVHlwZSBleHRlbmRzIEJ1aWx0aW5UeXBlIHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiVmFsdWVcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lKSB7XG5cdFx0c3dpdGNoIChuYW1lLnZhbHVlKSB7XG5cdFx0XHRjYXNlIFwiX19hZGRcIjpcblx0XHRcdGNhc2UgXCJfX3N1YlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IFZhbHVlVHlwZSgpXSwgbmV3IFZhbHVlVHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiX19tdWxcIjpcblx0XHRcdGNhc2UgXCJfX2RpdlwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IEludFR5cGUoKV0sIG5ldyBWYWx1ZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIl9fZ2VxXCI6XG5cdFx0XHRjYXNlIFwiX19ndFwiOlxuXHRcdFx0Y2FzZSBcIl9fbGVxXCI6XG5cdFx0XHRjYXNlIFwiX19sdFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbdGhpcywgbmV3IFZhbHVlVHlwZSgpXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJaRVJPXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IFZhbHVlVHlwZSgpKTtcblx0XHRcdGNhc2UgXCJsb3ZlbGFjZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEludFR5cGUoKV0sIG5ldyBWYWx1ZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcIm5ld1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEFzc2V0Q2xhc3NUeXBlKCksIG5ldyBJbnRUeXBlKCldLCBuZXcgVmFsdWVUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJmcm9tX21hcFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IE1hcFR5cGUobmV3IE1pbnRpbmdQb2xpY3lIYXNoVHlwZSgpLCBuZXcgTWFwVHlwZShuZXcgQnl0ZUFycmF5VHlwZSgpLCBuZXcgSW50VHlwZSgpKSldLCBuZXcgVmFsdWVUeXBlKCkpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBzdXBlci5nZXRUeXBlTWVtYmVyKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJjb250YWluc1wiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IFZhbHVlVHlwZSgpXSwgbmV3IEJvb2xUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJpc196ZXJvXCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldFwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbbmV3IEFzc2V0Q2xhc3NUeXBlKCldLCBuZXcgSW50VHlwZSgpKSk7XG5cdFx0XHRjYXNlIFwiZ2V0X3NhZmVcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBBc3NldENsYXNzVHlwZSgpXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldF9sb3ZlbGFjZVwiOlxuXHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBGdW5jVHlwZShbXSwgbmV3IEludFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldF9hc3NldHNcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBWYWx1ZVR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImdldF9wb2xpY3lcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBNaW50aW5nUG9saWN5SGFzaFR5cGUoKV0sIG5ldyBNYXBUeXBlKG5ldyBCeXRlQXJyYXlUeXBlKCksIG5ldyBJbnRUeXBlKCkpKSk7XG5cdFx0XHRjYXNlIFwiY29udGFpbnNfcG9saWN5XCI6XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtuZXcgTWludGluZ1BvbGljeUhhc2hUeXBlKCldLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcInNob3dcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBTdHJpbmdUeXBlKCkpKTtcblx0XHRcdGNhc2UgXCJ0b19tYXBcIjpcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW10sIG5ldyBNYXBUeXBlKG5ldyBNaW50aW5nUG9saWN5SGFzaFR5cGUoKSwgbmV3IE1hcFR5cGUobmV3IEJ5dGVBcnJheVR5cGUoKSwgbmV3IEludFR5cGUoKSkpKSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc3VwZXIuZ2V0SW5zdGFuY2VNZW1iZXIobmFtZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gXCJfX2hlbGlvc19fdmFsdWVcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7SGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0Z2V0IHVzZXJUeXBlKCkge1xuXHRcdHJldHVybiBWYWx1ZTtcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAxNDogU2NvcGVzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHbG9iYWxTY29wZSBzaXRzIGFib3ZlIHRoZSB0b3AtbGV2ZWwgc2NvcGUgYW5kIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBidWlsdGluIFZhbHVlcyBhbmQgVHlwZXNcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEdsb2JhbFNjb3BlIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtbV29yZCwgRXZhbEVudGl0eV1bXX1cblx0ICovXG5cdCN2YWx1ZXM7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy4jdmFsdWVzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHNjb3BlIGNvbnRhaW5zIGEgbmFtZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aGFzKG5hbWUpIHtcblx0XHRmb3IgKGxldCBwYWlyIG9mIHRoaXMuI3ZhbHVlcykge1xuXHRcdFx0aWYgKHBhaXJbMF0udG9TdHJpbmcoKSA9PSBuYW1lLnRvU3RyaW5nKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYSBnbG9iYWwgbmFtZSwgZG9lc24ndCBjaGVjayBmb3IgdW5pcXVlbmVzc1xuXHQgKiBDYWxsZWQgd2hlbiBpbml0aWFsaXppbmcgR2xvYmFsU2NvcGVcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBXb3JkfSBuYW1lXG5cdCAqIEBwYXJhbSB7RXZhbEVudGl0eX0gdmFsdWVcblx0ICovXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdC8qKiBAdHlwZSB7V29yZH0gKi9cblx0XHRsZXQgbmFtZVdvcmQgPSAhKG5hbWUgaW5zdGFuY2VvZiBXb3JkKSA/IFdvcmQubmV3KG5hbWUpIDogbmFtZTtcblxuXHRcdHRoaXMuI3ZhbHVlcy5wdXNoKFtuYW1lV29yZCwgdmFsdWVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgbmFtZWQgdmFsdWUgZnJvbSB0aGUgc2NvcGUuXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiBub3QgZm91bmQuXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXQobmFtZSkge1xuXHRcdGZvciAobGV0IHBhaXIgb2YgdGhpcy4jdmFsdWVzKSB7XG5cdFx0XHRpZiAocGFpclswXS50b1N0cmluZygpID09IG5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRwYWlyWzFdLm1hcmtBc1VzZWQoKTtcblx0XHRcdFx0cmV0dXJuIHBhaXJbMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7bmFtZS50b1N0cmluZygpfScgdW5kZWZpbmVkYCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgZnVuY3N0YXRlbWVudCBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgKGFsd2F5cyBmYWxzZSBoZXJlKVxuXHQgKiBAcGFyYW0ge1JlY3Vyc2VhYmxlU3RhdGVtZW50fSBzdGF0ZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1JlY3Vyc2l2ZShzdGF0ZW1lbnQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1N0cmljdCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQndmUgYmVlbiByZXR1cm5lZCBiZSBUb3BTY29wZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBHbG9iYWxTY29wZSB3aXRoIGFsbCB0aGUgYnVpbHRpbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHB1cnBvc2Vcblx0ICogQHJldHVybnMge0dsb2JhbFNjb3BlfVxuXHQgKi9cblx0c3RhdGljIG5ldyhwdXJwb3NlKSB7XG5cdFx0bGV0IHNjb3BlID0gbmV3IEdsb2JhbFNjb3BlKCk7XG5cblx0XHQvLyBMaXN0IChha2EgJ1tdJyksIE9wdGlvbiwgYW5kIE1hcCB0eXBlcyBhcmUgYWNjZXNzZWQgdGhyb3VnaCBzcGVjaWFsIGV4cHJlc3Npb25zXG5cblx0XHQvLyBmaWxsIHRoZSBnbG9iYWwgc2NvcGUgd2l0aCBidWlsdGluIHR5cGVzXG4gICAgICAgIHNjb3BlLnNldChcIkFkZHJlc3NcIiwgICAgICAgICAgICAgIG5ldyBBZGRyZXNzVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiQXNzZXRDbGFzc1wiLCAgICAgICAgICAgbmV3IEFzc2V0Q2xhc3NUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJCb29sXCIsICAgICAgICAgICAgICAgICBuZXcgQm9vbFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIkJ5dGVBcnJheVwiLCAgICAgICAgICAgIG5ldyBCeXRlQXJyYXlUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJDcmVkZW50aWFsXCIsICAgICAgICAgICBuZXcgQ3JlZGVudGlhbFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIkRhdHVtSGFzaFwiLCAgICAgICAgICAgIG5ldyBEYXR1bUhhc2hUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJEYXRhXCIsICAgICAgICAgICAgICAgICBuZXcgUmF3RGF0YVR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIkRDZXJ0XCIsICAgICAgICAgICAgICAgIG5ldyBEQ2VydFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIkR1cmF0aW9uXCIsICAgICAgICAgICAgIG5ldyBEdXJhdGlvblR5cGUoKSk7XG5cdFx0c2NvcGUuc2V0KFwiSW50XCIsICAgICAgICAgICAgICAgICAgbmV3IEludFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIk1pbnRpbmdQb2xpY3lIYXNoXCIsICAgIG5ldyBNaW50aW5nUG9saWN5SGFzaFR5cGUocHVycG9zZSkpO1xuICAgICAgICBzY29wZS5zZXQoXCJPdXRwdXREYXR1bVwiLCAgICAgICAgICBuZXcgT3V0cHV0RGF0dW1UeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJQdWJLZXlcIiwgICAgICAgICAgICAgICBuZXcgUHViS2V5VHlwZSgpKTtcblx0XHRzY29wZS5zZXQoXCJQdWJLZXlIYXNoXCIsICAgICAgICAgICBuZXcgUHViS2V5SGFzaFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIlNjcmlwdENvbnRleHRcIiwgICAgICAgIG5ldyBTY3JpcHRDb250ZXh0VHlwZShwdXJwb3NlKSk7XG4gICAgICAgIHNjb3BlLnNldChcIlNjcmlwdEhhc2hcIiwgICAgICAgICAgIG5ldyBTY3JpcHRIYXNoVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiU2NyaXB0UHVycG9zZVwiLCAgICAgICAgbmV3IFNjcmlwdFB1cnBvc2VUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJTdGFrZUtleUhhc2hcIiwgICAgICAgICBuZXcgU3Rha2VLZXlIYXNoVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiU3Rha2luZ0NyZWRlbnRpYWxcIiwgICAgbmV3IFN0YWtpbmdDcmVkZW50aWFsVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiU3Rha2luZ0hhc2hcIiwgICAgICAgICAgbmV3IFN0YWtpbmdIYXNoVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiU3Rha2luZ1B1cnBvc2VcIiwgICAgICAgbmV3IFN0YWtpbmdQdXJwb3NlVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiU3Rha2luZ1ZhbGlkYXRvckhhc2hcIiwgbmV3IFN0YWtpbmdWYWxpZGF0b3JIYXNoVHlwZShwdXJwb3NlKSk7XG5cdFx0c2NvcGUuc2V0KFwiU3RyaW5nXCIsICAgICAgICAgICAgICAgbmV3IFN0cmluZ1R5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIlRpbWVcIiwgICAgICAgICAgICAgICAgIG5ldyBUaW1lVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiVGltZVJhbmdlXCIsICAgICAgICAgICAgbmV3IFRpbWVSYW5nZVR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIlR4XCIsICAgICAgICAgICAgICAgICAgIG5ldyBUeFR5cGUoKSk7XG4gICAgICAgIHNjb3BlLnNldChcIlR4SWRcIiwgICAgICAgICAgICAgICAgIG5ldyBUeElkVHlwZSgpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiVHhJbnB1dFwiLCAgICAgICAgICAgICAgbmV3IFR4SW5wdXRUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJUeE91dHB1dFwiLCAgICAgICAgICAgICBuZXcgVHhPdXRwdXRUeXBlKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJUeE91dHB1dElkXCIsICAgICAgICAgICBuZXcgVHhPdXRwdXRJZFR5cGUoKSk7XG5cdFx0c2NvcGUuc2V0KFwiVmFsaWRhdG9ySGFzaFwiLCAgICAgICAgbmV3IFZhbGlkYXRvckhhc2hUeXBlKHB1cnBvc2UpKTtcbiAgICAgICAgc2NvcGUuc2V0KFwiVmFsdWVcIiwgICAgICAgICAgICAgICAgbmV3IFZhbHVlVHlwZSgpKTtcblxuICAgICAgICAvLyBidWlsdGluIGZ1bmN0aW9uc1xuICAgICAgICBzY29wZS5zZXQoXCJhc3NlcnRcIiwgICAgICAgICAgICAgICBuZXcgQXNzZXJ0RnVuYygpKTtcblx0XHRzY29wZS5zZXQoXCJlcnJvclwiLCAgICAgICAgICAgICAgICBuZXcgRXJyb3JGdW5jKCkpO1xuICAgICAgICBzY29wZS5zZXQoXCJwcmludFwiLCAgICAgICAgICAgICAgICBuZXcgUHJpbnRGdW5jKCkpO1xuXHRcdFxuXG5cdFx0cmV0dXJuIHNjb3BlO1xuXHR9XG5cblx0YWxsb3dNYWNyb3MoKSB7XG5cdFx0Zm9yIChsZXQgW18sIHZhbHVlXSBvZiB0aGlzLiN2YWx1ZXMpIHtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ1aWx0aW5UeXBlKSB7XG5cdFx0XHRcdHZhbHVlLmFsbG93TWFjcm9zKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7KG5hbWU6IHN0cmluZywgdHlwZTogVHlwZSkgPT4gdm9pZH0gY2FsbGJhY2sgXG5cdCAqL1xuXHRsb29wVHlwZXMoY2FsbGJhY2spIHtcblx0XHRmb3IgKGxldCBbaywgdl0gb2YgdGhpcy4jdmFsdWVzKSB7XG5cdFx0XHRpZiAodiBpbnN0YW5jZW9mIFR5cGUpIHtcblx0XHRcdFx0Y2FsbGJhY2soay52YWx1ZSwgdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVXNlciBzY29wZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgU2NvcGUge1xuXHQvKiogQHR5cGUge0dsb2JhbFNjb3BlIHwgU2NvcGV9ICovXG5cdCNwYXJlbnQ7XG5cblx0LyoqIFxuXHQgKiBUb3BTY29wZSBjYW4gZWx2ZXJhZ2UgdGhlICN2YWx1ZXMgdG8gc3RvcmUgTW9kdWxlU2NvcGVzXG5cdCAqIEB0eXBlIHtbV29yZCwgKEV2YWxFbnRpdHkgfCBTY29wZSldW119IFxuXHQgKi9cblx0I3ZhbHVlcztcblxuXHQvKipcblx0ICogQHBhcmFtIHtHbG9iYWxTY29wZSB8IFNjb3BlfSBwYXJlbnQgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwYXJlbnQpIHtcblx0XHR0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG5cdFx0dGhpcy4jdmFsdWVzID0gW107IC8vIGxpc3Qgb2YgcGFpcnNcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGJ5IHRvcC1zY29wZSB0byBsb29wIG92ZXIgYWxsIHRoZSBzdGF0ZW1lbnRzXG5cdCAqL1xuXHRnZXQgdmFsdWVzKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZXMuc2xpY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgc2NvcGUgY29udGFpbnMgYSBuYW1lXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXMobmFtZSkge1xuXHRcdGZvciAobGV0IHBhaXIgb2YgdGhpcy4jdmFsdWVzKSB7XG5cdFx0XHRpZiAocGFpclswXS50b1N0cmluZygpID09IG5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy4jcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jcGFyZW50LmhhcyhuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGEgbmFtZWQgdmFsdWUuIFRocm93cyBhbiBlcnJvciBpZiBub3QgdW5pcXVlXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHtFdmFsRW50aXR5IHwgU2NvcGV9IHZhbHVlIFxuXHQgKi9cblx0c2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuaGFzKG5hbWUpKSB7XG5cdFx0XHR0aHJvdyBuYW1lLnN5bnRheEVycm9yKGAnJHtuYW1lLnRvU3RyaW5nKCl9JyBhbHJlYWR5IGRlZmluZWRgKTtcblx0XHR9XG5cblx0XHR0aGlzLiN2YWx1ZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgbmFtZWQgdmFsdWUgZnJvbSB0aGUgc2NvcGUuIFRocm93cyBhbiBlcnJvciBpZiBub3QgZm91bmRcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eSB8IFNjb3BlfVxuXHQgKi9cblx0Z2V0KG5hbWUpIHtcblx0XHRpZiAoIShuYW1lIGluc3RhbmNlb2YgV29yZCkpIHtcblx0XHRcdG5hbWUgPSBXb3JkLm5ldyhuYW1lKTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBba2V5LCBlbnRpdHldIG9mIHRoaXMuI3ZhbHVlcykge1xuXHRcdFx0aWYgKGtleS50b1N0cmluZygpID09IG5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRpZiAoZW50aXR5IGluc3RhbmNlb2YgRXZhbEVudGl0eSkge1xuXHRcdFx0XHRcdGVudGl0eS5tYXJrQXNVc2VkKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW50aXR5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLiNwYXJlbnQuZ2V0KG5hbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKGAnJHtuYW1lLnRvU3RyaW5nKCl9JyB1bmRlZmluZWRgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgZnVuY3Rpb24gc3RhdGVtZW50IGlzIGNhbGxlZCByZWN1cnNpdmVseVxuXHQgKiBAcGFyYW0ge1JlY3Vyc2VhYmxlU3RhdGVtZW50fSBzdGF0ZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1JlY3Vyc2l2ZShzdGF0ZW1lbnQpIHtcblx0XHRyZXR1cm4gdGhpcy4jcGFyZW50LmlzUmVjdXJzaXZlKHN0YXRlbWVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1N0cmljdCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jcGFyZW50LmlzU3RyaWN0KCk7XG5cdH1cblxuXHQvKipcblx0ICogQXNzZXJ0cyB0aGF0IGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHVzZXIuXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiBzb21lIGFyZSB1bnVzZWQuXG5cdCAqIENoZWNrIGlzIG9ubHkgcnVuIGlmIHdlIGFyZSBpbiBzdHJpY3QgbW9kZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9ubHlJZlN0cmljdFxuXHQgKi9cblx0YXNzZXJ0QWxsVXNlZChvbmx5SWZTdHJpY3QgPSB0cnVlKSB7XG5cdFx0aWYgKCFvbmx5SWZTdHJpY3QgfHwgdGhpcy5pc1N0cmljdCgpKSB7XG5cdFx0XHRmb3IgKGxldCBbbmFtZSwgZW50aXR5XSBvZiB0aGlzLiN2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKGVudGl0eSBpbnN0YW5jZW9mIEV2YWxFbnRpdHkgJiYgIWVudGl0eS5pc1VzZWQoKSkge1xuXHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoYCcke25hbWUudG9TdHJpbmcoKX0nIHVudXNlZGApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1VzZWQobmFtZSkge1xuXHRcdGZvciAobGV0IFtuYW1lLCBlbnRpdHldIG9mIHRoaXMuI3ZhbHVlcykge1xuXHRcdFx0aWYgKG5hbWUudmFsdWUgPT0gbmFtZS52YWx1ZSAmJiBlbnRpdHkgaW5zdGFuY2VvZiBFdmFsRW50aXR5KSB7XG5cdFx0XHRcdHJldHVybiBlbnRpdHkuaXNVc2VkKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKGAke25hbWUudmFsdWV9IG5vdCBmb3VuZGApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRhc3NlcnRUeXBlKHNpdGUpIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImV4cGVjdGVkIGEgdHlwZSwgZ290IGEgbW9kdWxlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0YXNzZXJ0VmFsdWUoc2l0ZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwiZXhwZWN0ZWQgYSB2YWx1ZSwgZ290IGEgbW9kdWxlXCIpO1xuXHR9XG5cblx0ZHVtcCgpIHtcblx0XHRjb25zb2xlLmxvZyhcIkRVTVBJTkcgU0NPUEVcIiwgdGhpcy4jdmFsdWVzLmxlbmd0aCk7XG5cdFx0dGhpcy4jdmFsdWVzLmZvckVhY2goKFt3LCB2XSkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2cody52YWx1ZSwgdik7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHsobmFtZTogc3RyaW5nLCB0eXBlOiBUeXBlKSA9PiB2b2lkfSBjYWxsYmFjayBcblx0ICovXG5cdGxvb3BUeXBlcyhjYWxsYmFjaykge1xuXHRcdHRoaXMuI3BhcmVudC5sb29wVHlwZXMoY2FsbGJhY2spO1xuXG5cdFx0Zm9yIChsZXQgW2ssIHZdIG9mIHRoaXMuI3ZhbHVlcykge1xuXHRcdFx0aWYgKHYgaW5zdGFuY2VvZiBUeXBlKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGsudmFsdWUsIHYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRvcFNjb3BlIGlzIGEgc3BlY2lhbCBzY29wZSB0aGF0IGNhbiBjb250YWluIFVzZXJUeXBlc1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVG9wU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG5cdCNzdHJpY3Q7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7R2xvYmFsU2NvcGV9IHBhcmVudCBcblx0ICogQHBhcmFtIHtib29sZWFufSBzdHJpY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmVudCwgc3RyaWN0ID0gdHJ1ZSkge1xuXHRcdHN1cGVyKHBhcmVudCk7XG5cdFx0dGhpcy4jc3RyaWN0ID0gc3RyaWN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHtFdmFsRW50aXR5IHwgU2NvcGV9IHZhbHVlIFxuXHQgKi9cblx0c2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0c3VwZXIuc2V0KG5hbWUsIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHMgXG5cdCAqL1xuXHRzZXRTdHJpY3Qocykge1xuXHRcdHRoaXMuI3N0cmljdCA9IHM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1N0cmljdCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc3RyaWN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge01vZHVsZVNjb3BlfVxuXHQgKi9cblx0Z2V0TW9kdWxlU2NvcGUobmFtZSkge1xuXHRcdGNvbnN0IG1heWJlTW9kdWxlU2NvcGUgPSB0aGlzLmdldChuYW1lKTtcblx0XHRpZiAobWF5YmVNb2R1bGVTY29wZSBpbnN0YW5jZW9mIE1vZHVsZVNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gbWF5YmVNb2R1bGVTY29wZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgTW9kdWxlU2NvcGVcIik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgTW9kdWxlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG59XG5cbi8qKlxuICogRnVuY1N0YXRlbWVudFNjb3BlIGlzIGEgc3BlY2lhbCBzY29wZSB1c2VkIHRvIGRldGVjdCByZWN1cnNpb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEZ1bmNTdGF0ZW1lbnRTY29wZSBleHRlbmRzIFNjb3BlIHtcblx0I3N0YXRlbWVudDtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gcGFyZW50XG5cdCAqIEBwYXJhbSB7UmVjdXJzZWFibGVTdGF0ZW1lbnR9IHN0YXRlbWVudFxuXHQgKi9cblx0Y29uc3RydWN0b3IocGFyZW50LCBzdGF0ZW1lbnQpIHtcblx0XHRzdXBlcihwYXJlbnQpO1xuXG5cdFx0dGhpcy4jc3RhdGVtZW50ID0gc3RhdGVtZW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVjdXJzZWFibGVTdGF0ZW1lbnR9IHN0YXRlbWVudCBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1JlY3Vyc2l2ZShzdGF0ZW1lbnQpIHtcblx0XHRpZiAodGhpcy4jc3RhdGVtZW50ID09PSBzdGF0ZW1lbnQpIHtcblx0XHRcdHRoaXMuI3N0YXRlbWVudC5zZXRSZWN1cnNpdmUoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gc3VwZXIuaXNSZWN1cnNpdmUoc3RhdGVtZW50KTtcblx0XHR9XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDE1OiBIZWxpb3MgQVNUIGV4cHJlc3Npb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBldmVyeSBUeXBlIGFuZCBJbnN0YW5jZSBleHByZXNzaW9uLlxuICovXG5jbGFzcyBFeHByIGV4dGVuZHMgVG9rZW4ge1xuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGV2ZXJ5IFR5cGUgZXhwcmVzc2lvblxuICogQ2FjaGVzIGV2YWx1YXRlZCBUeXBlLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVHlwZUV4cHIgZXh0ZW5kcyBFeHByIHtcblx0I2NhY2hlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7P1R5cGV9IGNhY2hlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBjYWNoZSA9IG51bGwpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNjYWNoZSA9IGNhY2hlO1xuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0aWYgKHRoaXMuI2NhY2hlID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG5vdCB5ZXQgZXZhbHVhdGVkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jY2FjaGU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdGlmICh0aGlzLiNjYWNoZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jY2FjaGUgPSB0aGlzLmV2YWxJbnRlcm5hbChzY29wZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuI2NhY2hlO1xuXHR9XG59XG5cbi8qKlxuICogVHlwZSByZWZlcmVuY2UgY2xhc3MgKGkuZS4gdXNpbmcgYSBXb3JkKVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVHlwZVJlZkV4cHIgZXh0ZW5kcyBUeXBlRXhwciB7XG5cdCNuYW1lO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWVcblx0ICogQHBhcmFtIHs/VHlwZX0gY2FjaGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIGNhY2hlID0gbnVsbCkge1xuXHRcdHN1cGVyKG5hbWUuc2l0ZSwgY2FjaGUpO1xuXHRcdHRoaXMuI25hbWUgPSBuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZS50b1N0cmluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCB0eXBlID0gc2NvcGUuZ2V0KHRoaXMuI25hbWUpO1xuXG5cdFx0cmV0dXJuIHR5cGUuYXNzZXJ0VHlwZSh0aGlzLiNuYW1lLnNpdGUpO1xuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZS5wYXRoO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdGxldCB0ID0gdGhpcy50eXBlO1xuXG5cdFx0aWYgKHQgaW5zdGFuY2VvZiBTdGF0ZW1lbnRUeXBlKSB7XG5cdFx0XHR0LnN0YXRlbWVudC51c2UoKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUeXBlOjpNZW1iZXIgZXhwcmVzc2lvblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVHlwZVBhdGhFeHByIGV4dGVuZHMgVHlwZUV4cHIge1xuXHQjYmFzZUV4cHI7XG5cdCNtZW1iZXJOYW1lO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IGJhc2VFeHByIFxuXHQgKiBAcGFyYW0ge1dvcmR9IG1lbWJlck5hbWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGJhc2VFeHByLCBtZW1iZXJOYW1lKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jYmFzZUV4cHIgPSBiYXNlRXhwcjtcblx0XHR0aGlzLiNtZW1iZXJOYW1lID0gbWVtYmVyTmFtZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiNiYXNlRXhwci50b1N0cmluZygpfTo6JHt0aGlzLiNtZW1iZXJOYW1lLnRvU3RyaW5nKCl9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgZW51bVR5cGUgPSB0aGlzLiNiYXNlRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdGxldCBtZW1iZXJUeXBlID0gZW51bVR5cGUuZ2V0VHlwZU1lbWJlcih0aGlzLiNtZW1iZXJOYW1lKTtcblxuXHRcdHJldHVybiBtZW1iZXJUeXBlLmFzc2VydFR5cGUodGhpcy4jbWVtYmVyTmFtZS5zaXRlKTtcblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiB0aGlzLnR5cGUucGF0aDtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNiYXNlRXhwci51c2UoKTtcblx0fVxufVxuXG4vKipcbiAqIFtdSXRlbVR5cGVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIExpc3RUeXBlRXhwciBleHRlbmRzIFR5cGVFeHByIHtcblx0I2l0ZW1UeXBlRXhwcjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByfSBpdGVtVHlwZUV4cHIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBpdGVtVHlwZUV4cHIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNpdGVtVHlwZUV4cHIgPSBpdGVtVHlwZUV4cHI7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYFtdJHt0aGlzLiNpdGVtVHlwZUV4cHIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBpdGVtVHlwZSA9IHRoaXMuI2l0ZW1UeXBlRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdGlmIChpdGVtVHlwZSBpbnN0YW5jZW9mIEZ1bmNUeXBlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLiNpdGVtVHlwZUV4cHIudHlwZUVycm9yKFwibGlzdCBpdGVtIHR5cGUgY2FuJ3QgYmUgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBMaXN0VHlwZShpdGVtVHlwZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jaXRlbVR5cGVFeHByLnVzZSgpO1xuXHR9XG59XG5cbi8qKlxuICogTWFwW0tleVR5cGVdVmFsdWVUeXBlIGV4cHJlc3Npb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE1hcFR5cGVFeHByIGV4dGVuZHMgVHlwZUV4cHIge1xuXHQja2V5VHlwZUV4cHI7XG5cdCN2YWx1ZVR5cGVFeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IGtleVR5cGVFeHByIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByfSB2YWx1ZVR5cGVFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwga2V5VHlwZUV4cHIsIHZhbHVlVHlwZUV4cHIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNrZXlUeXBlRXhwciA9IGtleVR5cGVFeHByO1xuXHRcdHRoaXMuI3ZhbHVlVHlwZUV4cHIgPSB2YWx1ZVR5cGVFeHByO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBNYXBbJHt0aGlzLiNrZXlUeXBlRXhwci50b1N0cmluZygpfV0ke3RoaXMuI3ZhbHVlVHlwZUV4cHIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBrZXlUeXBlID0gdGhpcy4ja2V5VHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAoa2V5VHlwZSBpbnN0YW5jZW9mIEZ1bmNUeXBlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLiNrZXlUeXBlRXhwci50eXBlRXJyb3IoXCJtYXAga2V5IHR5cGUgY2FuJ3QgYmUgZnVuY3Rpb25cIik7XG5cdFx0fSBlbHNlIGlmIChrZXlUeXBlIGluc3RhbmNlb2YgQm9vbFR5cGUpIHtcblx0XHRcdHRocm93IHRoaXMuI2tleVR5cGVFeHByLnR5cGVFcnJvcihcIm1hcCBrZXkgdHlwZSBjYW4ndCBiZSBhIGJvb2xlYW5cIik7XG5cdFx0fVxuXG5cdFx0bGV0IHZhbHVlVHlwZSA9IHRoaXMuI3ZhbHVlVHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAodmFsdWVUeXBlIGluc3RhbmNlb2YgRnVuY1R5cGUpIHtcblx0XHRcdHRocm93IHRoaXMuI3ZhbHVlVHlwZUV4cHIudHlwZUVycm9yKFwibWFwIHZhbHVlIHR5cGUgY2FuJ3QgYmUgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBNYXBUeXBlKGtleVR5cGUsIHZhbHVlVHlwZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4ja2V5VHlwZUV4cHIudXNlKCk7XG5cdFx0dGhpcy4jdmFsdWVUeXBlRXhwci51c2UoKTtcblx0fVxufVxuXG4vKipcbiAqIE9wdGlvbltTb21lVHlwZV0gZXhwcmVzc2lvblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgT3B0aW9uVHlwZUV4cHIgZXh0ZW5kcyBUeXBlRXhwciB7XG5cdCNzb21lVHlwZUV4cHI7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlRXhwcn0gc29tZVR5cGVFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgc29tZVR5cGVFeHByKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jc29tZVR5cGVFeHByID0gc29tZVR5cGVFeHByO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBPcHRpb25bJHt0aGlzLiNzb21lVHlwZUV4cHIudG9TdHJpbmcoKX1dYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgc29tZVR5cGUgPSB0aGlzLiNzb21lVHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAoc29tZVR5cGUgaW5zdGFuY2VvZiBGdW5jVHlwZSkge1xuXHRcdFx0dGhyb3cgdGhpcy4jc29tZVR5cGVFeHByLnR5cGVFcnJvcihcIm9wdGlvbiBzb21lIHR5cGUgY2FuJ3QgYmUgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBPcHRpb25UeXBlKHNvbWVUeXBlKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNzb21lVHlwZUV4cHIudXNlKCk7XG5cdH1cbn1cblxuLyoqXG4gKiAnKCknIHdoaWNoIGNhbiBvbmx5IGJlIHVzZWQgYXMgcmV0dXJuIHR5cGUgb2YgZnVuY1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVm9pZFR5cGVFeHByIGV4dGVuZHMgVHlwZUV4cHIge1xuXHRjb25zdHJ1Y3RvcihzaXRlKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gXCIoKVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdHJldHVybiBuZXcgVm9pZFR5cGUoKTtcblx0fVxuXHRcblx0dXNlKCkge1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRnVuY0FyZ1R5cGVFeHByIGV4dGVuZHMgVG9rZW4ge1xuXHQjbmFtZTtcblx0I3R5cGVFeHByO1xuXHRvcHRpb25hbDtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge251bGwgfCBXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByfSB0eXBlRXhwciBcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbCBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG5hbWUsIHR5cGVFeHByLCBvcHRpb25hbCkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI25hbWUgPSBuYW1lO1xuXHRcdHRoaXMuI3R5cGVFeHByID0gdHlwZUV4cHI7XG5cdFx0dGhpcy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNOYW1lZCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZSA9PSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNPcHRpb25hbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHRoaXMuI25hbWUgIT0gbnVsbCA/IGAke3RoaXMuI25hbWUudG9TdHJpbmcoKX06IGAgOiBcIlwiLFxuXHRcdFx0dGhpcy5vcHRpb25hbCA/IFwiP1wiIDogXCJcIixcblx0XHRcdHRoaXMuI3R5cGVFeHByLnRvU3RyaW5nKClcblx0XHRdLmpvaW4oXCJcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtBcmdUeXBlfVxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdHJldHVybiBuZXcgQXJnVHlwZSh0aGlzLiNuYW1lLCB0aGlzLiN0eXBlRXhwci5ldmFsKHNjb3BlKSwgdGhpcy5vcHRpb25hbCk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jdHlwZUV4cHIudXNlKCk7XG5cdH1cbn1cblxuLyoqXG4gKiAoQXJnVHlwZTEsIC4uLikgLT4gUmV0VHlwZSBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBGdW5jVHlwZUV4cHIgZXh0ZW5kcyBUeXBlRXhwciB7XG5cdCNhcmdUeXBlRXhwcnM7XG5cdCNyZXRUeXBlRXhwcnM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtGdW5jQXJnVHlwZUV4cHJbXX0gYXJnVHlwZUV4cHJzIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByW119IHJldFR5cGVFeHBycyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGFyZ1R5cGVFeHBycywgcmV0VHlwZUV4cHJzKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jYXJnVHlwZUV4cHJzID0gYXJnVHlwZUV4cHJzO1xuXHRcdHRoaXMuI3JldFR5cGVFeHBycyA9IHJldFR5cGVFeHBycztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0aWYgKHRoaXMuI3JldFR5cGVFeHBycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHJldHVybiBgKCR7dGhpcy4jYXJnVHlwZUV4cHJzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSkgLT4gJHt0aGlzLiNyZXRUeXBlRXhwcnMudG9TdHJpbmcoKX1gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYCgke3RoaXMuI2FyZ1R5cGVFeHBycy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0pIC0+ICgke3RoaXMuI3JldFR5cGVFeHBycy5tYXAoZSA9PiBlLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0pYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0bGV0IGFyZ1R5cGVzID0gdGhpcy4jYXJnVHlwZUV4cHJzLm1hcChhID0+IGEuZXZhbChzY29wZSkpO1xuXG5cdFx0bGV0IHJldFR5cGVzID0gdGhpcy4jcmV0VHlwZUV4cHJzLm1hcChlID0+IGUuZXZhbChzY29wZSkpO1xuXG5cdFx0cmV0dXJuIG5ldyBGdW5jVHlwZShhcmdUeXBlcywgcmV0VHlwZXMpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRoaXMuI2FyZ1R5cGVFeHBycy5mb3JFYWNoKGFyZyA9PiBhcmcudXNlKCkpO1xuXHRcdHRoaXMuI3JldFR5cGVFeHBycy5mb3JFYWNoKGUgPT4gZS51c2UoKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIG9mIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZSB0byBWYWx1ZXMuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBWYWx1ZUV4cHIgZXh0ZW5kcyBFeHByIHtcblx0LyoqIEB0eXBlIHs/SW5zdGFuY2V9ICovXG5cdCNjYWNoZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXG5cdFx0dGhpcy4jY2FjaGUgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRpZiAodGhpcy4jY2FjaGUgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInR5cGUgbm90IHlldCBldmFsdWF0ZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiNjYWNoZTtcblx0XHR9XG5cdH1cblxuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZS5nZXRUeXBlKHRoaXMuc2l0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRpZiAodGhpcy4jY2FjaGUgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuI2NhY2hlID0gdGhpcy5ldmFsSW50ZXJuYWwoc2NvcGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLiNjYWNoZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIEludGVybWVkaWF0ZSBSZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIGV4cHJlc3Npb24uXG5cdCAqIFRoZSBJUiBzaG91bGQgYmUgaW5kZW50ZWQgdG8gbWFrZSBkZWJ1Z2dpbmcgZWFzaWVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdH1cbn1cblxuLyoqXG4gKiAnLi4uID0gLi4uIDsgLi4uJyBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBBc3NpZ25FeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0I25hbWVUeXBlcztcblx0I3Vwc3RyZWFtRXhwcjtcblx0I2Rvd25zdHJlYW1FeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7RGVzdHJ1Y3RFeHByW119IG5hbWVUeXBlcyBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IHVwc3RyZWFtRXhwciBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IGRvd25zdHJlYW1FeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgbmFtZVR5cGVzLCB1cHN0cmVhbUV4cHIsIGRvd25zdHJlYW1FeHByKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0YXNzZXJ0KG5hbWVUeXBlcy5sZW5ndGggPiAwKTtcblx0XHR0aGlzLiNuYW1lVHlwZXMgPSBuYW1lVHlwZXM7XG5cdFx0dGhpcy4jdXBzdHJlYW1FeHByID0gYXNzZXJ0RGVmaW5lZCh1cHN0cmVhbUV4cHIpO1xuXHRcdHRoaXMuI2Rvd25zdHJlYW1FeHByID0gYXNzZXJ0RGVmaW5lZChkb3duc3RyZWFtRXhwcik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdGxldCBkb3duc3RyZWFtU3RyID0gdGhpcy4jZG93bnN0cmVhbUV4cHIudG9TdHJpbmcoKTtcblx0XHRhc3NlcnQoZG93bnN0cmVhbVN0ciAhPSB1bmRlZmluZWQpO1xuXG5cdFx0aWYgKHRoaXMuI25hbWVUeXBlcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHJldHVybiBgJHt0aGlzLiNuYW1lVHlwZXMudG9TdHJpbmcoKX0gPSAke3RoaXMuI3Vwc3RyZWFtRXhwci50b1N0cmluZygpfTsgJHtkb3duc3RyZWFtU3RyfWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBgKCR7dGhpcy4jbmFtZVR5cGVzLm1hcChudCA9PiBudC50b1N0cmluZygpKS5qb2luKFwiLCBcIil9KSA9ICR7dGhpcy4jdXBzdHJlYW1FeHByLnRvU3RyaW5nKCl9OyAke2Rvd25zdHJlYW1TdHJ9YDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBzdWJTY29wZSA9IG5ldyBTY29wZShzY29wZSk7XG5cblx0XHRsZXQgdXBzdHJlYW1WYWwgPSB0aGlzLiN1cHN0cmVhbUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAodGhpcy4jbmFtZVR5cGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGlmICghKHVwc3RyZWFtVmFsIGluc3RhbmNlb2YgTXVsdGlJbnN0YW5jZSkpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy50eXBlRXJyb3IoXCJyaHMgaW5zJ3QgYSBtdWx0aS12YWx1ZVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCB2YWxzID0gdXBzdHJlYW1WYWwudmFsdWVzO1xuXG5cdFx0XHRcdGlmICh0aGlzLiNuYW1lVHlwZXMubGVuZ3RoICE9IHZhbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy50eXBlRXJyb3IoYGV4cGVjdGVkICR7dGhpcy4jbmFtZVR5cGVzLmxlbmd0aH0gcmhzIGluIG11bHRpLWFzc2lnbiwgZ290ICR7dmFscy5sZW5ndGh9YCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4jbmFtZVR5cGVzLmZvckVhY2goKG50LCBpKSA9PiBudC5ldmFsSW5Bc3NpZ25FeHByKHN1YlNjb3BlLCB2YWxzW2ldLmdldFR5cGUobnQuc2l0ZSksIGkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXVwc3RyZWFtVmFsLmlzVmFsdWUoKSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLnR5cGVFcnJvcihcInJocyBpc24ndCBhIHZhbHVlXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy4jbmFtZVR5cGVzWzBdLmhhc1R5cGUoKSkge1xuXHRcdFx0XHR0aGlzLiNuYW1lVHlwZXNbMF0uZXZhbEluQXNzaWduRXhwcihzdWJTY29wZSwgdXBzdHJlYW1WYWwuZ2V0VHlwZSh0aGlzLiNuYW1lVHlwZXNbMF0uc2l0ZSksIDApO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLiN1cHN0cmVhbUV4cHIuaXNMaXRlcmFsKCkpIHtcblx0XHRcdFx0Ly8gZW51bSB2YXJpYW50IHR5cGUgcmVzdWx0aW5nIGZyb20gYSBjb25zdHJ1Y3Rvci1saWtlIGFzc29jaWF0ZWQgZnVuY3Rpb24gbXVzdCBiZSBjYXN0IGJhY2sgaW50byBpdHMgZW51bSB0eXBlXG5cdFx0XHRcdGlmICgodGhpcy4jdXBzdHJlYW1FeHByIGluc3RhbmNlb2YgQ2FsbEV4cHIgJiZcblx0XHRcdFx0XHR0aGlzLiN1cHN0cmVhbUV4cHIuZm5FeHByIGluc3RhbmNlb2YgVmFsdWVQYXRoRXhwcikgfHwgXG5cdFx0XHRcdFx0KHRoaXMuI3Vwc3RyZWFtRXhwciBpbnN0YW5jZW9mIFZhbHVlUGF0aEV4cHIgJiYgXG5cdFx0XHRcdFx0IXRoaXMuI3Vwc3RyZWFtRXhwci5pc1plcm9GaWVsZENvbnN0cnVjdG9yKCkpKSBcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCB1cHN0cmVhbVR5cGUgPSB1cHN0cmVhbVZhbC5nZXRUeXBlKHRoaXMuI3Vwc3RyZWFtRXhwci5zaXRlKTtcblxuXHRcdFx0XHRcdGlmICh1cHN0cmVhbVR5cGUuaXNFbnVtTWVtYmVyKCkpIHtcblx0XHRcdFx0XHRcdHVwc3RyZWFtVmFsID0gSW5zdGFuY2UubmV3KHVwc3RyZWFtVHlwZS5wYXJlbnRUeXBlKFNpdGUuZHVtbXkoKSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN1YlNjb3BlLnNldCh0aGlzLiNuYW1lVHlwZXNbMF0ubmFtZSwgdXBzdHJlYW1WYWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgdGhpcy50eXBlRXJyb3IoXCJ1bmFibGUgdG8gaW5mZXIgdHlwZSBvZiBhc3NpZ25tZW50IHJoc1wiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBkb3duc3RyZWFtVmFsID0gdGhpcy4jZG93bnN0cmVhbUV4cHIuZXZhbChzdWJTY29wZSk7XG5cblx0XHRzdWJTY29wZS5hc3NlcnRBbGxVc2VkKCk7XG5cblx0XHRyZXR1cm4gZG93bnN0cmVhbVZhbDtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNuYW1lVHlwZXMuZm9yRWFjaChudCA9PiBudC51c2UoKSk7XG5cdFx0dGhpcy4jdXBzdHJlYW1FeHByLnVzZSgpO1xuXHRcdHRoaXMuI2Rvd25zdHJlYW1FeHByLnVzZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHRcblx0XHRpZiAodGhpcy4jbmFtZVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGV0IGlubmVyID0gdGhpcy4jZG93bnN0cmVhbUV4cHIudG9JUihpbmRlbnQgKyBUQUIpO1xuXG5cdFx0XHRpbm5lciA9IHRoaXMuI25hbWVUeXBlc1swXS53cmFwRGVzdHJ1Y3RJUihpbmRlbnQsIGlubmVyLCAwKTtcblxuXHRcdFx0bGV0IHVwc3RyZWFtID0gdGhpcy4jdXBzdHJlYW1FeHByLnRvSVIoaW5kZW50KTtcblxuXHRcdFx0Ly8gZW51bSBtZW1iZXIgcnVuLXRpbWUgZXJyb3IgSVJcblx0XHRcdGlmICh0aGlzLiNuYW1lVHlwZXNbMF0uaGFzVHlwZSgpKSB7XG5cdFx0XHRcdGNvbnN0IHQgPSB0aGlzLiNuYW1lVHlwZXNbMF0udHlwZTtcblxuXHRcdFx0XHRpZiAodC5pc0VudW1NZW1iZXIoKSkge1xuXHRcdFx0XHRcdHVwc3RyZWFtID0gbmV3IElSKFtcblx0XHRcdFx0XHRcdG5ldyBJUihcIl9faGVsaW9zX19jb21tb25fX2Fzc2VydF9jb25zdHJfaW5kZXgoXCIpLFxuXHRcdFx0XHRcdFx0dXBzdHJlYW0sXG5cdFx0XHRcdFx0XHRuZXcgSVIoYCwgJHt0LmdldENvbnN0ckluZGV4KHRoaXMuI25hbWVUeXBlc1swXS5zaXRlKX0pYClcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKFwiKFwiKSxcblx0XHRcdFx0dGhpcy4jbmFtZVR5cGVzWzBdLnRvTmFtZUlSKDApLFxuXHRcdFx0XHRuZXcgSVIoXCIpIFwiKSxcblx0XHRcdFx0bmV3IElSKFwiLT5cIiwgdGhpcy5zaXRlKSwgbmV3IElSKGAge1xcbiR7aW5kZW50fSR7VEFCfWApLFxuXHRcdFx0XHRpbm5lcixcblx0XHRcdFx0bmV3IElSKGBcXG4ke2luZGVudH19KGApLFxuXHRcdFx0XHR1cHN0cmVhbSxcblx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpbm5lciA9IHRoaXMuI2Rvd25zdHJlYW1FeHByLnRvSVIoaW5kZW50ICsgVEFCICsgVEFCKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuI25hbWVUeXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHQvLyBpbnRlcm5hbGx5IGdlbmVyYXRlcyBlbnVtLW1lbWJlciBlcnJvciBJUlxuXHRcdFx0XHRpbm5lciA9IHRoaXMuI25hbWVUeXBlc1tpXS53cmFwRGVzdHJ1Y3RJUihpbmRlbnQsIGlubmVyLCBpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXIgPSBuZXcgSVIoW1xuXHRcdFx0XHR0aGlzLiN1cHN0cmVhbUV4cHIudG9JUihpbmRlbnQpLFxuXHRcdFx0XHRuZXcgSVIoYChcXG4ke2luZGVudCArIFRBQn0oYCksIG5ldyBJUih0aGlzLiNuYW1lVHlwZXMubWFwKChudCwgaSkgPT4gbnQudG9OYW1lSVIoaSkpKS5qb2luKFwiLCBcIiksIG5ldyBJUihcIikgLT5cIiwgdGhpcy5zaXRlKSwgbmV3IElSKGAge1xcbiR7aW5kZW50fSR7VEFCfSR7VEFCfWApLFxuXHRcdFx0XHRpbm5lcixcblx0XHRcdFx0bmV3IElSKGBcXG4ke2luZGVudCArIFRBQn19XFxuJHtpbmRlbnR9KWApXG5cdFx0XHRdKTtcblxuXHRcdFx0cmV0dXJuIGlyO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIHByaW50KC4uLik7IC4uLiBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBQcmludEV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjbXNnRXhwcjtcblx0I2Rvd25zdHJlYW1FeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByfSBtc2dFeHByIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gZG93bnN0cmVhbUV4cHIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBtc2dFeHByLCBkb3duc3RyZWFtRXhwcikge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI21zZ0V4cHIgPSBtc2dFeHByO1xuXHRcdHRoaXMuI2Rvd25zdHJlYW1FeHByID0gZG93bnN0cmVhbUV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdGxldCBkb3duc3RyZWFtU3RyID0gdGhpcy4jZG93bnN0cmVhbUV4cHIudG9TdHJpbmcoKTtcblx0XHRhc3NlcnQoZG93bnN0cmVhbVN0ciAhPSB1bmRlZmluZWQpO1xuXHRcdHJldHVybiBgcHJpbnQoJHt0aGlzLiNtc2dFeHByLnRvU3RyaW5nKCl9KTsgJHtkb3duc3RyZWFtU3RyfWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBtc2dWYWwgPSB0aGlzLiNtc2dFeHByLmV2YWwoc2NvcGUpO1xuXG5cdFx0YXNzZXJ0KG1zZ1ZhbC5pc1ZhbHVlKCkpO1xuXG5cdFx0aWYgKCFtc2dWYWwuaXNJbnN0YW5jZU9mKHRoaXMuI21zZ0V4cHIuc2l0ZSwgU3RyaW5nVHlwZSkpIHtcblx0XHRcdHRocm93IHRoaXMuI21zZ0V4cHIudHlwZUVycm9yKFwiZXhwZWN0ZWQgc3RyaW5nIGFyZyBmb3IgcHJpbnRcIik7XG5cdFx0fVxuXG5cdFx0bGV0IGRvd25zdHJlYW1WYWwgPSB0aGlzLiNkb3duc3RyZWFtRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdHJldHVybiBkb3duc3RyZWFtVmFsO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRoaXMuI21zZ0V4cHIudXNlKCk7XG5cdFx0dGhpcy4jZG93bnN0cmVhbUV4cHIudXNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoXCJfX2NvcmVfX3RyYWNlXCIsIHRoaXMuc2l0ZSksIG5ldyBJUihcIihcIiksIG5ldyBJUihcIl9faGVsaW9zX19jb21tb25fX3VuU3RyaW5nRGF0YShcIiksXG5cdFx0XHR0aGlzLiNtc2dFeHByLnRvSVIoaW5kZW50KSxcblx0XHRcdG5ldyBJUihgKSwgKCkgLT4ge1xcbiR7aW5kZW50fSR7VEFCfWApLFxuXHRcdFx0dGhpcy4jZG93bnN0cmVhbUV4cHIudG9JUihpbmRlbnQgKyBUQUIpLFxuXHRcdFx0bmV3IElSKGBcXG4ke2luZGVudH19KSgpYClcblx0XHRdKTtcblx0fVxufVxuXG4vKipcbiAqIEhlbGlvcyBlcXVpdmFsZW50IG9mIHVuaXRcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFZvaWRFeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSkge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiKClcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0cmV0dXJuIG5ldyBWb2lkSW5zdGFuY2UoKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0fVxuXG5cdHRvSVIoKSB7XG5cdFx0cmV0dXJuIG5ldyBJUihcIigpXCIsIHRoaXMuc2l0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBleHByKC4uLik7IC4uLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQ2hhaW5FeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0I3Vwc3RyZWFtRXhwcjtcblx0I2Rvd25zdHJlYW1FeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByfSB1cHN0cmVhbUV4cHIgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByfSBkb3duc3RyZWFtRXhwciBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIHVwc3RyZWFtRXhwciwgZG93bnN0cmVhbUV4cHIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN1cHN0cmVhbUV4cHIgPSB1cHN0cmVhbUV4cHI7XG5cdFx0dGhpcy4jZG93bnN0cmVhbUV4cHIgPSBkb3duc3RyZWFtRXhwcjtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiN1cHN0cmVhbUV4cHIudG9TdHJpbmcoKX07ICR7dGhpcy4jZG93bnN0cmVhbUV4cHIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCB1cHN0cmVhbVZhbCA9IHRoaXMuI3Vwc3RyZWFtRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdGlmICh1cHN0cmVhbVZhbCBpbnN0YW5jZW9mIEVycm9ySW5zdGFuY2UpIHtcblx0XHRcdHRocm93IHRoaXMuI2Rvd25zdHJlYW1FeHByLnR5cGVFcnJvcihcInVucmVhY2hhYmxlIGNvZGUgKHVwc3RyZWFtIGFsd2F5cyB0aHJvd3MgZXJyb3IpXCIpO1xuXHRcdH0gZWxzZSBpZiAoISh1cHN0cmVhbVZhbCBpbnN0YW5jZW9mIFZvaWRJbnN0YW5jZSkpIHtcblx0XHRcdHRocm93IHRoaXMuI3Vwc3RyZWFtRXhwci50eXBlRXJyb3IoXCJ1bmV4cGVjdGVkIHJldHVybiB2YWx1ZSAoaGludDogdXNlICc9J1wiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy4jZG93bnN0cmVhbUV4cHIuZXZhbChzY29wZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jdXBzdHJlYW1FeHByLnVzZSgpO1xuXHRcdHRoaXMuI2Rvd25zdHJlYW1FeHByLnVzZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKFwiX19jb3JlX19jaG9vc2VVbml0KFwiLCB0aGlzLnNpdGUpLFxuXHRcdFx0dGhpcy4jdXBzdHJlYW1FeHByLnRvSVIoaW5kZW50KSxcblx0XHRcdG5ldyBJUihcIiwgXCIpLFxuXHRcdFx0dGhpcy4jZG93bnN0cmVhbUV4cHIudG9JUihpbmRlbnQpLFxuXHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdF0pO1xuXHR9XG59XG5cbi8qKlxuICogTGl0ZXJhbCBleHByZXNzaW9uIGNsYXNzICh3cmFwcyBsaXRlcmFsIHRva2VucylcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFByaW1pdGl2ZUxpdGVyYWxFeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0I3ByaW1pdGl2ZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtQcmltaXRpdmVMaXRlcmFsfSBwcmltaXRpdmUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwcmltaXRpdmUpIHtcblx0XHRzdXBlcihwcmltaXRpdmUuc2l0ZSk7XG5cdFx0dGhpcy4jcHJpbWl0aXZlID0gcHJpbWl0aXZlO1xuXHR9XG5cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy4jcHJpbWl0aXZlLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R5cGV9XG5cdCAqL1xuXHRnZXQgdHlwZSgpIHtcblx0XHRpZiAodGhpcy4jcHJpbWl0aXZlIGluc3RhbmNlb2YgSW50TGl0ZXJhbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBJbnRUeXBlKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwcmltaXRpdmUgaW5zdGFuY2VvZiBCb29sTGl0ZXJhbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBCb29sVHlwZSgpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy4jcHJpbWl0aXZlIGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTdHJpbmdUeXBlKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwcmltaXRpdmUgaW5zdGFuY2VvZiBCeXRlQXJyYXlMaXRlcmFsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJ5dGVBcnJheVR5cGUodGhpcy4jcHJpbWl0aXZlLmJ5dGVzLmxlbmd0aCA9PSAzMiA/IDMyIDogbnVsbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBwcmltaXRpdmUgdHlwZVwiKTtcblx0XHR9XHRcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRhSW5zdGFuY2UodGhpcy50eXBlKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50XG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdC8vIGFsbCBsaXRlcmFscyBjYW4gYmUgcmV1c2VkIGluIHRoZWlyIHN0cmluZy1mb3JtIGluIHRoZSBJUlxuXHRcdGxldCBpbm5lciA9IG5ldyBJUih0aGlzLiNwcmltaXRpdmUudG9TdHJpbmcoKSwgdGhpcy4jcHJpbWl0aXZlLnNpdGUpO1xuXG5cdFx0aWYgKHRoaXMuI3ByaW1pdGl2ZSBpbnN0YW5jZW9mIEludExpdGVyYWwpIHtcblx0XHRcdHJldHVybiBuZXcgSVIoW25ldyBJUihcIl9fY29yZV9faURhdGFcIiwgdGhpcy5zaXRlKSwgbmV3IElSKFwiKFwiKSwgaW5uZXIsIG5ldyBJUihcIilcIildKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuI3ByaW1pdGl2ZSBpbnN0YW5jZW9mIEJvb2xMaXRlcmFsKSB7XG5cdFx0XHRyZXR1cm4gaW5uZXI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwcmltaXRpdmUgaW5zdGFuY2VvZiBTdHJpbmdMaXRlcmFsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSKFtuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhXCIsIHRoaXMuc2l0ZSksIG5ldyBJUihcIihcIiksIGlubmVyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwcmltaXRpdmUgaW5zdGFuY2VvZiBCeXRlQXJyYXlMaXRlcmFsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSKFtuZXcgSVIoXCJfX2NvcmVfX2JEYXRhXCIsIHRoaXMuc2l0ZSksIG5ldyBJUihcIihcIiksIGlubmVyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBwcmltaXRpdmUgdHlwZVwiKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBMaXRlcmFsIFVwbGNEYXRhIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcGFyYW1ldGVyIHN1YnN0aXR1dGlvbnMuXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBMaXRlcmFsRGF0YUV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjdHlwZTtcblx0I2RhdGE7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtUeXBlfSB0eXBlXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGFcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIHR5cGUsIGRhdGEpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiN0eXBlID0gdHlwZTtcblx0XHR0aGlzLiNkYXRhID0gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAdHlwZSB7VHlwZX1cblx0ICovXG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzLiN0eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAjIyR7Ynl0ZXNUb0hleCh0aGlzLiNkYXRhLnRvQ2JvcigpKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMuI3R5cGUpO1xuXHR9XG5cblx0dXNlKCkge1xuXHR9XG5cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIG5ldyBJUih0aGlzLnRvU3RyaW5nKCksIHRoaXMuc2l0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTdHJ1Y3QgZmllbGQgKHBhcnQgb2YgYSBsaXRlcmFsIHN0cnVjdCBjb25zdHJ1Y3RvcilcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0cnVjdExpdGVyYWxGaWVsZCB7XG5cdCNuYW1lO1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7P1dvcmR9IG5hbWUgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByfSB2YWx1ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jdmFsdWUgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBzaXRlKCkge1xuXHRcdGlmICh0aGlzLiNuYW1lID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdmFsdWUuc2l0ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI25hbWUuc2l0ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc05hbWVkKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lICE9PSBudWxsO1xuXHR9XG5cblx0Z2V0IG5hbWUoKSB7XG5cdFx0aWYgKHRoaXMuI25hbWUgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5hbWUgb2YgZmllbGQgbm90IGdpdmVuXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jbmFtZTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRpZiAodGhpcy4jbmFtZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3ZhbHVlLnRvU3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBgJHt0aGlzLiNuYW1lLnRvU3RyaW5nKCl9OiAke3RoaXMuI3ZhbHVlLnRvU3RyaW5nKCl9YDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWUuZXZhbChzY29wZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jdmFsdWUudXNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlLnRvSVIoaW5kZW50KTtcblx0fVxufVxuXG4vKipcbiAqIFN0cnVjdCBsaXRlcmFsIGNvbnN0cnVjdG9yXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTdHJ1Y3RMaXRlcmFsRXhwciBleHRlbmRzIFZhbHVlRXhwciB7XG5cdCN0eXBlRXhwcjtcblx0I2ZpZWxkcztcblx0LyoqIEB0eXBlIHs/bnVtYmVyfSAtIHNldCBkdXJpbmcgZXZhbHVhdGlvbiAqL1xuXHQjY29uc3RySW5kZXg7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IHR5cGVFeHByIFxuXHQgKiBAcGFyYW0ge1N0cnVjdExpdGVyYWxGaWVsZFtdfSBmaWVsZHMgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0eXBlRXhwciwgZmllbGRzKSB7XG5cdFx0c3VwZXIodHlwZUV4cHIuc2l0ZSk7XG5cdFx0dGhpcy4jdHlwZUV4cHIgPSB0eXBlRXhwcjtcblx0XHR0aGlzLiNmaWVsZHMgPSBmaWVsZHM7XG5cdFx0dGhpcy4jY29uc3RySW5kZXggPSBudWxsO1xuXHR9XG5cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMuI3R5cGVFeHByLnRvU3RyaW5nKCl9eyR7dGhpcy4jZmllbGRzLm1hcChmID0+IGYudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfX1gO1xuXHR9XG5cblx0aXNOYW1lZCgpIHtcblx0XHQvLyB0aGUgZXhwcmVzc2lvbiBidWlsZGVyIGFscmVhZHkgY2hlY2tlZCB0aGF0IGFsbCBmaWVsZHMgYXJlIG5hbWVkIG9yIGFsbCBvciBwb3NpdGlvbmFsIChpLmUuIG5vdCBtaXhlZClcblx0XHRyZXR1cm4gdGhpcy4jZmllbGRzLmxlbmd0aCA+IDAgJiYgdGhpcy4jZmllbGRzWzBdLmlzTmFtZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMgXG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgdHlwZSA9IHRoaXMuI3R5cGVFeHByLmV2YWwoc2NvcGUpO1xuXG5cdFx0YXNzZXJ0KHR5cGUuaXNUeXBlKCkpO1xuXG5cdFx0dGhpcy4jY29uc3RySW5kZXggPSB0eXBlLmdldENvbnN0ckluZGV4KHRoaXMuc2l0ZSk7XG5cblx0XHRsZXQgaW5zdGFuY2UgPSBJbnN0YW5jZS5uZXcodHlwZSk7XG5cblx0XHRpZiAoaW5zdGFuY2UubkZpZWxkcyh0aGlzLnNpdGUpICE9IHRoaXMuI2ZpZWxkcy5sZW5ndGgpIHtcblx0XHRcdHRocm93IHRoaXMudHlwZUVycm9yKGB3cm9uZyBudW1iZXIgb2YgZmllbGRzIGZvciAke3R5cGUudG9TdHJpbmcoKX0sIGV4cGVjdGVkICR7aW5zdGFuY2UubkZpZWxkcyh0aGlzLnNpdGUpfSwgZ290ICR7dGhpcy4jZmllbGRzLmxlbmd0aH1gKTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI2ZpZWxkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGYgPSB0aGlzLiNmaWVsZHNbaV07XG5cdFx0XG5cdFx0XHRsZXQgZmllbGRWYWwgPSBmLmV2YWwoc2NvcGUpO1xuXG5cdFx0XHRpZiAoZi5pc05hbWVkKCkpIHtcblx0XHRcdFx0Ly8gY2hlY2sgdGhlIG5hbWVkIHR5cGVcblx0XHRcdFx0bGV0IG1lbWJlclR5cGUgPSBpbnN0YW5jZS5nZXRJbnN0YW5jZU1lbWJlcihmLm5hbWUpLmdldFR5cGUoZi5uYW1lLnNpdGUpO1xuXG5cdFx0XHRcdGlmICghZmllbGRWYWwuaXNJbnN0YW5jZU9mKGYuc2l0ZSwgbWVtYmVyVHlwZSkpIHtcblx0XHRcdFx0XHR0aHJvdyBmLnNpdGUudHlwZUVycm9yKGB3cm9uZyBmaWVsZCB0eXBlIGZvciAnJHtmLm5hbWUudG9TdHJpbmcoKX0nLCBleHBlY3RlZCAke21lbWJlclR5cGUudG9TdHJpbmcoKX0sIGdvdCAke2ZpZWxkVmFsLmdldFR5cGUoU2l0ZS5kdW1teSgpKS50b1N0cmluZygpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjaGVjayB0aGUgcG9zaXRpb25hbCB0eXBlXG5cdFx0XHRcdGxldCBtZW1iZXJUeXBlID0gaW5zdGFuY2UuZ2V0RmllbGRUeXBlKGYuc2l0ZSwgaSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWZpZWxkVmFsLmlzSW5zdGFuY2VPZihmLnNpdGUsIG1lbWJlclR5cGUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgZi5zaXRlLnR5cGVFcnJvcihgd3JvbmcgZmllbGQgdHlwZSBmb3IgZmllbGQgJHtpLnRvU3RyaW5nKCl9LCBleHBlY3RlZCAke21lbWJlclR5cGUudG9TdHJpbmcoKX0sIGdvdCAke2ZpZWxkVmFsLmdldFR5cGUoU2l0ZS5kdW1teSgpKS50b1N0cmluZygpfWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRoaXMuI3R5cGVFeHByLnVzZSgpO1xuXG5cdFx0Zm9yIChsZXQgZiBvZiB0aGlzLiNmaWVsZHMpIHtcblx0XHRcdGYudXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuXHQgKiBAcGFyYW0ge1R5cGV9IHR5cGVcblx0ICogQHBhcmFtIHtJUltdfSBmaWVsZHNcblx0ICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBjb25zdHJJbmRleFxuXHQgKi9cblx0c3RhdGljIHRvSVJJbnRlcm5hbChzaXRlLCB0eXBlLCBmaWVsZHMsIGNvbnN0ckluZGV4KSB7XG5cdFx0bGV0IGlyID0gbmV3IElSKFwiX19jb3JlX19ta05pbERhdGEoKCkpXCIpO1xuXG5cdFx0Y29uc3QgaW5zdGFuY2UgPSBJbnN0YW5jZS5uZXcodHlwZSk7XG5cblx0XHRmb3IgKGxldCBpID0gZmllbGRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsZXQgZiA9IGZpZWxkc1tpXTtcblxuXHRcdFx0Y29uc3QgaXNCb29sID0gaW5zdGFuY2UuZ2V0RmllbGRUeXBlKHNpdGUsIGkpIGluc3RhbmNlb2YgQm9vbFR5cGU7XG5cblx0XHRcdGlmIChpc0Jvb2wpIHtcblx0XHRcdFx0ZiA9IG5ldyBJUihbXG5cdFx0XHRcdFx0bmV3IElSKFwiX19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEoXCIpLFxuXHRcdFx0XHRcdGYsXG5cdFx0XHRcdFx0bmV3IElSKFwiKVwiKSxcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGluIGNhc2Ugb2YgYSBzdHJ1Y3Qgd2l0aCBvbmx5IG9uZSBmaWVsZCwgcmV0dXJuIHRoYXQgZmllbGQgZGlyZWN0bHkgXG5cdFx0XHRpZiAoZmllbGRzLmxlbmd0aCA9PSAxICYmIHR5cGUgaW5zdGFuY2VvZiBTdHJ1Y3RTdGF0ZW1lbnRUeXBlKSB7XG5cdFx0XHRcdHJldHVybiBmO1xuXHRcdFx0fVxuXG5cdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdG5ldyBJUihcIl9fY29yZV9fbWtDb25zKFwiKSxcblx0XHRcdFx0Zixcblx0XHRcdFx0bmV3IElSKFwiLCBcIiksXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIpXCIpXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHRpZiAoY29uc3RySW5kZXggPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0ckluZGV4IG5vdCB5ZXQgc2V0XCIpO1xuXHRcdH0gZWxzZSBpZiAoY29uc3RySW5kZXggPT0gLTEpIHtcblx0XHRcdC8vIHJlZ3VsYXIgc3RydWN0XG5cdFx0XHRyZXR1cm4gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKFwiX19jb3JlX19saXN0RGF0YVwiLCBzaXRlKSxcblx0XHRcdFx0bmV3IElSKFwiKFwiKSwgXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIpXCIpXG5cdFx0XHRdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRcdG5ldyBJUihcIl9fY29yZV9fY29uc3RyRGF0YVwiLCBzaXRlKSwgbmV3IElSKGAoJHtjb25zdHJJbmRleC50b1N0cmluZygpfSwgYCksXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIpXCIpXG5cdFx0XHRdKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHRjb25zdCB0eXBlID0gdGhpcy4jdHlwZUV4cHIudHlwZTtcblxuXHRcdGNvbnN0IGZpZWxkcyA9IHRoaXMuI2ZpZWxkcy5zbGljZSgpO1xuXG5cdFx0Ly8gc29ydCBmaWVsZHMgYnkgY29ycmVjdCBuYW1lXG5cdFx0aWYgKHRoaXMuaXNOYW1lZCgpKSB7XG5cdFx0XHRmaWVsZHMuc29ydCgoYSwgYikgPT4gdHlwZS5nZXRGaWVsZEluZGV4KHRoaXMuc2l0ZSwgYS5uYW1lLnZhbHVlKSAtIHR5cGUuZ2V0RmllbGRJbmRleCh0aGlzLnNpdGUsIGIubmFtZS52YWx1ZSkpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlyRmllbGRzID0gZmllbGRzLm1hcChmID0+IGYudG9JUihpbmRlbnQpKTtcblxuXHRcdHJldHVybiBTdHJ1Y3RMaXRlcmFsRXhwci50b0lSSW50ZXJuYWwodGhpcy5zaXRlLCB0eXBlLCBpckZpZWxkcywgdGhpcy4jY29uc3RySW5kZXgpO1xuXHR9XG59XG5cbi8qKlxuICogW117Li4ufSBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBMaXN0TGl0ZXJhbEV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjaXRlbVR5cGVFeHByO1xuXHQjaXRlbUV4cHJzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IGl0ZW1UeXBlRXhwciBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJbXX0gaXRlbUV4cHJzIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgaXRlbVR5cGVFeHByLCBpdGVtRXhwcnMpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNpdGVtVHlwZUV4cHIgPSBpdGVtVHlwZUV4cHI7XG5cdFx0dGhpcy4jaXRlbUV4cHJzID0gaXRlbUV4cHJzO1xuXHR9XG5cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBbXSR7dGhpcy4jaXRlbVR5cGVFeHByLnRvU3RyaW5nKCl9eyR7dGhpcy4jaXRlbUV4cHJzLm1hcChpdGVtRXhwciA9PiBpdGVtRXhwci50b1N0cmluZygpKS5qb2luKCcsICcpfX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlXG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgaXRlbVR5cGUgPSB0aGlzLiNpdGVtVHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAoaXRlbVR5cGUgaW5zdGFuY2VvZiBGdW5jVHlwZSkge1xuXHRcdFx0dGhyb3cgdGhpcy4jaXRlbVR5cGVFeHByLnR5cGVFcnJvcihcImNvbnRlbnQgb2YgbGlzdCBjYW4ndCBiZSBmdW5jXCIpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGl0ZW1FeHByIG9mIHRoaXMuI2l0ZW1FeHBycykge1xuXHRcdFx0bGV0IGl0ZW1WYWwgPSBpdGVtRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdFx0aWYgKCFpdGVtVmFsLmlzSW5zdGFuY2VPZihpdGVtRXhwci5zaXRlLCBpdGVtVHlwZSkpIHtcblx0XHRcdFx0dGhyb3cgaXRlbUV4cHIudHlwZUVycm9yKGBleHBlY3RlZCAke2l0ZW1UeXBlLnRvU3RyaW5nKCl9LCBnb3QgJHtpdGVtVmFsLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgTGlzdFR5cGUoaXRlbVR5cGUpKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNpdGVtVHlwZUV4cHIudXNlKCk7XG5cblx0XHRmb3IgKGxldCBpdGVtIG9mIHRoaXMuI2l0ZW1FeHBycykge1xuXHRcdFx0aXRlbS51c2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0bGV0IGlzQm9vbCA9IHRoaXMuI2l0ZW1UeXBlRXhwci50eXBlIGluc3RhbmNlb2YgQm9vbFR5cGU7XG5cblx0XHQvLyB1bnN1cmUgaWYgbGlzdCBsaXRlcmFscyBpbiB1bnR5cGVkIFBsdXR1cy1jb3JlIGFjY2VwdCBhcmJpdHJhcnkgdGVybXMsIHNvIHdlIHdpbGwgdXNlIHRoZSBtb3JlIHZlcmJvc2UgY29uc3RydWN0b3IgZnVuY3Rpb25zIFxuXHRcdGxldCByZXMgPSBuZXcgSVIoXCJfX2NvcmVfX21rTmlsRGF0YSgoKSlcIik7XG5cblx0XHQvLyBzdGFydGluZyBmcm9tIGxhc3QgZWxlbWVudCwga2VlcGluZyBwcmVwZW5kaW5nIGEgZGF0YSB2ZXJzaW9uIG9mIHRoYXQgaXRlbVxuXG5cdFx0Zm9yIChsZXQgaSA9IHRoaXMuI2l0ZW1FeHBycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGl0ZW1JUiA9IHRoaXMuI2l0ZW1FeHByc1tpXS50b0lSKGluZGVudCk7XG5cblx0XHRcdGlmIChpc0Jvb2wpIHtcblx0XHRcdFx0aXRlbUlSID0gbmV3IElSKFtcblx0XHRcdFx0XHRuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShcIiksXG5cdFx0XHRcdFx0aXRlbUlSLFxuXHRcdFx0XHRcdG5ldyBJUihcIilcIiksXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXMgPSBuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoXCJfX2NvcmVfX21rQ29ucyhcIiksXG5cdFx0XHRcdGl0ZW1JUixcblx0XHRcdFx0bmV3IElSKFwiLCBcIiksXG5cdFx0XHRcdHJlcyxcblx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUihbbmV3IElSKFwiX19jb3JlX19saXN0RGF0YVwiLCB0aGlzLnNpdGUpLCBuZXcgSVIoXCIoXCIpLCByZXMsIG5ldyBJUihcIilcIildKTtcblx0fVxufVxuXG4vKipcbiAqIE1hcFsuLi5dLi4uey4uLiA6IC4uLn0gZXhwcmVzc2lvblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgTWFwTGl0ZXJhbEV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQja2V5VHlwZUV4cHI7XG5cdCN2YWx1ZVR5cGVFeHByO1xuXHQjcGFpckV4cHJzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IGtleVR5cGVFeHByIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByfSB2YWx1ZVR5cGVFeHByXG5cdCAqIEBwYXJhbSB7W1ZhbHVlRXhwciwgVmFsdWVFeHByXVtdfSBwYWlyRXhwcnMgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBrZXlUeXBlRXhwciwgdmFsdWVUeXBlRXhwciwgcGFpckV4cHJzKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4ja2V5VHlwZUV4cHIgPSBrZXlUeXBlRXhwcjtcblx0XHR0aGlzLiN2YWx1ZVR5cGVFeHByID0gdmFsdWVUeXBlRXhwcjtcblx0XHR0aGlzLiNwYWlyRXhwcnMgPSBwYWlyRXhwcnM7XG5cdH1cblxuXHRpc0xpdGVyYWwoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYE1hcFske3RoaXMuI2tleVR5cGVFeHByLnRvU3RyaW5nKCl9XSR7dGhpcy4jdmFsdWVUeXBlRXhwci50b1N0cmluZygpfXske3RoaXMuI3BhaXJFeHBycy5tYXAoKFtrZXlFeHByLCB2YWx1ZUV4cHJdKSA9PiBgJHtrZXlFeHByLnRvU3RyaW5nKCl9OiAke3ZhbHVlRXhwci50b1N0cmluZygpfWApLmpvaW4oJywgJyl9fWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGVcblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBrZXlUeXBlID0gdGhpcy4ja2V5VHlwZUV4cHIuZXZhbChzY29wZSk7XG5cdFx0bGV0IHZhbHVlVHlwZSA9IHRoaXMuI3ZhbHVlVHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRpZiAoa2V5VHlwZSBpbnN0YW5jZW9mIEZ1bmNUeXBlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLiNrZXlUeXBlRXhwci50eXBlRXJyb3IoXCJrZXktdHlwZSBvZiBNYXAgY2FuJ3QgYmUgZnVuY1wiKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlVHlwZSBpbnN0YW5jZW9mIEZ1bmNUeXBlKSB7XG5cdFx0XHR0aHJvdyB0aGlzLiN2YWx1ZVR5cGVFeHByLnR5cGVFcnJvcihcInZhbHVlLXR5cGUgb2YgTWFwIGNhbid0IGJlIGZ1bmNcIik7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgW2tleUV4cHIsIHZhbHVlRXhwcl0gb2YgdGhpcy4jcGFpckV4cHJzKSB7XG5cdFx0XHRsZXQga2V5VmFsID0ga2V5RXhwci5ldmFsKHNjb3BlKTtcblx0XHRcdGxldCB2YWx1ZVZhbCA9IHZhbHVlRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdFx0aWYgKCFrZXlWYWwuaXNJbnN0YW5jZU9mKGtleUV4cHIuc2l0ZSwga2V5VHlwZSkpIHtcblx0XHRcdFx0dGhyb3cga2V5RXhwci50eXBlRXJyb3IoYGV4cGVjdGVkICR7a2V5VHlwZS50b1N0cmluZygpfSBmb3IgbWFwIGtleSwgZ290ICR7a2V5VmFsLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZVZhbC5pc0luc3RhbmNlT2YodmFsdWVFeHByLnNpdGUsIHZhbHVlVHlwZSkpIHtcblx0XHRcdFx0dGhyb3cgdmFsdWVFeHByLnR5cGVFcnJvcihgZXhwZWN0ZWQgJHt2YWx1ZVR5cGUudG9TdHJpbmcoKX0gZm9yIG1hcCB2YWx1ZSwgZ290ICR7dmFsdWVWYWwudG9TdHJpbmcoKX1gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KG5ldyBNYXBUeXBlKGtleVR5cGUsIHZhbHVlVHlwZSkpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRoaXMuI2tleVR5cGVFeHByLnVzZSgpO1xuXHRcdHRoaXMuI3ZhbHVlVHlwZUV4cHIudXNlKCk7XG5cblx0XHRmb3IgKGxldCBbZnN0LCBzbmRdIG9mIHRoaXMuI3BhaXJFeHBycykge1xuXHRcdFx0ZnN0LnVzZSgpO1xuXHRcdFx0c25kLnVzZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHRsZXQgaXNCb29sVmFsdWUgPSB0aGlzLiN2YWx1ZVR5cGVFeHByLnR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZTtcblxuXHRcdC8vIHVuc3VyZSBpZiBsaXN0IGxpdGVyYWxzIGluIHVudHlwZWQgUGx1dHVzLWNvcmUgYWNjZXB0IGFyYml0cmFyeSB0ZXJtcywgc28gd2Ugd2lsbCB1c2UgdGhlIG1vcmUgdmVyYm9zZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgXG5cdFx0bGV0IHJlcyA9IG5ldyBJUihcIl9fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSlcIik7XG5cblx0XHQvLyBzdGFydGluZyBmcm9tIGxhc3QgZWxlbWVudCwga2VlcGluZyBwcmVwZW5kaW5nIGEgZGF0YSB2ZXJzaW9uIG9mIHRoYXQgaXRlbVxuXG5cdFx0Zm9yIChsZXQgaSA9IHRoaXMuI3BhaXJFeHBycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IFtrZXlFeHByLCB2YWx1ZUV4cHJdID0gdGhpcy4jcGFpckV4cHJzW2ldO1xuXG5cdFx0XHRsZXQgdmFsdWVJUiA9IHZhbHVlRXhwci50b0lSKGluZGVudCk7XG5cblx0XHRcdGlmIChpc0Jvb2xWYWx1ZSkge1xuXHRcdFx0XHR2YWx1ZUlSID0gbmV3IElSKFtcblx0XHRcdFx0XHRuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShcIiksXG5cdFx0XHRcdFx0dmFsdWVJUixcblx0XHRcdFx0XHRuZXcgSVIoXCIpXCIpLFxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzID0gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKFwiX19jb3JlX19ta0NvbnMoXCIpLFxuXHRcdFx0XHRuZXcgSVIoXCJfX2NvcmVfX21rUGFpckRhdGEoXCIpLFxuXHRcdFx0XHRrZXlFeHByLnRvSVIoaW5kZW50KSxcblx0XHRcdFx0bmV3IElSKFwiLFwiKSxcblx0XHRcdFx0dmFsdWVJUixcblx0XHRcdFx0bmV3IElSKFwiKVwiKSxcblx0XHRcdFx0bmV3IElSKFwiLCBcIiksXG5cdFx0XHRcdHJlcyxcblx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUihbbmV3IElSKFwiX19jb3JlX19tYXBEYXRhXCIsIHRoaXMuc2l0ZSksIG5ldyBJUihcIihcIiksIHJlcywgbmV3IElSKFwiKVwiKV0pO1xuXHR9XG59XG5cbi8qKlxuICogTmFtZVR5cGVQYWlyIGlzIGJhc2UgY2xhc3Mgb2YgRnVuY0FyZyBhbmQgRGF0YUZpZWxkIChkaWZmZXJzIGZyb20gU3RydWN0TGl0ZXJhbEZpZWxkKSBcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE5hbWVUeXBlUGFpciB7XG5cdCNuYW1lO1xuXHQjdHlwZUV4cHI7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHs/VHlwZUV4cHJ9IHR5cGVFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSwgdHlwZUV4cHIpIHtcblx0XHR0aGlzLiNuYW1lID0gbmFtZTtcblx0XHR0aGlzLiN0eXBlRXhwciA9IHR5cGVFeHByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTaXRlfVxuXHQgKi9cblx0Z2V0IHNpdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUuc2l0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7V29yZH1cblx0ICovXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lO1xuXHR9XG5cblx0aXNJZ25vcmVkKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWUudmFsdWUgPT09IFwiX1wiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aGFzVHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZUV4cHIgIT09IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIGNhbGxlZCBiZWZvcmUgZXZhbFR5cGUoKVxuXHQgKiBAdHlwZSB7VHlwZX1cblx0ICovXG5cdGdldCB0eXBlKCkge1xuXHRcdGlmICh0aGlzLmlzSWdub3JlZCgpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEFueVR5cGUoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuI3R5cGVFeHByID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlRXhwciBub3Qgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZUV4cHIudHlwZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCB0eXBlTmFtZSgpIHtcblx0XHRpZiAodGhpcy4jdHlwZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZUV4cHIudG9TdHJpbmcoKTtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRpZiAodGhpcy4jdHlwZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLm5hbWUudG9TdHJpbmcoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGAke3RoaXMubmFtZS50b1N0cmluZygpfTogJHt0aGlzLiN0eXBlRXhwci50b1N0cmluZygpfWA7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgdHlwZSwgdXNlZCBieSBGdW5jTGl0ZXJhbEV4cHIgYW5kIERhdGFEZWZpbml0aW9uXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGV2YWxUeXBlKHNjb3BlKSB7XG5cdFx0aWYgKHRoaXMuaXNJZ25vcmVkKCkpIHtcblx0XHRcdHJldHVybiBuZXcgQW55VHlwZSgpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy4jdHlwZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInR5cGVFeHByIG5vdCBzZXRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlRXhwci5ldmFsKHNjb3BlKTtcblx0XHR9XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGVFeHByICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLiN0eXBlRXhwci51c2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUigpIHtcblx0XHRyZXR1cm4gbmV3IElSKHRoaXMuI25hbWUudG9TdHJpbmcoKSwgdGhpcy4jbmFtZS5zaXRlKTtcblx0fVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGFyZ3VtZW50IGNsYXNzXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBGdW5jQXJnIGV4dGVuZHMgTmFtZVR5cGVQYWlyIHtcblx0I2RlZmF1bHRWYWx1ZUV4cHI7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHs/VHlwZUV4cHJ9IHR5cGVFeHByXG5cdCAqIEBwYXJhbSB7bnVsbCB8IFZhbHVlRXhwcn0gZGVmYXVsdFZhbHVlRXhwclxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSwgdHlwZUV4cHIsIGRlZmF1bHRWYWx1ZUV4cHIgPSBudWxsKSB7XG5cdFx0c3VwZXIobmFtZSwgdHlwZUV4cHIpO1xuXG5cdFx0dGhpcy4jZGVmYXVsdFZhbHVlRXhwciA9IGRlZmF1bHRWYWx1ZUV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRldmFsRGVmYXVsdChzY29wZSkge1xuXHRcdGlmICh0aGlzLiNkZWZhdWx0VmFsdWVFeHByICE9IG51bGwpIHtcblx0XHRcdGNvbnN0IHYgPSB0aGlzLiNkZWZhdWx0VmFsdWVFeHByLmV2YWwoc2NvcGUpO1xuXG5cdFx0XHRjb25zdCB0ID0gdGhpcy5ldmFsVHlwZShzY29wZSk7XG5cblx0XHRcdGlmICghdi5pc0luc3RhbmNlT2YodGhpcy4jZGVmYXVsdFZhbHVlRXhwci5zaXRlLCB0KSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLiNkZWZhdWx0VmFsdWVFeHByLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCAke3QudG9TdHJpbmcoKX0sIGdvdCAke3YuZ2V0VHlwZShTaXRlLmR1bW15KCkpLnRvU3RyaW5nKCl9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7QXJnVHlwZX1cblx0ICovXG5cdGV2YWxBcmdUeXBlKHNjb3BlKSB7XG5cdFx0Y29uc3QgdCA9IHN1cGVyLmV2YWxUeXBlKHNjb3BlKTtcblxuXHRcdHJldHVybiBuZXcgQXJnVHlwZSh0aGlzLm5hbWUsIHQsIHRoaXMuI2RlZmF1bHRWYWx1ZUV4cHIgIT0gbnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUigpIHtcblx0XHRjb25zdCBuYW1lID0gc3VwZXIudG9JUigpO1xuXG5cdFx0aWYgKHRoaXMuI2RlZmF1bHRWYWx1ZUV4cHIgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoYF9fdXNlb3B0X18ke3RoaXMubmFtZS50b1N0cmluZygpfWApLFxuXHRcdFx0XHRuZXcgSVIoXCIsIFwiKSxcblx0XHRcdFx0bmFtZVxuXHRcdFx0XSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJ9IGJvZHlJUiBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEBwYXJhbSB7SVJ9IGRlZmF1bHRJUiBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0c3RhdGljIHdyYXBXaXRoRGVmYXVsdEludGVybmFsKGJvZHlJUiwgbmFtZSwgZGVmYXVsdElSKSB7XG5cdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoYCgke25hbWV9KSAtPiB7YCksXG5cdFx0XHRib2R5SVIsXG5cdFx0XHRuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoYH0oX19jb3JlX19pZlRoZW5FbHNlKF9fdXNlb3B0X18ke25hbWV9LCAoKSAtPiB7JHtuYW1lfX0sICgpIC0+IHtgKSxcblx0XHRcdFx0ZGVmYXVsdElSLCBcblx0XHRcdFx0bmV3IElSKFwifSkoKSlcIilcblx0XHRcdF0pXG5cdFx0XSk7XG5cdH1cblxuXHQvKipcblx0ICogKGFyZ05hbWUpIC0+IHtcblx0ICogICA8Ym9keUlSPlxuXHQgKiB9KFxuXHQgKiAgIGlmVGhlbkVsc2UoXG5cdCAqIFx0XHRfX3VzZW9wdGFyZ19fYXJnTmFtZSxcblx0ICogIFx0KCkgLT4ge1xuXHQgKiAgICAgICAgYXJnTmFtZVxuXHQgKiAgICAgIH0sXG5cdCAqICAgICAgKCkgLT4ge1xuXHQgKiAgICAgICAgPGRlZmF1bHRWYWx1ZUV4cHI+XG5cdCAqICAgICAgfVxuXHQgKiAgICkoKVxuXHQgKiApXG5cdCAqIFRPRE86IGluZGVudGF0aW9uXG5cdCAqIEBwYXJhbSB7SVJ9IGJvZHlJUiBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0d3JhcFdpdGhEZWZhdWx0KGJvZHlJUikge1xuXHRcdGlmICh0aGlzLiNkZWZhdWx0VmFsdWVFeHByID09IG51bGwpIHtcblx0XHRcdHJldHVybiBib2R5SVI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUudG9TdHJpbmcoKTtcblxuXHRcdFx0cmV0dXJuIEZ1bmNBcmcud3JhcFdpdGhEZWZhdWx0SW50ZXJuYWwoYm9keUlSLCBuYW1lLCB0aGlzLiNkZWZhdWx0VmFsdWVFeHByLnRvSVIoXCJcIikpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqICguLikgLT4gUmV0VHlwZUV4cHIgey4uLn0gZXhwcmVzc2lvblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRnVuY0xpdGVyYWxFeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0I2FyZ3M7XG5cdCNyZXRUeXBlRXhwcnM7XG5cdCNib2R5RXhwcjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge0Z1bmNBcmdbXX0gYXJncyBcblx0ICogQHBhcmFtIHsoP1R5cGVFeHByKVtdfSByZXRUeXBlRXhwcnMgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByfSBib2R5RXhwciBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGFyZ3MsIHJldFR5cGVFeHBycywgYm9keUV4cHIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNhcmdzID0gYXJncztcblx0XHR0aGlzLiNyZXRUeXBlRXhwcnMgPSByZXRUeXBlRXhwcnM7XG5cdFx0dGhpcy4jYm9keUV4cHIgPSBib2R5RXhwcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHlwZVtdfVxuXHQgKi9cblx0Z2V0IGFyZ1R5cGVzKCkge1xuXHRcdHJldHVybiB0aGlzLiNhcmdzLm1hcChhID0+IGEudHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ1tdfVxuXHQgKi9cblx0Z2V0IGFyZ1R5cGVOYW1lcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJncy5tYXAoYSA9PiBhLnR5cGVOYW1lKVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlW119XG5cdCAqL1xuXHRnZXQgcmV0VHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3JldFR5cGVFeHBycy5tYXAoZSA9PiB7XG5cdFx0XHRpZiAoZSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQW55VHlwZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGUudHlwZVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNMaXRlcmFsKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRpZiAodGhpcy4jcmV0VHlwZUV4cHJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGV0IHJldFR5cGVFeHByID0gdGhpcy4jcmV0VHlwZUV4cHJzWzBdO1xuXHRcdFx0aWYgKHJldFR5cGVFeHByID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGAoJHt0aGlzLiNhcmdzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSkgLT4geyR7dGhpcy4jYm9keUV4cHIudG9TdHJpbmcoKX19YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBgKCR7dGhpcy4jYXJncy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0pIC0+ICR7cmV0VHlwZUV4cHIudG9TdHJpbmcoKX0geyR7dGhpcy4jYm9keUV4cHIudG9TdHJpbmcoKX19YDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGAoJHt0aGlzLiNhcmdzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSkgLT4gKCR7dGhpcy4jcmV0VHlwZUV4cHJzLm1hcChlID0+IGFzc2VydERlZmluZWQoZSkudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSkgeyR7dGhpcy4jYm9keUV4cHIudG9TdHJpbmcoKX19YDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0ZXZhbFR5cGUoc2NvcGUpIHtcblx0XHRsZXQgYXJncyA9IHRoaXMuI2FyZ3M7XG5cdFx0aWYgKHRoaXMuaXNNZXRob2QoKSkge1xuXHRcdFx0YXJncyA9IGFyZ3Muc2xpY2UoMSk7XG5cdFx0fVxuXG5cdFx0bGV0IGFyZ1R5cGVzID0gYXJncy5tYXAoYSA9PiBhLmV2YWxBcmdUeXBlKHNjb3BlKSk7XG5cblx0XHRsZXQgcmV0VHlwZXMgPSB0aGlzLiNyZXRUeXBlRXhwcnMubWFwKGUgPT4ge1xuXHRcdFx0aWYgKGUgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFueVR5cGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBlLmV2YWwoc2NvcGUpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gbmV3IEZ1bmNUeXBlKGFyZ1R5cGVzLCByZXRUeXBlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtGdW5jSW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgZm5UeXBlID0gdGhpcy5ldmFsVHlwZShzY29wZSk7XG5cdFx0XG5cdFx0Ly8gYXJnVHlwZXMgaXMgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGFnYWluIGhlcmUgc28gaXQgaW5jbHVkZXMgc2VsZlxuXHRcdGxldCBhcmdUeXBlcyA9IHRoaXMuI2FyZ3MubWFwKGEgPT4gYS5ldmFsVHlwZShzY29wZSkpO1xuXG5cdFx0bGV0IHJlcyA9IG5ldyBGdW5jSW5zdGFuY2UoZm5UeXBlKTtcblxuXHRcdGxldCBzdWJTY29wZSA9IG5ldyBTY29wZShzY29wZSk7XG5cdFx0YXJnVHlwZXMuZm9yRWFjaCgoYSwgaSkgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLiNhcmdzW2ldLmlzSWdub3JlZCgpKSB7XG5cdFx0XHRcdHRoaXMuI2FyZ3NbaV0uZXZhbERlZmF1bHQoc3ViU2NvcGUpO1xuXG5cdFx0XHRcdHN1YlNjb3BlLnNldCh0aGlzLiNhcmdzW2ldLm5hbWUsIEluc3RhbmNlLm5ldyhhKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRsZXQgYm9keVZhbCA9IHRoaXMuI2JvZHlFeHByLmV2YWwoc3ViU2NvcGUpO1xuXG5cdFx0aWYgKHRoaXMuI3JldFR5cGVFeHBycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmICh0aGlzLiNyZXRUeXBlRXhwcnNbMF0gPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYm9keVZhbCBpbnN0YW5jZW9mIE11bHRpSW5zdGFuY2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZ1bmNJbnN0YW5jZShuZXcgRnVuY1R5cGUoZm5UeXBlLmFyZ1R5cGVzLCBib2R5VmFsLnZhbHVlcy5tYXAodiA9PiB2LmdldFR5cGUodGhpcy5zaXRlKSkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEZ1bmNJbnN0YW5jZShuZXcgRnVuY1R5cGUoZm5UeXBlLmFyZ1R5cGVzLCBib2R5VmFsLmdldFR5cGUodGhpcy5zaXRlKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGJvZHlWYWwgaW5zdGFuY2VvZiBNdWx0aUluc3RhbmNlKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuI3JldFR5cGVFeHByc1swXS50eXBlRXJyb3IoXCJ1bmV4cGVjdGVkIG11bHRpLXZhbHVlIGJvZHlcIik7XG5cdFx0XHR9IGVsc2UgaWYgKCFib2R5VmFsLmlzSW5zdGFuY2VPZih0aGlzLiNyZXRUeXBlRXhwcnNbMF0uc2l0ZSwgZm5UeXBlLnJldFR5cGVzWzBdKSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLiNyZXRUeXBlRXhwcnNbMF0udHlwZUVycm9yKGB3cm9uZyByZXR1cm4gdHlwZSwgZXhwZWN0ZWQgJHtmblR5cGUucmV0VHlwZXNbMF0udG9TdHJpbmcoKX0gYnV0IGdvdCAke3RoaXMuI2JvZHlFeHByLnR5cGUudG9TdHJpbmcoKX1gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGJvZHlWYWwgaW5zdGFuY2VvZiBNdWx0aUluc3RhbmNlKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7SW5zdGFuY2VbXX0gKi9cblx0XHRcdFx0bGV0IGJvZHlWYWxzID0gYm9keVZhbC52YWx1ZXM7XG5cblx0XHRcdFx0aWYgKGJvZHlWYWxzLmxlbmd0aCAhPT0gdGhpcy4jcmV0VHlwZUV4cHJzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRocm93IHRoaXMuI2JvZHlFeHByLnR5cGVFcnJvcihgZXhwZWN0ZWQgbXVsdGktdmFsdWUgZnVuY3Rpb24gYm9keSB3aXRoICR7dGhpcy4jcmV0VHlwZUV4cHJzLmxlbmd0aH0gdmFsdWVzLCBidXQgZ290ICR7Ym9keVZhbHMubGVuZ3RofSB2YWx1ZXNgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlWYWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQgdiA9IGJvZHlWYWxzW2ldO1xuXG5cdFx0XHRcdFx0XHRsZXQgcmV0VHlwZUV4cHIgPSBhc3NlcnREZWZpbmVkKHRoaXMuI3JldFR5cGVFeHByc1tpXSk7XG5cdFx0XHRcdFx0XHRpZiAoIXYuaXNJbnN0YW5jZU9mKHJldFR5cGVFeHByLnNpdGUsIGZuVHlwZS5yZXRUeXBlc1tpXSkpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgcmV0VHlwZUV4cHIudHlwZUVycm9yKGB3cm9uZyByZXR1cm4gdHlwZSBmb3IgdmFsdWUgJHtpfSwgZXhwZWN0ZWQgJHtmblR5cGUucmV0VHlwZXNbaV0udG9TdHJpbmcoKX0gYnV0IGdvdCAke3YuZ2V0VHlwZSh0aGlzLiNib2R5RXhwci5zaXRlKS50b1N0cmluZygpfWApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgdGhpcy4jYm9keUV4cHIudHlwZUVycm9yKGBleHBlY3RlZCBtdWx0aS12YWx1ZSBmdW5jdGlvbiBib2R5LCBidXQgZ290ICR7dGhpcy4jYm9keUV4cHIudHlwZS50b1N0cmluZygpfWApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN1YlNjb3BlLmFzc2VydEFsbFVzZWQoKTtcblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRpc01ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJncy5sZW5ndGggPiAwICYmIHRoaXMuI2FyZ3NbMF0ubmFtZS50b1N0cmluZygpID09IFwic2VsZlwiO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdGZvciAobGV0IGFyZyBvZiB0aGlzLiNhcmdzKSB7XG5cdFx0XHRhcmcudXNlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4jcmV0VHlwZUV4cHJzLmZvckVhY2goZSA9PiB7XG5cdFx0XHRpZiAoZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRlLnVzZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuI2JvZHlFeHByLnVzZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdGFyZ3NUb0lSKCkge1xuXHRcdGxldCBhcmdzID0gdGhpcy4jYXJncy5tYXAoYSA9PiBhLnRvSVIoKSk7XG5cdFx0aWYgKHRoaXMuaXNNZXRob2QoKSkge1xuXHRcdFx0YXJncyA9IGFyZ3Muc2xpY2UoMSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChuZXcgSVIoYXJncykpLmpvaW4oXCIsIFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbiByZXZlcnNlIG9yZGVyLCBiZWNhdXNlIGxhdGVyIG9wdCBhcmdzIG1pZ2h0IGRlcGVuZCBvbiBlYXJsaWVyIGFyZ3Ncblx0ICogQHBhcmFtIHtJUn0gaW5uZXJJUiBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0d3JhcFdpdGhEZWZhdWx0QXJncyhpbm5lcklSKSB7XG5cdFx0Y29uc3QgYXJncyA9IHRoaXMuI2FyZ3Muc2xpY2UoKS5yZXZlcnNlKCk7XG5cblx0XHRmb3IgKGxldCBhcmcgb2YgYXJncykge1xuXHRcdFx0aW5uZXJJUiA9IGFyZy53cmFwV2l0aERlZmF1bHQoaW5uZXJJUik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlubmVySVI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHs/c3RyaW5nfSByZWN1cnNpdmVOYW1lIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSSW50ZXJuYWwocmVjdXJzaXZlTmFtZSwgaW5kZW50ID0gXCJcIikge1xuXHRcdGxldCBhcmdzV2l0aENvbW1hcyA9IHRoaXMuYXJnc1RvSVIoKTtcblxuXHRcdGxldCBpbm5lckluZGVudCA9IGluZGVudDtcblx0XHRsZXQgbWV0aG9kSW5kZW50ID0gaW5kZW50O1xuXHRcdGlmICh0aGlzLmlzTWV0aG9kKCkpIHtcblx0XHRcdGlubmVySW5kZW50ICs9IFRBQjtcblx0XHR9XG5cblx0XHRpZiAocmVjdXJzaXZlTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0aW5uZXJJbmRlbnQgKz0gVEFCO1xuXHRcdFx0bWV0aG9kSW5kZW50ICs9IFRBQjtcblx0XHR9XG5cblx0XHRsZXQgaW5uZXJJUiA9IHRoaXMuI2JvZHlFeHByLnRvSVIoaW5uZXJJbmRlbnQgKyBUQUIpO1xuXG5cdFx0aW5uZXJJUiA9IHRoaXMud3JhcFdpdGhEZWZhdWx0QXJncyhpbm5lcklSKTtcblxuXHRcdGxldCBpciA9IG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoXCIoXCIpLFxuXHRcdFx0YXJnc1dpdGhDb21tYXMsXG5cdFx0XHRuZXcgSVIoXCIpIFwiKSwgbmV3IElSKFwiLT5cIiwgdGhpcy5zaXRlKSwgbmV3IElSKGAge1xcbiR7aW5uZXJJbmRlbnR9JHtUQUJ9YCksXG5cdFx0XHRpbm5lcklSLFxuXHRcdFx0bmV3IElSKGBcXG4ke2lubmVySW5kZW50fX1gKSxcblx0XHRdKTtcblxuXHRcdC8vIHdyYXAgd2l0aCAnc2VsZidcblx0XHRpZiAodGhpcy5pc01ldGhvZCgpKSB7XG5cdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdG5ldyBJUihgKHNlbGYpIC0+IHtcXG4ke21ldGhvZEluZGVudH0ke1RBQn1gKSxcblx0XHRcdFx0aXIsXG5cdFx0XHRcdG5ldyBJUihgXFxuJHttZXRob2RJbmRlbnR9fWApLFxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlY3Vyc2l2ZU5hbWUgIT09IG51bGwpIHtcblx0XHRcdGlyID0gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKFwiKFwiKSxcblx0XHRcdFx0bmV3IElSKHJlY3Vyc2l2ZU5hbWUpLFxuXHRcdFx0XHRuZXcgSVIoYCkgLT4ge1xcbiR7aW5kZW50fSR7VEFCfWApLFxuXHRcdFx0XHRpcixcblx0XHRcdFx0bmV3IElSKGBcXG4ke2luZGVudH19YClcblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVjdXJzaXZlTmFtZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUlJlY3Vyc2l2ZShyZWN1cnNpdmVOYW1lLCBpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9JUkludGVybmFsKHJlY3Vyc2l2ZU5hbWUsIGluZGVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9JUkludGVybmFsKG51bGwsIGluZGVudCk7XG5cdH1cbn1cblxuLyoqXG4gKiBWYXJpYWJsZSBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBWYWx1ZVJlZkV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjbmFtZTtcblx0I2lzUmVjdXJzaXZlRnVuYztcblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSkge1xuXHRcdHN1cGVyKG5hbWUuc2l0ZSk7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jaXNSZWN1cnNpdmVGdW5jID0gZmFsc2U7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZS50b1N0cmluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgdmFsID0gc2NvcGUuZ2V0KHRoaXMuI25hbWUpO1xuXG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmNJbnN0YW5jZSAmJiB2YWwuaXNSZWN1cnNpdmUoc2NvcGUpKSB7XG5cdFx0XHR0aGlzLiNpc1JlY3Vyc2l2ZUZ1bmMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWwuYXNzZXJ0VmFsdWUodGhpcy4jbmFtZS5zaXRlKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHRpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIEZ1bmNTdGF0ZW1lbnRJbnN0YW5jZSkge1xuXHRcdFx0dGhpcy52YWx1ZS5zdGF0ZW1lbnQudXNlKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgQ29uc3RTdGF0ZW1lbnRJbnN0YW5jZSkge1xuXHRcdFx0dGhpcy52YWx1ZS5zdGF0ZW1lbnQudXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdGxldCBwYXRoID0gdGhpcy50b1N0cmluZygpO1xuXG5cdFx0aWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBGdW5jU3RhdGVtZW50SW5zdGFuY2UgfHwgdGhpcy52YWx1ZSBpbnN0YW5jZW9mIENvbnN0U3RhdGVtZW50SW5zdGFuY2UpIHtcblx0XHRcdHBhdGggPSB0aGlzLnZhbHVlLnN0YXRlbWVudC5wYXRoO1xuXHRcdH0gZWxzZSBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIEJ1aWx0aW5GdW5jSW5zdGFuY2UpIHtcblx0XHRcdHBhdGggPSB0aGlzLnZhbHVlLnBhdGg7XG5cdFx0fVxuXG5cdFx0bGV0IGlyID0gbmV3IElSKHBhdGgsIHRoaXMuc2l0ZSk7XG5cblx0XHRpZiAodGhpcy4jaXNSZWN1cnNpdmVGdW5jKSB7XG5cdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIoXCIpLFxuXHRcdFx0XHRpcixcblx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpcjtcblx0fVxufVxuXG4vKipcbiAqIFdvcmQ6OldvcmQ6Oi4uLiBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBWYWx1ZVBhdGhFeHByIGV4dGVuZHMgVmFsdWVFeHByIHtcblx0I2Jhc2VUeXBlRXhwcjtcblx0I21lbWJlck5hbWU7XG5cdCNpc1JlY3Vyc2l2ZUZ1bmM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHlwZUV4cHJ9IGJhc2VUeXBlRXhwciBcblx0ICogQHBhcmFtIHtXb3JkfSBtZW1iZXJOYW1lIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoYmFzZVR5cGVFeHByLCBtZW1iZXJOYW1lKSB7XG5cdFx0c3VwZXIobWVtYmVyTmFtZS5zaXRlKTtcblx0XHR0aGlzLiNiYXNlVHlwZUV4cHIgPSBiYXNlVHlwZUV4cHI7XG5cdFx0dGhpcy4jbWVtYmVyTmFtZSA9IG1lbWJlck5hbWU7XG5cdFx0dGhpcy4jaXNSZWN1cnNpdmVGdW5jID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R5cGV9XG5cdCAqL1xuXHRnZXQgYmFzZVR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Jhc2VUeXBlRXhwci50eXBlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMuI2Jhc2VUeXBlRXhwci50b1N0cmluZygpfTo6JHt0aGlzLiNtZW1iZXJOYW1lLnRvU3RyaW5nKCl9YDtcblx0fVxuXG5cdGlzWmVyb0ZpZWxkQ29uc3RydWN0b3IoKSB7XG5cdFx0bGV0IHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAodHlwZSBpbnN0YW5jZW9mIEVudW1NZW1iZXJTdGF0ZW1lbnRUeXBlICYmIHR5cGUuc3RhdGVtZW50Lm5hbWUudmFsdWUgPT09IHRoaXMuI21lbWJlck5hbWUudmFsdWUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBWYWx1ZVBhdGhFeHByIGNvbnN0cnVjdHMgYSBsaXRlcmFsIGVudW0gbWVtYmVyIHdpdGggemVybyBmaWVsZCBvclxuXHQgKiBpZiB0aGlzIGJhc2VUeXBlIGlzIGFsc28gYSBiYXNlVHlwZSBvZiB0aGUgcmV0dXJuZWQgdmFsdWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0xpdGVyYWwoKSB7XG5cdFx0aWYgKHRoaXMuaXNaZXJvRmllbGRDb25zdHJ1Y3RvcigpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdGlmICh0aGlzLmJhc2VUeXBlLmlzQmFzZU9mKHRoaXMuc2l0ZSwgdHlwZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgYmFzZVR5cGUgPSB0aGlzLiNiYXNlVHlwZUV4cHIuZXZhbChzY29wZSk7XG5cdFx0YXNzZXJ0KGJhc2VUeXBlLmlzVHlwZSgpKTtcblxuXHRcdGxldCBtZW1iZXJWYWwgPSBiYXNlVHlwZS5nZXRUeXBlTWVtYmVyKHRoaXMuI21lbWJlck5hbWUpO1xuXG5cdFx0aWYgKG1lbWJlclZhbCBpbnN0YW5jZW9mIEZ1bmNJbnN0YW5jZSAmJiBtZW1iZXJWYWwuaXNSZWN1cnNpdmUoc2NvcGUpKSB7XG5cdFx0XHR0aGlzLiNpc1JlY3Vyc2l2ZUZ1bmMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1iZXJWYWwuYXNzZXJ0VmFsdWUodGhpcy4jbWVtYmVyTmFtZS5zaXRlKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNiYXNlVHlwZUV4cHIudXNlKCk7XG5cblx0XHRpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIENvbnN0U3RhdGVtZW50SW5zdGFuY2UpIHtcblx0XHRcdHRoaXMudmFsdWUuc3RhdGVtZW50LnVzZSgpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIEZ1bmNTdGF0ZW1lbnRJbnN0YW5jZSkge1xuXHRcdFx0dGhpcy52YWx1ZS5zdGF0ZW1lbnQudXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnRcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0Ly8gaWYgd2UgYXJlIGRpcmVjdGx5IGFjY2Vzc2luZyBhbiBlbnVtIG1lbWJlciBhcyBhIHplcm8tZmllbGQgY29uc3RydWN0b3Igd2UgbXVzdCBjaGFuZ2UgdGhlIGNvZGUgYSBiaXRcblx0XHRsZXQgbWVtYmVyVmFsID0gdGhpcy4jYmFzZVR5cGVFeHByLnR5cGUuZ2V0VHlwZU1lbWJlcih0aGlzLiNtZW1iZXJOYW1lKTtcblxuXHRcdGlmICgobWVtYmVyVmFsIGluc3RhbmNlb2YgRW51bU1lbWJlclN0YXRlbWVudFR5cGUpIHx8IChtZW1iZXJWYWwgaW5zdGFuY2VvZiBPcHRpb25Ob25lVHlwZSkpIHtcblx0XHRcdGxldCBjSWQgPSBtZW1iZXJWYWwuZ2V0Q29uc3RySW5kZXgodGhpcy4jbWVtYmVyTmFtZS5zaXRlKTtcblxuXHRcdFx0YXNzZXJ0KGNJZCA+PSAwKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBJUihgX19jb3JlX19jb25zdHJEYXRhKCR7Y0lkLnRvU3RyaW5nKCl9LCBfX2NvcmVfX21rTmlsRGF0YSgoKSkpYCwgdGhpcy5zaXRlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgaXIgPSBuZXcgSVIoYCR7dGhpcy4jYmFzZVR5cGVFeHByLnR5cGUucGF0aH1fXyR7dGhpcy4jbWVtYmVyTmFtZS50b1N0cmluZygpfWAsIHRoaXMuc2l0ZSk7XG5cblx0XHRcdGlmICh0aGlzLiNpc1JlY3Vyc2l2ZUZ1bmMpIHtcblx0XHRcdFx0aXIgPSBuZXcgSVIoW1xuXHRcdFx0XHRcdGlyLFxuXHRcdFx0XHRcdG5ldyBJUihcIihcIiksXG5cdFx0XHRcdFx0aXIsXG5cdFx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGlyO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFVuYXJ5IG9wZXJhdG9yIGV4cHJlc3Npb25cbiAqIE5vdGU6IHRoZXJlIGFyZSBubyBwb3N0LXVuYXJ5IG9wZXJhdG9ycywgb25seSBwcmVcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFVuYXJ5RXhwciBleHRlbmRzIFZhbHVlRXhwciB7XG5cdCNvcDtcblx0I2E7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3ltYm9sVG9rZW59IG9wIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gYSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wLCBhKSB7XG5cdFx0c3VwZXIob3Auc2l0ZSk7XG5cdFx0dGhpcy4jb3AgPSBvcDtcblx0XHR0aGlzLiNhID0gYTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiNvcC50b1N0cmluZygpfSR7dGhpcy4jYS50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgYW4gb3Agc3ltYm9sIGludG8gYW4gaW50ZXJuYWwgbmFtZVxuXHQgKiBAcmV0dXJucyB7V29yZH1cblx0ICovXG5cdHRyYW5zbGF0ZU9wKCkge1xuXHRcdGxldCBvcCA9IHRoaXMuI29wLnRvU3RyaW5nKCk7XG5cdFx0bGV0IHNpdGUgPSB0aGlzLiNvcC5zaXRlO1xuXG5cdFx0aWYgKG9wID09IFwiK1wiKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFdvcmQoc2l0ZSwgXCJfX3Bvc1wiKTtcblx0XHR9IGVsc2UgaWYgKG9wID09IFwiLVwiKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFdvcmQoc2l0ZSwgXCJfX25lZ1wiKTtcblx0XHR9IGVsc2UgaWYgKG9wID09IFwiIVwiKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFdvcmQoc2l0ZSwgXCJfX25vdFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkIHVuYXJ5IG9wXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0bGV0IGEgPSB0aGlzLiNhLmV2YWwoc2NvcGUpO1xuXG5cdFx0bGV0IGZuVmFsID0gYS5hc3NlcnRWYWx1ZSh0aGlzLiNhLnNpdGUpLmdldFR5cGUodGhpcy5zaXRlKS5nZXRUeXBlTWVtYmVyKHRoaXMudHJhbnNsYXRlT3AoKSk7XG5cblx0XHQvLyBvcHMgYXJlIGltbWVkaWF0ZWx5IGFwcGxpZWRcblx0XHRyZXR1cm4gZm5WYWwuY2FsbCh0aGlzLiNvcC5zaXRlLCBbYV0pO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdHRoaXMuI2EudXNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0bGV0IHBhdGggPSB0aGlzLnR5cGUucGF0aDtcblxuXHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKGAke3BhdGh9X18ke3RoaXMudHJhbnNsYXRlT3AoKS52YWx1ZX1gLCB0aGlzLnNpdGUpLCBuZXcgSVIoXCIoXCIpLFxuXHRcdFx0dGhpcy4jYS50b0lSKGluZGVudCksXG5cdFx0XHRuZXcgSVIoXCIpXCIpXG5cdFx0XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBCaW5hcnkgb3BlcmF0b3IgZXhwcmVzc2lvblxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgQmluYXJ5RXhwciBleHRlbmRzIFZhbHVlRXhwciB7XG5cdCNvcDtcblx0I2E7XG5cdCNiO1xuXHQjc3dhcDsgLy8gc3dhcCBhIGFuZCBiIGZvciBjb21tdXRhdGl2ZSBvcHNcblx0I2FsdDsgLy8gdXNlIGFsdCAoZWFjaCBvcGVyYXRvciBjYW4gaGF2ZSBvbmUgb3ZlcmxvYWQpXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3ltYm9sVG9rZW59IG9wIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gYSBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IGIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcCwgYSwgYikge1xuXHRcdHN1cGVyKG9wLnNpdGUpO1xuXHRcdHRoaXMuI29wID0gb3A7XG5cdFx0dGhpcy4jYSA9IGE7XG5cdFx0dGhpcy4jYiA9IGI7XG5cdFx0dGhpcy4jc3dhcCA9IGZhbHNlO1xuXHRcdHRoaXMuI2FsdCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAdHlwZSB7VmFsdWVFeHByfVxuXHQgKi9cblx0Z2V0IGZpcnN0KCkge1xuXHRcdHJldHVybiB0aGlzLiNzd2FwID8gdGhpcy4jYiA6IHRoaXMuI2E7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1ZhbHVlRXhwcn0gXG5cdCAqL1xuXHRnZXQgc2Vjb25kKCkge1xuXHRcdHJldHVybiB0aGlzLiNzd2FwID8gdGhpcy4jYSA6IHRoaXMuI2I7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy4jYS50b1N0cmluZygpfSAke3RoaXMuI29wLnRvU3RyaW5nKCl9ICR7dGhpcy4jYi50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgb3Agc3ltYm9sIGludG8gaW50ZXJuYWwgbmFtZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFsdFxuXHQgKiBAcmV0dXJucyB7V29yZH1cblx0ICovXG5cdHRyYW5zbGF0ZU9wKGFsdCA9IGZhbHNlKSB7XG5cdFx0bGV0IG9wID0gdGhpcy4jb3AudG9TdHJpbmcoKTtcblx0XHRsZXQgc2l0ZSA9IHRoaXMuI29wLnNpdGU7XG5cdFx0bGV0IG5hbWU7XG5cblx0XHRpZiAob3AgPT0gXCJ8fFwiKSB7XG5cdFx0XHRuYW1lID0gXCJfX29yXCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIiYmXCIpIHtcblx0XHRcdG5hbWUgPSBcIl9fYW5kXCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIj09XCIpIHtcblx0XHRcdG5hbWUgPSBcIl9fZXFcIjtcblx0XHR9IGVsc2UgaWYgKG9wID09IFwiIT1cIikge1xuXHRcdFx0bmFtZSA9IFwiX19uZXFcIjtcblx0XHR9IGVsc2UgaWYgKG9wID09IFwiPFwiKSB7XG5cdFx0XHRuYW1lID0gXCJfX2x0XCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIjw9XCIpIHtcblx0XHRcdG5hbWUgPSBcIl9fbGVxXCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIj5cIikge1xuXHRcdFx0bmFtZSA9IFwiX19ndFwiO1xuXHRcdH0gZWxzZSBpZiAob3AgPT0gXCI+PVwiKSB7XG5cdFx0XHRuYW1lID0gXCJfX2dlcVwiO1xuXHRcdH0gZWxzZSBpZiAob3AgPT0gXCIrXCIpIHtcblx0XHRcdG5hbWUgPSBcIl9fYWRkXCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIi1cIikge1xuXHRcdFx0bmFtZSA9IFwiX19zdWJcIjtcblx0XHR9IGVsc2UgaWYgKG9wID09IFwiKlwiKSB7XG5cdFx0XHRuYW1lID0gXCJfX211bFwiO1xuXHRcdH0gZWxzZSBpZiAob3AgPT0gXCIvXCIpIHtcblx0XHRcdG5hbWUgPSBcIl9fZGl2XCI7XG5cdFx0fSBlbHNlIGlmIChvcCA9PSBcIiVcIikge1xuXHRcdFx0bmFtZSA9IFwiX19tb2RcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkXCIpO1xuXHRcdH1cblxuXHRcdGlmIChhbHQpIHtcblx0XHRcdG5hbWUgKz0gXCJfYWx0XCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBXb3JkKHNpdGUsIG5hbWUpO1xuXHR9XG5cblx0aXNDb21tdXRhdGl2ZSgpIHtcblx0XHRsZXQgb3AgPSB0aGlzLiNvcC50b1N0cmluZygpO1xuXHRcdHJldHVybiBvcCA9PSBcIitcIiB8fCBvcCA9PSBcIipcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0bGV0IGEgPSB0aGlzLiNhLmV2YWwoc2NvcGUpO1xuXHRcdGxldCBiID0gdGhpcy4jYi5ldmFsKHNjb3BlKTtcblxuXHRcdGFzc2VydChhLmlzVmFsdWUoKSAmJiBiLmlzVmFsdWUoKSk7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7P1VzZXJFcnJvcn1cblx0XHQgKi9cblx0XHRsZXQgZmlyc3RFcnJvciA9IG51bGw7XG5cblx0XHRmb3IgKGxldCBzd2FwIG9mICh0aGlzLmlzQ29tbXV0YXRpdmUoKSA/IFtmYWxzZSwgdHJ1ZV0gOiBbZmFsc2VdKSkge1xuXHRcdFx0Zm9yIChsZXQgYWx0IG9mIFtmYWxzZSwgdHJ1ZV0pIHtcblx0XHRcdFx0bGV0IGZpcnN0ICA9IHN3YXAgPyBiIDogYTtcblx0XHRcdFx0bGV0IHNlY29uZCA9IHN3YXAgPyBhIDogYjtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxldCBmblZhbCA9IGZpcnN0LmdldFR5cGUodGhpcy5zaXRlKS5nZXRUeXBlTWVtYmVyKHRoaXMudHJhbnNsYXRlT3AoYWx0KSk7XG5cblx0XHRcdFx0XHRsZXQgcmVzID0gZm5WYWwuY2FsbCh0aGlzLiNvcC5zaXRlLCBbZmlyc3QsIHNlY29uZF0pO1xuXG5cdFx0XHRcdFx0dGhpcy4jc3dhcCA9IHN3YXA7XG5cdFx0XHRcdFx0dGhpcy4jYWx0ICA9IGFsdDtcblxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIFVzZXJFcnJvcikge1xuXHRcdFx0XHRcdFx0aWYgKGZpcnN0RXJyb3IgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Zmlyc3RFcnJvciA9IGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZmlyc3RFcnJvciAhPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgZmlyc3RFcnJvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHR9XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jYS51c2UoKTtcblx0XHR0aGlzLiNiLnVzZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdGxldCBwYXRoID0gdGhpcy5maXJzdC50eXBlLnBhdGg7XG5cblx0XHRsZXQgb3AgPSB0aGlzLnRyYW5zbGF0ZU9wKHRoaXMuI2FsdCkudmFsdWU7XG5cblx0XHRpZiAob3AgPT0gXCJfX2FuZFwiIHx8IG9wID09IFwiX19vclwiKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKGAke3BhdGh9JHtvcH1gLCB0aGlzLnNpdGUpLCBuZXcgSVIoYChcXG4ke2luZGVudH0ke1RBQn0oKSAtPiB7YCksXG5cdFx0XHRcdHRoaXMuZmlyc3QudG9JUihpbmRlbnQgKyBUQUIpLFxuXHRcdFx0XHRuZXcgSVIoYH0sXFxuJHtpbmRlbnR9JHtUQUJ9KCkgLT4ge2ApLFxuXHRcdFx0XHR0aGlzLnNlY29uZC50b0lSKGluZGVudCArIFRBQiksXG5cdFx0XHRcdG5ldyBJUihgfVxcbiR7aW5kZW50fSlgKVxuXHRcdFx0XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoYCR7cGF0aH1fXyR7b3B9YCwgdGhpcy5zaXRlKSwgbmV3IElSKFwiKFwiKSxcblx0XHRcdFx0dGhpcy5maXJzdC50b0lSKGluZGVudCksXG5cdFx0XHRcdG5ldyBJUihcIiwgXCIpLFxuXHRcdFx0XHR0aGlzLnNlY29uZC50b0lSKGluZGVudCksXG5cdFx0XHRcdG5ldyBJUihcIilcIilcblx0XHRcdF0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFBhcmVudGhlc2VzIGV4cHJlc3Npb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFBhcmVuc0V4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjZXhwcnM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJbXX0gZXhwcnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGV4cHJzKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jZXhwcnMgPSBleHBycztcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgKCR7dGhpcy4jZXhwcnMubWFwKGUgPT4gZS50b1N0cmluZygpKS5qb2luKFwiLCBcIil9KWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGlmICh0aGlzLiNleHBycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHJldHVybiB0aGlzLiNleHByc1swXS5ldmFsKHNjb3BlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBNdWx0aUluc3RhbmNlKHRoaXMuI2V4cHJzLm1hcChlID0+IHtcblx0XHRcdFx0Y29uc3QgdiA9IGUuZXZhbChzY29wZSk7XG5cblx0XHRcdFx0aWYgKHYuZ2V0VHlwZShlLnNpdGUpIGluc3RhbmNlb2YgRXJyb3JUeXBlKSB7XG5cdFx0XHRcdFx0dGhyb3cgZS5zaXRlLnR5cGVFcnJvcihcInVuZXhwZWN0ZWQgZXJyb3IgY2FsbCBpbiBtdWx0aS12YWx1ZWQgZXhwcmVzc2lvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNleHBycy5mb3JFYWNoKGUgPT4gZS51c2UoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0aWYgKHRoaXMuI2V4cHJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2V4cHJzWzBdLnRvSVIoaW5kZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBJUihcblx0XHRcdFx0W25ldyBJUihgKGNhbGxiYWNrKSAtPiB7XFxuJHtpbmRlbnQgKyBUQUJ9Y2FsbGJhY2soXFxuJHtpbmRlbnQgKyBUQUIgKyBUQUJ9YCwgdGhpcy5zaXRlKV1cblx0XHRcdFx0LmNvbmNhdChuZXcgSVIodGhpcy4jZXhwcnMubWFwKGUgPT4gZS50b0lSKGluZGVudCArIFRBQiArIFRBQikpKS5qb2luKGAsXFxuJHtpbmRlbnQgKyBUQUIgKyBUQUJ9YCkpXG5cdFx0XHRcdC5jb25jYXQoW25ldyBJUihgXFxuJHtpbmRlbnQgKyBUQUJ9KVxcbiR7aW5kZW50fX1gKV0pXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIENhbGxBcmdFeHByIGV4dGVuZHMgVG9rZW4ge1xuXHQjbmFtZTtcblx0I3ZhbHVlRXhwcjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge251bGwgfCBXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gdmFsdWVFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgbmFtZSwgdmFsdWVFeHByKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cblx0XHR0aGlzLiNuYW1lID0gbmFtZTtcblx0XHR0aGlzLiN2YWx1ZUV4cHIgPSB2YWx1ZUV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lPy50b1N0cmluZygpID8/IFwiXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1ZhbHVlRXhwcn1cblx0ICovXG5cdGdldCB2YWx1ZUV4cHIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlRXhwcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SW5zdGFuY2V9XG5cdCAqL1xuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlRXhwci52YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzTmFtZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUgIT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzTGl0ZXJhbCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWVFeHByLmlzTGl0ZXJhbCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0dGhpcy4jbmFtZSAhPSBudWxsID8gYCR7dGhpcy4jbmFtZS50b1N0cmluZygpfTogYDogXCJcIixcblx0XHRcdHRoaXMuI3ZhbHVlRXhwci50b1N0cmluZygpXG5cdFx0XS5qb2luKFwiXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsKHNjb3BlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlRXhwci5ldmFsKHNjb3BlKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiN2YWx1ZUV4cHIudXNlKCk7XG5cdH1cbn1cblxuLyoqXG4gKiAuLi4oLi4uKSBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBDYWxsRXhwciBleHRlbmRzIFZhbHVlRXhwciB7XG5cdCNmbkV4cHI7XG5cdCNhcmdFeHBycztcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gZm5FeHByIFxuXHQgKiBAcGFyYW0ge0NhbGxBcmdFeHByW119IGFyZ0V4cHJzIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgZm5FeHByLCBhcmdFeHBycykge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI2ZuRXhwciA9IGZuRXhwcjtcblx0XHR0aGlzLiNhcmdFeHBycyA9IGFyZ0V4cHJzO1xuXHR9XG5cblx0Z2V0IGZuRXhwcigpIHtcblx0XHRyZXR1cm4gdGhpcy4jZm5FeHByO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMuI2ZuRXhwci50b1N0cmluZygpfSgke3RoaXMuI2FyZ0V4cHJzLm1hcChhID0+IGEudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfSlgO1xuXHR9XG5cblx0aXNMaXRlcmFsKCkge1xuXHRcdGlmICh0aGlzLiNmbkV4cHIgaW5zdGFuY2VvZiBWYWx1ZVBhdGhFeHByICYmIHRoaXMuI2ZuRXhwci5iYXNlVHlwZS5pc0Jhc2VPZih0aGlzLnNpdGUsIHRoaXMudHlwZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRjb25zdCBmblZhbCA9IHRoaXMuI2ZuRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdGNvbnN0IGFyZ1ZhbHMgPSB0aGlzLiNhcmdFeHBycy5tYXAoYWUgPT4gYWUuZXZhbChzY29wZSkpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge0luc3RhbmNlW119XG5cdFx0ICovXG5cdFx0bGV0IHBvc0FyZ1ZhbHMgPSBbXTtcblxuXHRcdHRoaXMuI2FyZ0V4cHJzLmZvckVhY2goKGFyZ0V4cHIsIGkpID0+IHtcblx0XHRcdGlmICghYXJnRXhwci5pc05hbWVkKCkpIHtcblx0XHRcdFx0cG9zQXJnVmFscy5wdXNoKGFyZ1ZhbHNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cG9zQXJnVmFscyA9IE11bHRpSW5zdGFuY2UuZmxhdHRlbihwb3NBcmdWYWxzKTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHt7W25hbWU6IHN0cmluZ106IEluc3RhbmNlfX1cblx0XHQgKi9cblx0XHRjb25zdCBuYW1lZEFyZ1ZhbHMgPSB7fTtcblxuXHRcdHRoaXMuI2FyZ0V4cHJzLmZvckVhY2goKGFyZ0V4cHIsIGkpID0+IHtcblx0XHRcdGlmIChhcmdFeHByLmlzTmFtZWQoKSkge1xuXHRcdFx0XHRjb25zdCB2YWwgPSBhcmdWYWxzW2ldO1xuXG5cdFx0XHRcdC8vIGNhbid0IGJlIG11bHRpIGluc3RhbmNlXG5cdFx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBNdWx0aUluc3RhbmNlKSB7XG5cdFx0XHRcdFx0dGhyb3cgYXJnRXhwci50eXBlRXJyb3IoXCJjYW4ndCB1c2UgbXVsdGlwbGUgcmV0dXJuIHZhbHVlcyBhcyBuYW1lZCBhcmd1bWVudFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5hbWVkQXJnVmFsc1thcmdFeHByLm5hbWVdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KHBvc0FyZ1ZhbHMuZXZlcnkocGF2ID0+IHBhdiAhPSB1bmRlZmluZWQpKTtcblxuXHRcdHJldHVybiBmblZhbC5jYWxsKHRoaXMuc2l0ZSwgcG9zQXJnVmFscywgbmFtZWRBcmdWYWxzKTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNmbkV4cHIudXNlKCk7XG5cblx0XHRmb3IgKGxldCBhcmcgb2YgdGhpcy4jYXJnRXhwcnMpIHtcblx0XHRcdGFyZy51c2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRG9uJ3QgY2FsbCB0aGlzIGluc2lkZSBldmFsKCkgYmVjYXVzZSBwYXJhbSB0eXBlcyB3b24ndCB5ZXQgYmUgY29tcGxldGUuXG5cdCAqIEB0eXBlIHtGdW5jVHlwZX1cblx0ICovXG5cdGdldCBmbigpIHtcblx0XHRyZXR1cm4gYXNzZXJ0Q2xhc3ModGhpcy4jZm5FeHByLnZhbHVlLmdldFR5cGUodGhpcy4jZm5FeHByLnNpdGUpLCBGdW5jVHlwZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1tWYWx1ZUV4cHJbXSwgSVJbXV19IC0gZmlyc3QgbGlzdCBhcmUgcG9zaXRpb25hbCBhcmdzLCBzZWNvbmQgbGlzdCBuYW1lZCBhcmdzIGFuZCByZW1haW5pbmcgb3B0IGFyZ3Ncblx0ICovXG5cdGV4cGFuZEFyZ3MoKSB7XG5cdFx0Y29uc3QgZm4gPSB0aGlzLmZuO1xuXHRcdGNvbnN0IG5Ob25PcHRBcmdzID0gZm4ubk5vbk9wdEFyZ3M7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7VmFsdWVFeHByW119XG5cdFx0ICovXG5cdFx0Y29uc3QgcG9zaXRpb25hbCA9IFtdO1xuXG5cdFx0dGhpcy4jYXJnRXhwcnMuZm9yRWFjaChhZSA9PiB7XG5cdFx0XHRpZiAoIWFlLmlzTmFtZWQoKSkge1xuXHRcdFx0XHRwb3NpdGlvbmFsLnB1c2goYWUudmFsdWVFeHByKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtJUltdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IG5hbWVkT3B0aW9uYWwgPSBbXTtcblxuXHRcdHRoaXMuI2FyZ0V4cHJzLmZvckVhY2goYWUgPT4ge1xuXHRcdFx0aWYgKGFlLmlzTmFtZWQoKSkge1xuXHRcdFx0XHRjb25zdCBpID0gZm4uZ2V0TmFtZWRJbmRleChhZS5zaXRlLCBhZS5uYW1lKTtcblxuXHRcdFx0XHRpZiAoaSA8IG5Ob25PcHRBcmdzKSB7XG5cdFx0XHRcdFx0cG9zaXRpb25hbFtpXSA9IGFlLnZhbHVlRXhwcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuYW1lZE9wdGlvbmFsW2kgLSBuTm9uT3B0QXJnc10gPSBuZXcgSVIoW1xuXHRcdFx0XHRcdFx0bmV3IElSKFwidHJ1ZVwiKSxcblx0XHRcdFx0XHRcdG5ldyBJUihcIiwgXCIpLFxuXHRcdFx0XHRcdFx0YWUudmFsdWVFeHByLnRvSVIoKVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRmb3IgKGxldCBpID0gbk5vbk9wdEFyZ3M7IGkgPCBmbi5uQXJnczsgaSsrKSB7XG5cdFx0XHRpZiAobmFtZWRPcHRpb25hbFtpIC0gbk5vbk9wdEFyZ3NdID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRuYW1lZE9wdGlvbmFsW2kgLSBuTm9uT3B0QXJnc10gPSBuZXcgSVIoW1xuXHRcdFx0XHRcdG5ldyBJUihcImZhbHNlXCIpLFxuXHRcdFx0XHRcdG5ldyBJUihcIiwgXCIpLFxuXHRcdFx0XHRcdG5ldyBJUihcIigpXCIpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbcG9zaXRpb25hbC5maWx0ZXIocCA9PiBwICE9IHVuZGVmaW5lZCksIG5hbWVkT3B0aW9uYWxdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdGNvbnN0IGZuID0gdGhpcy5mbjtcblxuXHRcdC8qKlxuXHRcdCAqIEZpcnN0IHN0ZXAgaXMgdG8gZWxpbWluYXRlIHRoZSBuYW1lZCBhcmdzXG5cdFx0ICogQHR5cGUge1tWYWx1ZUV4cHJbXSwgSVJbXV19XG5cdFx0ICovXG5cdFx0Y29uc3QgW3Bvc2l0aW9uYWwsIG5hbWVkT3B0aW9uYWxdID0gdGhpcy5leHBhbmRBcmdzKCk7XG5cblx0XHRpZiAocG9zaXRpb25hbC5zb21lKGUgPT4gKCFlLmlzTGl0ZXJhbCgpKSAmJiAoZS52YWx1ZSBpbnN0YW5jZW9mIE11bHRpSW5zdGFuY2UpKSkge1xuXHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiBmaW5hbCBhcmdzXG5cdFx0XHRsZXQgbiA9IDA7XG5cblx0XHRcdHBvc2l0aW9uYWwuZm9yRWFjaCgoZSwgaSkgPT4ge1xuXHRcdFx0XHRpZiAoKCFlLmlzTGl0ZXJhbCgpKSAmJiAoZS52YWx1ZSBpbnN0YW5jZW9mIE11bHRpSW5zdGFuY2UpKSB7XG5cdFx0XHRcdFx0biArPSBlLnZhbHVlLnZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0biArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0biArPSBuYW1lZE9wdGlvbmFsLmxlbmd0aDtcblxuXHRcdFx0aWYgKG4gPiBmbi5uQXJncykge1xuXHRcdFx0XHRuYW1lZE9wdGlvbmFsLnNwbGljZSgwLCBuIC0gZm4ubkFyZ3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbmFtZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbi5uQXJnczsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID49IGZuLm5Ob25PcHRBcmdzKSB7XG5cdFx0XHRcdFx0bmFtZXMucHVzaChgX191c2VvcHRfX3gke2l9YCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuYW1lcy5wdXNoKGB4JHtpfWApO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXIgPSBuZXcgSVIoW1xuXHRcdFx0XHR0aGlzLiNmbkV4cHIudG9JUigpLFxuXHRcdFx0XHRuZXcgSVIoXCIoXCIpLFxuXHRcdFx0XHRuZXcgSVIobmFtZXMubWFwKG4gPT4gbmV3IElSKG4pKSkuam9pbihcIiwgXCIpLFxuXHRcdFx0XHRuZXcgSVIoXCIpXCIsIHRoaXMuc2l0ZSlcblx0XHRcdF0pO1xuXG5cdFx0XHRmb3IgKGxldCBuYW1lZElSIG9mIG5hbWVkT3B0aW9uYWwuc2xpY2UoKS5yZXZlcnNlKCkpIHtcblx0XHRcdFx0Y29uc3QgbjIgPSBhc3NlcnREZWZpbmVkKG5hbWVzLnBvcCgpKTtcblx0XHRcdFx0Y29uc3QgbjEgPSBhc3NlcnREZWZpbmVkKG5hbWVzLnBvcCgpKTtcblx0XHRcdFx0YXNzZXJ0KG4xLnN0YXJ0c1dpdGgoXCJfX3VzZW9wdF9fXCIpKTtcblxuXHRcdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0bmV3IElSKFwiKFwiKSxcblx0XHRcdFx0XHRuZXcgSVIobjEpLFxuXHRcdFx0XHRcdG5ldyBJUihcIiwgXCIpLFxuXHRcdFx0XHRcdG5ldyBJUihuMiksXG5cdFx0XHRcdFx0bmV3IElSKFwiKSAtPiB7XCIpLFxuXHRcdFx0XHRcdGlyLFxuXHRcdFx0XHRcdG5ldyBJUihcIn0oXCIpLFxuXHRcdFx0XHRcdGFzc2VydERlZmluZWQobmFtZWRJUiksIC8vIGJvb2wgLSB2YWwgcGFpclxuXHRcdFx0XHRcdG5ldyBJUihcIilcIilcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSBwb3NpdGlvbmFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGNvbnN0IGUgPSBwb3NpdGlvbmFsW2ldO1xuXG5cdFx0XHRcdGlmICgoIWUuaXNMaXRlcmFsKCkpICYmIChlLnZhbHVlIGluc3RhbmNlb2YgTXVsdGlJbnN0YW5jZSkpIHtcblx0XHRcdFx0XHRjb25zdCBuTXVsdGkgPSBlLnZhbHVlLnZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29uc3QgbXVsdGlOYW1lcyA9IFtdO1xuXHRcdFx0XHRcdGNvbnN0IG11bHRpT3B0ID0gW107XG5cblx0XHRcdFx0XHR3aGlsZSAobXVsdGlOYW1lcy5sZW5ndGggPCBuTXVsdGkpIHtcblx0XHRcdFx0XHRcdG11bHRpTmFtZXMudW5zaGlmdChhc3NlcnREZWZpbmVkKG5hbWVzLnBvcCgpKSk7XG5cblx0XHRcdFx0XHRcdGlmIChuYW1lcy5sZW5ndGggPiAwICYmIG5hbWVzW25hbWVzLmxlbmd0aC0xXSA9PSBgX191c2VvcHRfXyR7bXVsdGlOYW1lc1swXX1gKSB7XG5cdFx0XHRcdFx0XHRcdG11bHRpT3B0LnVuc2hpZnQoYXNzZXJ0RGVmaW5lZChuYW1lcy5wb3AoKSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtdWx0aU9wdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0XHRcdG5ldyBJUihcIihcIiksXG5cdFx0XHRcdFx0XHRcdG5ldyBJUihtdWx0aU9wdC5tYXAobiA9PiBuZXcgSVIobikpKS5qb2luKFwiLCBcIiksXG5cdFx0XHRcdFx0XHRcdG5ldyBJUihcIikgLT4ge1wiKSxcblx0XHRcdFx0XHRcdFx0aXIsXG5cdFx0XHRcdFx0XHRcdG5ldyBJUihcIn0oXCIpLFxuXHRcdFx0XHRcdFx0XHRuZXcgSVIobXVsdGlPcHQubWFwKG4gPT4gbmV3IElSKFwidHJ1ZVwiKSkpLmpvaW4oXCIsIFwiKSxcblx0XHRcdFx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XHRcdFx0XSlcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0XHRlLnRvSVIoKSxcblx0XHRcdFx0XHRcdG5ldyBJUihcIigoXCIpLFxuXHRcdFx0XHRcdFx0bmV3IElSKG11bHRpTmFtZXMubWFwKG4gPT4gbmV3IElSKG4pKSkuam9pbihcIiwgXCIpLFxuXHRcdFx0XHRcdFx0bmV3IElSKFwiKSAtPiB7XCIpLFxuXHRcdFx0XHRcdFx0aXIsXG5cdFx0XHRcdFx0XHRuZXcgSVIoXCJ9KVwiKVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBhc3NlcnREZWZpbmVkKG5hbWVzLnBvcCgpKTtcblxuXHRcdFx0XHRcdGlmIChuYW1lcy5sZW5ndGggPiAwICYmIG5hbWVzW25hbWVzLmxlbmd0aCAtIDFdID09IGBfX3VzZW9wdF9fJHtuYW1lfWApIHtcblx0XHRcdFx0XHRcdGlyID0gbmV3IElSKFtcblx0XHRcdFx0XHRcdFx0bmV3IElSKFwiKFwiKSxcblx0XHRcdFx0XHRcdFx0bmV3IElSKGFzc2VydERlZmluZWQobmFtZXMucG9wKCkpKSxcblx0XHRcdFx0XHRcdFx0bmV3IElSKFwiKSAtPiB7XCIpLFxuXHRcdFx0XHRcdFx0XHRuZXcgSVIoXCJ9KHRydWUpXCIpXG5cdFx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0XHRuZXcgSVIoXCIoXCIpLFxuXHRcdFx0XHRcdFx0bmV3IElSKG5hbWUpLFxuXHRcdFx0XHRcdFx0bmV3IElSKFwiKSAtPiB7XCIpLFxuXHRcdFx0XHRcdFx0aXIsXG5cdFx0XHRcdFx0XHRuZXcgSVIoXCJ9KFwiKSxcblx0XHRcdFx0XHRcdGUudG9JUigpLFxuXHRcdFx0XHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHBvc2l0aW9uYWwubGVuZ3RoICsgbmFtZWRPcHRpb25hbC5sZW5ndGggPiBmbi5uQXJncykge1xuXHRcdFx0XHRuYW1lZE9wdGlvbmFsLnNwbGljZSgwLCBwb3NpdGlvbmFsLmxlbmd0aCArIG5hbWVkT3B0aW9uYWwubGVuZ3RoIC0gZm4ubkFyZ3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYXJncyA9IHBvc2l0aW9uYWwubWFwKChhLCBpKSA9PiB7XG5cdFx0XHRcdGxldCBpciA9IGEudG9JUihpbmRlbnQpO1xuXG5cdFx0XHRcdGlmIChpID49IGZuLm5Ob25PcHRBcmdzKSB7XG5cdFx0XHRcdFx0aXIgPSBuZXcgSVIoW1xuXHRcdFx0XHRcdFx0bmV3IElSKFwidHJ1ZSwgXCIpLFxuXHRcdFx0XHRcdFx0aXJcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpcjtcblx0XHRcdH0pLmNvbmNhdChuYW1lZE9wdGlvbmFsKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRcdHRoaXMuI2ZuRXhwci50b0lSKGluZGVudCksXG5cdFx0XHRcdG5ldyBJUihcIihcIiksXG5cdFx0XHRcdChuZXcgSVIoYXJncykpLmpvaW4oXCIsIFwiKSxcblx0XHRcdFx0bmV3IElSKFwiKVwiLCB0aGlzLnNpdGUpXG5cdFx0XHRdKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiAgLi4uIC4gLi4uIGV4cHJlc3Npb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIE1lbWJlckV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjb2JqRXhwcjtcblx0I21lbWJlck5hbWU7XG5cdCNpc1JlY3Vyc2l2ZUZ1bmM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IG9iakV4cHIgXG5cdCAqIEBwYXJhbSB7V29yZH0gbWVtYmVyTmFtZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG9iakV4cHIsIG1lbWJlck5hbWUpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNvYmpFeHByID0gb2JqRXhwcjtcblx0XHR0aGlzLiNtZW1iZXJOYW1lID0gbWVtYmVyTmFtZTtcblx0XHR0aGlzLiNpc1JlY3Vyc2l2ZUZ1bmMgPSBmYWxzZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiNvYmpFeHByLnRvU3RyaW5nKCl9LiR7dGhpcy4jbWVtYmVyTmFtZS50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBvYmpWYWwgPSB0aGlzLiNvYmpFeHByLmV2YWwoc2NvcGUpO1xuXG5cdFx0bGV0IG1lbWJlclZhbCA9IG9ialZhbC5hc3NlcnRWYWx1ZSh0aGlzLiNvYmpFeHByLnNpdGUpLmdldEluc3RhbmNlTWVtYmVyKHRoaXMuI21lbWJlck5hbWUpO1xuXG5cdFx0aWYgKG1lbWJlclZhbCBpbnN0YW5jZW9mIEZ1bmNJbnN0YW5jZSAmJiBtZW1iZXJWYWwuaXNSZWN1cnNpdmUoc2NvcGUpKSB7XG5cdFx0XHR0aGlzLiNpc1JlY3Vyc2l2ZUZ1bmMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1iZXJWYWw7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jb2JqRXhwci51c2UoKTtcblxuXHRcdGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRnVuY1N0YXRlbWVudEluc3RhbmNlKSB7XG5cdFx0XHR0aGlzLnZhbHVlLnN0YXRlbWVudC51c2UoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudEluc3RhbmNlKSB7XG5cdFx0XHR0aGlzLnZhbHVlLnN0YXRlbWVudC51c2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0Ly8gbWVtYmVycyBjYW4gYmUgZnVuY3Rpb25zIHNvLCBmaWVsZCBnZXR0ZXJzIGFyZSBhbHNvIGVuY29kZWQgYXMgZnVuY3Rpb25zIGZvciBjb25zaXN0ZW5jeVxuXG5cdFx0bGV0IG9ialBhdGggPSB0aGlzLiNvYmpFeHByLnR5cGUucGF0aDtcblxuXHRcdC8vIGlmIHdlIGFyZSBnZXR0aW5nIHRoZSBtZW1iZXIgb2YgYW4gZW51bSBtZW1iZXIgd2Ugc2hvdWxkIGNoZWNrIGlmIGl0IGEgZmllbGQgb3IgbWV0aG9kLCBiZWNhdXNlIGZvciBhIG1ldGhvZCB3ZSBoYXZlIHRvIHVzZSB0aGUgcGFyZW50IHR5cGVcblx0XHRpZiAoKHRoaXMuI29iakV4cHIudHlwZSBpbnN0YW5jZW9mIEVudW1NZW1iZXJTdGF0ZW1lbnRUeXBlKSAmJiAoIXRoaXMuI29iakV4cHIudHlwZS5zdGF0ZW1lbnQuaGFzRmllbGQodGhpcy4jbWVtYmVyTmFtZSkpKSB7XG5cdFx0XHRvYmpQYXRoID0gdGhpcy4jb2JqRXhwci50eXBlLnN0YXRlbWVudC5wYXJlbnQucGF0aDtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgbWVtYmVyVmFsIHdhcyBhIFBhcmFtRnVuY1ZhbHVlIHRoZW4gdGhlIG1lbWJlciBuYW1lIG1pZ2h0IG5lZWQgdG8gYmUgbW9kaWZpZWQgaWYgdGhlIG91dHB1dCB0eXBlIG9mIHNvbWUgY2FsbGJhY2tzIGlzIGEgQm9vbFxuXHRcdGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgUGFyYW1GdW5jVmFsdWUgJiYgdGhpcy52YWx1ZS5jb3JyZWN0TWVtYmVyTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jbWVtYmVyTmFtZSA9IG5ldyBXb3JkKHRoaXMuI21lbWJlck5hbWUuc2l0ZSwgdGhpcy52YWx1ZS5jb3JyZWN0TWVtYmVyTmFtZSgpKTtcblx0XHR9XG5cblx0XHRsZXQgaXIgPSBuZXcgSVIoYCR7b2JqUGF0aH1fXyR7dGhpcy4jbWVtYmVyTmFtZS50b1N0cmluZygpfWAsIHRoaXMuc2l0ZSk7XG5cblx0XHRpZiAodGhpcy4jaXNSZWN1cnNpdmVGdW5jKSB7XG5cdFx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIoXCIpLFxuXHRcdFx0XHRpcixcblx0XHRcdFx0bmV3IElSKFwiKVwiKSxcblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0aXIsIG5ldyBJUihcIihcIiksXG5cdFx0XHR0aGlzLiNvYmpFeHByLnRvSVIoaW5kZW50KSxcblx0XHRcdG5ldyBJUihcIilcIiksXG5cdFx0XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBpZi10aGVuLWVsc2UgZXhwcmVzc2lvbiBcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElmRWxzZUV4cHIgZXh0ZW5kcyBWYWx1ZUV4cHIge1xuXHQjY29uZGl0aW9ucztcblx0I2JyYW5jaGVzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByW119IGNvbmRpdGlvbnMgXG5cdCAqIEBwYXJhbSB7VmFsdWVFeHByW119IGJyYW5jaGVzIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgY29uZGl0aW9ucywgYnJhbmNoZXMpIHtcblx0XHRhc3NlcnQoYnJhbmNoZXMubGVuZ3RoID09IGNvbmRpdGlvbnMubGVuZ3RoICsgMSk7XG5cdFx0YXNzZXJ0KGJyYW5jaGVzLmxlbmd0aCA+IDEpO1xuXG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jY29uZGl0aW9ucyA9IGNvbmRpdGlvbnM7XG5cdFx0dGhpcy4jYnJhbmNoZXMgPSBicmFuY2hlcztcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdGxldCBzID0gXCJcIjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI2NvbmRpdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHMgKz0gYGlmICgke3RoaXMuI2NvbmRpdGlvbnNbaV0udG9TdHJpbmcoKX0pIHske3RoaXMuI2JyYW5jaGVzW2ldLnRvU3RyaW5nKCl9fSBlbHNlIGA7XG5cdFx0fVxuXG5cdFx0cyArPSBgeyR7dGhpcy4jYnJhbmNoZXNbdGhpcy4jY29uZGl0aW9ucy5sZW5ndGhdLnRvU3RyaW5nKCl9fWA7XG5cblx0XHRyZXR1cm4gcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHs/VHlwZX0gcHJldlR5cGVcblx0ICogQHBhcmFtIHtUeXBlfSBuZXdUeXBlXG5cdCAqL1xuXHRzdGF0aWMgcmVkdWNlQnJhbmNoVHlwZShzaXRlLCBwcmV2VHlwZSwgbmV3VHlwZSkge1xuXHRcdGlmIChwcmV2VHlwZSA9PT0gbnVsbCB8fCBwcmV2VHlwZSBpbnN0YW5jZW9mIEVycm9yVHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ld1R5cGU7XG5cdFx0fSBlbHNlIGlmIChuZXdUeXBlIGluc3RhbmNlb2YgRXJyb3JUeXBlKSB7XG5cdFx0XHRyZXR1cm4gcHJldlR5cGU7XG5cdFx0fSBlbHNlIGlmICghcHJldlR5cGUuaXNCYXNlT2Yoc2l0ZSwgbmV3VHlwZSkpIHtcblx0XHRcdGlmIChuZXdUeXBlLmlzQmFzZU9mKHNpdGUsIHByZXZUeXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3VHlwZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGVudW1wYXJlbnQgaXMgYmFzZSBvZiBuZXdUeXBlIGFuZCBvZiBwcmV2VHlwZVxuXHRcdFx0XHRpZiAobmV3VHlwZS5pc0VudW1NZW1iZXIoKSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcmVudFR5cGUgPSBuZXdUeXBlLnBhcmVudFR5cGUoU2l0ZS5kdW1teSgpKTtcblxuXHRcdFx0XHRcdGlmIChwYXJlbnRUeXBlLmlzQmFzZU9mKHNpdGUsIHByZXZUeXBlKSAmJiBwYXJlbnRUeXBlLmlzQmFzZU9mKHNpdGUsIG5ld1R5cGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyZW50VHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImluY29uc2lzdGVudCB0eXBlc1wiKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHByZXZUeXBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHs/VHlwZVtdfSBwcmV2VHlwZXNcblx0ICogQHBhcmFtIHtJbnN0YW5jZX0gbmV3VmFsdWVcblx0ICogQHJldHVybnMgez9UeXBlW119XG5cdCAqL1xuXHRzdGF0aWMgcmVkdWNlQnJhbmNoTXVsdGlUeXBlKHNpdGUsIHByZXZUeXBlcywgbmV3VmFsdWUpIHtcblx0XHRpZiAoIShuZXdWYWx1ZSBpbnN0YW5jZW9mIE11bHRpSW5zdGFuY2UpICYmIG5ld1ZhbHVlLmdldFR5cGUoc2l0ZSkgaW5zdGFuY2VvZiBFcnJvclR5cGUpIHtcblx0XHRcdHJldHVybiBwcmV2VHlwZXM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV3VHlwZXMgPSAobmV3VmFsdWUgaW5zdGFuY2VvZiBNdWx0aUluc3RhbmNlKSA/XG5cdFx0XHRuZXdWYWx1ZS52YWx1ZXMubWFwKHYgPT4gdi5nZXRUeXBlKHNpdGUpKSA6XG5cdFx0XHRbbmV3VmFsdWUuZ2V0VHlwZShzaXRlKV07XG5cblx0XHRpZiAocHJldlR5cGVzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbmV3VHlwZXM7XG5cdFx0fSBlbHNlIGlmIChwcmV2VHlwZXMubGVuZ3RoICE9PSBuZXdUeXBlcy5sZW5ndGgpIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwiaW5jb25zaXN0ZW50IG51bWJlciBvZiBtdWx0aS12YWx1ZSB0eXBlc1wiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHByZXZUeXBlcy5tYXAoKHB0LCBpKSA9PiBJZkVsc2VFeHByLnJlZHVjZUJyYW5jaFR5cGUoc2l0ZSwgcHQsIG5ld1R5cGVzW2ldKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRmb3IgKGxldCBjIG9mIHRoaXMuI2NvbmRpdGlvbnMpIHtcblx0XHRcdGxldCBjVmFsID0gYy5ldmFsKHNjb3BlKTtcblx0XHRcdGlmICghY1ZhbC5pc0luc3RhbmNlT2YoYy5zaXRlLCBCb29sVHlwZSkpIHtcblx0XHRcdFx0dGhyb3cgYy50eXBlRXJyb3IoXCJleHBlY3RlZCBib29sXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFN1cHBvcnRzIG11bHRpcGxlIHJldHVybiB2YWx1ZXNcblx0XHQgKiBAdHlwZSB7P1R5cGVbXX1cblx0XHQgKi9cblx0XHRsZXQgYnJhbmNoTXVsdGlUeXBlID0gbnVsbDtcblxuXHRcdGZvciAobGV0IGIgb2YgdGhpcy4jYnJhbmNoZXMpIHtcblx0XHRcdGxldCBicmFuY2hWYWwgPSBiLmV2YWwoc2NvcGUpO1xuXG5cdFx0XHRicmFuY2hNdWx0aVR5cGUgPSBJZkVsc2VFeHByLnJlZHVjZUJyYW5jaE11bHRpVHlwZShcblx0XHRcdFx0Yi5zaXRlLCBcblx0XHRcdFx0YnJhbmNoTXVsdGlUeXBlLCBcblx0XHRcdFx0YnJhbmNoVmFsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChicmFuY2hNdWx0aVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIGkuZS4gZXZlcnkgYnJhbmNoIHRocm93cyBhbiBlcnJvclxuXHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRXJyb3JUeXBlKCkpO1xuXHRcdH0gZWxzZSAge1xuXHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhicmFuY2hNdWx0aVR5cGUpO1xuXHRcdH1cblx0fVxuXG5cdHVzZSgpIHtcblx0XHRmb3IgKGxldCBjIG9mIHRoaXMuI2NvbmRpdGlvbnMpIHtcblx0XHRcdGMudXNlKCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgYiBvZiB0aGlzLiNicmFuY2hlcykge1xuXHRcdFx0Yi51c2UoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0bGV0IG4gPSB0aGlzLiNjb25kaXRpb25zLmxlbmd0aDtcblxuXHRcdC8vIGVhY2ggYnJhbmNoIGFjdHVhbGx5IHJldHVybnMgYSBmdW5jdGlvbiB0byBhbGxvdyBkZWZlcnJlZCBldmFsdWF0aW9uXG5cdFx0bGV0IHJlcyA9IG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoXCIoKSAtPiB7XCIpLFxuXHRcdFx0dGhpcy4jYnJhbmNoZXNbbl0udG9JUihpbmRlbnQpLFxuXHRcdFx0bmV3IElSKFwifVwiKVxuXHRcdF0pO1xuXG5cdFx0Ly8gVE9ETzogbmljZSBpbmRlbnRhdGlvblxuXHRcdGZvciAobGV0IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHJlcyA9IG5ldyBJUihbXG5cdFx0XHRcdG5ldyBJUihcIl9fY29yZV9faWZUaGVuRWxzZShcIiksXG5cdFx0XHRcdHRoaXMuI2NvbmRpdGlvbnNbaV0udG9JUihpbmRlbnQpLFxuXHRcdFx0XHRuZXcgSVIoXCIsICgpIC0+IHtcIiksXG5cdFx0XHRcdHRoaXMuI2JyYW5jaGVzW2ldLnRvSVIoaW5kZW50KSxcblx0XHRcdFx0bmV3IElSKFwifSwgKCkgLT4ge1wiKSxcblx0XHRcdFx0cmVzLFxuXHRcdFx0XHRuZXcgSVIoXCIoKX0pXCIpLFxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUihbcmVzLCBuZXcgSVIoXCIoKVwiLCB0aGlzLnNpdGUpXSk7XG5cdH1cbn1cblxuLyoqXG4gKiBEZXN0cnVjdEV4cHIgaXMgZm9yIHRoZSBsaHMtc2lkZSBvZiBhc3NpZ25tZW50cyBhbmQgZm9yIHN3aXRjaCBjYXNlc1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRGVzdHJ1Y3RFeHByIHtcblx0I25hbWU7XG5cdCN0eXBlRXhwcjtcblx0I2Rlc3RydWN0RXhwcnM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSAtIHVzZSBhbiB1bmRlcnNjb3JlIGFzIGEgc2lua1xuXHQgKiBAcGFyYW0gez9UeXBlRXhwcn0gdHlwZUV4cHIgXG5cdCAqIEBwYXJhbSB7RGVzdHJ1Y3RFeHByW119IGRlc3RydWN0RXhwcnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIHR5cGVFeHByLCBkZXN0cnVjdEV4cHJzID0gW10pIHtcblx0XHR0aGlzLiNuYW1lID0gbmFtZTtcblx0XHR0aGlzLiN0eXBlRXhwciA9IHR5cGVFeHByO1xuXHRcdHRoaXMuI2Rlc3RydWN0RXhwcnMgPSBkZXN0cnVjdEV4cHJzO1xuXG5cdFx0YXNzZXJ0ICghKHRoaXMuI3R5cGVFeHByID09IG51bGwgJiYgdGhpcy4jZGVzdHJ1Y3RFeHBycy5sZW5ndGggPiAwKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1NpdGV9XG5cdCAqL1xuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZS5zaXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtXb3JkfVxuXHQgKi9cblx0Z2V0IG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWU7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNEZXN0cnVjdEV4cHJzKCkge1xuXHRcdHJldHVybiB0aGlzLiNkZXN0cnVjdEV4cHJzLmxlbmd0aCA+IDA7XG5cdH1cblxuXHRpc0lnbm9yZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMubmFtZS52YWx1ZSA9PT0gXCJfXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNUeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLiN0eXBlRXhwciAhPT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgY2FsbGVkIGJlZm9yZSBldmFsVHlwZSgpXG5cdCAqIEB0eXBlIHtUeXBlfVxuXHQgKi9cblx0Z2V0IHR5cGUoKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGVFeHByID09PSBudWxsKSB7XG5cdFx0XHRpZiAodGhpcy5pc0lnbm9yZWQoKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFueVR5cGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInR5cGVFeHByIG5vdCBzZXRcIik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlRXhwci50eXBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7V29yZH1cblx0ICovXG5cdGdldCB0eXBlTmFtZSgpIHtcblx0XHRpZiAodGhpcy4jdHlwZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBuZXcgV29yZCh0aGlzLnNpdGUsIFwiXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFdvcmQodGhpcy4jdHlwZUV4cHIuc2l0ZSwgdGhpcy4jdHlwZUV4cHIudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGVFeHByID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lLnRvU3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBkZXN0cnVjdFN0ciA9IFwiXCI7XG5cblx0XHRcdGlmICh0aGlzLiNkZXN0cnVjdEV4cHJzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0ZGVzdHJ1Y3RTdHIgPSBgeyR7dGhpcy4jZGVzdHJ1Y3RFeHBycy5tYXAoZGUgPT4gZGUudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpfX1gO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5pc0lnbm9yZWQoKSkge1xuXHRcdFx0XHRyZXR1cm4gYCR7dGhpcy4jdHlwZUV4cHIudG9TdHJpbmcoKX0ke2Rlc3RydWN0U3RyfWA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYCR7dGhpcy5uYW1lLnRvU3RyaW5nKCl9OiAke3RoaXMuI3R5cGVFeHByLnRvU3RyaW5nKCl9JHtkZXN0cnVjdFN0cn1gO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIHR5cGUsIHVzZWQgYnkgRnVuY0xpdGVyYWxFeHByIGFuZCBEYXRhRGVmaW5pdGlvblxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge1R5cGV9XG5cdCAqL1xuXHRldmFsVHlwZShzY29wZSkge1xuXHRcdGlmICh0aGlzLiN0eXBlRXhwciA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKHRoaXMuaXNJZ25vcmVkKCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBbnlUeXBlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlRXhwciBub3Qgc2V0XCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdHlwZUV4cHIuZXZhbChzY29wZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHVwc3RyZWFtVHlwZSBcblx0ICovXG5cdGV2YWxEZXN0cnVjdEV4cHJzKHNjb3BlLCB1cHN0cmVhbVR5cGUpIHtcblx0XHRpZiAodGhpcy4jZGVzdHJ1Y3RFeHBycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAoISh1cHN0cmVhbVR5cGUgaW5zdGFuY2VvZiBBbnlUeXBlKSAmJiB1cHN0cmVhbVR5cGUubkZpZWxkcyh0aGlzLnNpdGUpICE9IHRoaXMuI2Rlc3RydWN0RXhwcnMubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuc2l0ZS50eXBlRXJyb3IoYHdyb25nIG51bWJlciBvZiBkZXN0cnVjdCBmaWVsZHMsIGV4cGVjdGVkICR7dXBzdHJlYW1UeXBlLm5GaWVsZHModGhpcy5zaXRlKX0sIGdvdCAke3RoaXMuI2Rlc3RydWN0RXhwcnMubGVuZ3RofWApO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI2Rlc3RydWN0RXhwcnMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHR0aGlzLiNkZXN0cnVjdEV4cHJzW2ldLmV2YWxJbnRlcm5hbChcblx0XHRcdFx0XHRzY29wZSwgXG5cdFx0XHRcdFx0dXBzdHJlYW1UeXBlLmdldEZpZWxkVHlwZSh0aGlzLnNpdGUsIGkpLCBcblx0XHRcdFx0XHRpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcGFyYW0ge1R5cGV9IHVwc3RyZWFtVHlwZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlLCB1cHN0cmVhbVR5cGUsIGkpIHtcblx0XHRpZiAodGhpcy5oYXNUeXBlKCkpIHtcblx0XHRcdGxldCB0ID0gdGhpcy5ldmFsVHlwZShzY29wZSlcblxuXHRcdFx0YXNzZXJ0KHQuaXNUeXBlKCkpO1xuXG5cdFx0XHQvLyBkaWZmZXJzIGZyb20gdXBzdHJlYW1UeXBlIGJlY2F1c2UgY2FuIGJlIGVudW0gcGFyZW50XG5cdFx0XHRsZXQgY2hlY2tUeXBlID0gdDtcblxuXHRcdFx0Ly8gaWYgdCBpcyBlbnVtIHZhcmlhbnQsIGdldCBwYXJlbnQgaW5zdGVhZCAoZXhhY3QgdmFyaWFudCBpcyBjaGVja2VkIGF0IHJ1bnRpbWUgaW5zdGVhZClcblx0XHRcdGlmICh0LmlzRW51bU1lbWJlcigpICYmICF1cHN0cmVhbVR5cGUuaXNFbnVtTWVtYmVyKCkpIHtcblx0XHRcdFx0Y2hlY2tUeXBlID0gdC5wYXJlbnRUeXBlKHRoaXMuc2l0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghSW5zdGFuY2UubmV3KHVwc3RyZWFtVHlwZSkuaXNJbnN0YW5jZU9mKHRoaXMuc2l0ZSwgY2hlY2tUeXBlKSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCAke2NoZWNrVHlwZS50b1N0cmluZygpfSBmb3IgZGVzdHJ1Y3R1cmUgZmllbGQgJHtpKzF9LCBnb3QgJHt1cHN0cmVhbVR5cGUudG9TdHJpbmcoKX1gKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmlzSWdub3JlZCgpKSB7XG5cdFx0XHRcdC8vIFRPRE86IHRha2UgaW50byBhY2NvdW50IGdob3N0IHR5cGUgcGFyYW1ldGVyc1xuXHRcdFx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCBJbnN0YW5jZS5uZXcodCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmV2YWxEZXN0cnVjdEV4cHJzKHNjb3BlLCB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLmlzSWdub3JlZCgpKSB7XG5cdFx0XHRcdC8vIFRPRE86IHRha2UgaW50byBhY2NvdW50IGdob3N0IHR5cGUgcGFyYW1ldGVyc1xuXHRcdFx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCBJbnN0YW5jZS5uZXcodXBzdHJlYW1UeXBlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZXZhbERlc3RydWN0RXhwcnMoc2NvcGUsIHVwc3RyZWFtVHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlXG5cdCAqIEBwYXJhbSB7VHlwZX0gY2FzZVR5cGVcblx0ICovXG5cdGV2YWxJblN3aXRjaENhc2Uoc2NvcGUsIGNhc2VUeXBlKSB7XG5cdFx0aWYgKCF0aGlzLmlzSWdub3JlZCgpKSB7XG5cdFx0XHRzY29wZS5zZXQodGhpcy4jbmFtZSwgSW5zdGFuY2UubmV3KGNhc2VUeXBlKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ldmFsRGVzdHJ1Y3RFeHBycyhzY29wZSwgY2FzZVR5cGUpXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gdXBzdHJlYW1UeXBlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpXG5cdCAqL1xuXHRldmFsSW5Bc3NpZ25FeHByKHNjb3BlLCB1cHN0cmVhbVR5cGUsIGkpIHtcblx0XHRsZXQgdCA9IHRoaXMuZXZhbFR5cGUoc2NvcGUpXG5cblx0XHRhc3NlcnQodC5pc1R5cGUoKSk7XG5cblx0XHQvLyBkaWZmZXJzIGZyb20gdXBzdHJlYW1UeXBlIGJlY2F1c2UgY2FuIGJlIGVudW0gcGFyZW50XG5cdFx0bGV0IGNoZWNrVHlwZSA9IHQ7XG5cblx0XHQvLyBpZiB0IGlzIGVudW0gdmFyaWFudCwgZ2V0IHBhcmVudCBpbnN0ZWFkIChleGFjdCB2YXJpYW50IGlzIGNoZWNrZWQgYXQgcnVudGltZSBpbnN0ZWFkKVxuXHRcdGlmICh0LmlzRW51bU1lbWJlcigpICYmICF1cHN0cmVhbVR5cGUuaXNFbnVtTWVtYmVyKCkpIHtcblx0XHRcdGNoZWNrVHlwZSA9IHQucGFyZW50VHlwZSh0aGlzLnNpdGUpO1xuXHRcdH1cblxuXHRcdGlmICghSW5zdGFuY2UubmV3KHVwc3RyZWFtVHlwZSkuaXNJbnN0YW5jZU9mKHRoaXMuc2l0ZSwgY2hlY2tUeXBlKSkge1xuXHRcdFx0dGhyb3cgdGhpcy5zaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgJHtjaGVja1R5cGUudG9TdHJpbmcoKX0gZm9yIHJocyAke2krMX0sIGdvdCAke3Vwc3RyZWFtVHlwZS50b1N0cmluZygpfWApO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc0lnbm9yZWQoKSkge1xuXHRcdFx0Ly8gVE9ETzogdGFrZSBpbnRvIGFjY291bnQgZ2hvc3QgdHlwZSBwYXJhbWV0ZXJzXG5cdFx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCBJbnN0YW5jZS5uZXcodCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZXZhbERlc3RydWN0RXhwcnMoc2NvcGUsIHQpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdGlmICh0aGlzLiN0eXBlRXhwciAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jdHlwZUV4cHIudXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhcmdJbmRleCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9OYW1lSVIoYXJnSW5kZXgpIHtcblx0XHRpZiAodGhpcy5pc0lnbm9yZWQoKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBJUihgX19saHNfJHthcmdJbmRleH1gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBJUih0aGlzLiNuYW1lLnRvU3RyaW5nKCksIHRoaXMuI25hbWUuc2l0ZSlcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1N3aXRjaENhc2Vcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldEZpZWxkRm4oZmllbGRJbmRleCwgaXNTd2l0Y2hDYXNlID0gZmFsc2UpIHtcblx0XHRpZiAoaXNTd2l0Y2hDYXNlKSB7XG5cdFx0XHRyZXR1cm4gYF9faGVsaW9zX19jb21tb25fX2ZpZWxkXyR7ZmllbGRJbmRleH1gO1xuXHRcdH1cblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAodHlwZS5pc0VudW1NZW1iZXIoKSkge1xuXHRcdFx0cmV0dXJuIGBfX2hlbGlvc19fY29tbW9uX19maWVsZF8ke2ZpZWxkSW5kZXh9YDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdHJ1Y3RTdGF0ZW1lbnRUeXBlKSB7XG5cdFx0XHRpZiAodHlwZS5uRmllbGRzKFNpdGUuZHVtbXkoKSkgPT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBgX19oZWxpb3NfX2NvbW1vbl9fdHVwbGVfZmllbGRfJHtmaWVsZEluZGV4fWA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50XG5cdCAqIEBwYXJhbSB7SVJ9IGlubmVyIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZEZuXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHdyYXBEZXN0cnVjdElSSW50ZXJuYWwoaW5kZW50LCBpbm5lciwgb2JqTmFtZSwgZmllbGRJbmRleCwgZmllbGRGbikge1xuXHRcdGlmICh0aGlzLmlzSWdub3JlZCgpICYmIHRoaXMuI2Rlc3RydWN0RXhwcnMubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybiBpbm5lcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgYmFzZU5hbWUgPSB0aGlzLmlzSWdub3JlZCgpID8gYCR7b2JqTmFtZX1fJHtmaWVsZEluZGV4fWAgOiB0aGlzLiNuYW1lLnRvU3RyaW5nKCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLiNkZXN0cnVjdEV4cHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlubmVyID0gdGhpcy4jZGVzdHJ1Y3RFeHByc1tpXS53cmFwRGVzdHJ1Y3RJUkludGVybmFsKGluZGVudCArIFRBQiwgaW5uZXIsIGJhc2VOYW1lLCBpLCB0aGlzLmdldEZpZWxkRm4oaSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZ2V0dGVyID0gYCR7ZmllbGRGbn0oJHtvYmpOYW1lfSlgO1xuXG5cdFx0XHQvLyBhc3NlcnQgY29ycmVjdCBjb25zdHJ1Y3RvciBpbmRleFxuXHRcdFx0aWYgKHRoaXMuI3R5cGVFeHByICYmIHRoaXMudHlwZS5pc0VudW1NZW1iZXIoKSkge1xuXHRcdFx0XHRjb25zdCBjb25zdHJJZHggPSB0aGlzLnR5cGUuZ2V0Q29uc3RySW5kZXgodGhpcy4jdHlwZUV4cHIuc2l0ZSk7XG5cblx0XHRcdFx0Z2V0dGVyID0gYF9faGVsaW9zX19jb21tb25fX2Fzc2VydF9jb25zdHJfaW5kZXgoJHtnZXR0ZXJ9LCAke2NvbnN0cklkeH0pYDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRcdG5ldyBJUihcIihcIiksXG5cdFx0XHRcdG5ldyBJUihiYXNlTmFtZSwgdGhpcy4jbmFtZS5zaXRlKSxcblx0XHRcdFx0bmV3IElSKFwiKSBcIiksXG5cdFx0XHRcdG5ldyBJUihcIi0+XCIsIHRoaXMuc2l0ZSksIG5ldyBJUihgIHtcXG4ke2luZGVudH0ke1RBQn1gKSxcblx0XHRcdFx0aW5uZXIsXG5cdFx0XHRcdG5ldyBJUihgXFxuJHtpbmRlbnR9fSgke2dldHRlcn0pYCksXG5cdFx0XHRdKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudFxuXHQgKiBAcGFyYW0ge0lSfSBpbm5lciBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFyZ0luZGV4IFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3dpdGNoQ2FzZVxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR3cmFwRGVzdHJ1Y3RJUihpbmRlbnQsIGlubmVyLCBhcmdJbmRleCwgaXNTd2l0Y2hDYXNlID0gZmFsc2UpIHtcblx0XHRpZiAodGhpcy4jZGVzdHJ1Y3RFeHBycy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuIGlubmVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBiYXNlTmFtZSA9IHRoaXMuaXNJZ25vcmVkKCkgPyBgX19saHNfJHthcmdJbmRleH1gIDogdGhpcy4jbmFtZS50b1N0cmluZygpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy4jZGVzdHJ1Y3RFeHBycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRjb25zdCBkZSA9IHRoaXMuI2Rlc3RydWN0RXhwcnNbaV07XG5cblx0XHRcdFx0aW5uZXIgPSBkZS53cmFwRGVzdHJ1Y3RJUkludGVybmFsKGluZGVudCArIFRBQiwgaW5uZXIsIGJhc2VOYW1lLCBpLCB0aGlzLmdldEZpZWxkRm4oaSwgaXNTd2l0Y2hDYXNlKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbm5lcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUigpIHtcblx0XHRyZXR1cm4gbmV3IElSKHRoaXMuI25hbWUudG9TdHJpbmcoKSwgdGhpcy4jbmFtZS5zaXRlKTtcblx0fVxufVxuXG4vKipcbiAqIFN3aXRjaCBjYXNlIGZvciBhIHN3aXRjaCBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTd2l0Y2hDYXNlIGV4dGVuZHMgVG9rZW4ge1xuXHQjbGhzO1xuXHQjYm9keUV4cHI7XG5cblx0LyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuXHQjY29uc3RySW5kZXg7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtEZXN0cnVjdEV4cHJ9IGxoc1xuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gYm9keUV4cHIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBsaHMsIGJvZHlFeHByKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jbGhzID0gbGhzO1xuXHRcdHRoaXMuI2JvZHlFeHByID0gYm9keUV4cHI7XG5cdFx0dGhpcy4jY29uc3RySW5kZXggPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtWYWx1ZUV4cHJ9XG5cdCAqL1xuXHRnZXQgYm9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jYm9keUV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBieSBwYXJzZXIgdG8gY2hlY2sgaWYgdHlwZUV4cHIgcmVmZXJlbmNlIHRoZSBzYW1lIGJhc2UgZW51bVxuXHQgKiBAdHlwZSB7V29yZH0gLSB3b3JkIHJlcHJlc2VudGF0aW9uIG9mIHR5cGVcblx0ICovXG5cdGdldCBtZW1iZXJOYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNsaHMudHlwZU5hbWU7XG5cdH1cblxuXHRpc0RhdGFNZW1iZXIoKSB7XG5cdFx0c3dpdGNoICh0aGlzLm1lbWJlck5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJJbnRcIjpcblx0XHRcdGNhc2UgXCJbXURhdGFcIjpcblx0XHRcdGNhc2UgXCJCeXRlQXJyYXlcIjpcblx0XHRcdGNhc2UgXCJNYXBbRGF0YV1EYXRhXCI6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGdldCBjb25zdHJJbmRleCgpIHtcblx0XHRpZiAodGhpcy4jY29uc3RySW5kZXggPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImNvbnN0ckluZGV4IG5vdCB5ZXQgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jY29uc3RySW5kZXg7XG5cdFx0fVxuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMuI2xocy50b1N0cmluZygpfSA9PiAke3RoaXMuI2JvZHlFeHByLnRvU3RyaW5nKCl9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIHN3aXRjaCB0eXBlIGFuZCBib2R5IHZhbHVlIG9mIGEgY2FzZS5cblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gZW51bVR5cGVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEVudW1NZW1iZXIoc2NvcGUsIGVudW1UeXBlKSB7XG5cdFx0Y29uc3QgY2FzZVR5cGUgPSBlbnVtVHlwZS5nZXRUeXBlTWVtYmVyKHRoaXMubWVtYmVyTmFtZSkuYXNzZXJ0VHlwZSh0aGlzLm1lbWJlck5hbWUuc2l0ZSk7XG5cblx0XHR0aGlzLiNjb25zdHJJbmRleCA9IGNhc2VUeXBlLmdldENvbnN0ckluZGV4KHRoaXMubWVtYmVyTmFtZS5zaXRlKTtcblxuXHRcdGFzc2VydCh0aGlzLiNjb25zdHJJbmRleCA+PSAwKTtcblxuXHRcdGNvbnN0IGNhc2VTY29wZSA9IG5ldyBTY29wZShzY29wZSk7XG5cblx0XHR0aGlzLiNsaHMuZXZhbEluU3dpdGNoQ2FzZShjYXNlU2NvcGUsIGNhc2VUeXBlKTtcblxuXHRcdGNvbnN0IGJvZHlWYWwgPSB0aGlzLiNib2R5RXhwci5ldmFsKGNhc2VTY29wZSk7XG5cblx0XHRjYXNlU2NvcGUuYXNzZXJ0QWxsVXNlZCgpO1xuXG5cdFx0cmV0dXJuIGJvZHlWYWw7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHRoZSBzd2l0Y2ggdHlwZSBhbmQgYm9keSB2YWx1ZSBvZiBhIGNhc2UuXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWxEYXRhTWVtYmVyKHNjb3BlKSB7XG5cdFx0LyoqIEB0eXBlIHtUeXBlfSAqL1xuXHRcdGxldCBtZW1iZXJUeXBlO1xuXG5cdFx0c3dpdGNoICh0aGlzLm1lbWJlck5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJJbnRcIjpcblx0XHRcdFx0bWVtYmVyVHlwZSA9IG5ldyBJbnRUeXBlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIkJ5dGVBcnJheVwiOlxuXHRcdFx0XHRtZW1iZXJUeXBlID0gbmV3IEJ5dGVBcnJheVR5cGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiW11EYXRhXCI6XG5cdFx0XHRcdG1lbWJlclR5cGUgPSBuZXcgTGlzdFR5cGUobmV3IFJhd0RhdGFUeXBlKCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJNYXBbRGF0YV1EYXRhXCI6XG5cdFx0XHRcdG1lbWJlclR5cGUgPSBuZXcgTWFwVHlwZShuZXcgUmF3RGF0YVR5cGUoKSwgbmV3IFJhd0RhdGFUeXBlKCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGxldCBtYXliZU1lbWJlclR5cGUgPSBzY29wZS5nZXQodGhpcy5tZW1iZXJOYW1lKTtcblx0XHRcdFx0aWYgKG1heWJlTWVtYmVyVHlwZSBpbnN0YW5jZW9mIFR5cGUpIHtcblx0XHRcdFx0XHRtZW1iZXJUeXBlID0gbWF5YmVNZW1iZXJUeXBlO1xuXG5cdFx0XHRcdFx0aWYgKCEobWVtYmVyVHlwZSBpbnN0YW5jZW9mIEVudW1TdGF0ZW1lbnRUeXBlKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgdGhpcy5tZW1iZXJOYW1lLnR5cGVFcnJvcihcImV4cGVjdGVkIGFuIGVudW0gdHlwZVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgdGhpcy5tZW1iZXJOYW1lLnR5cGVFcnJvcihcImV4cGVjdGVkIGEgdHlwZVwiKTtcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGNhc2VTY29wZSA9IG5ldyBTY29wZShzY29wZSk7XG5cblx0XHR0aGlzLiNsaHMuZXZhbEluU3dpdGNoQ2FzZShjYXNlU2NvcGUsIG1lbWJlclR5cGUpO1xuXG5cdFx0Y29uc3QgYm9keVZhbCA9IHRoaXMuI2JvZHlFeHByLmV2YWwoY2FzZVNjb3BlKTtcblxuXHRcdGNhc2VTY29wZS5hc3NlcnRBbGxVc2VkKCk7XG5cblx0XHRyZXR1cm4gYm9keVZhbDtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHR0aGlzLiNib2R5RXhwci51c2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBY2NlcHQgYW4gYXJnIGJlY2F1c2Ugd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBjb250cm9sZXhwclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHRsZXQgaW5uZXIgPSB0aGlzLiNib2R5RXhwci50b0lSKGluZGVudCArIFRBQik7XG5cblx0XHRpbm5lciA9IHRoaXMuI2xocy53cmFwRGVzdHJ1Y3RJUihpbmRlbnQsIGlubmVyLCAwLCB0cnVlKTtcblxuXHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKFwiKFwiKSxcblx0XHRcdHRoaXMuI2xocy50b05hbWVJUigwKSwgXG5cdFx0XHRuZXcgSVIoXCIpIFwiKSxcblx0XHRcdG5ldyBJUihcIi0+XCIsIHRoaXMuc2l0ZSksIG5ldyBJUihgIHtcXG4ke2luZGVudH0ke1RBQn1gKSxcblx0XHRcdGlubmVyLFxuXHRcdFx0bmV3IElSKGBcXG4ke2luZGVudH19YCksXG5cdFx0XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBVbmNvbnN0ckRhdGFTd2l0Y2hDYXNlIGV4dGVuZHMgU3dpdGNoQ2FzZSB7XG5cdCNpbnRWYXJOYW1lO1xuXHQjbHN0VmFyTmFtZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0gez9Xb3JkfSBpbnRWYXJOYW1lIFxuXHQgKiBAcGFyYW0gez9Xb3JkfSBsc3RWYXJOYW1lIFxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gYm9keUV4cHIgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBpbnRWYXJOYW1lLCBsc3RWYXJOYW1lLCBib2R5RXhwcikge1xuXHRcdHN1cGVyKHNpdGUsIG5ldyBEZXN0cnVjdEV4cHIobmV3IFdvcmQoc2l0ZSwgXCJfXCIpLCBuZXcgVHlwZVJlZkV4cHIobmV3IFdvcmQoc2l0ZSwgXCIoSW50LCBbXURhdGEpXCIpKSksIGJvZHlFeHByKTtcblxuXHRcdHRoaXMuI2ludFZhck5hbWUgPSBpbnRWYXJOYW1lO1xuXHRcdHRoaXMuI2xzdFZhck5hbWUgPSBsc3RWYXJOYW1lO1xuXHR9XG5cblx0aXNEYXRhTWVtYmVyKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGAoJHt0aGlzLiNpbnRWYXJOYW1lID09PSBudWxsID8gXCJcIiA6IHRoaXMuI2ludFZhck5hbWUudmFsdWUgKyBcIjogXCJ9SW50LCAke3RoaXMuI2xzdFZhck5hbWUgPT09IG51bGwgPyBcIlwiIDogdGhpcy4jbHN0VmFyTmFtZS52YWx1ZSArIFwiOiBcIn0gW11EYXRhKSA9PiAke3RoaXMuYm9keS50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEBwYXJhbSB7VHlwZX0gZW51bVR5cGVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEVudW1NZW1iZXIoc2NvcGUsIGVudW1UeXBlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGF2YWlsYWJsZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIHN3aXRjaCB0eXBlIGFuZCBib2R5IHZhbHVlIG9mIGEgY2FzZS5cblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGVcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbERhdGFNZW1iZXIoc2NvcGUpIHtcblx0XHRpZiAodGhpcy4jaW50VmFyTmFtZSAhPT0gbnVsbCB8fCB0aGlzLiNsc3RWYXJOYW1lICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgY2FzZVNjb3BlID0gbmV3IFNjb3BlKHNjb3BlKTtcblxuXHRcdFx0aWYgKHRoaXMuI2ludFZhck5hbWUgIT09IG51bGwpIHtcblx0XHRcdFx0Y2FzZVNjb3BlLnNldCh0aGlzLiNpbnRWYXJOYW1lLCBJbnN0YW5jZS5uZXcobmV3IEludFR5cGUoKSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy4jbHN0VmFyTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRjYXNlU2NvcGUuc2V0KHRoaXMuI2xzdFZhck5hbWUsIEluc3RhbmNlLm5ldyhuZXcgTGlzdFR5cGUobmV3IFJhd0RhdGFUeXBlKCkpKSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBib2R5VmFsID0gdGhpcy5ib2R5LmV2YWwoY2FzZVNjb3BlKTtcblxuXHRcdFx0Y2FzZVNjb3BlLmFzc2VydEFsbFVzZWQoKTtcblxuXHRcdFx0cmV0dXJuIGJvZHlWYWw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmJvZHkuZXZhbChzY29wZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFjY2VwdHMgdHdvIGFyZ3Ncblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoYChkYXRhKSAtPiB7XFxuJHtpbmRlbnR9JHtUQUJ9YCksXG5cdFx0XHRuZXcgSVIoYChwYWlyKSAtPiB7XFxuJHtpbmRlbnR9JHtUQUJ9JHtUQUJ9YCksXG5cdFx0XHRuZXcgSVIoYCgke3RoaXMuI2ludFZhck5hbWUgIT09IG51bGwgPyB0aGlzLiNpbnRWYXJOYW1lLnRvU3RyaW5nKCkgOiBcIl9cIn0sICR7dGhpcy4jbHN0VmFyTmFtZSAhPT0gbnVsbCA/IHRoaXMuI2xzdFZhck5hbWUudG9TdHJpbmcoKSA6IFwiX1wifSkgYCksIG5ldyBJUihcIi0+XCIsIHRoaXMuc2l0ZSksIG5ldyBJUihgIHtcXG4ke2luZGVudH0ke1RBQn0ke1RBQn0ke1RBQn1gKSxcblx0XHRcdHRoaXMuYm9keS50b0lSKGluZGVudCArIFRBQiArIFRBQiArIFRBQiksXG5cdFx0XHRuZXcgSVIoYFxcbiR7aW5kZW50fSR7VEFCfSR7VEFCfX0oX19jb3JlX19pRGF0YShfX2NvcmVfX2ZzdFBhaXIocGFpcikpLCBfX2NvcmVfX2xpc3REYXRhKF9fY29yZV9fc25kUGFpcihwYWlyKSkpYCksXG5cdFx0XHRuZXcgSVIoYFxcbiR7aW5kZW50fSR7VEFCfX0oX19jb3JlX191bkNvbnN0ckRhdGEoZGF0YSkpYCksXG5cdFx0XHRuZXcgSVIoYFxcbiR7aW5kZW50fX1gKVxuXHRcdF0pO1xuXHR9XG59XG5cbi8qKlxuICogRGVmYXVsdCBzd2l0Y2ggY2FzZVxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgU3dpdGNoRGVmYXVsdCBleHRlbmRzIFRva2VuIHtcblx0I2JvZHlFeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IGJvZHlFeHByXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBib2R5RXhwcikge1xuXHRcdHN1cGVyKHNpdGUpO1xuXHRcdHRoaXMuI2JvZHlFeHByID0gYm9keUV4cHI7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYGVsc2UgPT4gJHt0aGlzLiNib2R5RXhwci50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTY29wZX0gc2NvcGUgXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy4jYm9keUV4cHIuZXZhbChzY29wZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jYm9keUV4cHIudXNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoYChfKSBgKSwgbmV3IElSKFwiLT5cIiwgdGhpcy5zaXRlKSwgbmV3IElSKGAge1xcbiR7aW5kZW50fSR7VEFCfWApLFxuXHRcdFx0dGhpcy4jYm9keUV4cHIudG9JUihpbmRlbnQgKyBUQUIpLFxuXHRcdFx0bmV3IElSKGBcXG4ke2luZGVudH19YClcblx0XHRdKTtcblx0fVxufVxuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBvZiBFbnVtU3dpdGNoRXhwciBhbmQgRGF0YVN3aXRjaEV4cHJcbiAqL1xuY2xhc3MgU3dpdGNoRXhwciBleHRlbmRzIFZhbHVlRXhwciB7XG5cdCNjb250cm9sRXhwcjtcblx0I2Nhc2VzO1xuXHQjZGVmYXVsdENhc2U7XG5cblx0LyoqIFxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtWYWx1ZUV4cHJ9IGNvbnRyb2xFeHByIC0gaW5wdXQgdmFsdWUgb2YgdGhlIHN3aXRjaFxuXHQgKiBAcGFyYW0ge1N3aXRjaENhc2VbXX0gY2FzZXNcblx0ICogQHBhcmFtIHs/U3dpdGNoRGVmYXVsdH0gZGVmYXVsdENhc2Vcblx0Ki9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgY29udHJvbEV4cHIsIGNhc2VzLCBkZWZhdWx0Q2FzZSA9IG51bGwpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNjb250cm9sRXhwciA9IGNvbnRyb2xFeHByO1xuXHRcdHRoaXMuI2Nhc2VzID0gY2FzZXM7XG5cdFx0dGhpcy4jZGVmYXVsdENhc2UgPSBkZWZhdWx0Q2FzZTtcblx0fVxuXG5cdGdldCBjb250cm9sRXhwcigpIHtcblx0XHRyZXR1cm4gdGhpcy4jY29udHJvbEV4cHI7XG5cdH1cblxuXHRnZXQgY2FzZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Nhc2VzO1xuXHR9XG5cblx0Z2V0IGRlZmF1bHRDYXNlKCkge1xuXHRcdHJldHVybiB0aGlzLiNkZWZhdWx0Q2FzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGVyZSBpc24ndCBlbm91Z2ggY292ZXJhZ2UgdGhlbiB3ZSBjYW4gc2ltcGx5IHNldCB0aGUgZGVmYXVsdCBjYXNlIHRvIHZvaWQsIHNvIHRoZSBvdGhlciBicmFuY2hlcyBjYW4gYmUgZXJyb3IsIHByaW50IG9yIGFzc2VydFxuXHQgKi9cblx0c2V0RGVmYXVsdENhc2VUb1ZvaWQoKSB7XG5cdFx0dGhpcy4jZGVmYXVsdENhc2UgPSBuZXcgU3dpdGNoRGVmYXVsdCh0aGlzLnNpdGUsIG5ldyBWb2lkRXhwcih0aGlzLnNpdGUpKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiNjb250cm9sRXhwci50b1N0cmluZygpfS5zd2l0Y2h7JHt0aGlzLiNjYXNlcy5tYXAoYyA9PiBjLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX0ke3RoaXMuI2RlZmF1bHRDYXNlID09PSBudWxsID8gXCJcIiA6IFwiLCBcIiArIHRoaXMuI2RlZmF1bHRDYXNlLnRvU3RyaW5nKCl9fWA7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jY29udHJvbEV4cHIudXNlKCk7XG5cblx0XHRmb3IgKGxldCBjIG9mIHRoaXMuI2Nhc2VzKSB7XG5cdFx0XHRjLnVzZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNkZWZhdWx0Q2FzZSAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jZGVmYXVsdENhc2UudXNlKCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogU3dpdGNoIGV4cHJlc3Npb24gZm9yIEVudW0sIHdpdGggU3dpdGNoQ2FzZXMgYW5kIFN3aXRjaERlZmF1bHQgYXMgY2hpbGRyZW5cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEVudW1Td2l0Y2hFeHByIGV4dGVuZHMgU3dpdGNoRXhwciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0bGV0IGNvbnRyb2xWYWwgPSB0aGlzLmNvbnRyb2xFeHByLmV2YWwoc2NvcGUpO1xuXHRcdGxldCBlbnVtVHlwZSA9IGNvbnRyb2xWYWwuZ2V0VHlwZSh0aGlzLmNvbnRyb2xFeHByLnNpdGUpO1xuXHRcdGxldCBuRW51bU1lbWJlcnMgPSBlbnVtVHlwZS5uRW51bU1lbWJlcnModGhpcy5jb250cm9sRXhwci5zaXRlKTtcblxuXHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBlbm91Z2ggY2FzZXMgdG8gY292ZXIgdGhlIGVudW0gbWVtYmVyc1xuXHRcdGlmICh0aGlzLmRlZmF1bHRDYXNlID09PSBudWxsICYmIG5FbnVtTWVtYmVycyA+IHRoaXMuY2FzZXMubGVuZ3RoKSB7XG5cdFx0XHQvLyBtdXRhdGUgZGVmYXVsdENhc2UgdG8gVm9pZEV4cHJcblx0XHRcdHRoaXMuc2V0RGVmYXVsdENhc2VUb1ZvaWQoKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUgez9UeXBlW119ICovXG5cdFx0bGV0IGJyYW5jaE11bHRpVHlwZSA9IG51bGw7XG5cblx0XHRmb3IgKGxldCBjIG9mIHRoaXMuY2FzZXMpIHtcblx0XHRcdGxldCBicmFuY2hWYWwgPSBjLmV2YWxFbnVtTWVtYmVyKHNjb3BlLCBlbnVtVHlwZSk7XG5cdFxuXHRcdFx0YnJhbmNoTXVsdGlUeXBlID0gSWZFbHNlRXhwci5yZWR1Y2VCcmFuY2hNdWx0aVR5cGUoXG5cdFx0XHRcdGMuc2l0ZSwgXG5cdFx0XHRcdGJyYW5jaE11bHRpVHlwZSwgXG5cdFx0XHRcdGJyYW5jaFZhbFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kZWZhdWx0Q2FzZSAhPT0gbnVsbCkge1xuXHRcdFx0bGV0IGRlZmF1bHRWYWwgPSB0aGlzLmRlZmF1bHRDYXNlLmV2YWwoc2NvcGUpO1xuXG5cdFx0XHRicmFuY2hNdWx0aVR5cGUgPSBJZkVsc2VFeHByLnJlZHVjZUJyYW5jaE11bHRpVHlwZShcblx0XHRcdFx0dGhpcy5kZWZhdWx0Q2FzZS5zaXRlLFxuXHRcdFx0XHRicmFuY2hNdWx0aVR5cGUsIFxuXHRcdFx0XHRkZWZhdWx0VmFsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChicmFuY2hNdWx0aVR5cGUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEVycm9yVHlwZSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhicmFuY2hNdWx0aVR5cGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50IFxuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKGluZGVudCA9IFwiXCIpIHtcblx0XHRsZXQgY2FzZXMgPSB0aGlzLmNhc2VzLnNsaWNlKCk7XG5cblx0XHQvKiogQHR5cGUge1N3aXRjaENhc2UgfCBTd2l0Y2hEZWZhdWx0fSAqL1xuXHRcdGxldCBsYXN0O1xuXHRcdGlmICh0aGlzLmRlZmF1bHRDYXNlICE9PSBudWxsKSB7XG5cdFx0XHRsYXN0ID0gdGhpcy5kZWZhdWx0Q2FzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdCA9IGFzc2VydERlZmluZWQoY2FzZXMucG9wKCkpO1xuXHRcdH1cblxuXHRcdGxldCBuID0gY2FzZXMubGVuZ3RoO1xuXG5cdFx0bGV0IHJlcyA9IGxhc3QudG9JUihpbmRlbnQgKyBUQUIgKyBUQUIgKyBUQUIpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVzID0gbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKGBfX2NvcmVfX2lmVGhlbkVsc2UoX19jb3JlX19lcXVhbHNJbnRlZ2VyKGksICR7Y2FzZXNbaV0uY29uc3RySW5kZXgudG9TdHJpbmcoKX0pLCAoKSAtPiB7YCksXG5cdFx0XHRcdGNhc2VzW2ldLnRvSVIoaW5kZW50ICsgVEFCICsgVEFCICsgVEFCKSxcblx0XHRcdFx0bmV3IElSKGB9LCAoKSAtPiB7YCksXG5cdFx0XHRcdHJlcyxcblx0XHRcdFx0bmV3IElSKGB9KSgpYClcblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKGAoZSkgYCksIG5ldyBJUihcIi0+XCIsIHRoaXMuc2l0ZSksIG5ldyBJUihgIHtcXG4ke2luZGVudH0ke1RBQn0oXFxuJHtpbmRlbnR9JHtUQUJ9JHtUQUJ9KGkpIC0+IHtcXG4ke2luZGVudH0ke1RBQn0ke1RBQn0ke1RBQn1gKSxcblx0XHRcdHJlcyxcblx0XHRcdG5ldyBJUihgXFxuJHtpbmRlbnR9JHtUQUJ9JHtUQUJ9fShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoZSkpKVxcbiR7aW5kZW50fSR7VEFCfSkoZSlcXG4ke2luZGVudH19KGApLFxuXHRcdFx0dGhpcy5jb250cm9sRXhwci50b0lSKGluZGVudCksXG5cdFx0XHRuZXcgSVIoXCIpXCIpLFxuXHRcdF0pO1xuXHR9XG59XG5cbi8qKlxuICogU3dpdGNoIGV4cHJlc3Npb24gZm9yIERhdGFcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIERhdGFTd2l0Y2hFeHByIGV4dGVuZHMgU3dpdGNoRXhwciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0bGV0IGNvbnRyb2xWYWwgPSB0aGlzLmNvbnRyb2xFeHByLmV2YWwoc2NvcGUpO1xuXHRcdGxldCBkYXRhVHlwZSA9IGNvbnRyb2xWYWwuZ2V0VHlwZSh0aGlzLmNvbnRyb2xFeHByLnNpdGUpO1xuXG5cdFx0bGV0IGNvbnRyb2xTaXRlID0gdGhpcy5jb250cm9sRXhwci5zaXRlO1xuXHRcdGlmICghZGF0YVR5cGUuaXNCYXNlT2YoY29udHJvbFNpdGUsIG5ldyBSYXdEYXRhVHlwZSgpKSkge1xuXHRcdFx0dGhyb3cgdGhpcy5jb250cm9sRXhwci50eXBlRXJyb3IoYGV4cGVjdGVkIERhdGEgdHlwZSwgZ290ICR7Y29udHJvbFZhbC5nZXRUeXBlKGNvbnRyb2xTaXRlKS50b1N0cmluZygpfWApO1xuXHRcdH1cblxuXHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBlbm91Z2ggY2FzZXMgdG8gY292ZXIgdGhlIGVudW0gbWVtYmVyc1xuXHRcdGlmICh0aGlzLmRlZmF1bHRDYXNlID09PSBudWxsICYmIHRoaXMuY2FzZXMubGVuZ3RoIDwgNSkge1xuXHRcdFx0Ly8gbXV0YXRlIGRlZmF1bHRDYXNlIHRvIFZvaWRFeHByXG5cdFx0XHR0aGlzLnNldERlZmF1bHRDYXNlVG9Wb2lkKCk7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHs/VHlwZVtdfSAqL1xuXHRcdGxldCBicmFuY2hNdWx0aVR5cGUgPSBudWxsO1xuXG5cdFx0Zm9yIChsZXQgYyBvZiB0aGlzLmNhc2VzKSB7XG5cdFx0XHRsZXQgYnJhbmNoVmFsID0gYy5ldmFsRGF0YU1lbWJlcihzY29wZSk7XG5cblx0XHRcdGJyYW5jaE11bHRpVHlwZSA9IElmRWxzZUV4cHIucmVkdWNlQnJhbmNoTXVsdGlUeXBlKFxuXHRcdFx0XHRjLnNpdGUsIFxuXHRcdFx0XHRicmFuY2hNdWx0aVR5cGUsIFxuXHRcdFx0XHRicmFuY2hWYWxcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZGVmYXVsdENhc2UgIT09IG51bGwpIHtcblx0XHRcdGxldCBkZWZhdWx0VmFsID0gdGhpcy5kZWZhdWx0Q2FzZS5ldmFsKHNjb3BlKTtcblxuXHRcdFx0YnJhbmNoTXVsdGlUeXBlID0gSWZFbHNlRXhwci5yZWR1Y2VCcmFuY2hNdWx0aVR5cGUoXG5cdFx0XHRcdHRoaXMuZGVmYXVsdENhc2Uuc2l0ZSwgXG5cdFx0XHRcdGJyYW5jaE11bHRpVHlwZSwgXG5cdFx0XHRcdGRlZmF1bHRWYWxcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGJyYW5jaE11bHRpVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gb25seSBwb3NzaWJsZSBpZiBlYWNoIGJyYW5jaCBpcyBhbiBlcnJvclxuXHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRXJyb3JUeXBlKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KGJyYW5jaE11bHRpVHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVIoaW5kZW50ID0gXCJcIikge1xuXHRcdC8qKiBAdHlwZSB7Wz9JUiwgP0lSLCA/SVIsID9JUiwgP0lSXX0gKi9cblx0XHRsZXQgY2FzZXMgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07IC8vIGNvbnN0ciwgbWFwLCBsaXN0LCBpbnQsIGJ5dGVBcnJheVxuXG5cdFx0Zm9yIChsZXQgYyBvZiB0aGlzLmNhc2VzKSB7XG5cdFx0XHRsZXQgaXIgPSBjLnRvSVIoaW5kZW50ICsgVEFCICsgVEFCKTtcblxuXHRcdFx0c3dpdGNoIChjLm1lbWJlck5hbWUudmFsdWUpIHtcblx0XHRcdFx0Y2FzZSBcIkJ5dGVBcnJheVwiOlxuXHRcdFx0XHRcdGNhc2VzWzRdID0gaXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJJbnRcIjpcblx0XHRcdFx0XHRjYXNlc1szXSA9IGlyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiW11EYXRhXCI6XG5cdFx0XHRcdFx0Y2FzZXNbMl0gPSBpcjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIk1hcFtEYXRhXURhdGFcIjpcblx0XHRcdFx0XHRjYXNlc1sxXSA9IGlyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiKEludCwgW11EYXRhKVwiOlxuXHRcdFx0XHRcdGNhc2VzWzBdID0gaXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKGNhc2VzWzBdICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQndmUgYmVlbiBjYXVnaHQgYmVmb3JlXCIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2VzWzBdID0gaXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZGVmYXVsdENhc2UgIT09IG51bGwpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdFx0XHRcdGlmIChjYXNlc1tpXSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNhc2VzW2ldID0gbmV3IElSKGAke2luZGVudH0ke1RBQn1kZWZgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCByZXMgPSBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKGAke2luZGVudH1fX2NvcmVfX2Nob29zZURhdGEoZSwgYCwgdGhpcy5zaXRlKSxcblx0XHRcdG5ldyBJUihjYXNlcy5tYXAoYyA9PiBhc3NlcnREZWZpbmVkKGMpKSkuam9pbihcIiwgXCIpLFxuXHRcdFx0bmV3IElSKGAke2luZGVudH0pYClcblx0XHRdKTtcblxuXHRcdGlmICh0aGlzLmRlZmF1bHRDYXNlICE9PSBudWxsKSB7XG5cdFx0XHRyZXMgPSBuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoYCR7aW5kZW50fShkZWYpIC0+IHtcXG5gKSxcblx0XHRcdFx0cmVzLFxuXHRcdFx0XHRuZXcgSVIoYFxcbiR7aW5kZW50fX0oYCksXG5cdFx0XHRcdHRoaXMuZGVmYXVsdENhc2UudG9JUihpbmRlbnQpLFxuXHRcdFx0XHRuZXcgSVIoYClgKVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0cmVzID0gbmV3IElSKFtcblx0XHRcdG5ldyBJUihgJHtpbmRlbnR9KGUpIC0+IHtcXG5gKSxcblx0XHRcdHJlcyxcblx0XHRcdG5ldyBJUihcIihlKVwiKSxcblx0XHRcdG5ldyBJUihgJHtpbmRlbnR9fShgKSxcblx0XHRcdHRoaXMuY29udHJvbEV4cHIudG9JUihpbmRlbnQpLFxuXHRcdFx0bmV3IElSKFwiKVwiKVxuXHRcdF0pO1xuXG5cdFx0cmV0dXJuIHJlcztcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDE2OiBMaXRlcmFsIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgLSBleHBlY3RlZCB0eXBlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgLSByZXN1bHQgb2YgSlNPTi5wYXJzZShzdHJpbmcpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGNvbnRleHQgZm9yIGRlYnVnZ2luZ1xuICogQHJldHVybnMge1ZhbHVlRXhwcn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRMaXRlcmFsRXhwckZyb21Kc29uKHNpdGUsIHR5cGUsIHZhbHVlLCBwYXRoKSB7XG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBub24tbnVsbCB2YWx1ZSBmb3IgcGFyYW1ldGVyICcke3BhdGh9J2ApO1xuXHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpIHtcblx0XHRcdHJldHVybiBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHIobmV3IEJvb2xMaXRlcmFsKHNpdGUsIHZhbHVlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBib29sZWFuIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgU3RyaW5nVHlwZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cmV0dXJuIG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcihuZXcgU3RyaW5nTGl0ZXJhbChzaXRlLCB2YWx1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgc3RyaW5nIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgSW50VHlwZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0aWYgKHZhbHVlJTEgPT0gMC4wKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHIobmV3IEludExpdGVyYWwoc2l0ZSwgQmlnSW50KHZhbHVlKSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIHJvdW5kIG51bWJlciBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIG51bWJlciBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEJ5dGVBcnJheVR5cGUgfHwgdHlwZSBpbnN0YW5jZW9mIEhhc2hUeXBlKSB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge251bWJlcltdfVxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBieXRlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaXRlbSA9PSBcIm51bWJlclwiICYmIGl0ZW0lMSA9PSAwLjAgJiYgaXRlbSA+PSAwICYmIGl0ZW0gPCAyNTYpIHtcblx0XHRcdFx0XHRieXRlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCB1aW50OFtdIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBAdHlwZSB7VmFsdWVFeHByfSAqL1xuXHRcdFx0bGV0IGxpdEV4cHIgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHIobmV3IEJ5dGVBcnJheUxpdGVyYWwoc2l0ZSwgYnl0ZXMpKTtcblxuXHRcdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBIYXNoVHlwZSkge1xuXHRcdFx0XHRsaXRFeHByID0gbmV3IENhbGxFeHByKHNpdGUsIG5ldyBWYWx1ZVBhdGhFeHByKG5ldyBUeXBlUmVmRXhwcihuZXcgV29yZChzaXRlLCB0eXBlLnRvU3RyaW5nKCkpLCB0eXBlKSwgbmV3IFdvcmQoc2l0ZSwgXCJuZXdcIikpLCBbbmV3IENhbGxBcmdFeHByKGxpdEV4cHIuc2l0ZSwgbnVsbCwgbGl0RXhwcildKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxpdEV4cHI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhcnJheSBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIExpc3RUeXBlKSB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge1ZhbHVlRXhwcltdfVxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBpdGVtcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goYnVpbGRMaXRlcmFsRXhwckZyb21Kc29uKHNpdGUsIHR5cGUuaXRlbVR5cGUsIGl0ZW0sIHBhdGggKyBcIltdXCIpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBMaXN0TGl0ZXJhbEV4cHIoc2l0ZSwgbmV3IFR5cGVFeHByKHNpdGUsIHR5cGUuaXRlbVR5cGUpLCBpdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhcnJheSBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIE1hcFR5cGUpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7W1ZhbHVlRXhwciwgVmFsdWVFeHByXVtdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IHBhaXJzID0gW107XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZS5rZXlUeXBlIGluc3RhbmNlb2YgU3RyaW5nVHlwZSkge1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdHBhaXJzLnB1c2goW25ldyBQcmltaXRpdmVMaXRlcmFsRXhwcihuZXcgU3RyaW5nTGl0ZXJhbChzaXRlLCBrZXkpKSwgYnVpbGRMaXRlcmFsRXhwckZyb21Kc29uKHNpdGUsIHR5cGUudmFsdWVUeXBlLCB2YWx1ZVtrZXldLCBwYXRoICsgXCIuXCIgKyBrZXkpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkgJiYgaXRlbS5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRcdHBhaXJzLnB1c2goW1xuXHRcdFx0XHRcdFx0YnVpbGRMaXRlcmFsRXhwckZyb21Kc29uKHNpdGUsIHR5cGUua2V5VHlwZSwgaXRlbVswXSwgcGF0aCArIFwiWzBdXCIpLFxuXHRcdFx0XHRcdFx0YnVpbGRMaXRlcmFsRXhwckZyb21Kc29uKHNpdGUsIHR5cGUudmFsdWVUeXBlLCBpdGVtWzFdLCBwYXRoICsgXCJbMV1cIiksXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIGFycmF5IG9mIHBhaXJzIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBhcnJheSBvciBvYmplY3QgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBNYXBMaXRlcmFsRXhwcihcblx0XHRcdHNpdGUsIFxuXHRcdFx0bmV3IFR5cGVFeHByKHNpdGUsIHR5cGUua2V5VHlwZSksIFxuXHRcdFx0bmV3IFR5cGVFeHByKHNpdGUsIHR5cGUudmFsdWVUeXBlKSxcblx0XHRcdHBhaXJzXG5cdFx0KTtcblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgU3RydWN0U3RhdGVtZW50VHlwZSB8fCB0eXBlIGluc3RhbmNlb2YgRW51bU1lbWJlclN0YXRlbWVudFR5cGUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGNvbnN0IG5GaWVsZHMgPSB0eXBlLnN0YXRlbWVudC5uRmllbGRzKHNpdGUpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtTdHJ1Y3RMaXRlcmFsRmllbGRbXX1cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgZmllbGRzID0gbmV3IEFycmF5KG5GaWVsZHMpO1xuXG5cdFx0XHRjb25zdCBuQWN0dWFsID0gT2JqZWN0LmVudHJpZXModmFsdWUpLmxlbmd0aDtcblxuXHRcdFx0aWYgKG5GaWVsZHMgIT0gbkFjdHVhbCkge1xuXHRcdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtuRmllbGRzLnRvU3RyaW5nfSBmaWVsZHMgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nIHdpdGggJHtuQWN0dWFsLnRvU3RyaW5nKCl9IGZpZWxkc2ApO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5GaWVsZHM7IGkrKykge1xuXHRcdFx0XHRjb25zdCBrZXkgPSB0eXBlLnN0YXRlbWVudC5nZXRGaWVsZE5hbWUoaSk7XG5cblx0XHRcdFx0Y29uc3Qgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuXG5cdFx0XHRcdGlmIChzdWJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIG9iamVjdCB3aXRoIGtleSAnJHtrZXl9JyBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfWApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZmllbGRUeXBlID0gdHlwZS5zdGF0ZW1lbnQuZ2V0RmllbGRUeXBlKHNpdGUsIGkpO1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlRXhwciA9IGJ1aWxkTGl0ZXJhbEV4cHJGcm9tSnNvbihzaXRlLCBmaWVsZFR5cGUsIHN1YlZhbHVlLCBwYXRoICsgXCIuXCIgKyBrZXkpO1xuXG5cdFx0XHRcdGZpZWxkc1tpXSA9IG5ldyBTdHJ1Y3RMaXRlcmFsRmllbGQobkZpZWxkcyA9PSAxID8gbnVsbCA6IG5ldyBXb3JkKHNpdGUsIGtleSksIHZhbHVlRXhwcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgU3RydWN0TGl0ZXJhbEV4cHIobmV3IFR5cGVFeHByKHNpdGUsIHR5cGUpLCBmaWVsZHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgb2JqZWN0IGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgdW5oYW5kbGVkIHBhcmFtZXRlciB0eXBlICcke3R5cGUudG9TdHJpbmcoKX0nLCBmb3IgcGFyYW1ldGVyICR7cGF0aH1gKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1NpdGV9IHNpdGVcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSAtIGV4cGVjdGVkIHR5cGVcbiAqIEBwYXJhbSB7VXBsY1ZhbHVlfSB2YWx1ZSBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gY29udGV4dCBmb3IgZGVidWdnaW5nXG4gKiBAcmV0dXJucyB7VmFsdWVFeHByfVxuICovXG5mdW5jdGlvbiBidWlsZExpdGVyYWxFeHByRnJvbVZhbHVlKHNpdGUsIHR5cGUsIHZhbHVlLCBwYXRoKSB7XG5cdGlmICh0eXBlIGluc3RhbmNlb2YgQm9vbFR5cGUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBVcGxjQm9vbCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcihuZXcgQm9vbExpdGVyYWwoc2l0ZSwgdmFsdWUuYm9vbCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgVXBsY0Jvb2wgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nYCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdHJpbmdUeXBlKSB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgVXBsY0RhdGFWYWx1ZSAmJiB2YWx1ZS5kYXRhIGluc3RhbmNlb2YgQnl0ZUFycmF5RGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcihuZXcgU3RyaW5nTGl0ZXJhbChzaXRlLCBieXRlc1RvVGV4dCh2YWx1ZS5kYXRhLmJ5dGVzKSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgQnl0ZUFycmF5RGF0YSBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIEludFR5cGUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBVcGxjRGF0YVZhbHVlICYmIHZhbHVlLmRhdGEgaW5zdGFuY2VvZiBJbnREYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByaW1pdGl2ZUxpdGVyYWxFeHByKG5ldyBJbnRMaXRlcmFsKHNpdGUsIHZhbHVlLmRhdGEudmFsdWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIEludERhdGEgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nYCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBCeXRlQXJyYXlUeXBlKSB7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgVXBsY0RhdGFWYWx1ZSAmJiB2YWx1ZS5kYXRhIGluc3RhbmNlb2YgQnl0ZUFycmF5RGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcmltaXRpdmVMaXRlcmFsRXhwcihuZXcgQnl0ZUFycmF5TGl0ZXJhbChzaXRlLCB2YWx1ZS5kYXRhLmJ5dGVzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBCeXRlQXJyYXlEYXRhIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgTGlzdFR5cGUpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBVcGxjRGF0YVZhbHVlICYmIHZhbHVlLmRhdGEgaW5zdGFuY2VvZiBMaXN0RGF0YSkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdHlwZSB7VmFsdWVFeHByW119XG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGl0ZW1zID0gW107XG5cblx0XHRcdGZvciAobGV0IGRhdGEgb2YgdmFsdWUuZGF0YS5saXN0KSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goYnVpbGRMaXRlcmFsRXhwckZyb21WYWx1ZShzaXRlLCB0eXBlLml0ZW1UeXBlLCBuZXcgVXBsY0RhdGFWYWx1ZShzaXRlLCBkYXRhKSwgcGF0aCArIFwiW11cIikpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IExpc3RMaXRlcmFsRXhwcihzaXRlLCBuZXcgVHlwZUV4cHIoc2l0ZSwgdHlwZS5pdGVtVHlwZSksIGl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGV4cGVjdGVkIExpc3REYXRhIGZvciBwYXJhbWV0ZXIgJyR7cGF0aH0nLCBnb3QgJyR7dmFsdWV9J2ApO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgTWFwVHlwZSkge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVwbGNEYXRhVmFsdWUgJiYgdmFsdWUuZGF0YSBpbnN0YW5jZW9mIE1hcERhdGEpIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge1tWYWx1ZUV4cHIsIFZhbHVlRXhwcl1bXX1cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgcGFpcnMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgZGF0YVBhaXIgb2YgdmFsdWUuZGF0YS5tYXApIHtcblx0XHRcdFx0Y29uc3Qga2V5RXhwciA9IGJ1aWxkTGl0ZXJhbEV4cHJGcm9tVmFsdWUoc2l0ZSwgdHlwZS5rZXlUeXBlLCBuZXcgVXBsY0RhdGFWYWx1ZShzaXRlLCBkYXRhUGFpclswXSksIHBhdGggKyBcIntrZXl9XCIpO1xuXHRcdFx0XHRjb25zdCB2YWx1ZUV4cHIgPSBidWlsZExpdGVyYWxFeHByRnJvbVZhbHVlKHNpdGUsIHR5cGUudmFsdWVUeXBlLCBuZXcgVXBsY0RhdGFWYWx1ZShzaXRlLCBkYXRhUGFpclsxXSksIHBhdGggKyBcInt2YWx1ZX1cIik7XG5cblx0XHRcdFx0cGFpcnMucHVzaChba2V5RXhwciwgdmFsdWVFeHByXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgTWFwTGl0ZXJhbEV4cHIoXG5cdFx0XHRcdHNpdGUsIFxuXHRcdFx0XHRuZXcgVHlwZUV4cHIoc2l0ZSwgdHlwZS5rZXlUeXBlKSwgXG5cdFx0XHRcdG5ldyBUeXBlRXhwcihzaXRlLCB0eXBlLnZhbHVlVHlwZSksXG5cdFx0XHRcdHBhaXJzXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgTGlzdERhdGEgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nYCk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdHJ1Y3RTdGF0ZW1lbnRUeXBlIHx8IHR5cGUgaW5zdGFuY2VvZiBFbnVtTWVtYmVyU3RhdGVtZW50VHlwZSkge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVwbGNEYXRhVmFsdWUgJiYgdmFsdWUuZGF0YSBpbnN0YW5jZW9mIENvbnN0ckRhdGEpIHtcblx0XHRcdGNvbnN0IG5GaWVsZHMgPSB0eXBlLnN0YXRlbWVudC5uRmllbGRzKHNpdGUpO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdHlwZSB7U3RydWN0TGl0ZXJhbEZpZWxkW119XG5cdFx0XHQgKi9cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5ldyBBcnJheShuRmllbGRzKTtcblxuXHRcdFx0aWYgKG5GaWVsZHMgIT0gdmFsdWUuZGF0YS5maWVsZHMubGVuZ3RoKSB7XG5cdFx0XHRcdHRocm93IHNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBDb25zdHJEYXRhIHdpdGggJHtuRmllbGRzLnRvU3RyaW5nfSBmaWVsZHMgZm9yIHBhcmFtZXRlciAnJHtwYXRofScsIGdvdCAnJHt2YWx1ZX0nIHdpdGggJHt2YWx1ZS5kYXRhLmZpZWxkcy5sZW5ndGgudG9TdHJpbmcoKX0gZmllbGRzYCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbkZpZWxkczsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGYgPSB2YWx1ZS5kYXRhLmZpZWxkc1tpXTtcblxuXHRcdFx0XHRjb25zdCBmaWVsZFR5cGUgPSB0eXBlLnN0YXRlbWVudC5nZXRGaWVsZFR5cGUoc2l0ZSwgaSk7XG5cblx0XHRcdFx0Y29uc3QgdmFsdWVFeHByID0gYnVpbGRMaXRlcmFsRXhwckZyb21WYWx1ZShzaXRlLCBmaWVsZFR5cGUsIG5ldyBVcGxjRGF0YVZhbHVlKHNpdGUsIGYpLCBwYXRoICsgXCIuXCIgKyBpLnRvU3RyaW5nKCkpO1xuXG5cdFx0XHRcdGZpZWxkc1tpXSA9IG5ldyBTdHJ1Y3RMaXRlcmFsRmllbGQobkZpZWxkcyA9PSAxID8gbnVsbCA6IG5ldyBXb3JkKHNpdGUsIHR5cGUuc3RhdGVtZW50LmdldEZpZWxkTmFtZShpKSksIHZhbHVlRXhwcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgU3RydWN0TGl0ZXJhbEV4cHIobmV3IFR5cGVFeHByKHNpdGUsIHR5cGUpLCBmaWVsZHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihgZXhwZWN0ZWQgQ29uc3RyRGF0YSBmb3IgcGFyYW1ldGVyICcke3BhdGh9JywgZ290ICcke3ZhbHVlfSdgKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYHVuaGFuZGxlZCBwYXJhbWV0ZXIgdHlwZSAnJHt0eXBlLnRvU3RyaW5nKCl9JywgZm9yIHBhcmFtZXRlciAke3BhdGh9YCk7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMTc6IEhlbGlvcyBBU1Qgc3RhdGVtZW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHNcbiAqIERvZXNuJ3QgcmV0dXJuIGEgdmFsdWUgdXBvbiBjYWxsaW5nIGV2YWwoc2NvcGUpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBTdGF0ZW1lbnQgZXh0ZW5kcyBUb2tlbiB7XG5cdCNuYW1lO1xuXHQjdXNlZDtcblx0I2Jhc2VQYXRoOyAvLyBzZXQgYnkgdGhlIHBhcmVudCBNb2R1bGVcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBuYW1lKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuI2Jhc2VQYXRoID0gXCJfX3VzZXJcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggXG5cdCAqL1xuXHRzZXRCYXNlUGF0aChiYXNlUGF0aCkge1xuXHRcdHRoaXMuI2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cdH1cblxuXHRnZXQgcGF0aCgpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy4jYmFzZVBhdGh9X18ke3RoaXMubmFtZS50b1N0cmluZygpfWA7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1dvcmR9XG5cdCAqL1xuXHRnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdGdldCB1c2VkKCkge1xuXHRcdHJldHVybiB0aGlzLiN1c2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TW9kdWxlU2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0dGhpcy4jdXNlZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVaW50OEFycmF5fSBtYXNrXG5cdCAqL1xuXHRoaWRlVW51c2VkKG1hc2spIHtcblx0XHRpZiAoIXRoaXMuI3VzZWQpIHtcblx0XHRcdGlmICh0aGlzLnNpdGUuZW5kU2l0ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRtYXNrLmZpbGwoMCwgdGhpcy5zaXRlLnN0YXJ0UG9zKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hc2suZmlsbCgwLCB0aGlzLnNpdGUuc3RhcnRQb3MsIHRoaXMuc2l0ZS5lbmRTaXRlLnN0YXJ0UG9zKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBJUiBvZiBzdGF0ZW1lbnQuXG5cdCAqIE5vIG5lZWQgdG8gc3BlY2lmeSBpbmRlbnQgaGVyZSwgYmVjYXVzZSBhbGwgc3RhdGVtZW50cyBhcmUgdG9wLWxldmVsXG5cdCAqIEBwYXJhbSB7SVJEZWZpbml0aW9uc30gbWFwIFxuXHQgKi9cblx0dG9JUihtYXApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG59XG5cbi8qKlxuICogRWFjaCBmaWVsZCBpcyBnaXZlbiBhIHNlcGFyYXRlIEltcG9ydFN0YXRlbWVudFxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSW1wb3J0U3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcblx0I29yaWdOYW1lO1xuXHQjbW9kdWxlTmFtZTtcblxuXHQvKiogXG5cdCAqIEB0eXBlIHs/U3RhdGVtZW50fSBcblx0ICovXG5cdCNvcmlnU3RhdGVtZW50O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcGFyYW0ge1dvcmR9IG9yaWdOYW1lXG5cdCAqIEBwYXJhbSB7V29yZH0gbW9kdWxlTmFtZVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgbmFtZSwgb3JpZ05hbWUsIG1vZHVsZU5hbWUpIHtcblx0XHRzdXBlcihzaXRlLCBuYW1lKTtcblx0XHR0aGlzLiNvcmlnTmFtZSA9IG9yaWdOYW1lO1xuXHRcdHRoaXMuI21vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuXHRcdHRoaXMuI29yaWdTdGF0ZW1lbnQgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtXb3JkfVxuXHQgKi9cblx0Z2V0IG1vZHVsZU5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI21vZHVsZU5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1N0YXRlbWVudH1cblx0ICovXG5cdGdldCBvcmlnU3RhdGVtZW50KCkge1xuXHRcdGlmICh0aGlzLiNvcmlnU3RhdGVtZW50ID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCBiZSBzZXRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiNvcmlnU3RhdGVtZW50O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01vZHVsZVNjb3BlfSBzY29wZVxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGV2YWxJbnRlcm5hbChzY29wZSkge1xuXHRcdGxldCBpbXBvcnRlZFNjb3BlID0gc2NvcGUuZ2V0KHRoaXMuI21vZHVsZU5hbWUpO1xuXG5cdFx0aWYgKGltcG9ydGVkU2NvcGUgaW5zdGFuY2VvZiBTY29wZSkge1xuXHRcdFx0bGV0IGltcG9ydGVkRW50aXR5ID0gaW1wb3J0ZWRTY29wZS5nZXQodGhpcy4jb3JpZ05hbWUpO1xuXG5cdFx0XHRpZiAoaW1wb3J0ZWRFbnRpdHkgaW5zdGFuY2VvZiBTY29wZSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLiNvcmlnTmFtZS50eXBlRXJyb3IoYGNhbid0IGltcG9ydCBhIG1vZHVsZSBmcm9tIGEgbW9kdWxlYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gaW1wb3J0ZWRFbnRpdHk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IHRoaXMuI21vZHVsZU5hbWUudHlwZUVycm9yKGAke3RoaXMubmFtZS50b1N0cmluZygpfSBpc24ndCBhIG1vZHVsZWApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01vZHVsZVNjb3BlfSBzY29wZSBcblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRsZXQgdiA9IHRoaXMuZXZhbEludGVybmFsKHNjb3BlKTtcblxuXHRcdGlmICh2IGluc3RhbmNlb2YgRnVuY1N0YXRlbWVudEluc3RhbmNlIHx8IHYgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudEluc3RhbmNlIHx8IHYgaW5zdGFuY2VvZiBTdGF0ZW1lbnRUeXBlKSB7XG5cdFx0XHR0aGlzLiNvcmlnU3RhdGVtZW50ID0gYXNzZXJ0Q2xhc3Modi5zdGF0ZW1lbnQsIFN0YXRlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgaW1wb3J0IGVudGl0eVwiKTtcblx0XHR9XG5cblx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCB2KTtcblx0fVxuXG5cdHVzZSgpIHtcblx0XHRzdXBlci51c2UoKTtcblxuXHRcdGlmICh0aGlzLiNvcmlnU3RhdGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgYmUgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiNvcmlnU3RhdGVtZW50LnVzZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRGVmaW5pdGlvbnN9IG1hcCBcblx0ICovXG5cdHRvSVIobWFwKSB7XG5cdFx0Ly8gaW1wb3J0IHN0YXRlbWVudHMgb25seSBoYXZlIGEgc2NvcGluZyBmdW5jdGlvbiBhbmQgZG9uJ3QgZG8gYW55dGhpbmcgdG8gdGhlIElSXG5cdH1cbn1cblxuLyoqXG4gKiBDb25zdCB2YWx1ZSBzdGF0ZW1lbnRcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIENvbnN0U3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcblx0LyoqXG5cdCAqIEB0eXBlIHs/VHlwZUV4cHJ9XG5cdCAqL1xuXHQjdHlwZUV4cHI7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtWYWx1ZUV4cHJ9XG5cdCAqL1xuXHQjdmFsdWVFeHByO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHs/VHlwZUV4cHJ9IHR5cGVFeHByIC0gY2FuIGJlIG51bGwgaW4gY2FzZSBvZiB0eXBlIGluZmVyZW5jZVxuXHQgKiBAcGFyYW0ge1ZhbHVlRXhwcn0gdmFsdWVFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgbmFtZSwgdHlwZUV4cHIsIHZhbHVlRXhwcikge1xuXHRcdHN1cGVyKHNpdGUsIG5hbWUpO1xuXHRcdHRoaXMuI3R5cGVFeHByID0gdHlwZUV4cHI7XG5cdFx0dGhpcy4jdmFsdWVFeHByID0gdmFsdWVFeHByO1xuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0aWYgKHRoaXMuI3R5cGVFeHByID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdmFsdWVFeHByLnR5cGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiN0eXBlRXhwci50eXBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFVwbGNWYWx1ZX0gdmFsdWUgXG5cdCAqL1xuXHRjaGFuZ2VWYWx1ZSh2YWx1ZSkge1xuXHRcdGxldCB0eXBlID0gdGhpcy50eXBlO1xuXHRcdGxldCBzaXRlID0gdGhpcy4jdmFsdWVFeHByLnNpdGU7XG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRoaXMuI3ZhbHVlRXhwciA9IGJ1aWxkTGl0ZXJhbEV4cHJGcm9tSnNvbihzaXRlLCB0eXBlLCBKU09OLnBhcnNlKHZhbHVlKSwgdGhpcy5uYW1lLnZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4jdmFsdWVFeHByID0gYnVpbGRMaXRlcmFsRXhwckZyb21WYWx1ZShzaXRlLCB0eXBlLCB2YWx1ZSwgdGhpcy5uYW1lLnZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlIHRoaXMgdG8gY2hhbmdlIGEgdmFsdWUgb2Ygc29tZXRoaW5nIHRoYXQgaXMgYWxyZWFkeSB0eXBlY2hlY2tlZC5cblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YVxuXHQgKi9cblx0Y2hhbmdlVmFsdWVTYWZlKGRhdGEpIHtcblx0XHRjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuXHRcdGNvbnN0IHNpdGUgPSB0aGlzLiN2YWx1ZUV4cHIuc2l0ZTtcblxuXHRcdGlmICgobmV3IEJvb2xUeXBlKCkpLmlzQmFzZU9mKHNpdGUsIHR5cGUpKSB7XG5cdFx0XHR0aGlzLiN2YWx1ZUV4cHIgPSBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHIobmV3IEJvb2xMaXRlcmFsKHNpdGUsIGRhdGEuaW5kZXggPT0gMSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiN2YWx1ZUV4cHIgPSBuZXcgTGl0ZXJhbERhdGFFeHByKHNpdGUsIHR5cGUsIGRhdGEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBjb25zdCAke3RoaXMubmFtZS50b1N0cmluZygpfSR7dGhpcy4jdHlwZUV4cHIgPT09IG51bGwgPyBcIlwiIDogXCI6IFwiICsgdGhpcy4jdHlwZUV4cHIudG9TdHJpbmcoKX0gPSAke3RoaXMuI3ZhbHVlRXhwci50b1N0cmluZygpfTtgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKiBAcmV0dXJucyB7SW5zdGFuY2V9XG5cdCAqL1xuXHRldmFsSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRsZXQgdmFsdWUgPSB0aGlzLiN2YWx1ZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHQvKiogQHR5cGUge1R5cGV9ICovXG5cdFx0bGV0IHR5cGU7XG5cblx0XHRpZiAodGhpcy4jdHlwZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdGlmICghdGhpcy4jdmFsdWVFeHByLmlzTGl0ZXJhbCgpKSB7XG5cdFx0XHRcdHRocm93IHRoaXMudHlwZUVycm9yKFwiY2FuJ3QgaW5mZXIgdHlwZVwiKTtcblx0XHRcdH1cblxuXHRcdFx0dHlwZSA9IHRoaXMuI3ZhbHVlRXhwci50eXBlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlID0gdGhpcy4jdHlwZUV4cHIuZXZhbChzY29wZSk7XG5cblx0XHRcdGlmICghdmFsdWUuaXNJbnN0YW5jZU9mKHRoaXMuI3ZhbHVlRXhwci5zaXRlLCB0eXBlKSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLiN2YWx1ZUV4cHIudHlwZUVycm9yKFwid3JvbmcgdHlwZVwiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0U3RhdGVtZW50SW5zdGFuY2UodHlwZSwgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHJocyBhbmQgYWRkcyB0byBzY29wZVxuXHQgKiBAcGFyYW0ge1RvcFNjb3BlfSBzY29wZSBcblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCB0aGlzLmV2YWxJbnRlcm5hbChzY29wZSkpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdGlmICghdGhpcy51c2VkKSB7XG5cdFx0XHRzdXBlci51c2UoKTtcblxuXHRcdFx0dGhpcy4jdmFsdWVFeHByLnVzZSgpO1xuXG5cdFx0XHRpZiAodGhpcy4jdHlwZUV4cHIgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy4jdHlwZUV4cHIudXNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJUn1cblx0ICovXG5cdHRvSVJJbnRlcm5hbCgpIHtcblx0XHRyZXR1cm4gbmV3IElSKFtcblx0XHRcdG5ldyBJUihcImNvbnN0KFwiLCB0aGlzLnNpdGUpLFxuXHRcdFx0dGhpcy4jdmFsdWVFeHByLnRvSVIoKSxcblx0XHRcdG5ldyBJUihcIilcIilcblx0XHRdKVxuXHRcdFxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJEZWZpbml0aW9uc30gbWFwIFxuXHQgKi9cblx0dG9JUihtYXApIHtcblx0XHRtYXAuc2V0KHRoaXMucGF0aCwgdGhpcy50b0lSSW50ZXJuYWwoKSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTaW5nbGUgZmllbGQgaW4gc3RydWN0IG9yIGVudW0gbWVtYmVyXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBEYXRhRmllbGQgZXh0ZW5kcyBOYW1lVHlwZVBhaXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1R5cGVFeHByfSB0eXBlRXhwciBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIHR5cGVFeHByKSB7XG5cdFx0c3VwZXIobmFtZSwgdHlwZUV4cHIpO1xuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc3RydWN0IGFuZCBlbnVtIG1lbWJlclxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgRGF0YURlZmluaXRpb24gZXh0ZW5kcyBTdGF0ZW1lbnQge1xuXHQjZmllbGRzO1xuXG5cdC8qKiBAdHlwZSB7U2V0PHN0cmluZz59ICovXG5cdCN1c2VkQXV0b01ldGhvZHM7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge0RhdGFGaWVsZFtdfSBmaWVsZHMgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlLCBuYW1lLCBmaWVsZHMpIHtcblx0XHRzdXBlcihzaXRlLCBuYW1lKTtcblx0XHR0aGlzLiNmaWVsZHMgPSBmaWVsZHM7XG5cdFx0dGhpcy4jdXNlZEF1dG9NZXRob2RzID0gbmV3IFNldCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlfVxuXHQgKi9cblx0Z2V0IHR5cGUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdGdldCBmaWVsZHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZpZWxkcy5zbGljZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaW5kZXggb2YgYSBmaWVsZC5cblx0ICogUmV0dXJucyAtMSBpZiBub3QgZm91bmQuXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGZpbmRGaWVsZChuYW1lKSB7XG5cdFx0bGV0IGZvdW5kID0gLTE7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGZvciAobGV0IGYgb2YgdGhpcy4jZmllbGRzKSB7XG5cdFx0XHRpZiAoZi5uYW1lLnRvU3RyaW5nKCkgPT0gbmFtZS50b1N0cmluZygpKSB7XG5cdFx0XHRcdGZvdW5kID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvdW5kO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNGaWVsZChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmluZEZpZWxkKG5hbWUpICE9IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNNZW1iZXIobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLmhhc0ZpZWxkKG5hbWUpIHx8IG5hbWUudmFsdWUgPT0gXCJjb3B5XCI7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy5uYW1lLnRvU3RyaW5nKCl9IHske3RoaXMuI2ZpZWxkcy5tYXAoZiA9PiBmLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX19YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0Zm9yIChsZXQgZiBvZiB0aGlzLiNmaWVsZHMpIHtcblx0XHRcdGxldCBmaWVsZFR5cGUgPSBmLmV2YWxUeXBlKHNjb3BlKTtcblxuXHRcdFx0aWYgKGZpZWxkVHlwZSBpbnN0YW5jZW9mIEZ1bmNUeXBlKSB7XG5cdFx0XHRcdHRocm93IGYuc2l0ZS50eXBlRXJyb3IoXCJmaWVsZCBjYW4ndCBiZSBmdW5jdGlvbiB0eXBlXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRuRmllbGRzKHNpdGUpIHtcblx0XHRyZXR1cm4gdGhpcy4jZmllbGRzLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIFxuXHQgKiBAcmV0dXJucyB7VHlwZX1cblx0ICovXG5cdGdldEZpZWxkVHlwZShzaXRlLCBpKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZpZWxkc1tpXS50eXBlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRGaWVsZEluZGV4KHNpdGUsIG5hbWUpIHtcblx0XHRjb25zdCBpID0gdGhpcy5maW5kRmllbGQobmV3IFdvcmQoU2l0ZS5kdW1teSgpLCBuYW1lKSk7XG5cblx0XHRpZiAoaSA9PSAtMSkge1xuXHRcdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYGZpZWxkICR7bmFtZX0gbm90IGZpbmQgaW4gJHt0aGlzLnRvU3RyaW5nKCl9YCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0RmllbGROYW1lKGkpIHtcblx0XHRyZXR1cm4gdGhpcy4jZmllbGRzW2ldLm5hbWUudG9TdHJpbmcoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoYCcke3RoaXMubmFtZS52YWx1ZX0nIGlzbid0IGFuIGVudW0gdHlwZWApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHJldHVybnMge0V2YWxFbnRpdHl9XG5cdCAqL1xuXHRnZXRUeXBlTWVtYmVyKG5hbWUpIHtcblx0XHRpZiAodGhpcy5oYXNGaWVsZChuYW1lKSkge1xuXHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7dGhpcy5uYW1lLnRvU3RyaW5nKCl9Ojoke25hbWUudG9TdHJpbmcoKX0nIHVuZGVmaW5lZCAoZGlkIHlvdSBtZWFuICcke3RoaXMubmFtZS50b1N0cmluZygpfS4ke25hbWUudG9TdHJpbmcoKX0nPylgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7dGhpcy5uYW1lLnRvU3RyaW5nKCl9Ojoke25hbWUudG9TdHJpbmcoKX0nIHVuZGVmaW5lZGApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGluc2FuY2UgbWVtYmVyIHZhbHVlLlxuXHQgKiBJZiBkcnlSdW4gPT0gdHJ1ZSB1c2FnZSBpcyB0cmlnZ2VyZWRcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1biBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJjb3B5XCI6XG5cdFx0XHRcdHRoaXMuI3VzZWRBdXRvTWV0aG9kcy5hZGQobmFtZS52YWx1ZSk7XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKHRoaXMuI2ZpZWxkcy5tYXAoZiA9PiBuZXcgQXJnVHlwZShmLm5hbWUsIGYudHlwZSwgdHJ1ZSkpLCB0aGlzLnR5cGUpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGxldCBpID0gdGhpcy5maW5kRmllbGQobmFtZSk7XG5cblx0XHRcdFx0aWYgKGkgPT0gLTEpIHtcblx0XHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKGAnJHt0aGlzLm5hbWUudG9TdHJpbmcoKX0uJHtuYW1lLnRvU3RyaW5nKCl9JyB1bmRlZmluZWRgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSW5zdGFuY2UubmV3KHRoaXMuI2ZpZWxkc1tpXS50eXBlKTtcblx0XHRcdFx0fVxuXHRcdH1cblx0XHRcblx0fVxuXG5cdHVzZSgpIHtcblx0XHRpZiAoIXRoaXMudXNlZCkge1xuXHRcdFx0c3VwZXIudXNlKCk7XG5cdFx0XHRcblx0XHRcdGZvciAobGV0IGYgb2YgdGhpcy4jZmllbGRzKSB7XG5cdFx0XHRcdGYudXNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7SVJEZWZpbml0aW9uc30gbWFwIFxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBnZXR0ZXJOYW1lc1xuXHQgKi9cblx0Y29weVRvSVIobWFwLCBnZXR0ZXJOYW1lcykge1xuXHRcdGNvbnN0IGtleSA9IGAke3RoaXMucGF0aH1fX2NvcHlgO1xuXG5cdFx0Ly8gdXNpbmcgZXhpc3RpbmcgSVIgZ2VuZXJhdG9ycyBhcyBtdWNoIGFzIHBvc3NpYmxlXG5cblx0XHRsZXQgaXIgPSBTdHJ1Y3RMaXRlcmFsRXhwci50b0lSSW50ZXJuYWwodGhpcy5zaXRlLCB0aGlzLnR5cGUsIHRoaXMuI2ZpZWxkcy5tYXAoZGYgPT4gbmV3IElSKGRmLm5hbWUudmFsdWUpKSwgdGhpcy5nZXRDb25zdHJJbmRleCh0aGlzLnNpdGUpKTtcblxuXHRcdC8vIHdyYXAgd2l0aCBkZWZhdWx0c1xuXG5cdFx0Zm9yIChsZXQgaSA9IGdldHRlck5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBmaWVsZE5hbWUgPSB0aGlzLiNmaWVsZHNbaV0ubmFtZS50b1N0cmluZygpO1xuXG5cdFx0XHRpciA9IEZ1bmNBcmcud3JhcFdpdGhEZWZhdWx0SW50ZXJuYWwoaXIsIGZpZWxkTmFtZSwgbmV3IElSKFtcblx0XHRcdFx0bmV3IElSKGdldHRlck5hbWVzW2ldKSxcblx0XHRcdFx0bmV3IElSKFwiKHNlbGYpXCIpXG5cdFx0XHRdKSlcblx0XHR9XG5cblx0XHRpciA9IG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoXCIoc2VsZikgLT4ge1wiKSxcblx0XHRcdG5ldyBJUihcIihcIiksXG5cdFx0XHRuZXcgSVIodGhpcy4jZmllbGRzLm1hcChmID0+IG5ldyBJUihgX191c2VvcHRfXyR7Zi5uYW1lLnRvU3RyaW5nKCl9LCAke2YubmFtZS50b1N0cmluZygpfWApKSkuam9pbihcIiwgXCIpLFxuXHRcdFx0bmV3IElSKFwiKSAtPiB7XCIpLFxuXHRcdFx0aXIsXG5cdFx0XHRuZXcgSVIoXCJ9fVwiKVxuXHRcdF0pO1xuXG5cdFx0bWFwLnNldChrZXksIGlyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2Vzbid0IHJldHVybiBhbnl0aGluZywgYnV0IHNldHMgaXRzIElSZGVmIGluIHRoZSBtYXBcblx0ICogQHBhcmFtIHtJUkRlZmluaXRpb25zfSBtYXBcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0NvbnN0clxuXHQgKi9cblx0dG9JUihtYXAsIGlzQ29uc3RyID0gdHJ1ZSkge1xuXHRcdGNvbnN0IGdldHRlckJhc2VOYW1lID0gaXNDb25zdHIgPyBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXCIgOiBcIl9faGVsaW9zX19jb21tb25fX3R1cGxlX2ZpZWxkXCI7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7c3RyaW5nW119XG5cdFx0ICovXG5cdFx0Y29uc3QgZ2V0dGVyTmFtZXMgPSBbXTtcblxuXHRcdC8vIGFkZCBhIGdldHRlciBmb3IgZWFjaCBmaWVsZFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jZmllbGRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZiA9IHRoaXMuI2ZpZWxkc1tpXTtcblx0XHRcdGxldCBrZXkgPSBgJHt0aGlzLnBhdGh9X18ke2YubmFtZS50b1N0cmluZygpfWA7XG5cdFx0XHRnZXR0ZXJOYW1lcy5wdXNoKGtleSk7XG5cdFx0XHRsZXQgaXNCb29sID0gZi50eXBlIGluc3RhbmNlb2YgQm9vbFR5cGU7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge0lSfVxuXHRcdFx0ICovXG5cdFx0XHRsZXQgZ2V0dGVyO1xuXG5cdFx0XHRpZiAoaSA8IDIwKSB7XG5cblx0XHRcdFx0Z2V0dGVyID0gbmV3IElSKGAke2dldHRlckJhc2VOYW1lfV8ke2l9YCwgZi5zaXRlKTtcblxuXHRcdFx0XHRpZiAoaXNCb29sKSB7XG5cdFx0XHRcdFx0Z2V0dGVyID0gbmV3IElSKFtcblx0XHRcdFx0XHRcdG5ldyBJUihcIihzZWxmKSBcIiksIG5ldyBJUihcIi0+XCIsIGYuc2l0ZSksIG5ldyBJUihcIiB7XCIpLFxuXHRcdFx0XHRcdFx0bmV3IElSKGBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKCR7Z2V0dGVyQmFzZU5hbWV9XyR7aX0oc2VsZikpYCksXG5cdFx0XHRcdFx0XHRuZXcgSVIoXCJ9XCIpLFxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaW5uZXIgPSBpc0NvbnN0ciA/IG5ldyBJUihcIl9fY29yZV9fc25kUGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShzZWxmKSlcIikgOiBuZXcgSVIoXCJfX2NvcmVfX3VuTGlzdERhdGEoc2VsZilcIik7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHtcblx0XHRcdFx0XHRpbm5lciA9IG5ldyBJUihbbmV3IElSKFwiX19jb3JlX190YWlsTGlzdChcIiksIGlubmVyLCBuZXcgSVIoXCIpXCIpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbm5lciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0bmV3IElSKFwiX19jb3JlX19oZWFkTGlzdChcIiksXG5cdFx0XHRcdFx0aW5uZXIsXG5cdFx0XHRcdFx0bmV3IElSKFwiKVwiKSxcblx0XHRcdFx0XSk7XG5cblx0XHRcdFx0aWYgKGlzQm9vbCkge1xuXHRcdFx0XHRcdGlubmVyID0gbmV3IElSKFtuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKFwiKSwgaW5uZXIsIG5ldyBJUihcIilcIildKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdldHRlciA9IG5ldyBJUihbXG5cdFx0XHRcdFx0bmV3IElSKFwiKHNlbGYpIFwiKSwgbmV3IElSKFwiLT5cIiwgZi5zaXRlKSwgbmV3IElSKFwiIHtcIiksXG5cdFx0XHRcdFx0aW5uZXIsXG5cdFx0XHRcdFx0bmV3IElSKFwifVwiKSxcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cblx0XHRcdG1hcC5zZXQoa2V5LCBnZXR0ZXIpXG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3VzZWRBdXRvTWV0aG9kcy5oYXMoXCJjb3B5XCIpKSB7XG5cdFx0XHR0aGlzLmNvcHlUb0lSKG1hcCwgZ2V0dGVyTmFtZXMpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFN0cnVjdCBzdGF0ZW1lbnRcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIFN0cnVjdFN0YXRlbWVudCBleHRlbmRzIERhdGFEZWZpbml0aW9uIHtcblx0I2ltcGw7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge0RhdGFGaWVsZFtdfSBmaWVsZHMgXG5cdCAqIEBwYXJhbSB7SW1wbERlZmluaXRpb259IGltcGxcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG5hbWUsIGZpZWxkcywgaW1wbCkge1xuXHRcdHN1cGVyKHNpdGUsIG5hbWUsIGZpZWxkcyk7XG5cblx0XHR0aGlzLiNpbXBsID0gaW1wbDtcblx0fVxuXG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiBuZXcgU3RydWN0U3RhdGVtZW50VHlwZSh0aGlzKTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBcInN0cnVjdCBcIiArIHN1cGVyLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyAtMSwgd2hpY2ggbWVhbnMgLT4gZG9uJ3QgdXNlIENvbnN0ckRhdGEsIGJ1dCB1c2UgW11EYXRhIGRpcmVjdGx5XG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldENvbnN0ckluZGV4KHNpdGUpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIG93biB0eXBlIGFuZCBhZGRzIHRvIHNjb3BlXG5cdCAqIEBwYXJhbSB7VG9wU2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdGlmIChzY29wZS5pc1N0cmljdCgpICYmIHRoaXMuZmllbGRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0aHJvdyB0aGlzLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3QgMSBzdHJ1Y3QgZmllbGRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIGJlZm9yZSBzbyByZWN1cnNpdmUgdHlwZXMgYXJlIHBvc3NpYmxlXG5cdFx0c2NvcGUuc2V0KHRoaXMubmFtZSwgdGhpcy50eXBlKTtcblxuXHRcdHRoaXMuZXZhbEludGVybmFsKHNjb3BlKTtcblxuXHRcdC8vIGNoZWNrIHRoZSB0eXBlcyBvZiB0aGUgbWVtYmVyIG1ldGhvZHNcblx0XHR0aGlzLiNpbXBsLmV2YWwoc2NvcGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHtib29sZWFufSBkcnlSdW4gXG5cdCAqIEByZXR1cm5zIHtJbnN0YW5jZX1cblx0ICovXG5cdGdldEluc3RhbmNlTWVtYmVyKG5hbWUsIGRyeVJ1biA9IGZhbHNlKSB7XG5cdFx0aWYgKHN1cGVyLmhhc01lbWJlcihuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUsIGRyeVJ1bik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiNpbXBsLmdldEluc3RhbmNlTWVtYmVyKG5hbWUsIGRyeVJ1bik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1blxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHQvLyBvbmx5IHRoZSBpbXBsIGNhbiBjb250YWluIHBvdGVudGlhbGx5IGNvbnRhaW4gdHlwZSBtZW1iZXJzXG5cdFx0cmV0dXJuIHRoaXMuI2ltcGwuZ2V0VHlwZU1lbWJlcihuYW1lLCBkcnlSdW4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VWludDhBcnJheX0gbWFza1xuXHQgKi9cblx0aGlkZVVudXNlZChtYXNrKSB7XG5cdFx0c3VwZXIuaGlkZVVudXNlZChtYXNrKTtcblxuXHRcdHRoaXMuI2ltcGwuaGlkZVVudXNlZChtYXNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRGVmaW5pdGlvbnN9IG1hcFxuXHQgKi9cblx0dG9JUihtYXApIHtcblx0XHRpZiAodGhpcy5maWVsZHMubGVuZ3RoID09IDEpIHtcblx0XHRcdGxldCBmID0gdGhpcy5maWVsZHNbMF07XG5cdFx0XHRsZXQga2V5ID0gYCR7dGhpcy5wYXRofV9fJHtmLm5hbWUudG9TdHJpbmcoKX1gO1xuXHRcdFx0bGV0IGlzQm9vbCA9IGYudHlwZSBpbnN0YW5jZW9mIEJvb2xUeXBlO1xuXG5cdFx0XHRpZiAoaXNCb29sKSB7XG5cdFx0XHRcdG1hcC5zZXQoa2V5LCBuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhXCIsIGYuc2l0ZSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWFwLnNldChrZXksIG5ldyBJUihcIl9faGVsaW9zX19jb21tb25fX2lkZW50aXR5XCIsIGYuc2l0ZSkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdXBlci50b0lSKG1hcCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdHRoaXMuI2ltcGwudG9JUihtYXApO1xuXHR9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc3RhdGVtZW50XG4gKiAoYmFzaWNhbGx5IGp1c3QgYSBuYW1lZCBGdW5jTGl0ZXJhbEV4cHIpXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBGdW5jU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcblx0I2Z1bmNFeHByO1xuXHQjcmVjdXJzaXZlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHtGdW5jTGl0ZXJhbEV4cHJ9IGZ1bmNFeHByIFxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2l0ZSwgbmFtZSwgZnVuY0V4cHIpIHtcblx0XHRzdXBlcihzaXRlLCBuYW1lKTtcblx0XHR0aGlzLiNmdW5jRXhwciA9IGZ1bmNFeHByO1xuXHRcdHRoaXMuI3JlY3Vyc2l2ZSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtUeXBlW119XG5cdCAqL1xuXHRnZXQgYXJnVHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Z1bmNFeHByLmFyZ1R5cGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmdbXX1cblx0ICovXG5cdGdldCBhcmdUeXBlTmFtZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Z1bmNFeHByLmFyZ1R5cGVOYW1lcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHlwZVtdfVxuXHQgKi9cblx0Z2V0IHJldFR5cGVzKCkge1xuXHRcdHJldHVybiB0aGlzLiNmdW5jRXhwci5yZXRUeXBlcztcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgZnVuYyAke3RoaXMubmFtZS50b1N0cmluZygpfSR7dGhpcy4jZnVuY0V4cHIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyBhIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgZnVuYyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0ZXZhbEludGVybmFsKHNjb3BlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Z1bmNFeHByLmV2YWxJbnRlcm5hbChzY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIHR5cGUgb2YgYSBmdW50aW9uLlxuXHQgKiBTZXBhcmF0ZSBmcm9tIGV2YWxJbnRlcm5hbCBzbyB3ZSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gcmVjdXJzaXZlbHkgaW5zaWRlIGV2YWxJbnRlcm5hbFxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge0Z1bmNUeXBlfVxuXHQgKi9cblx0ZXZhbFR5cGUoc2NvcGUpIHtcblx0XHRyZXR1cm4gdGhpcy4jZnVuY0V4cHIuZXZhbFR5cGUoc2NvcGUpO1xuXHR9XG5cblx0dXNlKCkge1xuXHRcdGlmICghdGhpcy51c2VkKSB7XG5cdFx0XHRzdXBlci51c2UoKTtcblxuXHRcdFx0dGhpcy4jZnVuY0V4cHIudXNlKCk7XG5cdFx0fVxuXHR9XG5cblx0aXNSZWN1cnNpdmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3JlY3Vyc2l2ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgaW4gRnVuY1N0YXRlbWVudFNjb3BlIGFzIHNvb24gYXMgcmVjdXJzaW9uIGlzIGRldGVjdGVkXG5cdCAqL1xuXHRzZXRSZWN1cnNpdmUoKSB7XG5cdFx0dGhpcy4jcmVjdXJzaXZlID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHQvLyBhZGQgdG8gc2NvcGUgYmVmb3JlIGV2YWx1YXRpbmcsIHRvIGFsbG93IHJlY3Vyc2l2ZSBjYWxsc1xuXG5cdFx0bGV0IGZuVHlwZSA9IHRoaXMuZXZhbFR5cGUoc2NvcGUpO1xuXG5cdFx0bGV0IGZuVmFsID0gbmV3IEZ1bmNTdGF0ZW1lbnRJbnN0YW5jZShmblR5cGUsIHRoaXMpO1xuXG5cdFx0c2NvcGUuc2V0KHRoaXMubmFtZSwgZm5WYWwpO1xuXG5cdFx0dm9pZCB0aGlzLiNmdW5jRXhwci5ldmFsSW50ZXJuYWwobmV3IEZ1bmNTdGF0ZW1lbnRTY29wZShzY29wZSwgdGhpcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgSVIgb2YgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsTmFtZSAtIGZ1bGxOYW1lIGhhcyBiZWVuIHByZWZpeGVkIHdpdGggYSB0eXBlIHBhdGggZm9yIGltcGwgbWVtYmVyc1xuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSSW50ZXJuYWwoZnVsbE5hbWUgPSB0aGlzLnBhdGgpIHtcblx0XHRpZiAodGhpcy4jcmVjdXJzaXZlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jZnVuY0V4cHIudG9JUlJlY3Vyc2l2ZShmdWxsTmFtZSwgVEFCKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2Z1bmNFeHByLnRvSVIoVEFCKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkRlZmluaXRpb25zfSBtYXAgXG5cdCAqL1xuXHR0b0lSKG1hcCkge1xuXHRcdG1hcC5zZXQodGhpcy5wYXRoLCB0aGlzLnRvSVJJbnRlcm5hbCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N0YXRlbWVudH0gcyBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNNZXRob2Qocykge1xuXHRcdGlmIChzIGluc3RhbmNlb2YgRnVuY1N0YXRlbWVudCkge1xuXHRcdFx0cmV0dXJuIHMuI2Z1bmNFeHByLmlzTWV0aG9kKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBFbnVtTWVtYmVyIGRlZmludGlvbiBpcyBzaW1pbGFyIHRvIGEgc3RydWN0IGRlZmluaXRpb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEVudW1NZW1iZXIgZXh0ZW5kcyBEYXRhRGVmaW5pdGlvbiB7XG5cdC8qKiBAdHlwZSB7P0VudW1TdGF0ZW1lbnR9ICovXG5cdCNwYXJlbnQ7XG5cblx0LyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuXHQjY29uc3RySW5kZXg7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKiBAcGFyYW0ge0RhdGFGaWVsZFtdfSBmaWVsZHNcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWUsIGZpZWxkcykge1xuXHRcdHN1cGVyKG5hbWUuc2l0ZSwgbmFtZSwgZmllbGRzKTtcblx0XHR0aGlzLiNwYXJlbnQgPSBudWxsOyAvLyByZWdpc3RlcmVkIGxhdGVyXG5cdFx0dGhpcy4jY29uc3RySW5kZXggPSBudWxsO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAcGFyYW0ge0VudW1TdGF0ZW1lbnR9IHBhcmVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQqL1xuXHRyZWdpc3RlclBhcmVudChwYXJlbnQsIGkpIHtcblx0XHR0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG5cdFx0dGhpcy4jY29uc3RySW5kZXggPSBpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHR5cGUge0VudW1TdGF0ZW1lbnR9XG5cdCAqL1xuXHRnZXQgcGFyZW50KCkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInBhcmVudCBub3QgeWV0IHJlZ2lzdGVyZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLiNwYXJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBFbnVtTWVtYmVyU3RhdGVtZW50VHlwZSh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0aWYgKHRoaXMuI2NvbnN0ckluZGV4ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJJbmRleCBub3Qgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jY29uc3RySW5kZXg7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInBhcmVudCBzaG91bGQndmUgYmVlbiByZWdpc3RlcmVkXCIpO1xuXHRcdH1cblxuXHRcdHN1cGVyLmV2YWxJbnRlcm5hbChzY29wZSk7IC8vIHRoZSBpbnRlcm5hbGx5IGNyZWF0ZWQgdHlwZSBpc24ndCBiZSBhZGRlZCB0byB0aGUgc2NvcGUuICh0aGUgcGFyZW50IGVudW0gdHlwZSB0YWtlcyBjYXJlIG9mIHRoYXQpXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1biBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHRpZiAodGhpcy5oYXNGaWVsZChuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHN1cGVyLmdldEluc3RhbmNlTWVtYmVyKG5hbWUsIGRyeVJ1bik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGFyZW50IHNob3VsZCd2ZSBiZWVuIHJlZ2lzdGVyZWRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4jcGFyZW50LmdldEluc3RhbmNlTWVtYmVyKG5hbWUsIGRyeVJ1bik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHBhdGgoKSB7XG5cdFx0cmV0dXJuIGAke3RoaXMucGFyZW50LnBhdGh9X18ke3RoaXMubmFtZS50b1N0cmluZygpfWA7XG5cdH1cbn1cblxuLyoqXG4gKiBFbnVtIHN0YXRlbWVudCwgY29udGFpbmluZyBhdCBsZWFzdCBvbmUgbWVtYmVyXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBFbnVtU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcblx0I21lbWJlcnM7XG5cdCNpbXBsO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZSBcblx0ICogQHBhcmFtIHtFbnVtTWVtYmVyW119IG1lbWJlcnMgXG5cdCAqIEBwYXJhbSB7SW1wbERlZmluaXRpb259IGltcGxcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG5hbWUsIG1lbWJlcnMsIGltcGwpIHtcblx0XHRzdXBlcihzaXRlLCBuYW1lKTtcblx0XHR0aGlzLiNtZW1iZXJzID0gbWVtYmVycztcblx0XHR0aGlzLiNpbXBsID0gaW1wbDtcblx0XHRcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI21lbWJlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuI21lbWJlcnNbaV0ucmVnaXN0ZXJQYXJlbnQodGhpcywgaSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHR5cGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBFbnVtU3RhdGVtZW50VHlwZSh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGluZGV4IG9mIGVudW0gbWVtYmVyLlxuXHQgKiBSZXR1cm5zIC0xIGlmIG5vdCBmb3VuZFxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHQvLyByZXR1cm5zIGFuIGluZGV4XG5cdGZpbmRFbnVtTWVtYmVyKG5hbWUpIHtcblx0XHRsZXQgZm91bmQgPSAtMTtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgbWVtYmVyIG9mIHRoaXMuI21lbWJlcnMpIHtcblx0XHRcdGlmIChtZW1iZXIubmFtZS50b1N0cmluZygpID09IG5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRmb3VuZCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBmb3VuZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpXG5cdCAqIEByZXR1cm5zIHtFbnVtTWVtYmVyfVxuXHQgKi9cblx0Z2V0RW51bU1lbWJlcihzaXRlLCBpKSB7XG5cdFx0cmV0dXJuIGFzc2VydERlZmluZWQodGhpcy4jbWVtYmVyc1tpXSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aGFzRW51bU1lbWJlcihuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmluZEVudW1NZW1iZXIobmFtZSkgIT0gLTE7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYGVudW0gJHt0aGlzLm5hbWUudG9TdHJpbmcoKX0geyR7dGhpcy4jbWVtYmVycy5tYXAobSA9PiBtLnRvU3RyaW5nKCkpLmpvaW4oXCIsIFwiKX19YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1Njb3BlfSBzY29wZSBcblx0ICovXG5cdGV2YWwoc2NvcGUpIHtcblx0XHRzY29wZS5zZXQodGhpcy5uYW1lLCB0aGlzLnR5cGUpO1xuXG5cdFx0dGhpcy4jbWVtYmVycy5mb3JFYWNoKG0gPT4ge1xuXHRcdFx0bS5ldmFsKHNjb3BlKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuI2ltcGwuZXZhbChzY29wZSk7XG5cdH1cblxuXHR1c2UoKSB7XG5cdFx0aWYgKCF0aGlzLnVzZWQpIHtcblx0XHRcdHN1cGVyLnVzZSgpO1xuXG5cdFx0XHRmb3IgKGxldCBtIG9mIHRoaXMuI21lbWJlcnMpIHtcblx0XHRcdFx0bS51c2UoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0bkZpZWxkcyhzaXRlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoXCJlbnVtIGRvZXNuJ3QgaGF2ZSBmaWVsZHNcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpXG5cdCAqIEByZXR1cm5zIHtUeXBlfVxuXHQgKi9cblx0Z2V0RmllbGRUeXBlKHNpdGUsIGkpIHtcblx0XHR0aHJvdyBzaXRlLnR5cGVFcnJvcihcImVudW0gZG9lc24ndCBoYXZlIGZpZWxkc1wiKTtcblx0fVxuXG5cdC8qKmZcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGdldEZpZWxkSW5kZXgoc2l0ZSwgbmFtZSkge1xuXHRcdHRocm93IHNpdGUudHlwZUVycm9yKFwiZW51bSBkb2Vzbid0IGhhdmUgZmllbGRzXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0RmllbGROYW1lKGkpIHtcblx0XHR0aHJvdyBTaXRlLmR1bW15KCkudHlwZUVycm9yKFwiZW51bSBkb2Vzbid0IGhhdmUgZmllbGRzXCIpO1xuXHR9XG5cdFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V29yZH0gbmFtZSBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNGaWVsZChuYW1lKSB7XG4gICAgICAgIHRocm93IG5hbWUuc2l0ZS50eXBlRXJyb3IoXCJlbnVtIGRvZXNuJ3QgaGF2ZSBmaWVsZHNcIik7XG4gICAgfVxuXG5cdC8qKiBcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1biBcblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHRpZiAodGhpcy5oYXNFbnVtTWVtYmVyKG5hbWUpKSB7XG5cdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKGAnJHtuYW1lLnRvU3RyaW5nKCl9JyBpcyBhbiBlbnVtIG9mICcke3RoaXMudG9TdHJpbmd9JyAoZGlkIHlvdSBtZWFuICcke3RoaXMudG9TdHJpbmcoKX06OiR7bmFtZS50b1N0cmluZygpfSc/KWApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jaW1wbC5nZXRJbnN0YW5jZU1lbWJlcihuYW1lLCBkcnlSdW4pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJ5UnVuXG5cdCAqIEByZXR1cm5zIHtFdmFsRW50aXR5fVxuXHQgKi9cblx0Z2V0VHlwZU1lbWJlcihuYW1lLCBkcnlSdW4gPSBmYWxzZSkge1xuXHRcdGxldCBpID0gdGhpcy5maW5kRW51bU1lbWJlcihuYW1lKTtcblx0XHRpZiAoaSA9PSAtMSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2ltcGwuZ2V0VHlwZU1lbWJlcihuYW1lLCBkcnlSdW4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jbWVtYmVyc1tpXS50eXBlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXRDb25zdHJJbmRleChzaXRlKSB7XG5cdFx0dGhyb3cgc2l0ZS50eXBlRXJyb3IoXCJjYW4ndCBjb25zdHJ1Y3QgYW4gZW51bSBkaXJlY3RseSAoY2FzdCB0byBhIGNvbmNyZXRlIHR5cGUgZmlyc3QpXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdG5FbnVtTWVtYmVycyhzaXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI21lbWJlcnMubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VWludDhBcnJheX0gbWFza1xuXHQgKi9cblx0aGlkZVVudXNlZChtYXNrKSB7XG5cdFx0c3VwZXIuaGlkZVVudXNlZChtYXNrKTtcblxuXHRcdHRoaXMuI2ltcGwuaGlkZVVudXNlZChtYXNrKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRGVmaW5pdGlvbnN9IG1hcCBcblx0ICovXG5cdHRvSVIobWFwKSB7XG5cdFx0Zm9yIChsZXQgbWVtYmVyIG9mIHRoaXMuI21lbWJlcnMpIHtcblx0XHRcdG1lbWJlci50b0lSKG1hcCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4jaW1wbC50b0lSKG1hcCk7XG5cdH1cbn1cblxuLyoqXG4gKiBJbXBsIHN0YXRlbWVudHMsIHdoaWNoIGFkZCBmdW5jdGlvbnMgYW5kIGNvbnN0YW50cyB0byByZWdpc3RyeSBvZiB1c2VyIHR5cGVzIChTdHJ1Y3QsIEVudW0gTWVtYmVyIGFuZCBFbnVtcylcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIEltcGxEZWZpbml0aW9uIHtcblx0I3NlbGZUeXBlRXhwcjtcblx0I3N0YXRlbWVudHM7XG5cblx0LyoqIEB0eXBlIHtJbnN0YW5jZVtdfSAtIGZpbGxlZCBkdXJpbmcgZXZhbCB0byBhbGxvdyBzYW1lIHJlY3Vyc2l2ZSBiZWhhdmlvdXIgYXMgZm9yIHRvcC1sZXZlbCBzdGF0ZW1lbnRzICovXG5cdCNzdGF0ZW1lbnRWYWx1ZXM7XG5cblx0LyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cblx0I3VzZWRTdGF0ZW1lbnRzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R5cGVSZWZFeHByfSBzZWxmVHlwZUV4cHI7XG5cdCAqIEBwYXJhbSB7KEZ1bmNTdGF0ZW1lbnQgfCBDb25zdFN0YXRlbWVudClbXX0gc3RhdGVtZW50cyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNlbGZUeXBlRXhwciwgc3RhdGVtZW50cykge1xuXHRcdHRoaXMuI3NlbGZUeXBlRXhwciA9IHNlbGZUeXBlRXhwcjtcblx0XHR0aGlzLiNzdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcblx0XHR0aGlzLiNzdGF0ZW1lbnRWYWx1ZXMgPSBbXTtcblx0XHR0aGlzLiN1c2VkU3RhdGVtZW50cyA9IG5ldyBTZXQoKTsgLy8gdXNlZCBmb3IgY29kZS1nZW5lcmF0aW9uLCBidXQgbm90IGZvciBjbGVhblNvdXJjZSBmaWx0ZXJpbmdcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgJHt0aGlzLiNzdGF0ZW1lbnRzLm1hcChzID0+IHMudG9TdHJpbmcoKSkuam9pbihcIlxcblwiKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0ZXZhbChzY29wZSkge1xuXHRcdGxldCBzZWxmVHlwZSA9IHRoaXMuI3NlbGZUeXBlRXhwci5ldmFsKHNjb3BlKTtcblxuXHRcdGlmICghKHNlbGZUeXBlIGluc3RhbmNlb2YgU3RhdGVtZW50VHlwZSkpIHtcblx0XHRcdHRocm93IHRoaXMuI3NlbGZUeXBlRXhwci5yZWZlcmVuY2VFcnJvcihcIm5vdCBhIHVzZXItdHlwZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgcyBvZiB0aGlzLiNzdGF0ZW1lbnRzKSB7XG5cdFx0XHRcdGlmIChzIGluc3RhbmNlb2YgRnVuY1N0YXRlbWVudCkge1xuXHRcdFx0XHRcdC8vIG92ZXJyaWRlIGV2YWwoKSBvZiBGdW5jU3RhdGVtZW50IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0aGUgZnVuY3Rpb24gdG8gYWRkIGl0c2VsZiB0byB0aGUgc2NvcGUgZGlyZWN0bHkuXG5cdFx0XHRcdFx0bGV0IHYgPSBuZXcgRnVuY1N0YXRlbWVudEluc3RhbmNlKHMuZXZhbFR5cGUoc2NvcGUpLCBzKTtcblxuXHRcdFx0XHRcdHRoaXMuI3N0YXRlbWVudFZhbHVlcy5wdXNoKHYpOyAvLyBhZGQgZnVuYyB0eXBlIHRvICNzdGF0ZW1lbnRWYWx1ZXMgaW4gb3JkZXIgdG8gYWxsb3cgcmVjdXJzaXZlIGNhbGxzIChhY3RzIGFzIGEgc3BlY2lhbCBzY29wZSlcblxuXHRcdFx0XHRcdC8vIGV2YWwgaW50ZXJuYWwgZG9lc24ndCBhZGQgYW55dGhpbmcgdG8gc2NvcGVcblx0XHRcdFx0XHR2b2lkIHMuZXZhbEludGVybmFsKG5ldyBGdW5jU3RhdGVtZW50U2NvcGUoc2NvcGUsIHMpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBldmFsIGludGVybmFsIGRvZXNuJ3QgYWRkIGFueXRoaW5nIHRvIHNjb3BlXG5cdFx0XHRcdFx0dGhpcy4jc3RhdGVtZW50VmFsdWVzLnB1c2gocy5ldmFsSW50ZXJuYWwoc2NvcGUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWVcblx0ICogQHBhcmFtIHtib29sZWFufSBkcnlSdW5cblx0ICogQHJldHVybnMge0luc3RhbmNlfVxuXHQgKi9cblx0Z2V0SW5zdGFuY2VNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJzZXJpYWxpemVcIjpcblx0XHRcdFx0dGhpcy4jdXNlZFN0YXRlbWVudHMuYWRkKG5hbWUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFtdLCBuZXcgQnl0ZUFycmF5VHlwZSgpKSk7XG5cdFx0XHRcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIGxvb3AgdGhlIGNvbnRhaW5lZCBzdGF0ZW1lbnRzIHRvIGZpbmQgb25lIHdpdGggbmFtZSAnbmFtZSdcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNzdGF0ZW1lbnRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRsZXQgcyA9IHRoaXMuI3N0YXRlbWVudHNbaV07XG5cblx0XHRcdFx0XHRpZiAobmFtZS50b1N0cmluZygpID09IHMubmFtZS50b1N0cmluZygpKSB7XG5cdFx0XHRcdFx0XHRpZiAoRnVuY1N0YXRlbWVudC5pc01ldGhvZChzKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWRyeVJ1bikge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuI3VzZWRTdGF0ZW1lbnRzLmFkZChuYW1lLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuI3N0YXRlbWVudFZhbHVlc1tpXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoYCcke3RoaXMuI3NlbGZUeXBlRXhwci50b1N0cmluZygpfS4ke25hbWUudG9TdHJpbmcoKX0nIGlzbid0IGEgbWV0aG9kIChkaWQgeW91IG1lYW4gJyR7dGhpcy4jc2VsZlR5cGVFeHByLnRvU3RyaW5nKCl9Ojoke25hbWUudG9TdHJpbmcoKX0nPylgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aHJvdyBuYW1lLnJlZmVyZW5jZUVycm9yKGAnJHt0aGlzLiNzZWxmVHlwZUV4cHIudG9TdHJpbmcoKX0uJHtuYW1lLnRvU3RyaW5nKCl9JyB1bmRlZmluZWRgKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJ5UnVuIFxuXHQgKiBAcmV0dXJucyB7RXZhbEVudGl0eX1cblx0ICovXG5cdGdldFR5cGVNZW1iZXIobmFtZSwgZHJ5UnVuID0gZmFsc2UpIHtcblx0XHRzd2l0Y2ggKG5hbWUudmFsdWUpIHtcblx0XHRcdGNhc2UgXCJfX2VxXCI6XG5cdFx0XHRjYXNlIFwiX19uZXFcIjpcblx0XHRcdFx0dGhpcy4jdXNlZFN0YXRlbWVudHMuYWRkKG5hbWUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdHJldHVybiBJbnN0YW5jZS5uZXcobmV3IEZ1bmNUeXBlKFt0aGlzLiNzZWxmVHlwZUV4cHIudHlwZSwgdGhpcy4jc2VsZlR5cGVFeHByLnR5cGVdLCBuZXcgQm9vbFR5cGUoKSkpO1xuXHRcdFx0Y2FzZSBcImZyb21fZGF0YVwiOlxuXHRcdFx0XHR0aGlzLiN1c2VkU3RhdGVtZW50cy5hZGQobmFtZS50b1N0cmluZygpKTtcblx0XHRcdFx0cmV0dXJuIEluc3RhbmNlLm5ldyhuZXcgRnVuY1R5cGUoW25ldyBSYXdEYXRhVHlwZSgpXSwgdGhpcy4jc2VsZlR5cGVFeHByLnR5cGUpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jc3RhdGVtZW50VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IHMgPSB0aGlzLiNzdGF0ZW1lbnRzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKG5hbWUudG9TdHJpbmcoKSA9PSBzLm5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRcdFx0aWYgKEZ1bmNTdGF0ZW1lbnQuaXNNZXRob2QocykpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7dGhpcy4jc2VsZlR5cGVFeHByLnRvU3RyaW5nKCl9Ojoke25hbWUudmFsdWV9JyBpcyBhIG1ldGhvZCAoZGlkIHlvdSBtZWFuICcke3RoaXMuI3NlbGZUeXBlRXhwci50b1N0cmluZygpfS4ke25hbWUudG9TdHJpbmcoKX0nPylgKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFkcnlSdW4pIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiN1c2VkU3RhdGVtZW50cy5hZGQobmFtZS50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLiNzdGF0ZW1lbnRWYWx1ZXNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgbmFtZS5yZWZlcmVuY2VFcnJvcihgJyR7dGhpcy4jc2VsZlR5cGVFeHByLnRvU3RyaW5nKCl9Ojoke25hbWUudG9TdHJpbmcoKX0nIHVuZGVmaW5lZGApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1hc2tcblx0ICovXG5cdGhpZGVVbnVzZWQobWFzaykge1xuXHRcdGZvciAobGV0IHMgb2YgdGhpcy4jc3RhdGVtZW50cykge1xuXHRcdFx0aWYgKCFzLnVzZWQpIHtcblx0XHRcdFx0bGV0IHNpdGUgPSBzLnNpdGU7XG5cblx0XHRcdFx0aWYgKHNpdGUuZW5kU2l0ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdG1hc2suZmlsbCgwLCBzaXRlLnN0YXJ0UG9zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXNrLmZpbGwoMCwgc2l0ZS5zdGFydFBvcywgc2l0ZS5lbmRTaXRlLnN0YXJ0UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIElSIG9mIGFsbCBpbXBsIG1lbWJlcnNcblx0ICogQHBhcmFtIHtJUkRlZmluaXRpb25zfSBtYXAgXG5cdCAqL1xuXHR0b0lSKG1hcCkge1xuXHRcdGxldCBwYXRoID0gdGhpcy4jc2VsZlR5cGVFeHByLnBhdGg7XG5cdFx0bGV0IHNpdGUgPSB0aGlzLiNzZWxmVHlwZUV4cHIuc2l0ZTtcblxuXHRcdGlmICh0aGlzLiN1c2VkU3RhdGVtZW50cy5oYXMoXCJfX2VxXCIpKSB7XG5cdFx0XHRtYXAuc2V0KGAke3BhdGh9X19fX2VxYCwgbmV3IElSKFwiX19oZWxpb3NfX2NvbW1vbl9fX19lcVwiLCBzaXRlKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3VzZWRTdGF0ZW1lbnRzLmhhcyhcIl9fbmVxXCIpKSB7XG5cdFx0XHRtYXAuc2V0KGAke3BhdGh9X19fX25lcWAsIG5ldyBJUihcIl9faGVsaW9zX19jb21tb25fX19fbmVxXCIsIHNpdGUpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jdXNlZFN0YXRlbWVudHMuaGFzKFwic2VyaWFsaXplXCIpKSB7XG5cdFx0XHRtYXAuc2V0KGAke3BhdGh9X19zZXJpYWxpemVgLCBuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX19zZXJpYWxpemVcIiwgc2l0ZSkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiN1c2VkU3RhdGVtZW50cy5oYXMoXCJmcm9tX2RhdGFcIikpIHtcblx0XHRcdG1hcC5zZXQoYCR7cGF0aH1fX2Zyb21fZGF0YWAsIG5ldyBJUihcIl9faGVsaW9zX19jb21tb25fX2lkZW50aXR5XCIsIHNpdGUpKTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBzIG9mIHRoaXMuI3N0YXRlbWVudHMpIHtcblx0XHRcdGxldCBrZXkgPSBgJHtwYXRofV9fJHtzLm5hbWUudG9TdHJpbmcoKX1gXG5cdFx0XHRpZiAocyBpbnN0YW5jZW9mIEZ1bmNTdGF0ZW1lbnQpIHtcblx0XHRcdFx0bWFwLnNldChrZXksIHMudG9JUkludGVybmFsKGtleSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWFwLnNldChrZXksIHMudG9JUkludGVybmFsKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMTg6IEhlbGlvcyBBU1QgYnVpbGRpbmdcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY29uc3QgQVVUT01BVElDX01FVEhPRFMgPSBbXG5cdFwiX19lcVwiLFxuXHRcIl9fbmVxXCIsXG5cdFwiY29weVwiLFxuXHRcImZyb21fZGF0YVwiLFxuXHRcInNlcmlhbGl6ZVwiXG5dO1xuXG4vKipcbiAqIEB0eXBlIHtudWxsIHwgKChwYXRoOiBTdHJpbmdMaXRlcmFsKSA9PiAoc3RyaW5nIHwgbnVsbCkpfVxuICovXG5sZXQgaW1wb3J0UGF0aFRyYW5zbGF0b3IgPSBudWxsXG5cbi8qKlxuICogVXNlZCBieSBWU0NvZGUgcGx1Z2luXG4gKiBAcGFyYW0geyhwYXRoOiBTdHJpbmdMaXRlcmFsKSA9PiAoc3RyaW5nIHwgbnVsbCl9IGZuIFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SW1wb3J0UGF0aFRyYW5zbGF0b3IoZm4pIHtcblx0aW1wb3J0UGF0aFRyYW5zbGF0b3IgPSBmblxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcmV0dXJucyB7U3RhdGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUHJvZ3JhbVN0YXRlbWVudHModHMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtTdGF0ZW1lbnRbXX1cblx0ICovXG5cdGxldCBzdGF0ZW1lbnRzID0gW107XG5cblx0d2hpbGUgKHRzLmxlbmd0aCAhPSAwKSB7XG5cdFx0Y29uc3QgdCA9IHRzLnNoaWZ0KCk/LmFzc2VydFdvcmQoKTtcblxuXHRcdGlmICghdCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga3cgPSB0LnZhbHVlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1N0YXRlbWVudCB8IChTdGF0ZW1lbnQgfCBudWxsKVtdIHwgbnVsbH1cblx0XHQgKi9cblx0XHRsZXQgcyA9IG51bGw7XG5cblx0XHRpZiAoa3cgPT0gXCJjb25zdFwiKSB7XG5cdFx0XHRzID0gYnVpbGRDb25zdFN0YXRlbWVudCh0LnNpdGUsIHRzKTtcblx0XHR9IGVsc2UgaWYgKGt3ID09IFwic3RydWN0XCIpIHtcblx0XHRcdHMgPSBidWlsZFN0cnVjdFN0YXRlbWVudCh0LnNpdGUsIHRzKTtcblx0XHR9IGVsc2UgaWYgKGt3ID09IFwiZnVuY1wiKSB7XG5cdFx0XHRzID0gYnVpbGRGdW5jU3RhdGVtZW50KHQuc2l0ZSwgdHMpO1xuXHRcdH0gZWxzZSBpZiAoa3cgPT0gXCJlbnVtXCIpIHtcblx0XHRcdHMgPSBidWlsZEVudW1TdGF0ZW1lbnQodC5zaXRlLCB0cyk7XG5cdFx0fSBlbHNlIGlmIChrdyA9PSBcImltcG9ydFwiKSB7XG5cdFx0XHRzID0gYnVpbGRJbXBvcnRTdGF0ZW1lbnRzKHQuc2l0ZSwgdHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LnN5bnRheEVycm9yKGBpbnZhbGlkIHRvcC1sZXZlbCBrZXl3b3JkICcke2t3fSdgKTtcblx0XHR9XG5cblx0XHRpZiAocykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocykpIHtcblx0XHRcdFx0Zm9yIChsZXQgc18gb2Ygcykge1xuXHRcdFx0XHRcdGlmIChzXykge1xuXHRcdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKHNfKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlbWVudHMucHVzaChzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RhdGVtZW50cztcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0c1xuICogQHBhcmFtIHtudWxsIHwgbnVtYmVyfSBleHBlY3RlZFB1cnBvc2VcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBXb3JkXSB8IG51bGx9IC0gW3B1cnBvc2UsIG5hbWVdIChTY3JpcHRQdXJwb3NlIGlzIGFuIGludGVnZXIpXG4gKiBAcGFja2FnZVxuICovXG5mdW5jdGlvbiBidWlsZFNjcmlwdFB1cnBvc2UodHMsIGV4cGVjdGVkUHVycG9zZSA9IG51bGwpIHtcblx0Ly8gbmVlZCBhdCBsZWFzdCAyIHRva2VucyBmb3IgdGhlIHNjcmlwdCBwdXJwb3NlXG5cdGlmICh0cy5sZW5ndGggPCAyKSB7XG5cblx0XHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdFNpdGUuZHVtbXkoKS5zeW50YXhFcnJvcihcImludmFsaWQgc2NyaXB0IHB1cnBvc2Ugc3ludGF4XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0c1swXS5zeW50YXhFcnJvcihcImludmFsaWQgc2NyaXB0IHB1cnBvc2Ugc3ludGF4XCIpO1xuXHRcdFx0dHMuc3BsaWNlKDApO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgcHVycG9zZVdvcmQgPSB0cy5zaGlmdCgpPy5hc3NlcnRXb3JkKCk7XG5cblx0aWYgKCFwdXJwb3NlV29yZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXIgfCBudWxsfVxuXHQgKi9cblx0bGV0IHB1cnBvc2UgPSBudWxsO1xuXG5cdGlmIChwdXJwb3NlV29yZC5pc1dvcmQoXCJzcGVuZGluZ1wiKSkge1xuXHRcdHB1cnBvc2UgPSBTY3JpcHRQdXJwb3NlLlNwZW5kaW5nO1xuXHR9IGVsc2UgaWYgKHB1cnBvc2VXb3JkLmlzV29yZChcIm1pbnRpbmdcIikpIHtcblx0XHRwdXJwb3NlID0gU2NyaXB0UHVycG9zZS5NaW50aW5nO1xuXHR9IGVsc2UgaWYgKHB1cnBvc2VXb3JkLmlzV29yZChcInN0YWtpbmdcIikpIHtcblx0XHRwdXJwb3NlID0gU2NyaXB0UHVycG9zZS5TdGFraW5nO1xuXHR9IGVsc2UgaWYgKHB1cnBvc2VXb3JkLmlzV29yZChcInRlc3RpbmdcIikpIHsgLy8gJ3Rlc3QnIGlzIG5vdCByZXNlcnZlZCBhcyBhIGtleXdvcmQgdGhvdWdoXG5cdFx0cHVycG9zZSA9IFNjcmlwdFB1cnBvc2UuVGVzdGluZztcblx0fSBlbHNlIGlmIChwdXJwb3NlV29yZC5pc1dvcmQoXCJtb2R1bGVcIikpIHtcblx0XHRwdXJwb3NlID0gU2NyaXB0UHVycG9zZS5Nb2R1bGU7XG5cdH0gZWxzZSBpZiAocHVycG9zZVdvcmQuaXNLZXl3b3JkKCkpIHtcblx0XHRwdXJwb3NlV29yZC5zeW50YXhFcnJvcihgc2NyaXB0IHB1cnBvc2UgbWlzc2luZ2ApO1xuXG5cdFx0dHMudW5zaGlmdChwdXJwb3NlV29yZCk7XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRwdXJwb3NlV29yZC5zeW50YXhFcnJvcihgdW5yZWNvZ25pemVkIHNjcmlwdCBwdXJwb3NlICcke3B1cnBvc2VXb3JkLnZhbHVlfScgKGV4cGVjdGVkICd0ZXN0aW5nJywgJ3NwZW5kaW5nJywgJ3N0YWtpbmcnLCAnbWludGluZycgb3IgJ21vZHVsZScpYCk7XG5cdFx0cHVycG9zZSA9IC0xO1xuXHR9XG5cblx0aWYgKGV4cGVjdGVkUHVycG9zZSAhPT0gbnVsbCAmJiBwdXJwb3NlICE9PSBudWxsKSB7XG5cdFx0aWYgKGV4cGVjdGVkUHVycG9zZSAhPSBwdXJwb3NlKSB7XG5cdFx0XHRwdXJwb3NlV29yZC5zeW50YXhFcnJvcihgZXhwZWN0ZWQgJyR7Z2V0UHVycG9zZU5hbWUocHVycG9zZSl9JyBzY3JpcHQgcHVycG9zZWApO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IG5hbWUgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBwdXJwb3NlV29yZC5zaXRlKT8uYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0aWYgKCFuYW1lKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAobmFtZS52YWx1ZSA9PT0gXCJtYWluXCIpIHtcblx0XHRuYW1lLnN5bnRheEVycm9yKGAke3B1cnBvc2VXb3JkLnZhbHVlfSBzY3JpcHQgY2FuJ3QgYmUgbmFtZWQgJ21haW4nYCk7XG5cdH1cblxuXHRyZXR1cm4gW3B1cnBvc2UsIG5hbWVdO1xufVxuXG4vKipcbiAqIEFsc28gdXNlZCBieSBWU0NvZGUgcGx1Z2luXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBleHBlY3RlZFB1cnBvc2UgXG4gKiBAcmV0dXJucyB7W251bWJlciB8IG51bGwsIFdvcmQgfCBudWxsLCBTdGF0ZW1lbnRbXSwgbnVtYmVyXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2NyaXB0KHRzLCBleHBlY3RlZFB1cnBvc2UgPSBudWxsKSB7XG5cdGNvbnN0IGZpcnN0ID0gdHNbMF07XG5cblx0Y29uc3QgcHVycG9zZU5hbWUgPSBidWlsZFNjcmlwdFB1cnBvc2UodHMsIGV4cGVjdGVkUHVycG9zZSk7XG5cblx0Y29uc3Qgc3RhdGVtZW50cyA9IGJ1aWxkUHJvZ3JhbVN0YXRlbWVudHModHMpO1xuXG5cdGxldCBtYWluSWR4ID0gLTE7XG5cblx0Y29uc3QgW3B1cnBvc2UsIG5hbWVdID0gcHVycG9zZU5hbWUgIT09IG51bGwgPyBwdXJwb3NlTmFtZSA6IFtudWxsLCBudWxsXTtcblxuXHRpZiAocHVycG9zZSAhPSBTY3JpcHRQdXJwb3NlLk1vZHVsZSkge1xuXHRcdG1haW5JZHggPSBzdGF0ZW1lbnRzLmZpbmRJbmRleChzID0+IHMubmFtZS52YWx1ZSA9PT0gXCJtYWluXCIpO1xuXG5cdFx0aWYgKG1haW5JZHggPT0gLTEpIHtcblx0XHRcdGlmIChuYW1lICE9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0LnNpdGUubWVyZ2UobmFtZS5zaXRlKS5zeW50YXhFcnJvcihcImVudHJ5cG9pbnQgJ21haW4nIG5vdCBmb3VuZFwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcnN0LnNpdGUuc3ludGF4RXJyb3IoXCJlbnRyeXBvaW50ICdtYWluJyBub3QgZm91bmRcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtwdXJwb3NlLCBuYW1lLCBzdGF0ZW1lbnRzLCBtYWluSWR4XTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgSGVsaW9zIHF1aWNrbHkgdG8gZXh0cmFjdCB0aGUgc2NyaXB0IHB1cnBvc2UgaGVhZGVyLlxuICogUmV0dXJucyBudWxsIGlmIGhlYWRlciBpcyBtaXNzaW5nIG9yIGluY29ycmVjdGx5IGZvcm1lZCAoaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcilcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdTcmMgXG4gKiBAcmV0dXJucyB7P1tzdHJpbmcsIHN0cmluZ119IC0gW3B1cnBvc2UsIG5hbWVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2NyaXB0UHVycG9zZUFuZE5hbWUocmF3U3JjKSB7XG5cdHRyeSB7XG5cdFx0bGV0IHNyYyA9IG5ldyBTb3VyY2UocmF3U3JjKTtcblxuXHRcdGxldCB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHNyYyk7XG5cblx0XHRsZXQgZ2VuID0gdG9rZW5pemVyLnN0cmVhbVRva2VucygpO1xuXG5cdFx0Ly8gRG9uJ3QgcGFyc2UgdGhlIHdob2xlIHNjcmlwdCwganVzdCAnZWF0JyAyIHRva2VuczogYDxwdXJwb3NlPiA8bmFtZT5gXG5cdFx0bGV0IHRzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdGxldCB5aWVsZGVkID0gZ2VuLm5leHQoKTtcblx0XHRcdGlmICh5aWVsZGVkLmRvbmUpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRzLnB1c2goeWllbGRlZC52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcHVycG9zZU5hbWUgPSBidWlsZFNjcmlwdFB1cnBvc2UodHMpO1xuXG5cdFx0c3JjLnRocm93RXJyb3JzKCk7XG5cblx0XHRpZiAocHVycG9zZU5hbWUgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IFtwdXJwb3NlLCBuYW1lXSA9IHB1cnBvc2VOYW1lO1xuXG5cdFx0XHRyZXR1cm4gW2dldFB1cnBvc2VOYW1lKHB1cnBvc2UpLCBuYW1lLnZhbHVlXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTsgLy8gc2hvdWxkJ3ZlIGJlZW4gY2F1Z2h0IGFib3ZlIGJ5IGNhbGxpbmcgc3JjLnRocm93RXJyb3JzKClcblx0XHR9XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoIShlIGluc3RhbmNlb2YgVXNlckVycm9yKSkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7Q29uc3RTdGF0ZW1lbnQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZENvbnN0U3RhdGVtZW50KHNpdGUsIHRzKSB7XG5cdGlmICh0cy5sZW5ndGggPT0gMCkge1xuXHRcdHNpdGUuc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheCAoZXhwZWN0ZWQgbmFtZSBhZnRlciAnY29uc3QnKVwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IG5hbWUgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBzaXRlKT8uYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0aWYgKCFuYW1lKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRsZXQgdHlwZUV4cHIgPSBudWxsO1xuXG5cdGlmICh0cy5sZW5ndGggPiAwICYmIHRzWzBdLmlzU3ltYm9sKFwiOlwiKSkge1xuXHRcdGNvbnN0IGNvbG9uID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKTtcblxuXHRcdGNvbnN0IGVxdWFsc1BvcyA9IFN5bWJvbFRva2VuLmZpbmQodHMsIFwiPVwiKTtcblxuXHRcdGlmIChlcXVhbHNQb3MgPT0gLTEpIHtcblx0XHRcdHRzLnVuc2hpZnQoY29sb24pO1xuXHRcdFx0c2l0ZS5tZXJnZSh0c1t0cy5sZW5ndGgtMV0uc2l0ZSkuc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheCAoZXhwZWN0ZWQgJz0nIGFmdGVyICdjb25zdCcpXCIpO1xuXHRcdFx0dHMuc3BsaWNlKDApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIGlmIChlcXVhbHNQb3MgPT0gMCkge1xuXHRcdFx0Y29sb24uc2l0ZS5tZXJnZSh0c1swXS5zaXRlKS5zeW50YXhFcnJvcihcImV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvbiBiZXR3ZWVuICc6JyBhbmQgJz0nXCIpO1xuXHRcdFx0dHMuc2hpZnQoKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihjb2xvbi5zaXRlLCB0cy5zcGxpY2UoMCwgZXF1YWxzUG9zKSk7XG5cdH1cblxuXHRjb25zdCBtYXliZUVxdWFscyA9IHRzLnNoaWZ0KCk7XG5cblx0aWYgKG1heWJlRXF1YWxzID09PSB1bmRlZmluZWQpIHtcblx0XHRzaXRlLm1lcmdlKG5hbWUuc2l0ZSkuc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnPScgYWZ0ZXIgJ2NvbnN0J1wiKTtcblx0XHR0cy5zcGxpY2UoMCk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoIW1heWJlRXF1YWxzLmlzU3ltYm9sKFwiPVwiKSkge1xuXHRcdHNpdGUubWVyZ2UobWF5YmVFcXVhbHMuc2l0ZSkuc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnPScgYWZ0ZXIgJ2NvbnN0J1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBlcXVhbHMgPSBtYXliZUVxdWFscy5hc3NlcnRTeW1ib2woXCI9XCIpO1xuXG5cdFx0aWYgKCFlcXVhbHMpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IG5leHRTdGF0ZW1lbnRQb3MgPSBXb3JkLmZpbmQodHMsIFtcImNvbnN0XCIsIFwiZnVuY1wiLCBcInN0cnVjdFwiLCBcImVudW1cIiwgXCJpbXBvcnRcIl0pO1xuXG5cdFx0Y29uc3QgdHNWYWx1ZSA9IG5leHRTdGF0ZW1lbnRQb3MgPT0gLTEgPyB0cy5zcGxpY2UoMCkgOiB0cy5zcGxpY2UoMCwgbmV4dFN0YXRlbWVudFBvcyk7XG5cblx0XHRpZiAodHNWYWx1ZS5sZW5ndGggPT0gMCkge1xuXHRcdFx0ZXF1YWxzLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciAnPSdcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZW5kU2l0ZSA9IHRzVmFsdWVbdHNWYWx1ZS5sZW5ndGgtMV0uc2l0ZTtcblxuXHRcdFx0Y29uc3QgdmFsdWVFeHByID0gYnVpbGRWYWx1ZUV4cHIodHNWYWx1ZSk7XG5cblx0XHRcdGlmICh2YWx1ZUV4cHIgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbnN0U3RhdGVtZW50KHNpdGUubWVyZ2UoZW5kU2l0ZSksIG5hbWUsIHR5cGVFeHByLCB2YWx1ZUV4cHIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcmV0dXJucyB7W1Rva2VuW10sIFRva2VuW11dfVxuICovXG5mdW5jdGlvbiBzcGxpdERhdGFJbXBsKHRzKSB7XG5cdGNvbnN0IGltcGxQb3MgPSBXb3JkLmZpbmQodHMsIFtcImNvbnN0XCIsIFwiZnVuY1wiXSk7XG5cblx0aWYgKGltcGxQb3MgPT0gLTEpIHtcblx0XHRyZXR1cm4gW3RzLCBbXV07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFt0cy5zbGljZSgwLCBpbXBsUG9zKSwgdHMuc2xpY2UoaW1wbFBvcyldO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7U3RydWN0U3RhdGVtZW50IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHJ1Y3RTdGF0ZW1lbnQoc2l0ZSwgdHMpIHtcblx0Y29uc3QgbWF5YmVOYW1lID0gdHMuc2hpZnQoKTtcblxuXHRpZiAobWF5YmVOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgbmFtZSBhZnRlciAnc3RydWN0J1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRpZiAoIW1heWJlTmFtZS5pc1dvcmQoKSkge1xuXHRcdFx0bWF5YmVOYW1lLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgbmFtZSBhZnRlciAnc3RydWN0J1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBpZiAobWF5YmVOYW1lLmlzS2V5d29yZCgpKSB7XG5cdFx0XHRtYXliZU5hbWUuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIGtleXdvcmQgYWZ0ZXIgJ3N0cnVjdCdcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmFtZSA9IG1heWJlTmFtZT8uYXNzZXJ0V29yZCgpO1xuXG5cdFx0aWYgKCFuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBtYXliZUJyYWNlcyA9IHRzLnNoaWZ0KCk7XG5cblx0XHRpZiAobWF5YmVCcmFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bmFtZS5zeW50YXhFcnJvcihgZXhwZWN0ZWQgJ3suLi59JyBhZnRlciAnc3RydWN0ICR7bmFtZS50b1N0cmluZygpfSdgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIW1heWJlQnJhY2VzLmlzR3JvdXAoXCJ7XCIsIDEpKSB7XG5cdFx0XHRcdG1heWJlQnJhY2VzLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgbm9uLWVtcHR5ICd7Li59JyB3aXRob3V0IHNlcGFyYXRvcnNcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBicmFjZXMgPSBtYXliZUJyYWNlcy5hc3NlcnRHcm91cChcIntcIiwgMSk7XG5cblx0XHRcdGlmICghYnJhY2VzKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBbdHNGaWVsZHMsIHRzSW1wbF0gPSBzcGxpdERhdGFJbXBsKGJyYWNlcy5maWVsZHNbMF0pO1xuXG5cdFx0XHRjb25zdCBmaWVsZHMgPSBidWlsZERhdGFGaWVsZHModHNGaWVsZHMpO1xuXG5cdFx0XHRjb25zdCBpbXBsID0gYnVpbGRJbXBsRGVmaW5pdGlvbih0c0ltcGwsIG5ldyBUeXBlUmVmRXhwcihuYW1lKSwgZmllbGRzLm1hcChmID0+IGYubmFtZSksIGJyYWNlcy5zaXRlLmVuZFNpdGUpO1xuXG5cdFx0XHRpZiAoaW1wbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBuZXcgU3RydWN0U3RhdGVtZW50KHNpdGUubWVyZ2UoYnJhY2VzLnNpdGUpLCBuYW1lLCBmaWVsZHMsIGltcGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge0RhdGFGaWVsZFtdfVxuICovXG5mdW5jdGlvbiBidWlsZERhdGFGaWVsZHModHMpIHtcblx0LyoqIEB0eXBlIHtEYXRhRmllbGRbXX0gKi9cblx0Y29uc3QgZmllbGRzID0gW11cblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBmaWVsZE5hbWVcblx0ICovXG5cdGZ1bmN0aW9uIGFzc2VydFVuaXF1ZShmaWVsZE5hbWUpIHtcblx0XHRpZiAoZmllbGRzLmZpbmRJbmRleChmID0+IGYubmFtZS50b1N0cmluZygpID09IGZpZWxkTmFtZS50b1N0cmluZygpKSAhPSAtMSkge1xuXHRcdFx0ZmllbGROYW1lLnR5cGVFcnJvcihgZHVwbGljYXRlIGZpZWxkIFxcJyR7ZmllbGROYW1lLnRvU3RyaW5nKCl9XFwnYCk7XG5cdFx0fVxuXHR9XG5cblx0d2hpbGUgKHRzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zdCBjb2xvblBvcyA9IFN5bWJvbFRva2VuLmZpbmQodHMsIFwiOlwiKTtcblxuXHRcdGlmIChjb2xvblBvcyA9PSAtMSkge1xuXHRcdFx0dHNbMF0uc2l0ZS5tZXJnZSh0c1t0cy5sZW5ndGgtMV0uc2l0ZSkuc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnOicgaW4gZGF0YSBmaWVsZFwiKTtcblx0XHRcdHJldHVybiBmaWVsZHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29sb24gPSB0c1tjb2xvblBvc107XG5cdFx0Y29uc3QgdHNCZWYgPSB0cy5zbGljZSgwLCBjb2xvblBvcyk7XG5cdFx0Y29uc3QgdHNBZnQgPSB0cy5zbGljZShjb2xvblBvcysxKTtcblx0XHRjb25zdCBtYXliZUZpZWxkTmFtZSA9IHRzQmVmLnNoaWZ0KCk7XG5cdFx0aWYgKG1heWJlRmllbGROYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbG9uLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgd29yZCBiZWZvcmUgJzonXCIpO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IG1heWJlRmllbGROYW1lPy5hc3NlcnRXb3JkKCk/LmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRcdFx0aWYgKCFmaWVsZE5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGZpZWxkcztcblx0XHRcdH1cblxuXHRcdFx0YXNzZXJ0VW5pcXVlKGZpZWxkTmFtZSk7XG5cblx0XHRcdGlmICh0c0FmdC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRjb2xvbi5zeW50YXhFcnJvcihcImV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvbiBhZnRlciAnOidcIik7XG5cdFx0XHRcdHJldHVybiBmaWVsZHM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5leHRDb2xvblBvcyA9IFN5bWJvbFRva2VuLmZpbmQodHNBZnQsIFwiOlwiKTtcblxuXHRcdFx0aWYgKG5leHRDb2xvblBvcyAhPSAtMSkge1xuXHRcdFx0XHRpZiAobmV4dENvbG9uUG9zID09IDApIHtcblx0XHRcdFx0XHR0c0FmdFtuZXh0Q29sb25Qb3NdLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgd29yZCBiZWZvcmUgJzonXCIpO1xuXHRcdFx0XHRcdHJldHVybiBmaWVsZHM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2b2lkIHRzQWZ0W25leHRDb2xvblBvcy0xXS5hc3NlcnRXb3JkKCk7XG5cblx0XHRcdFx0dHMgPSB0c0FmdC5zcGxpY2UobmV4dENvbG9uUG9zLTEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHMgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZUV4cHIgPSBidWlsZFR5cGVFeHByKGNvbG9uLnNpdGUsIHRzQWZ0KTtcblxuXHRcdFx0aWYgKCF0eXBlRXhwcikge1xuXHRcdFx0XHRyZXR1cm4gZmllbGRzO1xuXHRcdFx0fVxuXG5cdFx0XHRmaWVsZHMucHVzaChuZXcgRGF0YUZpZWxkKGZpZWxkTmFtZSwgdHlwZUV4cHIpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHBhcmFtIHs/VHlwZUV4cHJ9IG1ldGhvZE9mIC0gbWV0aG9kT2YgIT09IG51bGwgdGhlbiBmaXJzdCBhcmcgY2FuIGJlIG5hbWVkICdzZWxmJ1xuICogQHJldHVybnMge0Z1bmNTdGF0ZW1lbnQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZEZ1bmNTdGF0ZW1lbnQoc2l0ZSwgdHMsIG1ldGhvZE9mID0gbnVsbCkge1xuXHRjb25zdCBuYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgc2l0ZSk/LmFzc2VydFdvcmQoKT8uYXNzZXJ0Tm90S2V5d29yZCgpO1xuXG5cdGlmICghbmFtZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0bmFtZS5zaXRlLnN5bnRheEVycm9yKFwiaW52YWxpZCBzeW50YXhcIik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBmbkV4cHIgPSBidWlsZEZ1bmNMaXRlcmFsRXhwcih0cywgbWV0aG9kT2YsIGZhbHNlKTtcblxuXHRpZiAoIWZuRXhwcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBGdW5jU3RhdGVtZW50KHNpdGUubWVyZ2UoZm5FeHByLnNpdGUpLCBuYW1lLCBmbkV4cHIpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHBhcmFtIHs/VHlwZUV4cHJ9IG1ldGhvZE9mIC0gbWV0aG9kT2YgIT09IG51bGwgdGhlbiBmaXJzdCBhcmcgY2FuIGJlIG5hbWVkICdzZWxmJ1xuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0luZmVycmVkUmV0VHlwZVxuICogQHJldHVybnMge0Z1bmNMaXRlcmFsRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRnVuY0xpdGVyYWxFeHByKHRzLCBtZXRob2RPZiA9IG51bGwsIGFsbG93SW5mZXJyZWRSZXRUeXBlID0gZmFsc2UpIHtcblx0Y29uc3QgcGFyZW5zID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRHcm91cChcIihcIik7XG5cblx0aWYgKCFwYXJlbnMpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHNpdGUgPSBwYXJlbnMuc2l0ZTtcblx0Y29uc3QgYXJncyA9IGJ1aWxkRnVuY0FyZ3MocGFyZW5zLCBtZXRob2RPZik7XG5cblx0Y29uc3QgYXJyb3cgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBzaXRlKT8uYXNzZXJ0U3ltYm9sKFwiLT5cIik7XG5cblx0aWYgKCFhcnJvdykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgYm9keVBvcyA9IEdyb3VwLmZpbmQodHMsIFwie1wiKTtcblxuXHRpZiAoYm9keVBvcyA9PSAtMSkge1xuXHRcdHNpdGUuc3ludGF4RXJyb3IoXCJubyBmdW5jdGlvbiBib2R5XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKGJvZHlQb3MgPT0gMCAmJiAhYWxsb3dJbmZlcnJlZFJldFR5cGUpIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwibm8gcmV0dXJuIHR5cGUgc3BlY2lmaWVkXCIpO1xuXHR9XG5cblx0Y29uc3QgcmV0VHlwZUV4cHJzID0gYnVpbGRGdW5jUmV0VHlwZUV4cHJzKGFycm93LnNpdGUsIHRzLnNwbGljZSgwLCBib2R5UG9zKSwgYWxsb3dJbmZlcnJlZFJldFR5cGUpO1xuXG5cdGlmIChyZXRUeXBlRXhwcnMgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGJvZHlHcm91cCA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIHNpdGUpPy5hc3NlcnRHcm91cChcIntcIiwgMSlcblxuXHRpZiAoIWJvZHlHcm91cCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgYm9keUV4cHIgPSBidWlsZFZhbHVlRXhwcihib2R5R3JvdXAuZmllbGRzWzBdKTtcblxuXHRpZiAoIWJvZHlFeHByKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gbmV3IEZ1bmNMaXRlcmFsRXhwcihzaXRlLCBhcmdzLCByZXRUeXBlRXhwcnMsIGJvZHlFeHByKTtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtHcm91cH0gcGFyZW5zIFxuICogQHBhcmFtIHs/VHlwZUV4cHJ9IG1ldGhvZE9mIC0gbWV0aG9kT2YgIT09IG51bCB0aGVuIGZpcnN0IGFyZyBjYW4gYmUgbmFtZWQgJ3NlbGYnXG4gKiBAcmV0dXJucyB7RnVuY0FyZ1tdfVxuICovXG5mdW5jdGlvbiBidWlsZEZ1bmNBcmdzKHBhcmVucywgbWV0aG9kT2YgPSBudWxsKSB7XG5cdC8qKiBAdHlwZSB7RnVuY0FyZ1tdfSAqL1xuXHRjb25zdCBhcmdzID0gW107XG5cblx0bGV0IGhhc0RlZmF1bHRBcmdzID0gZmFsc2U7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgZiA9IHBhcmVucy5maWVsZHNbaV07XG5cdFx0Y29uc3QgdHMgPSBmLnNsaWNlKCk7XG5cblx0XHRjb25zdCBuYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgcGFyZW5zLnNpdGUpPy5hc3NlcnRXb3JkKCk7XG5cblx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChuYW1lLnRvU3RyaW5nKCkgPT0gXCJzZWxmXCIpIHtcblx0XHRcdGlmIChpICE9IDAgfHwgbWV0aG9kT2YgPT09IG51bGwpIHtcblx0XHRcdFx0bmFtZS5zeW50YXhFcnJvcihcIidzZWxmJyBpcyByZXNlcnZlZFwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0aWYgKHRzWzBdLmlzU3ltYm9sKFwiOlwiKSkge1xuXHRcdFx0XHRcdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvbiBhZnRlciAnc2VsZidcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRzWzBdLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlblwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJncy5wdXNoKG5ldyBGdW5jQXJnKG5hbWUsIG1ldGhvZE9mKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG5hbWUudG9TdHJpbmcoKSA9PSBcIl9cIikge1xuXHRcdFx0aWYgKHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0aWYgKHRzWzBdLmlzU3ltYm9sKFwiOlwiKSkge1xuXHRcdFx0XHRcdHRzWzBdLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0eXBlIGV4cHJlc3Npb24gYWZ0ZXIgJ18nXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRzWzBdLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlblwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJncy5wdXNoKG5ldyBGdW5jQXJnKG5hbWUsIG1ldGhvZE9mKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChuYW1lLmlzS2V5d29yZCgpKSB7XG5cdFx0XHRcdG5hbWUuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIGtleXdvcmRcIik7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IHByZXYgb2YgYXJncykge1xuXHRcdFx0XHRpZiAocHJldi5uYW1lLnRvU3RyaW5nKCkgPT0gbmFtZS50b1N0cmluZygpKSB7XG5cdFx0XHRcdFx0bmFtZS5zeW50YXhFcnJvcihgZHVwbGljYXRlIGFyZ3VtZW50ICcke25hbWUudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWF5YmVDb2xvbiA9IHRzLnNoaWZ0KCk7XG5cdFx0XHRpZiAobWF5YmVDb2xvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5hbWUuc3ludGF4RXJyb3IoYGV4cGVjdGVkICc6JyBhZnRlciAnJHtuYW1lLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgY29sb24gPSBtYXliZUNvbG9uLmFzc2VydFN5bWJvbChcIjpcIik7XG5cblx0XHRcdFx0aWYgKCFjb2xvbikge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZXF1YWxzUG9zID0gU3ltYm9sVG9rZW4uZmluZCh0cywgXCI9XCIpO1xuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBAdHlwZSB7bnVsbCB8IFZhbHVlRXhwcn1cblx0XHRcdFx0ICovXG5cdFx0XHRcdGxldCBkZWZhdWx0VmFsdWVFeHByID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoZXF1YWxzUG9zICE9IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGVxdWFsc1BvcyA9PSB0cy5sZW5ndGgtMSkge1xuXHRcdFx0XHRcdFx0dHNbZXF1YWxzUG9zXS5zeW50YXhFcnJvcihcImV4cGVjdGVkIGV4cHJlc3Npb24gYWZ0ZXIgJz0nXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2dHMgPSB0cy5zcGxpY2UoZXF1YWxzUG9zKTtcblxuXHRcdFx0XHRcdFx0dnRzLnNoaWZ0KCk/LmFzc2VydFN5bWJvbChcIj1cIik7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZUV4cHIgPSBidWlsZFZhbHVlRXhwcih2dHMpO1xuXG5cdFx0XHRcdFx0XHRoYXNEZWZhdWx0QXJncyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChoYXNEZWZhdWx0QXJncykge1xuXHRcdFx0XHRcdFx0bmFtZS5zeW50YXhFcnJvcihcInBvc2l0aW9uYWwgYXJncyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXJnc1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQHR5cGUge1R5cGVFeHByIHwgbnVsbH1cblx0XHRcdFx0ICovXG5cdFx0XHRcdGxldCB0eXBlRXhwciA9IG51bGw7XG5cblx0XHRcdFx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0Y29sb24uc3ludGF4RXJyb3IoXCJleHBlY3RlZCB0eXBlIGV4cHJlc3Npb24gYWZ0ZXIgJzonXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihjb2xvbi5zaXRlLCB0cyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcmdzLnB1c2gobmV3IEZ1bmNBcmcobmFtZSwgdHlwZUV4cHIsIGRlZmF1bHRWYWx1ZUV4cHIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtFbnVtU3RhdGVtZW50IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRFbnVtU3RhdGVtZW50KHNpdGUsIHRzKSB7XG5cdGNvbnN0IG1heWJlTmFtZSA9IHRzLnNoaWZ0KCk7XG5cblx0aWYgKG1heWJlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIHdvcmQgYWZ0ZXIgJ2VudW0nXCIpO1xuXHRcdHJldHVybiBudWxsXG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgbmFtZSA9IG1heWJlTmFtZS5hc3NlcnRXb3JkKCk/LmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRcdGlmICghbmFtZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWF5YmVCcmFjZXMgPSB0cy5zaGlmdCgpO1xuXG5cdFx0aWYgKG1heWJlQnJhY2VzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdG5hbWUuc3ludGF4RXJyb3IoYGV4cGVjdGVkICd7Li4ufScgYWZ0ZXIgJ2VudW0gJHtuYW1lLnRvU3RyaW5nKCl9J2ApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGJyYWNlcyA9IG1heWJlQnJhY2VzLmFzc2VydEdyb3VwKFwie1wiLCAxKTtcblxuXHRcdFx0aWYgKCFicmFjZXMpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IFt0c01lbWJlcnMsIHRzSW1wbF0gPSBzcGxpdERhdGFJbXBsKGJyYWNlcy5maWVsZHNbMF0pO1xuXG5cdFx0XHRpZiAodHNNZW1iZXJzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdGJyYWNlcy5zeW50YXhFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBlbnVtIG1lbWJlclwiKTtcblx0XHRcdH1cblxuXHRcdFx0LyoqIEB0eXBlIHtFbnVtTWVtYmVyW119ICovXG5cdFx0XHRjb25zdCBtZW1iZXJzID0gW107XG5cblx0XHRcdHdoaWxlICh0c01lbWJlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBtZW1iZXIgPSBidWlsZEVudW1NZW1iZXIodHNNZW1iZXJzKTtcblxuXHRcdFx0XHRpZiAoIW1lbWJlcikge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVtYmVycy5wdXNoKG1lbWJlcik7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGltcGwgPSBidWlsZEltcGxEZWZpbml0aW9uKHRzSW1wbCwgbmV3IFR5cGVSZWZFeHByKG5hbWUpLCBtZW1iZXJzLm1hcChtID0+IG0ubmFtZSksIGJyYWNlcy5zaXRlLmVuZFNpdGUpO1xuXG5cdFx0XHRpZiAoIWltcGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgRW51bVN0YXRlbWVudChzaXRlLm1lcmdlKGJyYWNlcy5zaXRlKSwgbmFtZSwgbWVtYmVycywgaW1wbCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7KEltcG9ydFN0YXRlbWVudCB8IG51bGwpW10gfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZEltcG9ydFN0YXRlbWVudHMoc2l0ZSwgdHMpIHtcblx0Y29uc3QgbWF5YmVCcmFjZXMgPSB0cy5zaGlmdCgpO1xuXG5cdGlmIChtYXliZUJyYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkICd7Li4ufScgYWZ0ZXIgJ2ltcG9ydCdcIik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgYnJhY2VzID0gbWF5YmVCcmFjZXMuYXNzZXJ0R3JvdXAoXCJ7XCIpO1xuXHRcdGlmICghYnJhY2VzKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBtYXliZUZyb20gPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBtYXliZUJyYWNlcy5zaXRlLCBcImV4cGVjdGVkICdmcm9tJyBhZnRlciAnaW1wb3J0IHsuLi59J1wiKT8uYXNzZXJ0V29yZChcImZyb21cIik7XG5cdFx0aWYgKCFtYXliZUZyb20pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1heWJlTW9kdWxlTmFtZSA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIG1heWJlRnJvbS5zaXRlLCBcImV4cGVjdGVkIG1vZHVsZSBuYW1lIGFmdGVyICdpbXBvcnQgey4uLn0gZnJvbSdcIik7XG5cdFx0aWYgKCFtYXliZU1vZHVsZU5hbWUpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtudWxsIHwgdW5kZWZpbmVkIHwgV29yZH1cblx0XHQgKi9cblx0XHRsZXQgbW9kdWxlTmFtZSA9IG51bGw7XG5cblx0XHRpZiAobWF5YmVNb2R1bGVOYW1lIGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbCAmJiBpbXBvcnRQYXRoVHJhbnNsYXRvcikge1xuXHRcdFx0bGV0IHRyYW5zbGF0ZWQgPSBpbXBvcnRQYXRoVHJhbnNsYXRvcihtYXliZU1vZHVsZU5hbWUpO1xuXG5cdFx0XHRpZiAoIXRyYW5zbGF0ZWQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdG1vZHVsZU5hbWUgPSBuZXcgV29yZChtYXliZU1vZHVsZU5hbWUuc2l0ZSwgdHJhbnNsYXRlZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vZHVsZU5hbWUgPSBtYXliZU1vZHVsZU5hbWUuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFtb2R1bGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBtTmFtZSA9IG1vZHVsZU5hbWU7XG5cblx0XHRpZiAoYnJhY2VzLmZpZWxkcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGJyYWNlcy5zeW50YXhFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IDEgaW1wb3J0IGZpZWxkXCIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBicmFjZXMuZmllbGRzLm1hcChmdHMgPT4ge1xuXHRcdFx0Y29uc3QgdHMgPSBmdHMuc2xpY2UoKTtcblx0XHRcdGNvbnN0IG1heWJlT3JpZ05hbWUgPSB0cy5zaGlmdCgpO1xuXG5cdFx0XHRpZiAobWF5YmVPcmlnTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGJyYWNlcy5zeW50YXhFcnJvcihcImVtcHR5IGltcG9ydCBmaWVsZFwiKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBvcmlnTmFtZSA9IG1heWJlT3JpZ05hbWUuYXNzZXJ0V29yZCgpO1xuXG5cdFx0XHRcdGlmICghb3JpZ05hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICh0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEltcG9ydFN0YXRlbWVudChzaXRlLCBvcmlnTmFtZSwgb3JpZ05hbWUsIG1OYW1lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBtYXliZUFzID0gdHMuc2hpZnQoKTtcblxuXHRcdFx0XHRcdGlmIChtYXliZUFzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdG1heWJlT3JpZ05hbWUuc3ludGF4RXJyb3IoYGV4cGVjdGVkICdhcycgb3Igbm90aGluZyBhZnRlciAnJHtvcmlnTmFtZS52YWx1ZX0nYCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF5YmVBcy5hc3NlcnRXb3JkKFwiYXNcIik7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG1heWJlTmV3TmFtZSA9IHRzLnNoaWZ0KCk7XG5cblx0XHRcdFx0XHRcdGlmIChtYXliZU5ld05hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRtYXliZUFzLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgd29yZCBhZnRlciAnYXMnXCIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5ld05hbWUgPSBtYXliZU5ld05hbWUuYXNzZXJ0V29yZCgpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghbmV3TmFtZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVtID0gdHMuc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHJlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVtLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlblwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEltcG9ydFN0YXRlbWVudChzaXRlLCBuZXdOYW1lLCBvcmlnTmFtZSwgbU5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSkuZmlsdGVyKGYgPT4gZiAhPT0gbnVsbClcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge0VudW1NZW1iZXIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZEVudW1NZW1iZXIodHMpIHtcblx0Y29uc3QgbmFtZSA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0aWYgKCFuYW1lKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAodHMubGVuZ3RoID09IDAgfHwgdHNbMF0uaXNXb3JkKCkpIHtcblx0XHRyZXR1cm4gbmV3IEVudW1NZW1iZXIobmFtZSwgW10pO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGJyYWNlcyA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIG5hbWUuc2l0ZSk/LmFzc2VydEdyb3VwKFwie1wiLCAxKTtcblxuXHRcdGlmICghYnJhY2VzKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZmllbGRzID0gYnVpbGREYXRhRmllbGRzKGJyYWNlcy5maWVsZHNbMF0pO1xuXG5cdFx0XHRyZXR1cm4gbmV3IEVudW1NZW1iZXIobmFtZSwgZmllbGRzKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIFxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcGFyYW0ge1R5cGVSZWZFeHByfSBzZWxmVHlwZUV4cHIgLSByZWZlcmVuY2UgdG8gcGFyZW50IHR5cGVcbiAqIEBwYXJhbSB7V29yZFtdfSBmaWVsZE5hbWVzIC0gdG8gY2hlY2sgaWYgaW1wbCBzdGF0ZW1lbnRzIGhhdmUgYSB1bmlxdWUgbmFtZVxuICogQHBhcmFtIHs/U2l0ZX0gZW5kU2l0ZVxuICogQHJldHVybnMge0ltcGxEZWZpbml0aW9uIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRJbXBsRGVmaW5pdGlvbih0cywgc2VsZlR5cGVFeHByLCBmaWVsZE5hbWVzLCBlbmRTaXRlKSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBpc05vbkF1dG8obmFtZSkge1xuXHRcdGlmIChBVVRPTUFUSUNfTUVUSE9EUy5maW5kSW5kZXgobiA9PiBuID09IG5hbWUudG9TdHJpbmcoKSkgIT0gLTEpIHtcblx0XHRcdG5hbWUuc3ludGF4RXJyb3IoYCcke25hbWUudG9TdHJpbmcoKX0nIGlzIGEgcmVzZXJ2ZWQgbWVtYmVyYCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZvciAobGV0IGZpZWxkTmFtZSBvZiBmaWVsZE5hbWVzKSB7XG5cdFx0aWYgKCFpc05vbkF1dG8oZmllbGROYW1lKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc3RhdGVtZW50cyA9IGJ1aWxkSW1wbE1lbWJlcnModHMsIHNlbGZUeXBlRXhwcik7XG5cblx0LyoqIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBva1xuXHQgKi9cblx0ZnVuY3Rpb24gaXNVbmlxdWUoaSkge1xuXHRcdGxldCBzID0gc3RhdGVtZW50c1tpXTtcblxuXHRcdGlzTm9uQXV0byhzLm5hbWUpO1xuXG5cdFx0Zm9yIChsZXQgZmllbGROYW1lIG9mIGZpZWxkTmFtZXMpIHtcblx0XHRcdGlmIChmaWVsZE5hbWUudG9TdHJpbmcoKSA9PSBzLm5hbWUudG9TdHJpbmcoKSkge1xuXHRcdFx0XHRzLm5hbWUuc3ludGF4RXJyb3IoYCcke3MubmFtZS50b1N0cmluZygpfScgaXMgZHVwbGljYXRlYCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGxldCBqID0gaSsxOyBqIDwgc3RhdGVtZW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0aWYgKHN0YXRlbWVudHNbal0ubmFtZS50b1N0cmluZygpID09IHMubmFtZS50b1N0cmluZygpKSB7XG5cdFx0XHRcdHN0YXRlbWVudHNbal0ubmFtZS5zeW50YXhFcnJvcihgJyR7cy5uYW1lLnRvU3RyaW5nKCl9JyBpcyBkdXBsaWNhdGVgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Y29uc3QgbiA9IHN0YXRlbWVudHMubGVuZ3RoO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0aWYgKCFpc1VuaXF1ZShpKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG4gPiAwICYmIGVuZFNpdGUgIT09IG51bGwpIHtcblx0XHRzdGF0ZW1lbnRzW24tMV0uc2l0ZS5zZXRFbmRTaXRlKGVuZFNpdGUpO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBJbXBsRGVmaW5pdGlvbihzZWxmVHlwZUV4cHIsIHN0YXRlbWVudHMpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHBhcmFtIHtUeXBlRXhwcn0gbWV0aG9kT2ZcbiAqIEByZXR1cm5zIHsoQ29uc3RTdGF0ZW1lbnQgfCBGdW5jU3RhdGVtZW50KVtdfVxuICovXG5mdW5jdGlvbiBidWlsZEltcGxNZW1iZXJzKHRzLCBtZXRob2RPZikge1xuXHQvKiogQHR5cGUgeyhDb25zdFN0YXRlbWVudCB8IEZ1bmNTdGF0ZW1lbnQpW119ICovXG5cdGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcblxuXHR3aGlsZSAodHMubGVuZ3RoICE9IDApIHtcblx0XHRjb25zdCB0ID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRXb3JkKCk7XG5cblx0XHRpZiAoIXQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGt3ID0gdC52YWx1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtudWxsIHwgQ29uc3RTdGF0ZW1lbnQgfCBGdW5jU3RhdGVtZW50fVxuXHRcdCAqL1xuXHRcdGxldCBzID0gbnVsbDtcblxuXHRcdGlmIChrdyA9PSBcImNvbnN0XCIpIHtcblx0XHRcdHMgPSBidWlsZENvbnN0U3RhdGVtZW50KHQuc2l0ZSwgdHMpO1xuXHRcdH0gZWxzZSBpZiAoa3cgPT0gXCJmdW5jXCIpIHtcblx0XHRcdHMgPSBidWlsZEZ1bmNTdGF0ZW1lbnQodC5zaXRlLCB0cywgbWV0aG9kT2YpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LnN5bnRheEVycm9yKFwiaW52YWxpZCBpbXBsIHN5bnRheFwiKTtcblx0XHR9XG5cblx0XHRpZiAocykge1xuXHRcdFx0c3RhdGVtZW50cy5wdXNoKHMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdGF0ZW1lbnRzXG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtUeXBlRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHlwZUV4cHIoc2l0ZSwgdHMpIHtcblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIHRva2VuXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKHRzWzBdLmlzR3JvdXAoXCJbXCIpKSB7XG5cdFx0cmV0dXJuIGJ1aWxkTGlzdFR5cGVFeHByKHRzKTtcblx0fSBlbHNlIGlmICh0c1swXS5pc1dvcmQoXCJNYXBcIikpIHtcblx0XHRyZXR1cm4gYnVpbGRNYXBUeXBlRXhwcih0cyk7XG5cdH0gZWxzZSBpZiAodHNbMF0uaXNXb3JkKFwiT3B0aW9uXCIpKSB7XG5cdFx0cmV0dXJuIGJ1aWxkT3B0aW9uVHlwZUV4cHIodHMpO1xuXHR9IGVsc2UgaWYgKHRzLmxlbmd0aCA+IDEgJiYgdHNbMF0uaXNHcm91cChcIihcIikgJiYgdHNbMV0uaXNTeW1ib2woXCItPlwiKSkge1xuXHRcdHJldHVybiBidWlsZEZ1bmNUeXBlRXhwcih0cyk7XG5cdH0gZWxzZSBpZiAodHMubGVuZ3RoID4gMSAmJiB0c1swXS5pc1dvcmQoKSAmJiB0c1sxXS5pc1N5bWJvbChcIjo6XCIpKSB7XG5cdFx0cmV0dXJuIGJ1aWxkVHlwZVBhdGhFeHByKHRzKTtcblx0fSBlbHNlIGlmICh0c1swXS5pc1dvcmQoKSkge1xuXHRcdHJldHVybiBidWlsZFR5cGVSZWZFeHByKHRzKTtcblx0fSBlbHNlIHtcblx0XHR0c1swXS5zeW50YXhFcnJvcihcImludmFsaWQgdHlwZSBzeW50YXhcIik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtMaXN0VHlwZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZExpc3RUeXBlRXhwcih0cykge1xuXHRjb25zdCBicmFja2V0cyA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0R3JvdXAoXCJbXCIsIDApO1xuXG5cdGlmICghYnJhY2tldHMpIHtcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cblx0Y29uc3QgaXRlbVR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihicmFja2V0cy5zaXRlLCB0cyk7XG5cblx0aWYgKCFpdGVtVHlwZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBuZXcgTGlzdFR5cGVFeHByKGJyYWNrZXRzLnNpdGUsIGl0ZW1UeXBlRXhwcik7XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7TWFwVHlwZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZE1hcFR5cGVFeHByKHRzKSB7XG5cdGNvbnN0IGt3ID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRXb3JkKFwiTWFwXCIpO1xuXG5cdGlmICgha3cpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IG1heWJlS2V5VHlwZUV4cHIgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBrdy5zaXRlLCBcIm1pc3NpbmcgTWFwIGtleS10eXBlXCIpO1xuXG5cdGlmICghbWF5YmVLZXlUeXBlRXhwcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3Qga2V5VHlwZVRzID0gbWF5YmVLZXlUeXBlRXhwci5hc3NlcnRHcm91cChcIltcIiwgMSk/LmZpZWxkc1swXTtcblx0aWYgKGtleVR5cGVUcyA9PT0gbnVsbCB8fCBrZXlUeXBlVHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKGtleVR5cGVUcy5sZW5ndGggPT0gMCkge1xuXHRcdGt3LnN5bnRheEVycm9yKFwibWlzc2luZyBNYXAga2V5LXR5cGUgKGJyYWNrZXRzIGNhbid0IGJlIGVtcHR5KVwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBcblxuXHRjb25zdCBrZXlUeXBlRXhwciA9IGJ1aWxkVHlwZUV4cHIoa3cuc2l0ZSwga2V5VHlwZVRzKTtcblx0aWYgKCFrZXlUeXBlRXhwcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0a3cuc3ludGF4RXJyb3IoXCJtaXNzaW5nIE1hcCB2YWx1ZS10eXBlXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IFxuXG5cdGNvbnN0IHZhbHVlVHlwZUV4cHIgPSBidWlsZFR5cGVFeHByKGt3LnNpdGUsIHRzKTtcblxuXHRpZiAoIXZhbHVlVHlwZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBuZXcgTWFwVHlwZUV4cHIoa3cuc2l0ZSwga2V5VHlwZUV4cHIsIHZhbHVlVHlwZUV4cHIpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge1R5cGVFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRPcHRpb25UeXBlRXhwcih0cykge1xuXHRjb25zdCBrdyA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZChcIk9wdGlvblwiKTtcblxuXHRpZiAoIWt3KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCB0eXBlVHMgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBrdy5zaXRlKT8uYXNzZXJ0R3JvdXAoXCJbXCIsIDEpPy5maWVsZHNbMF07XG5cblx0aWYgKCF0eXBlVHMpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHNvbWVUeXBlRXhwciA9IGJ1aWxkVHlwZUV4cHIoa3cuc2l0ZSwgdHlwZVRzKTtcblx0aWYgKCFzb21lVHlwZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHR5cGVFeHByID0gbmV3IE9wdGlvblR5cGVFeHByKGt3LnNpdGUsIHNvbWVUeXBlRXhwcik7XG5cdGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0aWYgKHRzWzBdLmlzU3ltYm9sKFwiOjpcIikgJiYgdHNbMV0uaXNXb3JkKFtcIlNvbWVcIiwgXCJOb25lXCJdKSkge1xuXHRcdFx0aWYgKHRzLmxlbmd0aCA+IDIpIHtcblx0XHRcdFx0dHNbMl0uc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2VuXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG1lbWJlck5hbWUgPSB0c1sxXS5hc3NlcnRXb3JkKClcblxuXHRcdFx0XHRpZiAoIW1lbWJlck5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVHlwZVBhdGhFeHByKHRzWzBdLnNpdGUsIHR5cGVFeHByLCBtZW1iZXJOYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJpbnZhbGlkIG9wdGlvbiB0eXBlIHN5bnRheFwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdHlwZUV4cHI7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtGdW5jVHlwZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZEZ1bmNUeXBlRXhwcih0cykge1xuXHRjb25zdCBwYXJlbnMgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydEdyb3VwKFwiKFwiKTtcblxuXHRpZiAoIXBhcmVucykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0bGV0IGhhc09wdEFyZ3MgPSBmYWxzZTtcblxuXHRjb25zdCBhcmdUeXBlcyA9IHJlZHVjZU51bGwocGFyZW5zLmZpZWxkcy5tYXAoZiA9PiB7XG5cdFx0Y29uc3QgZnRzID0gZi5zbGljZSgpO1xuXG5cdFx0aWYgKGZ0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0cGFyZW5zLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgZnVuYyBhcmcgdHlwZVwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZ1bmNBcmdUeXBlRXhwciA9IGJ1aWxkRnVuY0FyZ1R5cGVFeHByKGZ0cyk7XG5cblx0XHRpZiAoIWZ1bmNBcmdUeXBlRXhwcikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGhhc09wdEFyZ3MpIHtcblx0XHRcdGlmICghZnVuY0FyZ1R5cGVFeHByLmlzT3B0aW9uYWwoKSkge1xuXHRcdFx0XHRmdW5jQXJnVHlwZUV4cHIuc3ludGF4RXJyb3IoXCJvcHRpb25hbCBhcmd1bWVudHMgbXVzdCBjb21lIGxhc3RcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZnVuY0FyZ1R5cGVFeHByLmlzT3B0aW9uYWwoKSkge1xuXHRcdFx0XHRoYXNPcHRBcmdzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY0FyZ1R5cGVFeHByO1xuXHR9KSk7XG5cblx0aWYgKCFhcmdUeXBlcykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChhcmdUeXBlcy5zb21lKGF0ID0+IGF0LmlzTmFtZWQoKSkgJiYgYXJnVHlwZXMuc29tZShhdCA9PiAhYXQuaXNOYW1lZCgpKSkge1xuXHRcdFx0YXJnVHlwZXNbMF0uc3ludGF4RXJyb3IoXCJjYW4ndCBtaXggbmFtZWQgYW5kIHVubmFtZWQgYXJncyBpbiBmdW5jIHR5cGVcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFxuXHRcdGNvbnN0IGFycm93ID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgcGFyZW5zLnNpdGUpPy5hc3NlcnRTeW1ib2woXCItPlwiKTtcblxuXHRcdGlmICghYXJyb3cpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XG5cdFx0Y29uc3QgcmV0VHlwZXMgPSBidWlsZEZ1bmNSZXRUeXBlRXhwcnMoYXJyb3cuc2l0ZSwgdHMsIGZhbHNlKTtcblxuXHRcdGlmICghcmV0VHlwZXMpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRnVuY1R5cGVFeHByKHBhcmVucy5zaXRlLCBhcmdUeXBlcywgcmV0VHlwZXMubWFwKHQgPT4gYXNzZXJ0RGVmaW5lZCh0KSkpO1xuXHR9XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge0Z1bmNBcmdUeXBlRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRnVuY0FyZ1R5cGVFeHByKHRzKSB7XG5cdGNvbnN0IGNvbG9uUG9zID0gU3ltYm9sVG9rZW4uZmluZCh0cywgXCI6XCIpO1xuXG5cdGlmIChjb2xvblBvcyAhPSAtMSAmJiBjb2xvblBvcyAhPSAxKSB7XG5cdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheFwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7V29yZCB8IG51bGx9XG5cdCAqL1xuXHRsZXQgbmFtZSA9IG51bGw7XG5cblx0aWYgKGNvbG9uUG9zICE9IC0xKSB7XG5cdFx0bmFtZSA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCkgPz8gbnVsbDtcblxuXHRcdGlmICghbmFtZSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29sb24gPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydFN5bWJvbChcIjpcIik7XG5cblx0XHRpZiAoIWNvbG9uKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRjb2xvbi5zeW50YXhFcnJvcihcImV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvbiBhZnRlciAnOidcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBuZXh0ID0gYXNzZXJ0RGVmaW5lZCh0c1swXSk7XG5cblx0Y29uc3QgaGFzRGVmYXVsdCA9IG5leHQuaXNTeW1ib2woXCI/XCIpO1xuXHRpZiAoaGFzRGVmYXVsdCkge1xuXHRcdGNvbnN0IG9wdCA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSk7XG5cblx0XHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdG9wdC5zeW50YXhFcnJvcihcImludmFsaWQgdHlwZSBleHByZXNzaW9uIGFmdGVyICc/J1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihuZXh0LnNpdGUsIHRzKTtcblx0aWYgKCF0eXBlRXhwcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBGdW5jQXJnVHlwZUV4cHIobmFtZSAhPT0gbnVsbCA/IG5hbWUuc2l0ZSA6IHR5cGVFeHByLnNpdGUsIG5hbWUsIHR5cGVFeHByLCBoYXNEZWZhdWx0KTtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dJbmZlcnJlZFJldFR5cGVcbiAqIEByZXR1cm5zIHtudWxsIHwgKG51bGwgfCBUeXBlRXhwcilbXX1cbiAqL1xuZnVuY3Rpb24gYnVpbGRGdW5jUmV0VHlwZUV4cHJzKHNpdGUsIHRzLCBhbGxvd0luZmVycmVkUmV0VHlwZSA9IGZhbHNlKSB7XG5cdGlmICh0cy5sZW5ndGggPT09IDApIHtcblx0XHRpZiAoYWxsb3dJbmZlcnJlZFJldFR5cGUpIHtcblx0XHRcdHJldHVybiBbbnVsbF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCB0eXBlIGV4cHJlc3Npb24gYWZ0ZXIgJy0+J1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAodHNbMF0uaXNHcm91cChcIihcIikgJiYgKHRzLmxlbmd0aCA9PSAxIHx8ICF0c1sxXS5pc1N5bWJvbChcIi0+XCIpKSkge1xuXHRcdFx0Y29uc3QgZ3JvdXAgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBzaXRlKT8uYXNzZXJ0R3JvdXAoXCIoXCIpO1xuXG5cdFx0XHRpZiAoIWdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmIChncm91cC5maWVsZHMubGVuZ3RoID09IDApIHtcblx0XHRcdFx0cmV0dXJuIFtuZXcgVm9pZFR5cGVFeHByKGdyb3VwLnNpdGUpXTtcblx0XHRcdH0gZWxzZSBpZiAoZ3JvdXAuZmllbGRzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdGdyb3VwLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgMCBvciAyIG9yIG1vcmUgdHlwZXMgaW4gbXVsdGkgcmV0dXJuIHR5cGVcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGdyb3VwLmZpZWxkcy5tYXAoZnRzID0+IHtcblx0XHRcdFx0XHRmdHMgPSBmdHMuc2xpY2UoKTtcblxuXHRcdFx0XHRcdHJldHVybiBidWlsZFR5cGVFeHByKGdyb3VwLnNpdGUsIGZ0cyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW2J1aWxkVHlwZUV4cHIoc2l0ZSwgdHMpXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtudWxsIHwgVHlwZVBhdGhFeHByfVxuICovXG5mdW5jdGlvbiBidWlsZFR5cGVQYXRoRXhwcih0cykge1xuXHRjb25zdCBiYXNlTmFtZSA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0aWYgKCFiYXNlTmFtZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3Qgc3ltYm9sID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgYmFzZU5hbWUuc2l0ZSk/LmFzc2VydFN5bWJvbChcIjo6XCIpO1xuXG5cdGlmICghc3ltYm9sKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBtZW1iZXJOYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgc3ltYm9sLnNpdGUpPy5hc3NlcnRXb3JkKCk7XG5cblx0aWYgKCFtZW1iZXJOYW1lKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAodHMubGVuZ3RoID4gMCkge1xuXHRcdHRzWzBdLnN5bnRheEVycm9yKFwiaW52YWxpZCB0eXBlIHN5bnRheFwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRcblx0cmV0dXJuIG5ldyBUeXBlUGF0aEV4cHIoc3ltYm9sLnNpdGUsIG5ldyBUeXBlUmVmRXhwcihiYXNlTmFtZSksIG1lbWJlck5hbWUpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge1R5cGVSZWZFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRUeXBlUmVmRXhwcih0cykge1xuXHRjb25zdCBuYW1lID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRXb3JkKCk/LmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRpZiAoIW5hbWUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJpbnZhbGlkIHR5cGUgc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBUeXBlUmVmRXhwcihuYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjIFxuICogQHJldHVybnMge1ZhbHVlRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVFeHByKHRzLCBwcmVjID0gMCkge1xuXHRhc3NlcnQodHMubGVuZ3RoID4gMCk7XG5cblx0Ly8gbG93ZXIgaW5kZXggaW4gZXhwckJ1aWxkZXJzIGlzIGxvd2VyIHByZWNlZGVuY2Vcblx0LyoqIEB0eXBlIHsoKHRzOiBUb2tlbltdLCBwcmV2OiBudW1iZXIpID0+IChWYWx1ZUV4cHIgfCBudWxsKSlbXX0gKi9cblx0Y29uc3QgZXhwckJ1aWxkZXJzID0gW1xuXHRcdC8qKlxuXHRcdCAqIDA6IGxvd2VzdCBwcmVjZWRlbmNlIGlzIGFzc2lnbm1lbnRcblx0XHQgKiBAcGFyYW0ge1Rva2VuW119IHRzXyBcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gcHJlY18gXG5cdFx0ICogQHJldHVybnMgXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gKHRzXywgcHJlY18pIHtcblx0XHRcdHJldHVybiBidWlsZE1heWJlQXNzaWduT3JQcmludEV4cHIodHNfLCBwcmVjXyk7XG5cdFx0fSxcblx0XHRtYWtlQmluYXJ5RXhwckJ1aWxkZXIoJ3x8JyksIC8vIDE6IGxvZ2ljYWwgb3Igb3BlcmF0b3Jcblx0XHRtYWtlQmluYXJ5RXhwckJ1aWxkZXIoJyYmJyksIC8vIDI6IGxvZ2ljYWwgYW5kIG9wZXJhdG9yXG5cdFx0bWFrZUJpbmFyeUV4cHJCdWlsZGVyKFsnPT0nLCAnIT0nXSksIC8vIDM6IGVxIG9yIG5lcVxuXHRcdG1ha2VCaW5hcnlFeHByQnVpbGRlcihbJzwnLCAnPD0nLCAnPicsICc+PSddKSwgLy8gNDogY29tcGFyaXNvblxuXHRcdG1ha2VCaW5hcnlFeHByQnVpbGRlcihbJysnLCAnLSddKSwgLy8gNTogYWRkaXRpb24gc3VidHJhY3Rpb25cblx0XHRtYWtlQmluYXJ5RXhwckJ1aWxkZXIoWycqJywgJy8nLCAnJSddKSwgLy8gNjogbXVsdGlwbGljYXRpb24gZGl2aXNpb24gcmVtYWluZGVyXG5cdFx0bWFrZVVuYXJ5RXhwckJ1aWxkZXIoWychJywgJysnLCAnLSddKSwgLy8gNzogbG9naWNhbCBub3QsIG5lZ2F0ZVxuXHRcdC8qKlxuXHRcdCAqIDg6IHZhcmlhYmxlcyBvciBsaXRlcmFsIHZhbHVlcyBjaGFpbmVkIHdpdGg6IChlbnVtKW1lbWJlciBhY2Nlc3MsIGluZGV4aW5nIGFuZCBjYWxsaW5nXG5cdFx0ICogQHBhcmFtIHtUb2tlbltdfSB0c18gXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IHByZWNfIFxuXHRcdCAqIEByZXR1cm5zIFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uICh0c18sIHByZWNfKSB7XG5cdFx0XHRyZXR1cm4gYnVpbGRDaGFpbmVkVmFsdWVFeHByKHRzXywgcHJlY18pO1xuXHRcdH1cblx0XTtcblxuXHRyZXR1cm4gZXhwckJ1aWxkZXJzW3ByZWNdKHRzLCBwcmVjKTtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0c1xuICogQHBhcmFtIHtudW1iZXJ9IHByZWNcbiAqIEByZXR1cm5zIHtWYWx1ZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZE1heWJlQXNzaWduT3JQcmludEV4cHIodHMsIHByZWMpIHtcblx0bGV0IHNlbWljb2xvblBvcyA9IFN5bWJvbFRva2VuLmZpbmQodHMsIFwiO1wiKTtcblx0Y29uc3QgZXF1YWxzUG9zID0gU3ltYm9sVG9rZW4uZmluZCh0cywgXCI9XCIpO1xuXHRjb25zdCBwcmludFBvcyA9IFdvcmQuZmluZCh0cywgXCJwcmludFwiKTtcblxuXHRpZiAoc2VtaWNvbG9uUG9zID09IC0xKSB7XG5cdFx0aWYgKGVxdWFsc1BvcyAhPSAtMSkge1xuXHRcdFx0dHNbZXF1YWxzUG9zXS5zeW50YXhFcnJvcihcImludmFsaWQgYXNzaWdubWVudCBzeW50YXgsIGV4cGVjdGVkICc7JyBhZnRlciAnLi4uPS4uLidcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGJ1aWxkVmFsdWVFeHByKHRzLCBwcmVjICsgMSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgoZXF1YWxzUG9zID09IC0xIHx8IGVxdWFsc1BvcyA+IHNlbWljb2xvblBvcykgJiYgKHByaW50UG9zID09IC0xIHx8IHByaW50UG9zID4gc2VtaWNvbG9uUG9zKSkge1xuXHRcdFx0Y29uc3QgdXBzdHJlYW1FeHByID0gYnVpbGRWYWx1ZUV4cHIodHMuc3BsaWNlKDAsIHNlbWljb2xvblBvcyksIHByZWMrMSk7XG5cdFx0XHRjb25zdCBzaXRlID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5zaXRlO1xuXG5cdFx0XHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIGV4cHJlc3Npb24gYWZ0ZXIgJzsnXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAodXBzdHJlYW1FeHByID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIGVycm9yIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gY3JlYXRlZFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGRvd25zdHJlYW1FeHByID0gYnVpbGRWYWx1ZUV4cHIodHMsIHByZWMpO1xuXG5cdFx0XHRcdGlmIChkb3duc3RyZWFtRXhwciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIGVycm9yIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gY3JlYXRlZFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQ2hhaW5FeHByKHNpdGUsIHVwc3RyZWFtRXhwciwgZG93bnN0cmVhbUV4cHIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChlcXVhbHNQb3MgIT0gLTEgJiYgZXF1YWxzUG9zIDwgc2VtaWNvbG9uUG9zKSB7XG5cdFx0XHRpZiAocHJpbnRQb3MgIT0gLTEpIHtcblx0XHRcdFx0aWYgKHByaW50UG9zIDw9IHNlbWljb2xvblBvcykge1xuXHRcdFx0XHRcdHRzW3ByaW50UG9zXS5zeW50YXhFcnJvcihcImV4cGVjdGVkICc7JyBhZnRlciAncHJpbnQoLi4uKSdcIik7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXF1YWxzID0gdHNbZXF1YWxzUG9zXS5hc3NlcnRTeW1ib2woXCI9XCIpO1xuXG5cdFx0XHRpZiAoIWVxdWFscykge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXF1YWxzU2l0ZSA9IGVxdWFscy5zaXRlO1xuXG5cdFx0XHRjb25zdCBsdHMgPSB0cy5zcGxpY2UoMCwgZXF1YWxzUG9zKTtcblxuXHRcdFx0Y29uc3QgbGhzID0gYnVpbGRBc3NpZ25MaHMoZXF1YWxzU2l0ZSwgbHRzKTtcblx0XHRcdFxuXHRcdFx0YXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRTeW1ib2woXCI9XCIpO1xuXG5cdFx0XHRzZW1pY29sb25Qb3MgPSBTeW1ib2xUb2tlbi5maW5kKHRzLCBcIjtcIik7XG5cdFx0XHRhc3NlcnQoc2VtaWNvbG9uUG9zICE9IC0xKTtcblxuXHRcdFx0bGV0IHVwc3RyZWFtVHMgPSB0cy5zcGxpY2UoMCwgc2VtaWNvbG9uUG9zKTtcblx0XHRcdGlmICh1cHN0cmVhbVRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdGVxdWFsc1NpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBleHByZXNzaW9uIGJldHdlZW4gJz0nIGFuZCAnOydcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB1cHN0cmVhbUV4cHIgPSBidWlsZFZhbHVlRXhwcih1cHN0cmVhbVRzLCBwcmVjICsgMSk7XG5cblx0XHRcdGNvbnN0IHNlbWljb2xvbiAgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBlcXVhbHNTaXRlKT8uYXNzZXJ0U3ltYm9sKFwiO1wiKTtcblxuXHRcdFx0aWYgKCFzZW1pY29sb24pIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbWljb2xvblNpdGUgPSBzZW1pY29sb24uc2l0ZTtcblxuXHRcdFx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHNlbWljb2xvblNpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBleHByZXNzaW9uIGFmdGVyICc7J1wiKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRvd25zdHJlYW1FeHByID0gYnVpbGRWYWx1ZUV4cHIodHMsIHByZWMpO1xuXG5cdFx0XHRpZiAoZG93bnN0cmVhbUV4cHIgPT09IG51bGwgfHwgdXBzdHJlYW1FeHByID09PSBudWxsIHx8IGxocyA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBlcnJvciB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHRocm93biBpbnRlcm5hbGx5XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBc3NpZ25FeHByKGVxdWFsc1NpdGUsIGxocywgdXBzdHJlYW1FeHByLCBkb3duc3RyZWFtRXhwcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChwcmludFBvcyAhPSAtMSAmJiBwcmludFBvcyA8IHNlbWljb2xvblBvcykge1xuXHRcdFx0aWYgKGVxdWFsc1BvcyAhPSAtMSkge1xuXHRcdFx0XHRpZiAoZXF1YWxzUG9zIDw9IHNlbWljb2xvblBvcykge1xuXHRcdFx0XHRcdHRzW2VxdWFsc1Bvc10uc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnOycgYWZ0ZXIgJy4uLj0uLi4nXCIpO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByaW50ID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRXb3JkKFwicHJpbnRcIik7XG5cblx0XHRcdGlmICghcHJpbnQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByaW50U2l0ZSA9IHByaW50LnNpdGU7XG5cblx0XHRcdGNvbnN0IG1heWJlUGFyZW5zID0gdHMuc2hpZnQoKTtcblxuXHRcdFx0aWYgKG1heWJlUGFyZW5zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dHNbcHJpbnRQb3NdLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgJyguLi4pJyBhZnRlciAncHJpbnQnXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHBhcmVucyA9IG1heWJlUGFyZW5zLmFzc2VydEdyb3VwKFwiKFwiLCAxKTtcblxuXHRcdFx0XHRpZiAoIXBhcmVucykge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbXNnRXhwciA9IGJ1aWxkVmFsdWVFeHByKHBhcmVucy5maWVsZHNbMF0pO1xuXG5cdFx0XHRcdGNvbnN0IHNlbWljb2xvbiA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIHBhcmVucy5zaXRlKT8uYXNzZXJ0U3ltYm9sKFwiO1wiKVxuXG5cdFx0XHRcdGlmICghc2VtaWNvbG9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBzZW1pY29sb25TaXRlID0gc2VtaWNvbG9uLnNpdGU7XG5cblx0XHRcdFx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0c2VtaWNvbG9uU2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIGV4cHJlc3Npb24gYWZ0ZXIgJzsnXCIpO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZG93bnN0cmVhbUV4cHIgPSBidWlsZFZhbHVlRXhwcih0cywgcHJlYyk7XG5cblx0XHRcdFx0aWYgKCFkb3duc3RyZWFtRXhwciB8fCAhbXNnRXhwcikge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQcmludEV4cHIocHJpbnRTaXRlLCBtc2dFeHByLCBkb3duc3RyZWFtRXhwcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRzWzBdLnN5bnRheEVycm9yKFwidW5oYW5kbGVkXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTd2l0Y2hDYXNlXG4gKiBAcmV0dXJucyB7RGVzdHJ1Y3RFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGREZXN0cnVjdEV4cHIoc2l0ZSwgdHMsIGlzU3dpdGNoQ2FzZSA9IGZhbHNlKSB7XG5cdGlmICh0cy5sZW5ndGggPT0gMCkge1xuXHRcdHNpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCB0b2tlbiBpbnNpZGUgZGVzdHJ1Y3R1cmluZyBicmFjZXNcIik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRsZXQgbWF5YmVOYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgc2l0ZSk7XG5cblx0aWYgKCFtYXliZU5hbWUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChtYXliZU5hbWUuaXNXb3JkKFwiX1wiKSkge1xuXHRcdGlmICh0cy5sZW5ndGggIT0gMCkge1xuXHRcdFx0bWF5YmVOYW1lLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlbnMgYWZ0ZXIgJ18nXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgRGVzdHJ1Y3RFeHByKG5ldyBXb3JkKG1heWJlTmFtZS5zaXRlLCBcIl9cIiksIG51bGwpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsZXQgbmFtZSA9IG5ldyBXb3JkKG1heWJlTmFtZS5zaXRlLCBcIl9cIik7XG5cblx0XHRpZiAodHMubGVuZ3RoID49IDEgJiYgdHNbMF0uaXNTeW1ib2woXCI6XCIpKSB7XG5cdFx0XHRsZXQgbmFtZV8gPSBtYXliZU5hbWUuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0XHRcdGlmICghbmFtZV8pIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWUgPSBuYW1lXztcblxuXHRcdFx0Y29uc3QgY29sb24gPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBuYW1lLnNpdGUpPy5hc3NlcnRTeW1ib2woXCI6XCIpO1xuXG5cdFx0XHRpZiAoIWNvbG9uKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdFx0Y29sb24uc3ludGF4RXJyb3IoXCJleHBlY3RlZCB0eXBlIGV4cHJlc3Npb24gYWZ0ZXIgJzonXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gXG5cblx0XHRcdGNvbnN0IGRlc3RydWN0RXhwcnMgPSBidWlsZERlc3RydWN0RXhwcnModHMpO1xuXG5cdFx0XHRpZiAoZGVzdHJ1Y3RFeHBycyA9PT0gbnVsbCB8fCBkZXN0cnVjdEV4cHJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZUV4cHIgPSBidWlsZFR5cGVFeHByKGNvbG9uLnNpdGUsIHRzKTtcblxuXHRcdFx0aWYgKCF0eXBlRXhwcikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBEZXN0cnVjdEV4cHIobmFtZSwgdHlwZUV4cHIsIGRlc3RydWN0RXhwcnMpO1xuXHRcdH0gZWxzZSBpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdGlmIChpc1N3aXRjaENhc2UpIHtcblx0XHRcdFx0Y29uc3QgdHlwZU5hbWUgPSBtYXliZU5hbWUuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0XHRcdFx0aWYgKCF0eXBlTmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdHlwZUV4cHIgPSBuZXcgVHlwZVJlZkV4cHIodHlwZU5hbWUpO1xuXG5cdFx0XHRcdGlmICghdHlwZUV4cHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBcblxuXHRcdFx0XHRyZXR1cm4gbmV3IERlc3RydWN0RXhwcihuYW1lLCB0eXBlRXhwcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBuYW1lID0gbWF5YmVOYW1lLmFzc2VydFdvcmQoKT8uYXNzZXJ0Tm90S2V5d29yZCgpO1xuXG5cdFx0XHRcdGlmICghbmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBEZXN0cnVjdEV4cHIobmFtZSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRzLnVuc2hpZnQobWF5YmVOYW1lKTtcblxuXHRcdFx0Y29uc3QgZGVzdHJ1Y3RFeHBycyA9IGJ1aWxkRGVzdHJ1Y3RFeHBycyh0cyk7XG5cblx0XHRcdGlmIChkZXN0cnVjdEV4cHJzID09PSBudWxsIHx8IGRlc3RydWN0RXhwcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XG5cdFx0XHRjb25zdCB0eXBlRXhwciA9IGJ1aWxkVHlwZUV4cHIoc2l0ZSwgdHMpO1xuXG5cdFx0XHRpZiAoIXR5cGVFeHByKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IERlc3RydWN0RXhwcihuYW1lLCB0eXBlRXhwciwgZGVzdHJ1Y3RFeHBycyk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUG9wcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRzIGlmIGl0IGlzIGEgYnJhY2VzIGdyb3VwXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcmV0dXJucyB7bnVsbCB8IERlc3RydWN0RXhwcltdfVxuICovXG5mdW5jdGlvbiBidWlsZERlc3RydWN0RXhwcnModHMpIHtcblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9IGVsc2UgaWYgKHRzW3RzLmxlbmd0aCAtMV0uaXNHcm91cChcIntcIikpIHtcblx0XHRjb25zdCBncm91cCA9IGFzc2VydERlZmluZWQodHMucG9wKCkpLmFzc2VydEdyb3VwKFwie1wiKTtcblxuXHRcdGlmICghZ3JvdXApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRlc3RydWN0RXhwcnMgPSBncm91cC5maWVsZHMubWFwKGZ0cyA9PiB7XG5cdFx0XHRyZXR1cm4gYnVpbGREZXN0cnVjdEV4cHIoZ3JvdXAuc2l0ZSwgZnRzKTtcblx0XHR9KTtcblx0XG5cdFx0aWYgKGRlc3RydWN0RXhwcnMuZXZlcnkobGUgPT4gbGUgIT09IG51bGwgJiYgbGUuaXNJZ25vcmVkKCkgJiYgIWxlLmhhc0Rlc3RydWN0RXhwcnMoKSkpIHtcblx0XHRcdGdyb3VwLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHVzZWQgZmllbGQgd2hpbGUgZGVzdHJ1Y3R1cmluZ1wiKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlZHVjZU51bGwoZGVzdHJ1Y3RFeHBycyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XHRcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtudWxsIHwgRGVzdHJ1Y3RFeHByW119XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQXNzaWduTGhzKHNpdGUsIHRzKSB7XG5cdGNvbnN0IG1heWJlTmFtZSA9IHRzLnNoaWZ0KCk7XG5cdGlmIChtYXliZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHNpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBhIG5hbWUgYmVmb3JlICc9J1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7RGVzdHJ1Y3RFeHByW119XG5cdFx0ICovXG5cdFx0Y29uc3QgcGFpcnMgPSBbXTtcblxuXHRcdGlmIChtYXliZU5hbWUuaXNXb3JkKCkpIHtcblx0XHRcdHRzLnVuc2hpZnQobWF5YmVOYW1lKTtcblxuXHRcdFx0Y29uc3QgbGhzID0gYnVpbGREZXN0cnVjdEV4cHIobWF5YmVOYW1lLnNpdGUsIHRzKTtcblxuXHRcdFx0aWYgKGxocyA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAobGhzLmlzSWdub3JlZCgpICYmICFsaHMuaGFzRGVzdHJ1Y3RFeHBycygpKSB7XG5cdFx0XHRcdG1heWJlTmFtZS5zeW50YXhFcnJvcihgdW51c2VkIGFzc2lnbm1lbnQgJHttYXliZU5hbWUudG9TdHJpbmcoKX1gKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHBhaXJzLnB1c2gobGhzKTtcblx0XHR9IGVsc2UgaWYgKG1heWJlTmFtZS5pc0dyb3VwKFwiKFwiKSkge1xuXHRcdFx0Y29uc3QgZ3JvdXAgPSBtYXliZU5hbWUuYXNzZXJ0R3JvdXAoXCIoXCIpO1xuXG5cdFx0XHRpZiAoIWdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3JvdXAuZmllbGRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0Z3JvdXAuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBhdCBsZWFzdCAyIGxocycgZm9yIG11bHRpLWFzc2lnblwiKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBzb21lTm9uZVVuZGVyc2NvcmUgPSBmYWxzZTtcblx0XHRcdGZvciAobGV0IGZ0cyBvZiBncm91cC5maWVsZHMpIHtcblx0XHRcdFx0aWYgKGZ0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGdyb3VwLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCBlbXB0eSBmaWVsZCBmb3IgbXVsdGktYXNzaWduXCIpO1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnRzID0gZnRzLnNsaWNlKCk7XG5cblx0XHRcdFx0Y29uc3QgbGhzID0gYnVpbGREZXN0cnVjdEV4cHIoZ3JvdXAuc2l0ZSwgZnRzKTtcblxuXHRcdFx0XHRpZiAoIWxocykge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIWxocy5pc0lnbm9yZWQoKSB8fCBsaHMuaGFzRGVzdHJ1Y3RFeHBycygpKSB7XG5cdFx0XHRcdFx0c29tZU5vbmVVbmRlcnNjb3JlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIHRoYXQgbmFtZSBpcyB1bmlxdWVcblx0XHRcdFx0cGFpcnMuZm9yRWFjaChwID0+IHtcblx0XHRcdFx0XHRpZiAoIWxocy5pc0lnbm9yZWQoKSAmJiBwLm5hbWUudmFsdWUgPT09IGxocy5uYW1lLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRsaHMubmFtZS5zeW50YXhFcnJvcihgZHVwbGljYXRlIG5hbWUgJyR7bGhzLm5hbWUudmFsdWV9JyBpbiBsaHMgb2YgbXVsdGktYXNzaWduYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwYWlycy5wdXNoKGxocyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc29tZU5vbmVVbmRlcnNjb3JlKSB7XG5cdFx0XHRcdGdyb3VwLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIG5vbi11bmRlcnNjb3JlIGluIGxocyBvZiBtdWx0aS1hc3NpZ25cIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXliZU5hbWUuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHN5bnRheCBmb3IgbGhzIG9mID1cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFpcnM7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gc3ltYm9sIFxuICogQHJldHVybnMgeyh0czogVG9rZW5bXSwgcHJlYzogbnVtYmVyKSA9PiAoVmFsdWVFeHByIHwgbnVsbCl9XG4gKi9cbmZ1bmN0aW9uIG1ha2VCaW5hcnlFeHByQnVpbGRlcihzeW1ib2wpIHtcblx0Ly8gZGVmYXVsdCBiZWhhdmlvdXIgaXMgbGVmdC10by1yaWdodCBhc3NvY2lhdGl2ZVxuXHRyZXR1cm4gZnVuY3Rpb24gKHRzLCBwcmVjKSB7XG5cdFx0Y29uc3QgaU9wID0gU3ltYm9sVG9rZW4uZmluZExhc3QodHMsIHN5bWJvbCk7XG5cblx0XHRpZiAoaU9wID09IHRzLmxlbmd0aCAtIDEpIHtcblx0XHRcdC8vIHBvc3QtdW5hcnkgb3BlcmF0b3IsIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdHRzW2lPcF0uc3ludGF4RXJyb3IoYGludmFsaWQgc3ludGF4LCAnJHt0c1tpT3BdLnRvU3RyaW5nKCl9JyBjYW4ndCBiZSB1c2VkIGFzIGEgcG9zdC11bmFyeSBvcGVyYXRvcmApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIGlmIChpT3AgPiAwKSB7IC8vIGlPcCA9PSAwIG1lYW5zIG1heWJlIGEgKHByZSl1bmFyeSBvcCwgd2hpY2ggaXMgaGFuZGxlZCBieSBhIGhpZ2hlciBwcmVjZWRlbmNlXG5cdFx0XHRjb25zdCBhID0gYnVpbGRWYWx1ZUV4cHIodHMuc2xpY2UoMCwgaU9wKSwgcHJlYyk7XG5cdFx0XHRjb25zdCBiID0gYnVpbGRWYWx1ZUV4cHIodHMuc2xpY2UoaU9wICsgMSksIHByZWMgKyAxKTtcblx0XHRcdGNvbnN0IG9wID0gdHNbaU9wXS5hc3NlcnRTeW1ib2woKTtcblxuXHRcdFx0aWYgKCFhIHx8ICFiIHx8ICFvcCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCaW5hcnlFeHByKG9wLCBhLCBiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGJ1aWxkVmFsdWVFeHByKHRzLCBwcmVjICsgMSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBzeW1ib2wgXG4gKiBAcmV0dXJucyB7KHRzOiBUb2tlbltdLCBwcmVjOiBudW1iZXIpID0+IChWYWx1ZUV4cHIgfCBudWxsKX1cbiAqL1xuZnVuY3Rpb24gbWFrZVVuYXJ5RXhwckJ1aWxkZXIoc3ltYm9sKSB7XG5cdC8vIGRlZmF1bHQgYmVoYXZpb3VyIGlzIHJpZ2h0LXRvLWxlZnQgYXNzb2NpYXRpdmVcblx0cmV0dXJuIGZ1bmN0aW9uICh0cywgcHJlYykge1xuXHRcdGlmICh0c1swXS5pc1N5bWJvbChzeW1ib2wpKSB7XG5cdFx0XHRjb25zdCByaHMgPSBidWlsZFZhbHVlRXhwcih0cy5zbGljZSgxKSwgcHJlYyk7XG5cdFx0XHRjb25zdCBvcCA9IHRzWzBdLmFzc2VydFN5bWJvbCgpO1xuXG5cdFx0XHRpZiAoIXJocyB8fCAhb3ApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgVW5hcnlFeHByKG9wLCByaHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYnVpbGRWYWx1ZUV4cHIodHMsIHByZWMgKyAxKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjIFxuICogQHJldHVybnMge1ZhbHVlRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ2hhaW5lZFZhbHVlRXhwcih0cywgcHJlYykge1xuXHQvKiogQHR5cGUge1ZhbHVlRXhwciB8IG51bGx9ICovXG5cdGxldCBleHByID0gYnVpbGRDaGFpblN0YXJ0VmFsdWVFeHByKHRzKTtcblxuXHQvLyBub3cgd2UgY2FuIHBhcnNlIHRoZSByZXN0IG9mIHRoZSBjaGFpbmluZ1xuXHR3aGlsZSAodHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChleHByID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCB0ID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKTtcblxuXHRcdGlmICh0LmlzR3JvdXAoXCIoXCIpKSB7XG5cdFx0XHRleHByID0gYnVpbGRDYWxsRXhwcih0LnNpdGUsIGV4cHIsIGFzc2VydERlZmluZWQodC5hc3NlcnRHcm91cCgpKSk7XG5cdFx0fSBlbHNlIGlmICh0LmlzR3JvdXAoXCJbXCIpKSB7XG5cdFx0XHR0LnN5bnRheEVycm9yKFwiaW52YWxpZCBleHByZXNzaW9uICdbLi4uXSdcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHQuaXNTeW1ib2woXCIuXCIpICYmIHRzLmxlbmd0aCA+IDAgJiYgdHNbMF0uaXNXb3JkKFwic3dpdGNoXCIpKSB7XG5cdFx0XHRleHByID0gYnVpbGRTd2l0Y2hFeHByKGV4cHIsIHRzKTtcblx0XHR9IGVsc2UgaWYgKHQuaXNTeW1ib2woXCIuXCIpKSB7XG5cdFx0XHRjb25zdCBuYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgdC5zaXRlKT8uYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0XHRcdGlmICghbmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZXhwciA9IG5ldyBNZW1iZXJFeHByKHQuc2l0ZSwgZXhwciwgbmFtZSk7XG5cdFx0fSBlbHNlIGlmICh0LmlzR3JvdXAoXCJ7XCIpKSB7XG5cdFx0XHR0LnN5bnRheEVycm9yKFwiaW52YWxpZCBzeW50YXhcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHQuaXNTeW1ib2woXCI6OlwiKSkge1xuXHRcdFx0dC5zeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQuc3ludGF4RXJyb3IoYGludmFsaWQgc3ludGF4ICcke3QudG9TdHJpbmcoKX0nYCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZXhwcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG4gKiBAcGFyYW0ge1ZhbHVlRXhwcn0gZm5FeHByIFxuICogQHBhcmFtIHtHcm91cH0gcGFyZW5zXG4gKiBAcmV0dXJucyB7Q2FsbEV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZENhbGxFeHByKHNpdGUsIGZuRXhwciwgcGFyZW5zKSB7XG5cdGNvbnN0IGNhbGxBcmdzID0gYnVpbGRDYWxsQXJncyhwYXJlbnMpO1xuXG5cdGlmIChjYWxsQXJncyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuZXcgQ2FsbEV4cHIoc2l0ZSwgZm5FeHByLCBjYWxsQXJncyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtWYWx1ZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZENoYWluU3RhcnRWYWx1ZUV4cHIodHMpIHtcblx0aWYgKHRzLmxlbmd0aCA+IDEgJiYgdHNbMF0uaXNHcm91cChcIihcIikgJiYgdHNbMV0uaXNTeW1ib2woXCItPlwiKSkge1xuXHRcdHJldHVybiBidWlsZEZ1bmNMaXRlcmFsRXhwcih0cywgbnVsbCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZiAodHNbMF0uaXNXb3JkKFwiaWZcIikpIHtcblx0XHRyZXR1cm4gYnVpbGRJZkVsc2VFeHByKHRzKTtcblx0fSBlbHNlIGlmICh0c1swXS5pc1dvcmQoXCJzd2l0Y2hcIikpIHtcblx0XHR0c1swXS5zeW50YXhFcnJvcihcImV4cGVjdGVkICcuLi4gLnN3aXRjaCcgaW5zdGVhZCBvZiAnc3dpdGNoJ1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0c1swXS5pc0xpdGVyYWwoKSkge1xuXHRcdHJldHVybiBuZXcgUHJpbWl0aXZlTGl0ZXJhbEV4cHIoYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKSk7IC8vIGNhbiBzaW1wbHkgYmUgcmV1c2VkXG5cdH0gZWxzZSBpZiAodHNbMF0uaXNHcm91cChcIihcIikpIHtcblx0XHRyZXR1cm4gYnVpbGRQYXJlbnNFeHByKHRzKTtcblx0fSBlbHNlIGlmIChHcm91cC5maW5kKHRzLCBcIntcIikgIT0gLTEpIHtcblx0XHRpZiAodHNbMF0uaXNHcm91cChcIltcIikpIHtcblx0XHRcdHJldHVybiBidWlsZExpc3RMaXRlcmFsRXhwcih0cyk7XG5cdFx0fSBlbHNlIGlmICh0c1swXS5pc1dvcmQoXCJNYXBcIikgJiYgdHNbMV0uaXNHcm91cChcIltcIikpIHtcblx0XHRcdHJldHVybiBidWlsZE1hcExpdGVyYWxFeHByKHRzKTsgXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvdWxkIGJlIHN3aXRjaCBvciBsaXRlcmFsIHN0cnVjdCBjb25zdHJ1Y3Rpb25cblx0XHRcdGNvbnN0IGlCcmFjZXMgPSBHcm91cC5maW5kKHRzLCBcIntcIik7XG5cdFx0XHRjb25zdCBpU3dpdGNoID0gV29yZC5maW5kKHRzLCBcInN3aXRjaFwiKTtcblx0XHRcdGNvbnN0IGlQZXJpb2QgPSBTeW1ib2xUb2tlbi5maW5kKHRzLCBcIi5cIik7XG5cblx0XHRcdGlmIChpU3dpdGNoICE9IC0xICYmIGlQZXJpb2QgIT0gLTEgJiYgaVN3aXRjaCA8IGlCcmFjZXMgJiYgaVBlcmlvZCA8IGlCcmFjZXMgJiYgaVN3aXRjaCA+IGlQZXJpb2QpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkVmFsdWVFeHByKHRzLnNwbGljZSgwLCBpUGVyaW9kKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGRTdHJ1Y3RMaXRlcmFsRXhwcih0cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKFN5bWJvbFRva2VuLmZpbmQodHMsIFwiOjpcIikgIT0gLTEpIHtcblx0XHRyZXR1cm4gYnVpbGRWYWx1ZVBhdGhFeHByKHRzKTtcblx0fSBlbHNlIGlmICh0c1swXS5pc1dvcmQoKSkge1xuXHRcdGlmICh0c1swXS5pc1dvcmQoXCJjb25zdFwiKSB8fCB0c1swXS5pc1dvcmQoXCJzdHJ1Y3RcIikgfHwgdHNbMF0uaXNXb3JkKFwiZW51bVwiKSB8fCB0c1swXS5pc1dvcmQoXCJmdW5jXCIpIHx8IHRzWzBdLmlzV29yZChcImltcG9ydFwiKSkge1xuXHRcdFx0dHNbMF0uc3ludGF4RXJyb3IoYGludmFsaWQgdXNlIG9mICcke2Fzc2VydERlZmluZWQodHNbMF0uYXNzZXJ0V29yZCgpKS52YWx1ZX0nLCBjYW4gb25seSBiZSB1c2VkIGFzIHRvcC1sZXZlbCBzdGF0ZW1lbnRgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBuYW1lID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpPy5hc3NlcnRXb3JkKCkpO1xuXG5cdFx0XHRpZiAobmFtZS52YWx1ZSA9PSBcInNlbGZcIikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFZhbHVlUmVmRXhwcihuYW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG4gPSBuYW1lLmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRcdFx0XHRpZiAoIW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVmFsdWVSZWZFeHByKG4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0c1swXS5zeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHNcbiAqIEByZXR1cm5zIHtWYWx1ZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZFBhcmVuc0V4cHIodHMpIHtcblx0Y29uc3QgZ3JvdXAgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydEdyb3VwKFwiKFwiKTtcblxuXHRpZiAoIWdyb3VwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBzaXRlID0gZ3JvdXAuc2l0ZTtcblxuXHRpZiAoZ3JvdXAuZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdGdyb3VwLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGV4cHIgaW4gcGFyZW5zXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGZpZWxkcyA9IGdyb3VwLmZpZWxkcy5tYXAoZnRzID0+IGJ1aWxkVmFsdWVFeHByKGZ0cykpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1ZhbHVlRXhwcltdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IG5vbk51bGxGaWVsZHMgPSBbXTtcblxuXHRcdGZpZWxkcy5mb3JFYWNoKGYgPT4ge1xuXHRcdFx0aWYgKGYgIT09IG51bGwpIHtcblx0XHRcdFx0bm9uTnVsbEZpZWxkcy5wdXNoKGYpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKG5vbk51bGxGaWVsZHMubGVuZ3RoID09IDApIHtcblx0XHRcdC8vIGVycm9yIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gdGhyb3duIGludGVybmFsbHlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBhcmVuc0V4cHIoc2l0ZSwgbm9uTnVsbEZpZWxkcyk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7R3JvdXB9IHBhcmVucyBcbiAqIEByZXR1cm5zIHtDYWxsQXJnRXhwcltdIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRDYWxsQXJncyhwYXJlbnMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cblx0ICovXG5cdGNvbnN0IG5hbWVzID0gbmV3IFNldCgpO1xuXG5cdGNvbnN0IGNhbGxBcmdzID0gcmVkdWNlTnVsbChwYXJlbnMuZmllbGRzLm1hcChmdHMgPT4ge1xuXHRcdGNvbnN0IGNhbGxBcmcgPSBidWlsZENhbGxBcmdFeHByKHBhcmVucy5zaXRlLCBmdHMpO1xuXG5cdFx0aWYgKGNhbGxBcmcgIT09IG51bGwgJiYgY2FsbEFyZy5pc05hbWVkKCkpIHtcblx0XHRcdGlmIChuYW1lcy5oYXMoY2FsbEFyZy5uYW1lKSkge1xuXHRcdFx0XHRjYWxsQXJnLnN5bnRheEVycm9yKGBkdXBsaWNhdGUgbmFtZWQgY2FsbCBhcmcgJHtjYWxsQXJnLm5hbWV9YCk7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzLmFkZChjYWxsQXJnLm5hbWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYWxsQXJnO1xuXHR9KSk7XG5cblx0aWYgKGNhbGxBcmdzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGNhbGxBcmdzLnNvbWUoY2EgPT4gY2EuaXNOYW1lZCgpKSAmJiBjYWxsQXJncy5zb21lKGNhID0+ICFjYS5pc05hbWVkKCkpKSB7XG5cdFx0XHRjYWxsQXJnc1swXS5zeW50YXhFcnJvcihcImNhbid0IG1peCBwb3NpdGlvbmFsIGFuZCBuYW1lZCBhcmdzXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhbGxBcmdzO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtDYWxsQXJnRXhwciB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ2FsbEFyZ0V4cHIoc2l0ZSwgdHMpIHtcblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudWxsIHwgdW5kZWZpbmVkIHwgV29yZH1cblx0ICovXG5cdGxldCBuYW1lID0gbnVsbDtcblxuXHRpZiAodHMubGVuZ3RoID49IDIgJiYgdHNbMF0uaXNXb3JkKCkgJiYgdHNbMV0uaXNTeW1ib2woXCI6XCIpKSB7XG5cdFx0bmFtZSA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbG9uID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKTtcblxuXHRcdGlmICh0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0Y29sb24uc3ludGF4RXJyb3IoXCJleHBlY3RlZCB2YWx1ZSBleHByZXNzaW9ucyBhZnRlciAnOidcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2YWx1ZSA9IGJ1aWxkVmFsdWVFeHByKHRzKTtcblxuXHRpZiAoIXZhbHVlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gbmV3IENhbGxBcmdFeHByKG5hbWUgIT0gbnVsbCA/IG5hbWUuc2l0ZSA6IHZhbHVlLnNpdGUsIG5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtJZkVsc2VFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRJZkVsc2VFeHByKHRzKSB7XG5cdGNvbnN0IGlmV29yZCA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0V29yZChcImlmXCIpO1xuXG5cdGlmICghaWZXb3JkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBzaXRlID0gaWZXb3JkLnNpdGU7XG5cblx0LyoqIEB0eXBlIHtWYWx1ZUV4cHJbXX0gKi9cblx0Y29uc3QgY29uZGl0aW9ucyA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7VmFsdWVFeHByW119ICovXG5cdGNvbnN0IGJyYW5jaGVzID0gW107XG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Y29uc3QgcGFyZW5zID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgc2l0ZSk/LmFzc2VydEdyb3VwKFwiKFwiKTtcblxuXHRcdGlmICghcGFyZW5zKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBicmFjZXMgPSBhc3NlcnRUb2tlbih0cy5zaGlmdCgpLCBzaXRlKT8uYXNzZXJ0R3JvdXAoXCJ7XCIpO1xuXG5cdFx0aWYgKCFicmFjZXMpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChwYXJlbnMuZmllbGRzLmxlbmd0aCAhPSAxKSB7XG5cdFx0XHRwYXJlbnMuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBzaW5nbGUgaWYtZWxzZSBjb25kaXRpb25cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoYnJhY2VzLmZpZWxkcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0YnJhY2VzLnN5bnRheEVycm9yKFwiYnJhbmNoIGJvZHkgY2FuJ3QgYmUgZW1wdHlcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGJyYWNlcy5maWVsZHMubGVuZ3RoICE9IDEpIHtcblx0XHRcdGJyYWNlcy5zeW50YXhFcnJvcihcImV4cGVjdGVkIHNpbmdsZSBpZi1lbHNlIGJyYW5jaCBleHBlc3Npb25cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBjb25kID0gYnVpbGRWYWx1ZUV4cHIocGFyZW5zLmZpZWxkc1swXSk7XG5cdFx0Y29uc3QgYnJhbmNoID0gYnVpbGRWYWx1ZUV4cHIoYnJhY2VzLmZpZWxkc1swXSk7XG5cblx0XHRpZiAoY29uZCA9PT0gbnVsbCB8fCBicmFuY2ggPT09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbmRpdGlvbnMucHVzaChjb25kKTtcblx0XHRicmFuY2hlcy5wdXNoKGJyYW5jaCk7XG5cblx0XHRjb25zdCBtYXliZUVsc2UgPSB0cy5zaGlmdCgpO1xuXG5cdFx0aWYgKG1heWJlRWxzZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gYWRkIGEgdm9pZCBlbHNlIGJyYW5jaFxuXHRcdFx0YnJhbmNoZXMucHVzaChuZXcgVm9pZEV4cHIoYnJhY2VzLnNpdGUpKTtcblx0XHRcdGJyZWFrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBlbHNlV29yZCA9IG1heWJlRWxzZS5hc3NlcnRXb3JkKFwiZWxzZVwiKTtcblxuXHRcdFx0aWYgKCFlbHNlV29yZCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmV4dCA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIGVsc2VXb3JkLnNpdGUpO1xuXG5cdFx0XHRpZiAoIW5leHQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKG5leHQuaXNHcm91cChcIntcIikpIHtcblx0XHRcdFx0Ly8gbGFzdCBncm91cFxuXHRcdFx0XHRjb25zdCBicmFjZXMgPSBuZXh0LmFzc2VydEdyb3VwKCk7XG5cblx0XHRcdFx0aWYgKCFicmFjZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChicmFjZXMuZmllbGRzLmxlbmd0aCAhPSAxKSB7XG5cdFx0XHRcdFx0YnJhY2VzLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgc2luZ2xlIGV4cGVzc2lvbiBmb3IgaWYtZWxzZSBicmFuY2hcIik7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBlbHNlQnJhbmNoID0gYnVpbGRWYWx1ZUV4cHIoYnJhY2VzLmZpZWxkc1swXSk7XG5cblx0XHRcdFx0aWYgKCFlbHNlQnJhbmNoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmFuY2hlcy5wdXNoKGVsc2VCcmFuY2gpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSBpZiAobmV4dC5pc1dvcmQoXCJpZlwiKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5leHQuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2VuXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3IElmRWxzZUV4cHIoc2l0ZSwgY29uZGl0aW9ucywgYnJhbmNoZXMpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1ZhbHVlRXhwcn0gY29udHJvbEV4cHJcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7VmFsdWVFeHByIHwgbnVsbH0gLSBFbnVtU3dpdGNoRXhwciBvciBEYXRhU3dpdGNoRXhwclxuICovXG5mdW5jdGlvbiBidWlsZFN3aXRjaEV4cHIoY29udHJvbEV4cHIsIHRzKSB7XG5cdGNvbnN0IHN3aXRjaFdvcmQgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydFdvcmQoXCJzd2l0Y2hcIik7XG5cblx0aWYgKCFzd2l0Y2hXb3JkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBzaXRlID0gc3dpdGNoV29yZC5zaXRlO1xuXG5cdGNvbnN0IGJyYWNlcyA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIHNpdGUpPy5hc3NlcnRHcm91cChcIntcIik7XG5cblx0aWYgKCFicmFjZXMpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKiBAdHlwZSB7U3dpdGNoQ2FzZVtdfSAqL1xuXHRjb25zdCBjYXNlcyA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IFN3aXRjaERlZmF1bHR9ICovXG5cdGxldCBkZWYgPSBudWxsO1xuXG5cdGZvciAobGV0IHRzSW5uZXIgb2YgYnJhY2VzLmZpZWxkcykge1xuXHRcdGlmICh0c0lubmVyWzBdLmlzV29yZChcImVsc2VcIikgfHwgdHNJbm5lclswXS5pc1dvcmQoXCJfXCIpKSB7XG5cdFx0XHRpZiAoZGVmICE9PSBudWxsKSB7XG5cdFx0XHRcdGRlZi5zeW50YXhFcnJvcihcImR1cGxpY2F0ZSBkZWZhdWx0IGNhc2UgaW4gc3dpdGNoXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZGVmID0gYnVpbGRTd2l0Y2hEZWZhdWx0KHRzSW5uZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoZGVmICE9PSBudWxsKSB7XG5cdFx0XHRcdGRlZi5zeW50YXhFcnJvcihcInN3aXRjaCBkZWZhdWx0IGNhc2UgbXVzdCBjb21lIGxhc3RcIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjID0gYnVpbGRTd2l0Y2hDYXNlKHRzSW5uZXIpO1xuXG5cdFx0XHRpZiAoYyA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhc2VzLnB1c2goYyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gY2hlY2sgdGhlIHVuaXF1ZW5lc3Mgb2YgZWFjaCBjYXNlIGhlcmVcblx0LyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cblx0Y29uc3Qgc2V0ID0gbmV3IFNldCgpXG5cdGZvciAobGV0IGMgb2YgY2FzZXMpIHtcblx0XHRsZXQgdCA9IGMubWVtYmVyTmFtZS50b1N0cmluZygpO1xuXHRcdGlmIChzZXQuaGFzKHQpKSB7XG5cdFx0XHRjLm1lbWJlck5hbWUuc3ludGF4RXJyb3IoYGR1cGxpY2F0ZSBzd2l0Y2ggY2FzZSAnJHt0fScpYCk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRzZXQuYWRkKHQpO1xuXHR9XG5cblx0aWYgKGNhc2VzLmxlbmd0aCA8IDEpIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHN3aXRjaCBjYXNlXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKGNhc2VzLnNvbWUoYyA9PiBjLmlzRGF0YU1lbWJlcigpKSkge1xuXHRcdGlmIChjYXNlcy5sZW5ndGggKyAoZGVmID09PSBudWxsID8gMCA6IDEpID4gNSkge1xuXHRcdFx0c2l0ZS5zeW50YXhFcnJvcihgdG9vIG1hbnkgY2FzZXMgZm9yIGRhdGEgc3dpdGNoLCBleHBlY3RlZCA1IG9yIGxlc3MsIGdvdCAke2Nhc2VzLmxlbmd0aC50b1N0cmluZygpfWApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRjYXNlcy5mb3JFYWNoKGMgPT4ge2lmICghYy5pc0RhdGFNZW1iZXIoKSl7Y291bnQrK319KTtcblxuXHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRzaXRlLnN5bnRheEVycm9yKGBleHBlY3RlZCBhdCBtb3N0IDEgZW51bSBjYXNlIGluIGRhdGEgc3dpdGNoLCBnb3QgJHtjb3VudH1gKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoY291bnQgPT09IDEgJiYgY2FzZXMuc29tZShjID0+IGMgaW5zdGFuY2VvZiBVbmNvbnN0ckRhdGFTd2l0Y2hDYXNlKSkge1xuXHRcdFx0XHRcdHNpdGUuc3ludGF4RXJyb3IoYGNhbid0IGhhdmUgYm90aCBlbnVtIGFuZCAoSW50LCBbXURhdGEpIGluIGRhdGEgc3dpdGNoYCk7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBEYXRhU3dpdGNoRXhwcihzaXRlLCBjb250cm9sRXhwciwgY2FzZXMsIGRlZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBFbnVtU3dpdGNoRXhwcihzaXRlLCBjb250cm9sRXhwciwgY2FzZXMsIGRlZik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWZ0ZXJDb2xvblxuICogQHJldHVybnMge1dvcmQgfCBudWxsfSBcbiAqL1xuZnVuY3Rpb24gYnVpbGRTd2l0Y2hDYXNlTmFtZShzaXRlLCB0cywgaXNBZnRlckNvbG9uKSB7XG5cdGNvbnN0IGZpcnN0ID0gdHMuc2hpZnQoKTtcblxuXHRpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChpc0FmdGVyQ29sb24pIHtcblx0XHRcdHNpdGUuc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN3aXRjaCBjYXNlIHN5bnRheCwgZXhwZWN0ZWQgbWVtYmVyIG5hbWUgYWZ0ZXIgJzonXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpdGUuc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN3aXRjaCBjYXNlIHN5bnRheFwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXHRcdFxuXHRpZiAoZmlyc3QuaXNXb3JkKFwiTWFwXCIpKSB7XG5cdFx0Y29uc3Qgc2Vjb25kID0gdHMuc2hpZnQoKTtcblxuXHRcdGlmICghc2Vjb25kKSB7XG5cdFx0XHRzaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgdG9rZW4gYWZ0ZXIgJ01hcCdcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCBrZXlUcyA9IHNlY29uZC5hc3NlcnRHcm91cChcIltdXCIsIDEpPy5maWVsZHNbMF07XG5cblx0XHRpZiAoa2V5VHMgPT09IHVuZGVmaW5lZCB8fCBrZXlUcyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga2V5ID0ga2V5VHMuc2hpZnQoKTtcblxuXHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2Vjb25kLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgJ01hcFtEYXRhXURhdGEnXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0a2V5LmFzc2VydFdvcmQoXCJEYXRhXCIpO1xuXG5cdFx0aWYgKGtleVRzLmxlbmd0aCA+IDApIHtcblx0XHRcdGtleVRzWzBdLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlbiBhZnRlciAnRGF0YSdcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCB0aGlyZCA9IHRzLnNoaWZ0KCk7XG5cblx0XHRpZiAodGhpcmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIHRva2VuIGFmdGVyICdNYXBbRGF0YV1cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlyZC5hc3NlcnRXb3JkKFwiRGF0YVwiKTtcblxuXHRcdGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0c1swXS5zeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW4gYWZ0ZXIgJ01hcFtEYXRhXURhdGEnXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBXb3JkKGZpcnN0LnNpdGUsIFwiTWFwW0RhdGFdRGF0YVwiKTtcblx0fSBlbHNlIGlmIChmaXJzdC5pc1dvcmQoKSkge1xuXHRcdGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0c1swXS5zeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmlyc3Q/LmFzc2VydFdvcmQoKT8uYXNzZXJ0Tm90S2V5d29yZCgpID8/IG51bGw7XG5cdH0gZWxzZSBpZiAoZmlyc3QuaXNHcm91cChcIltcIikpIHtcblx0XHQvLyBsaXN0IFxuXHRcdGZpcnN0LmFzc2VydEdyb3VwKFwiW1wiLCAwKTtcblxuXHRcdGNvbnN0IHNlY29uZCA9IHRzLnNoaWZ0KCk7XG5cblx0XHRpZiAoc2Vjb25kID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHNpdGUuc3ludGF4RXJyb3IoXCJleHBlY3RlZCB0b2tlbiBhZnRlciAnW10nXCIpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIGlmICh0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0c1swXS5zeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRzZWNvbmQuYXNzZXJ0V29yZChcIkRhdGFcIik7XG5cblx0XHRyZXR1cm4gbmV3IFdvcmQoZmlyc3Quc2l0ZSwgXCJbXURhdGFcIik7XG5cdH0gZWxzZSB7XG5cdFx0Zmlyc3Quc3ludGF4RXJyb3IoXCJpbnZhbGlkIHN3aXRjaCBjYXNlIG5hbWUgc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7U3dpdGNoQ2FzZSB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3dpdGNoQ2FzZSh0cykge1xuXHRjb25zdCBhcnJvd1BvcyA9IFN5bWJvbFRva2VuLmZpbmQodHMsIFwiPT5cIik7XG5cblx0aWYgKGFycm93UG9zID09IC0xKSB7XG5cdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnPT4nIGluIHN3aXRjaCBjYXNlXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKGFycm93UG9zID09IDApIHtcblx0XHR0c1swXS5zeW50YXhFcnJvcihcImV4cGVjdGVkICc8d29yZD4nIG9yICc8d29yZD46IDx3b3JkPicgdG8gdGhlIGxlZnQgb2YgJz0+J1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHRzTGVmdCA9IHRzLnNwbGljZSgwLCBhcnJvd1Bvcyk7XG5cblx0aWYgKHRzTGVmdC5sZW5ndGggPT09IDEgJiYgdHNMZWZ0WzBdLmlzR3JvdXAoXCIoXCIpKSB7XG5cdFx0cmV0dXJuIGJ1aWxkTXVsdGlBcmdTd2l0Y2hDYXNlKHRzTGVmdCwgdHMpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBidWlsZFNpbmdsZUFyZ1N3aXRjaENhc2UodHNMZWZ0LCB0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtudWxsIHwgWz9Xb3JkLCBXb3JkXX0gLSB2YXJOYW1lIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3dpdGNoQ2FzZU5hbWVUeXBlKHRzKSB7XG5cdGNvbnN0IGNvbG9uUG9zID0gU3ltYm9sVG9rZW4uZmluZCh0cywgXCI6XCIpO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IFdvcmR9ICovXG5cdGxldCB2YXJOYW1lID0gbnVsbDtcblxuXHQvKiogQHR5cGUge251bGwgfCBXb3JkfSAqL1xuXHRsZXQgbWVtYmVyTmFtZSA9IG51bGw7XG5cblx0aWYgKGNvbG9uUG9zICE9IC0xKSB7XG5cdFx0Y29uc3QgbWF5YmVWYXJOYW1lID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRXb3JkKCk/LmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRcdGlmICghbWF5YmVWYXJOYW1lKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXJOYW1lID0gbWF5YmVWYXJOYW1lO1xuXHRcdFxuXHRcdGNvbnN0IG1heWJlQ29sb24gPSB0cy5zaGlmdCgpO1xuXG5cdFx0aWYgKG1heWJlQ29sb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyTmFtZS5zeW50YXhFcnJvcihcImludmFsaWQgc3dpdGNoIGNhc2Ugc3ludGF4LCBleHBlY3RlZCAnKDxuYW1lPjogPGVudW0tbWVtYmVyPiknLCBnb3QgJyg8bmFtZT4pJ1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2b2lkIG1heWJlQ29sb24uYXNzZXJ0U3ltYm9sKFwiOlwiKTtcblxuXHRcdFx0bWVtYmVyTmFtZSA9IGJ1aWxkU3dpdGNoQ2FzZU5hbWUobWF5YmVDb2xvbi5zaXRlLCB0cywgdHJ1ZSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdG1lbWJlck5hbWUgPSBidWlsZFN3aXRjaENhc2VOYW1lKHRzWzBdLnNpdGUsIHRzLCBmYWxzZSk7XG5cdH1cblxuXHRpZiAodHMubGVuZ3RoICE9PSAwKSB7XG5cdFx0dHNbMF0uc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2VuXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKG1lbWJlck5hbWUgPT09IG51bGwpIHtcblx0XHQvLyBlcnJvciB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHRocm93biBpbnRlcm5hbGx5XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFt2YXJOYW1lLCBtZW1iZXJOYW1lXTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzTGVmdFxuICogQHBhcmFtIHtUb2tlbltdfSB0c1xuICogQHJldHVybnMge1N3aXRjaENhc2UgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZE11bHRpQXJnU3dpdGNoQ2FzZSh0c0xlZnQsIHRzKSB7XG5cdGNvbnN0IHBhcmVucyA9IGFzc2VydERlZmluZWQodHNMZWZ0LnNoaWZ0KCkpLmFzc2VydEdyb3VwKFwiKFwiKTtcblxuXHRpZiAoIXBhcmVucykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgcGFpcnMgPSByZWR1Y2VOdWxsKHBhcmVucy5maWVsZHMubWFwKGZ0cyA9PiBidWlsZFN3aXRjaENhc2VOYW1lVHlwZShmdHMpKSk7XG5cblx0aWYgKHBhaXJzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhc3NlcnQodHNMZWZ0Lmxlbmd0aCA9PT0gMCk7XG5cblx0aWYgKHBhaXJzLmxlbmd0aCAhPT0gMikge1xuXHRcdHBhcmVucy5zeW50YXhFcnJvcihgZXhwZWN0ZWQgKEludCwgW11EYXRhKSBjYXNlLCBnb3QgKCR7cGFpcnMubWFwKHAgPT4gcFsxXS52YWx1ZSkuam9pbihcIiwgXCIpfWApO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHBhaXJzWzBdWzFdLnZhbHVlICE9IFwiSW50XCIgfHwgcGFpcnNbMV1bMV0udmFsdWUgIT0gXCJbXURhdGFcIikge1xuXHRcdHBhcmVucy5zeW50YXhFcnJvcihgZXhwZWN0ZWQgKEludCwgW11EYXRhKSBjYXNlLCBnb3QgKCR7cGFpcnNbMF1bMV0udmFsdWV9LCAke3BhaXJzWzFdWzFdLnZhbHVlfSlgKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBtYXliZUFycm93ID0gdHMuc2hpZnQoKTtcblxuXHRcdGlmIChtYXliZUFycm93ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmVucy5zeW50YXhFcnJvcihcImV4cGVjdGVkICc9PidcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgYXJyb3cgPSBtYXliZUFycm93LmFzc2VydFN5bWJvbChcIj0+XCIpO1xuXG5cdFx0XHRpZiAoIWFycm93KSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib2R5RXhwciA9IGJ1aWxkU3dpdGNoQ2FzZUJvZHkoYXJyb3cuc2l0ZSwgdHMpO1xuXG5cdFx0XHRpZiAoYm9keUV4cHIgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFVuY29uc3RyRGF0YVN3aXRjaENhc2UoYXJyb3cuc2l0ZSwgcGFpcnNbMF1bMF0sIHBhaXJzWzFdWzBdLCBib2R5RXhwcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHNMZWZ0IFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtTd2l0Y2hDYXNlIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRTaW5nbGVBcmdTd2l0Y2hDYXNlKHRzTGVmdCwgdHMpIHtcblx0Y29uc3Qgc2l0ZSA9IHRzTGVmdFt0c0xlZnQubGVuZ3RoLTFdLnNpdGU7XG5cblx0Y29uc3QgZGVzdHJ1Y3RFeHByID0gYnVpbGREZXN0cnVjdEV4cHIoc2l0ZSwgdHNMZWZ0LCB0cnVlKTtcblxuXHRpZiAoZGVzdHJ1Y3RFeHByID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoIWRlc3RydWN0RXhwci5oYXNUeXBlKCkpIHtcblx0XHRkZXN0cnVjdEV4cHIuc2l0ZS5zeW50YXhFcnJvcihcImludmFsaWQgc3dpdGNoIGNhc2Ugc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdFxuXHRjb25zdCBtYXliZUFycm93ID0gdHMuc2hpZnQoKTtcblxuXHRpZiAobWF5YmVBcnJvdyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkICc9PidcIik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgYXJyb3cgPSBtYXliZUFycm93LmFzc2VydFN5bWJvbChcIj0+XCIpO1xuXG5cdFx0aWYgKCFhcnJvdykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYm9keUV4cHIgPSBidWlsZFN3aXRjaENhc2VCb2R5KGFycm93LnNpdGUsIHRzKTtcblxuXHRcdGlmIChib2R5RXhwciA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgU3dpdGNoQ2FzZShhcnJvdy5zaXRlLCBkZXN0cnVjdEV4cHIsIGJvZHlFeHByKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtWYWx1ZUV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZFN3aXRjaENhc2VCb2R5KHNpdGUsIHRzKSB7XG5cdC8qKiBAdHlwZSB7P1ZhbHVlRXhwcn0gKi9cblx0bGV0IGJvZHlFeHByID0gbnVsbDtcblxuXHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciAnPT4nXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHRzWzBdLmlzR3JvdXAoXCJ7XCIpKSB7XG5cdFx0aWYgKHRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRzWzFdLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCB0b2tlblwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRzQm9keSA9IHRzWzBdLmFzc2VydEdyb3VwKFwie1wiLCAxKT8uZmllbGRzWzBdO1xuXG5cdFx0aWYgKHRzQm9keSA9PT0gdW5kZWZpbmVkIHx8IHRzQm9keSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ym9keUV4cHIgPSBidWlsZFZhbHVlRXhwcih0c0JvZHkpO1xuXHR9IGVsc2Uge1xuXHRcdGJvZHlFeHByID0gYnVpbGRWYWx1ZUV4cHIodHMpO1xuXHR9XG5cblx0cmV0dXJuIGJvZHlFeHByO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge1N3aXRjaERlZmF1bHQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZFN3aXRjaERlZmF1bHQodHMpIHtcblx0Y29uc3QgZWxzZVdvcmQgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydFdvcmQoKTtcblxuXHRpZiAoIWVsc2VXb3JkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoIShlbHNlV29yZC5pc1dvcmQoXCJlbHNlXCIpIHx8IGVsc2VXb3JkLmlzV29yZChcIl9cIikpKSB7XG5cdFx0ZWxzZVdvcmQuc3ludGF4RXJyb3IoXCJleHBlY3RlZCAnZWxzZScgb3IgJ18nXCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3Qgc2l0ZSA9IGVsc2VXb3JkLnNpdGU7XG5cblx0Y29uc3QgbWF5YmVBcnJvdyA9IHRzLnNoaWZ0KCk7XG5cdGlmIChtYXliZUFycm93ID09PSB1bmRlZmluZWQpIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKGBleHBlY3RlZCAnPT4nIGFmdGVyICcke2Vsc2VXb3JkLnZhbHVlfSdgKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBhcnJvdyA9IG1heWJlQXJyb3cuYXNzZXJ0U3ltYm9sKFwiPT5cIik7XG5cblx0XHRpZiAoIWFycm93KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge251bGwgfCBWYWx1ZUV4cHJ9ICovXG5cdFx0bGV0IGJvZHlFeHByID0gbnVsbDtcblxuXHRcdGlmICh0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0YXJyb3cuc3ludGF4RXJyb3IoXCJleHBlY3RlZCBleHByZXNzaW9uIGFmdGVyICc9PidcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHRzWzBdLmlzR3JvdXAoXCJ7XCIpKSB7XG5cdFx0XHRpZiAodHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0c1sxXS5zeW50YXhFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5cIik7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgYm9keVRzID0gdHNbMF0uYXNzZXJ0R3JvdXAoXCJ7XCIsIDEpPy5maWVsZHNbMF07XG5cblx0XHRcdFx0aWYgKGJvZHlUcyA9PT0gdW5kZWZpbmVkIHx8IGJvZHlUcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ym9keUV4cHIgPSBidWlsZFZhbHVlRXhwcihib2R5VHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRib2R5RXhwciA9IGJ1aWxkVmFsdWVFeHByKHRzKTtcblx0XHR9XG5cblx0XHRpZiAoIWJvZHlFeHByKSB7XG5cdFx0XHRhcnJvdy5zeW50YXhFcnJvcihcImVtcHR5IHN3aXRjaCBkZWZhdWx0IGNhc2UgYm9keVwiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU3dpdGNoRGVmYXVsdChhcnJvdy5zaXRlLCBib2R5RXhwcik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtUb2tlbltdfSB0cyBcbiAqIEByZXR1cm5zIHtMaXN0TGl0ZXJhbEV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZExpc3RMaXRlcmFsRXhwcih0cykge1xuXHRjb25zdCBncm91cCA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0R3JvdXAoXCJbXCIsIDApO1xuXG5cdGlmICghZ3JvdXApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHNpdGUgPSBncm91cC5zaXRlO1xuXG5cdGNvbnN0IGJyYWNlc1BvcyA9IEdyb3VwLmZpbmQodHMsIFwie1wiKTtcblxuXHRpZiAoYnJhY2VzUG9zID09IC0xKSB7XG5cdFx0c2l0ZS5zeW50YXhFcnJvcihcImludmFsaWQgbGlzdCBsaXRlcmFsIGV4cHJlc3Npb24gc3ludGF4XCIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgaXRlbVR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihzaXRlLCB0cy5zcGxpY2UoMCwgYnJhY2VzUG9zKSk7XG5cblx0aWYgKCFpdGVtVHlwZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGJyYWNlcyA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIHNpdGUpPy5hc3NlcnRHcm91cChcIntcIik7XG5cblx0aWYgKCFicmFjZXMpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGl0ZW1FeHBycyA9IHJlZHVjZU51bGwoYnJhY2VzLmZpZWxkcy5tYXAoZnRzID0+IGJ1aWxkVmFsdWVFeHByKGZ0cykpKTtcblxuXHRpZiAoaXRlbUV4cHJzID09PSBudWxsKSB7XG5cdFx0Ly8gZXJyb3Igd2lsbCBoYXZlIGFscmVhZHkgYmVlbiB0aHJvd24gaW50ZXJuYWxseVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBMaXN0TGl0ZXJhbEV4cHIoc2l0ZSwgaXRlbVR5cGVFeHByLCBpdGVtRXhwcnMpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcmV0dXJucyB7TWFwTGl0ZXJhbEV4cHIgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZE1hcExpdGVyYWxFeHByKHRzKSB7XG5cdGNvbnN0IG1hcFdvcmQgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydFdvcmQoXCJNYXBcIik7XG5cblx0aWYgKCFtYXBXb3JkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBzaXRlID0gbWFwV29yZC5zaXRlO1xuXG5cdGNvbnN0IGJyYWNrZXQgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydEdyb3VwKFwiW1wiLCAxKTtcblxuXHRpZiAoIWJyYWNrZXQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGtleVR5cGVFeHByID0gYnVpbGRUeXBlRXhwcihzaXRlLCBicmFja2V0LmZpZWxkc1swXSk7XG5cblx0aWYgKCFrZXlUeXBlRXhwcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgYnJhY2VzUG9zID0gR3JvdXAuZmluZCh0cywgXCJ7XCIpO1xuXG5cdGlmIChicmFjZXNQb3MgPT0gLTEpIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwiaW52YWxpZCBtYXAgbGl0ZXJhbCBleHByZXNzaW9uIHN5bnRheFwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IHZhbHVlVHlwZUV4cHIgPSBidWlsZFR5cGVFeHByKHNpdGUsIHRzLnNwbGljZSgwLCBicmFjZXNQb3MpKTtcblxuXHRpZiAoIXZhbHVlVHlwZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGNvbnN0IGJyYWNlcyA9IGFzc2VydERlZmluZWQodHMuc2hpZnQoKSkuYXNzZXJ0R3JvdXAoXCJ7XCIpO1xuXG5cdGlmICghYnJhY2VzKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge251bGwgfCBbVmFsdWVFeHByLCBWYWx1ZUV4cHJdW119XG5cdCAqL1xuXHRjb25zdCBwYWlycyA9IHJlZHVjZU51bGxQYWlycyhicmFjZXMuZmllbGRzLm1hcChmdHMgPT4ge1xuXHRcdGNvbnN0IGNvbG9uUG9zID0gU3ltYm9sVG9rZW4uZmluZChmdHMsIFwiOlwiKTtcblxuXHRcdGlmIChjb2xvblBvcyA9PSAtMSkge1xuXHRcdFx0aWYgKGZ0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRicmFjZXMuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIGVtcHR5IGZpZWxkXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnRzWzBdLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgJzonIGluIG1hcCBsaXRlcmFsIGZpZWxkXCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY29sb25Qb3MgPT0gMCkge1xuXHRcdFx0ZnRzW2NvbG9uUG9zXS5zeW50YXhFcnJvcihcImV4cGVjdGVkIGV4cHJlc3Npb24gYmVmb3JlICc6JyBpbiBtYXAgbGl0ZXJhbCBmaWVsZFwiKTtcblx0XHR9IGVsc2UgaWYgKGNvbG9uUG9zID09IGZ0cy5sZW5ndGggLSAxKSB7XG5cdFx0XHRmdHNbY29sb25Qb3NdLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgZXhwcmVzc2lvbiBhZnRlciAnOicgaW4gbWFwIGxpdGVyYWwgZmllbGRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGtleUV4cHIgPSBidWlsZFZhbHVlRXhwcihmdHMuc2xpY2UoMCwgY29sb25Qb3MpKTtcblxuXHRcdFx0Y29uc3QgdmFsdWVFeHByID0gYnVpbGRWYWx1ZUV4cHIoZnRzLnNsaWNlKGNvbG9uUG9zKzEpKTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAdHlwZSB7W1ZhbHVlRXhwciB8IG51bGwsIFZhbHVlRXhwciB8IG51bGxdfVxuXHRcdFx0ICovXG5cdFx0XHRyZXR1cm4gW2tleUV4cHIsIHZhbHVlRXhwcl07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtudWxsLCBudWxsXTtcblx0fSkpO1xuXG5cdGlmIChwYWlycyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBNYXBMaXRlcmFsRXhwcihzaXRlLCBrZXlUeXBlRXhwciwgdmFsdWVUeXBlRXhwciwgcGFpcnMpO1xufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge1N0cnVjdExpdGVyYWxFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHJ1Y3RMaXRlcmFsRXhwcih0cykge1xuXHRjb25zdCBicmFjZXNQb3MgPSBHcm91cC5maW5kKHRzLCBcIntcIik7XG5cblx0YXNzZXJ0KGJyYWNlc1BvcyAhPSAtMSk7XG5cblx0Y29uc3Qgc2l0ZSA9IHRzW2JyYWNlc1Bvc10uc2l0ZTtcblxuXHRpZiAoYnJhY2VzUG9zID09IDApIHtcblx0XHRzaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgc3RydWN0IHR5cGUgYmVmb3JlIGJyYWNlc1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRcblx0Y29uc3QgdHlwZUV4cHIgPSBidWlsZFR5cGVFeHByKHNpdGUsIHRzLnNwbGljZSgwLCBicmFjZXNQb3MpKTtcblxuXHRpZiAoIXR5cGVFeHByKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBicmFjZXMgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpLmFzc2VydEdyb3VwKFwie1wiKTtcblxuXHRpZiAoIWJyYWNlcykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Y29uc3QgZmllbGRzID0gcmVkdWNlTnVsbChicmFjZXMuZmllbGRzLm1hcChmdHMgPT4gYnVpbGRTdHJ1Y3RMaXRlcmFsRmllbGQoYnJhY2VzLnNpdGUsIGZ0cykpKTtcblxuXHRpZiAoZmllbGRzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gXG5cdFxuXHRpZiAoZmllbGRzLmV2ZXJ5KGYgPT4gZi5pc05hbWVkKCkpIHx8IGZpZWxkcy5ldmVyeShmID0+ICFmLmlzTmFtZWQoKSkpIHtcblx0XHRyZXR1cm4gbmV3IFN0cnVjdExpdGVyYWxFeHByKHR5cGVFeHByLCBmaWVsZHMpO1xuXHR9IGVsc2Uge1xuXHRcdGJyYWNlcy5zaXRlLnN5bnRheEVycm9yKFwibWFuZ2xlZCBsaXRlcmFsIHN0cnVjdCAoaGludDogc3BlY2lmeSBhbGwgZmllbGRzIHBvc2l0aW9uYWxseSBvciBhbGwgd2l0aCBrZXlzKVwiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKiBAcGFyYW0ge1NpdGV9IHNpdGUgLSBzaXRlIG9mIHRoZSBicmFjZXNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHNcbiAqIEByZXR1cm5zIHtTdHJ1Y3RMaXRlcmFsRmllbGQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBidWlsZFN0cnVjdExpdGVyYWxGaWVsZChzaXRlLCB0cykge1xuXHRpZiAodHMubGVuZ3RoID4gMiAmJiB0c1swXS5pc1dvcmQoKSAmJiB0c1sxXS5pc1N5bWJvbChcIjpcIikpIHtcblx0XHRyZXR1cm4gYnVpbGRTdHJ1Y3RMaXRlcmFsTmFtZWRGaWVsZChzaXRlLCB0cyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGJ1aWxkU3RydWN0TGl0ZXJhbFVubmFtZWRGaWVsZChzaXRlLCB0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICogQHBhcmFtIHtTaXRlfSBzaXRlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzXG4gKiBAcmV0dXJucyB7U3RydWN0TGl0ZXJhbEZpZWxkIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHJ1Y3RMaXRlcmFsTmFtZWRGaWVsZChzaXRlLCB0cykge1xuXHRjb25zdCBuYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgc2l0ZSwgXCJlbXB0eSBzdHJ1Y3QgbGl0ZXJhbCBmaWVsZFwiKT8uYXNzZXJ0V29yZCgpPy5hc3NlcnROb3RLZXl3b3JkKCk7XG5cblx0aWYgKCFuYW1lKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBjb2xvbiA9IGFzc2VydFRva2VuKHRzLnNoaWZ0KCksIG5hbWUuc2l0ZSwgXCJleHBlY3RlZCAnOicgYWZ0ZXIgc3RydWN0IGZpZWxkIG5hbWVcIik/LmFzc2VydFN5bWJvbChcIjpcIik7XG5cblx0aWYgKCFjb2xvbikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKHRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0Y29sb24uc3ludGF4RXJyb3IoXCJleHBlY3RlZCBleHByZXNzaW9uIGFmdGVyICc6J1wiKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRjb25zdCB2YWx1ZUV4cHIgPSBidWlsZFZhbHVlRXhwcih0cyk7XG5cblx0aWYgKCF2YWx1ZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBuZXcgU3RydWN0TGl0ZXJhbEZpZWxkKG5hbWUsIHZhbHVlRXhwcik7XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7U2l0ZX0gc2l0ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0c1xuICogQHJldHVybnMge1N0cnVjdExpdGVyYWxGaWVsZCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3RydWN0TGl0ZXJhbFVubmFtZWRGaWVsZChzaXRlLCB0cykge1xuXHRjb25zdCB2YWx1ZUV4cHIgPSBidWlsZFZhbHVlRXhwcih0cyk7XG5cblx0aWYgKCF2YWx1ZUV4cHIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBuZXcgU3RydWN0TGl0ZXJhbEZpZWxkKG51bGwsIHZhbHVlRXhwcik7XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7VmFsdWVFeHByIHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRWYWx1ZVBhdGhFeHByKHRzKSB7XG5cdGNvbnN0IGRjb2xvblBvcyA9IFN5bWJvbFRva2VuLmZpbmRMYXN0KHRzLCBcIjo6XCIpO1xuXG5cdGFzc2VydChkY29sb25Qb3MgIT0gLTEpO1xuXG5cdGNvbnN0IHR5cGVFeHByID0gYnVpbGRUeXBlRXhwcih0c1tkY29sb25Qb3NdLnNpdGUsIHRzLnNwbGljZSgwLCBkY29sb25Qb3MpKTtcblxuXHRpZiAoIXR5cGVFeHByKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBkY29sb24gPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCk/LmFzc2VydFN5bWJvbChcIjo6XCIpKTtcblxuXHRjb25zdCBtZW1iZXJOYW1lID0gYXNzZXJ0VG9rZW4odHMuc2hpZnQoKSwgZGNvbG9uLnNpdGUpPy5hc3NlcnRXb3JkKCk/LmFzc2VydE5vdEtleXdvcmQoKTtcblxuXHRpZiAoIW1lbWJlck5hbWUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRcblx0cmV0dXJuIG5ldyBWYWx1ZVBhdGhFeHByKHR5cGVFeHByLCBtZW1iZXJOYW1lKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAxOTogSVIgZGVmaW5pdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogRm9yIGNvbGxlY3RpbmcgdGVzdCBjb3ZlcmFnZSBzdGF0aXN0aWNzXG4gKiBAdHlwZSB7PygobmFtZTogc3RyaW5nLCBjb3VudDogbnVtYmVyKSA9PiB2b2lkKX1cbiAqL1xudmFyIG9uTm90aWZ5UmF3VXNhZ2UgPSBudWxsO1xuXG4vKipcbiAqIFNldCB0aGUgc3RhdGlzdGljcyBjb2xsZWN0b3IgKHVzZWQgYnkgdGhlIHRlc3Qtc3VpdGUpXG4gKiBAcGFyYW0geyhuYW1lOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpID0+IHZvaWR9IGNhbGxiYWNrIFxuICovXG5mdW5jdGlvbiBzZXRSYXdVc2FnZU5vdGlmaWVyKGNhbGxiYWNrKSB7XG5cdG9uTm90aWZ5UmF3VXNhZ2UgPSBjYWxsYmFjaztcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGZvciBhIGJ1aWx0aW4gZnVuY3Rpb24gKHdyaXR0ZW4gaW4gSVIpXG4gKi9cbmNsYXNzIFJhd0Z1bmMge1xuXHQjbmFtZTtcblx0I2RlZmluaXRpb247XG5cblx0LyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cblx0I2RlcGVuZGVuY2llcztcblxuXHQvKipcblx0ICogQ29uc3RydWN0IGEgUmF3RnVuYywgYW5kIGltbWVkaWF0ZWx5IHNjYW4gdGhlIGRlZmluaXRpb24gZm9yIGRlcGVuZGVuY2llc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRlZmluaXRpb24gXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihuYW1lLCBkZWZpbml0aW9uKSB7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0YXNzZXJ0KGRlZmluaXRpb24gIT0gdW5kZWZpbmVkKTtcblx0XHR0aGlzLiNkZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblx0XHR0aGlzLiNkZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG5cblx0XHRsZXQgcmUgPSBuZXcgUmVnRXhwKFwiX19oZWxpb3NfX1thLXpBLVpfMC05XSpcIiwgXCJnXCIpO1xuXG5cdFx0bGV0IG1hdGNoZXMgPSB0aGlzLiNkZWZpbml0aW9uLm1hdGNoKHJlKTtcblxuXHRcdGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG5cdFx0XHRcdHRoaXMuI2RlcGVuZGVuY2llcy5hZGQobWF0Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvYWRzICd0aGlzLiNkZXBlbmRlY2llcycgKGlmIG5vdCBhbHJlYWR5IGxvYWRlZCksIHRoZW4gbG9hZCAndGhpcydcblx0ICogQHBhcmFtIHtNYXA8c3RyaW5nLCBSYXdGdW5jPn0gZGIgXG5cdCAqIEBwYXJhbSB7TWFwPHN0cmluZywgSVI+fSBkc3QgXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0bG9hZChkYiwgZHN0KSB7XG5cdFx0aWYgKG9uTm90aWZ5UmF3VXNhZ2UgIT09IG51bGwpIHtcblx0XHRcdG9uTm90aWZ5UmF3VXNhZ2UodGhpcy4jbmFtZSwgMSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRzdC5oYXModGhpcy4jbmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgZGVwIG9mIHRoaXMuI2RlcGVuZGVuY2llcykge1xuXHRcdFx0XHRpZiAoIWRiLmhhcyhkZXApKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbEVycm9yOiBkZXBlbmRlbmN5ICR7ZGVwfSBpcyBub3QgYSBidWlsdGluYCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXNzZXJ0RGVmaW5lZChkYi5nZXQoZGVwKSkubG9hZChkYiwgZHN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkc3Quc2V0KHRoaXMuI25hbWUsIG5ldyBJUihyZXBsYWNlVGFicyh0aGlzLiNkZWZpbml0aW9uKSkpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBkYiBjb250YWluaW5nIGFsbCB0aGUgYnVpbHRpbiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBSYXdGdW5jPn1cbiAqL1xuLy8gb25seSBuZWVkIHRvIHdyYXAgdGhlc2Ugc291cmNlIGluIElSIHJpZ2h0IGF0IHRoZSB2ZXJ5IGVuZFxuZnVuY3Rpb24gbWFrZVJhd0Z1bmN0aW9ucygpIHtcblx0LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBSYXdGdW5jPn0gKi9cblx0bGV0IGRiID0gbmV3IE1hcCgpO1xuXG5cdC8vIGxvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmF3RnVuY30gZm4gXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGQoZm4pIHtcblx0XHRpZiAoZGIuaGFzKGZuLm5hbWUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGJ1aWx0aW4gJHtmbi5uYW1lfSBkdXBsaWNhdGVgKTtcblx0XHR9XG5cdFx0ZGIuc2V0KGZuLm5hbWUsIGZuKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGJhc2ljIGF1dG8gbWVtYmVycyB0byBhIGZ1bGx5IG5hbWVkIHR5cGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5zIFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkRGF0YUZ1bmNzKG5zKSB7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGAke25zfV9fX19lcWAsIFwiX19oZWxpb3NfX2NvbW1vbl9fX19lcVwiKSk7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGAke25zfV9fX19uZXFgLCBcIl9faGVsaW9zX19jb21tb25fX19fbmVxXCIpKTtcblx0XHRhZGQobmV3IFJhd0Z1bmMoYCR7bnN9X19zZXJpYWxpemVgLCBcIl9faGVsaW9zX19jb21tb25fX3NlcmlhbGl6ZVwiKSk7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGAke25zfV9fZnJvbV9kYXRhYCwgXCJfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eVwiKSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBiYXNpYyBhdXRvIG1lbWJlcnMgdG8gYSBmdWxseSBuYW1lZCBlbnVtIHR5cGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5zIFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkRW51bURhdGFGdW5jcyhucykge1xuXHRcdGFkZChuZXcgUmF3RnVuYyhgJHtuc31fX19fZXFgLCBcIl9faGVsaW9zX19jb21tb25fX19fZXFcIikpO1xuXHRcdGFkZChuZXcgUmF3RnVuYyhgJHtuc31fX19fbmVxYCwgXCJfX2hlbGlvc19fY29tbW9uX19fX25lcVwiKSk7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGAke25zfV9fc2VyaWFsaXplYCwgXCJfX2hlbGlvc19fY29tbW9uX19zZXJpYWxpemVcIikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB0aGUgSVIgbmVlZGVkIHRvIHVud3JhcCBhIFBsdXR1cy1jb3JlIGNvbnN0ckRhdGFcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRhdGFFeHByXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpQ29uc3RyIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaUZpZWxkIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JFeHByIFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gdW5EYXRhKGRhdGFFeHByLCBpQ29uc3RyLCBpRmllbGQsIGVycm9yRXhwciA9IFwiZXJyb3IoXFxcInVuZXhwZWN0ZWQgY29uc3RydWN0b3IgaW5kZXhcXFwiKVwiKSB7XG5cdFx0bGV0IGlubmVyID0gXCJfX2NvcmVfX3NuZFBhaXIocGFpcilcIjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGlGaWVsZDsgaSsrKSB7XG5cdFx0XHRpbm5lciA9IGBfX2NvcmVfX3RhaWxMaXN0KCR7aW5uZXJ9KWA7XG5cdFx0fVxuXG5cdFx0Ly8gZGVmZXJyZWQgZXZhbHVhdGlvbiBvZiBpZlRoZW5FbHNlIGJyYW5jaGVzXG5cdFx0cmV0dXJuIGAocGFpcikgLT4ge19fY29yZV9faWZUaGVuRWxzZShfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19mc3RQYWlyKHBhaXIpLCAke2lDb25zdHJ9KSwgKCkgLT4ge19fY29yZV9faGVhZExpc3QoJHtpbm5lcn0pfSwgKCkgLT4geyR7ZXJyb3JFeHByfX0pKCl9KF9fY29yZV9fdW5Db25zdHJEYXRhKCR7ZGF0YUV4cHJ9KSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB2ZXJib3NlIElSIGZvciB1bndyYXBwaW5nIGEgUGx1dHVzLWNvcmUgY29uc3RyRGF0YS5cblx0ICogSWYgY29uZmlnLkRFQlVHID09PSBmYWxzZSB0aGVuIHJldHVybnMgSVIgd2l0aG91dCBwcmludCBzdGF0ZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRhdGFFeHByXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb25zdHJOYW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpQ29uc3RyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpRmllbGRcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHVuRGF0YVZlcmJvc2UoZGF0YUV4cHIsIGNvbnN0ck5hbWUsIGlDb25zdHIsIGlGaWVsZCkge1xuXHRcdGlmICghY29uZmlnLkRFQlVHKSB7XG5cdFx0XHRyZXR1cm4gdW5EYXRhKGRhdGFFeHByLCBpQ29uc3RyLCBpRmllbGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdW5EYXRhKGRhdGFFeHByLCBpQ29uc3RyLCBpRmllbGQsIGBfX2hlbGlvc19fY29tbW9uX192ZXJib3NlX2Vycm9yKF9fY29yZV9fYXBwZW5kU3RyaW5nKFwiYmFkIGNvbnN0ciBmb3IgJHtjb25zdHJOYW1lfSwgd2FudCAke2lDb25zdHIudG9TdHJpbmcoKX0gYnV0IGdvdCBcIiwgX19oZWxpb3NfX2ludF9fc2hvdyhfX2NvcmVfX2ZzdFBhaXIocGFpcikpKCkpKWApXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBJUiBmb3IgY29uc3RydWN0aW5nIGEgbGlzdC5cblx0ICogQnkgZGVmYXVsdCB0aGUgcmVzdWx0IGlzIGtlcHQgYXMgbGlzdCwgYW5kIG5vdCBjb252ZXJ0ZWQgdG8gZGF0YVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRvRGF0YSBcblx0ICogQHJldHVybnMgXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlTGlzdChhcmdzLCB0b0RhdGEgPSBmYWxzZSkge1xuXHRcdGxldCBuID0gYXJncy5sZW5ndGg7XG5cdFx0bGV0IGlubmVyID0gXCJfX2NvcmVfX21rTmlsRGF0YSgoKSlcIjtcblxuXHRcdGZvciAobGV0IGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlubmVyID0gYF9fY29yZV9fbWtDb25zKCR7YXJnc1tpXX0sICR7aW5uZXJ9KWA7XG5cdFx0fVxuXG5cdFx0aWYgKHRvRGF0YSkge1xuXHRcdFx0aW5uZXIgPSBgX19jb3JlX19saXN0RGF0YSgke2lubmVyfSlgXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlubmVyO1xuXHR9XG5cblxuXHQvLyBDb21tb24gYnVpbHRpbnNcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fdmVyYm9zZV9lcnJvclwiLFxuXHRgKG1zZykgLT4ge1xuXHRcdF9fY29yZV9fdHJhY2UobXNnLCAoKSAtPiB7ZXJyb3IoXCJcIil9KSgpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2Fzc2VydF9jb25zdHJfaW5kZXhcIixcblx0YChkYXRhLCBpKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShkYXRhKSksIGkpLFxuXHRcdFx0KCkgLT4ge2RhdGF9LFxuXHRcdFx0KCkgLT4ge2Vycm9yKFwidW5leHBlY3RlZCBjb25zdHJ1Y3RvciBpbmRleFwiKX1cblx0XHQpKClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHlcIixcblx0YChzZWxmKSAtPiB7c2VsZn1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX25vdFwiLFxuXHRgKGIpIC0+IHtcblx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoYiwgZmFsc2UsIHRydWUpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX19fZXFcIiwgXCJfX2NvcmVfX2VxdWFsc0RhdGFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19fX25lcVwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoX19jb3JlX19lcXVhbHNEYXRhKGEsIGIpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19zZXJpYWxpemVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19jb3JlX19iRGF0YShfX2NvcmVfX3NlcmlhbGlzZURhdGEoc2VsZikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19hbnlcIixcblx0YChzZWxmLCBmbikgLT4ge1xuXHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsIGZuKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgc2VsZiwgZm4pIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdCgpIC0+IHtmYWxzZX0sIFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChzZWxmKSksXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHt0cnVlfSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoc2VsZiksIGZuKX1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSgpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19hbGxcIiwgXG5cdGAoc2VsZiwgZm4pIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBzZWxmLCBmbilcblx0XHR9KFxuXHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGZuKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRzZWxmLFxuXHRcdFx0XHRcdCgpIC0+IHt0cnVlfSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdGZuKF9fY29yZV9faGVhZExpc3Qoc2VsZikpLFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KHNlbGYpLCBmbil9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7ZmFsc2V9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fbWFwXCIsXG5cdGAoc2VsZiwgZm4sIGluaXQpIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBzZWxmLCBpbml0KVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgcmVtLCBsc3QpIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdHJlbSxcblx0XHRcdFx0XHQoKSAtPiB7bHN0fSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX21rQ29ucyhcblx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChyZW0pKSwgXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChyZW0pLCBsc3QpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2ZpbHRlclwiLCBcblx0YChzZWxmLCBmbiwgbmlsKSAtPiB7XG5cdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgc2VsZiwgZm4pXG5cdFx0fShcblx0XHRcdChyZWN1cnNlLCBzZWxmLCBmbikgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0c2VsZiwgXG5cdFx0XHRcdFx0KCkgLT4ge25pbH0sIFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChzZWxmKSksXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rQ29ucyhfX2NvcmVfX2hlYWRMaXN0KHNlbGYpLCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoc2VsZiksIGZuKSl9LCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge3JlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChzZWxmKSwgZm4pfVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2ZpbHRlcl9saXN0XCIsIFxuXHRgKHNlbGYsIGZuKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fZmlsdGVyKHNlbGYsIGZuLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzApXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2ZpbHRlcl9tYXBcIixcblx0YChzZWxmLCBmbikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX2ZpbHRlcihzZWxmLCBmbiwgX19jb3JlX19ta05pbFBhaXJEYXRhKCgpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fZmluZFwiLFxuXHRgKHNlbGYsIGZuLCBjYWxsYmFjaykgLT4ge1xuXHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsIGZuKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgc2VsZiwgZm4pIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdCgpIC0+IHtlcnJvcihcIm5vdCBmb3VuZFwiKX0sIFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChzZWxmKSksIFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7Y2FsbGJhY2soX19jb3JlX19oZWFkTGlzdChzZWxmKSl9LCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge3JlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChzZWxmKSwgZm4pfVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2ZpbmRfc2FmZVwiLFxuXHRgKHNlbGYsIGZuLCBjYWxsYmFjaykgLT4ge1xuXHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsIGZuKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgc2VsZiwgZm4pIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX2NvbnN0ckRhdGEoMSwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wKX0sIFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChzZWxmKSksIFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShjYWxsYmFjayhfX2NvcmVfX2hlYWRMaXN0KHNlbGYpKSkpfSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoc2VsZiksIGZuKX1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSgpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19mb2xkXCIsXG5cdGAoc2VsZiwgZm4sIHopIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBzZWxmLCBmbiwgeilcblx0XHR9KFxuXHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGZuLCB6KSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0XHQoKSAtPiB7en0sIFxuXHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoc2VsZiksIGZuLCBmbih6LCBfX2NvcmVfX2hlYWRMaXN0KHNlbGYpKSl9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fZm9sZF9sYXp5XCIsXG5cdGAoc2VsZiwgZm4sIHopIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBzZWxmLCBmbiwgeilcblx0XHR9KFxuXHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGZuLCB6KSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0XHQoKSAtPiB7en0sIFxuXHRcdFx0XHRcdCgpIC0+IHtmbihfX2NvcmVfX2hlYWRMaXN0KHNlbGYpLCAoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KHNlbGYpLCBmbiwgeil9KX1cblx0XHRcdFx0KSgpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19pbnNlcnRfaW5fc29ydGVkXCIsXG5cdGAoeCwgbHN0LCBjb21wKSAtPiB7XG5cdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgbHN0KVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgbHN0KSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRsc3QsXG5cdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtDb25zKHgsIGxzdCl9LFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdChoZWFkKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRjb21wKHgsIGhlYWQpLFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rQ29ucyh4LCBsc3QpfSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19ta0NvbnMoaGVhZCwgcmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KGxzdCkpKX1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3QobHN0KSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fc29ydFwiLCBcblx0YChsc3QsIGNvbXApIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBsc3QpXG5cdFx0fShcblx0XHRcdChyZWN1cnNlLCBsc3QpIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdGxzdCxcblx0XHRcdFx0XHQoKSAtPiB7bHN0fSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHQoaGVhZCwgdGFpbCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19pbnNlcnRfaW5fc29ydGVkKGhlYWQsIHRhaWwsIGNvbXApXG5cdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3QobHN0KSwgcmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KGxzdCkpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSgpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19tYXBfZ2V0XCIsXG5cdGAoc2VsZiwga2V5LCBmbkZvdW5kLCBmbk5vdEZvdW5kKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgc2VsZiwga2V5KVxuXHRcdFx0fShcblx0XHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGtleSkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdFx0Zm5Ob3RGb3VuZCwgXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoa2V5LCBfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChzZWxmKSkpLCBcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7Zm5Gb3VuZChfX2NvcmVfX3NuZFBhaXIoX19jb3JlX19oZWFkTGlzdChzZWxmKSkpfSwgXG5cdFx0XHRcdFx0XHRcdFx0KCkgLT4ge3JlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChzZWxmKSwga2V5KX1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19pc19pbl9ieXRlYXJyYXlfbGlzdFwiLFxuXHRgKGxzdCwga2V5KSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fYW55KGxzdCwgKGl0ZW0pIC0+IHtfX2NvcmVfX2VxdWFsc0RhdGEoaXRlbSwga2V5KX0pXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGFcIixcblx0YChkKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShkKSksIDApLCBcblx0XHRcdGZhbHNlLCBcblx0XHRcdHRydWVcblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhXCIsXG5cdGAoYikgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YShfX2NvcmVfX2lmVGhlbkVsc2UoYiwgMSwgMCksIF9faGVsaW9zX19jb21tb25fX2xpc3RfMClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fdW5TdHJpbmdEYXRhXCIsXG5cdGAoZCkgLT4ge1xuXHRcdF9fY29yZV9fZGVjb2RlVXRmOChfX2NvcmVfX3VuQkRhdGEoZCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGFcIixcblx0YChzKSAtPiB7XG5cdFx0X19jb3JlX19iRGF0YShfX2NvcmVfX2VuY29kZVV0ZjgocykpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2xlbmd0aFwiLCBcblx0YChsc3QpIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0X19jb3JlX19pRGF0YShyZWN1cnNlKHJlY3Vyc2UsIGxzdCkpXG5cdFx0fShcblx0XHRcdChyZWN1cnNlLCBsc3QpIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdGxzdCwgXG5cdFx0XHRcdFx0KCkgLT4gezB9LCBcblx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19hZGRJbnRlZ2VyKHJlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChsc3QpKSwgMSl9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fbWF4XCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKGEsIGIpLFxuXHRcdFx0Yixcblx0XHRcdGFcblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX21pblwiLCBcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0X19jb3JlX19sZXNzVGhhbkVxdWFsc0ludGVnZXIoYSwgYiksXG5cdFx0XHRhLFxuXHRcdFx0YlxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fY29uY2F0XCIsIFxuXHRgKGEsIGIpIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBiLCBhKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgbHN0LCByZW0pIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdHJlbSxcblx0XHRcdFx0XHQoKSAtPiB7bHN0fSxcblx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19ta0NvbnMoX19jb3JlX19oZWFkTGlzdChyZW0pLCByZWN1cnNlKHJlY3Vyc2UsIGxzdCwgX19jb3JlX190YWlsTGlzdChyZW0pKSl9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fc2xpY2VfYnl0ZWFycmF5XCIsXG5cdGAoc2VsZiwgc2VsZkxlbmd0aEZuKSAtPiB7XG5cdFx0KHN0YXJ0LCBlbmQpIC0+IHtcblx0XHRcdChzZWxmKSAtPiB7XG5cdFx0XHRcdChzdGFydCwgZW5kKSAtPiB7XG5cdFx0XHRcdFx0KG5vcm1hbGl6ZSkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19iRGF0YShcblx0XHRcdFx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0Zm4obm9ybWFsaXplKHN0YXJ0KSlcblx0XHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0XHQoc3RhcnQpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbihub3JtYWxpemUoZW5kKSlcblx0XHRcdFx0XHRcdFx0XHRcdH0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdChlbmQpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX3NsaWNlQnl0ZVN0cmluZyhzdGFydCwgX19jb3JlX19zdWJ0cmFjdEludGVnZXIoZW5kLCBfX2hlbGlvc19fY29tbW9uX19tYXgoc3RhcnQsIDApKSwgc2VsZilcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdH0oXG5cdFx0XHRcdFx0XHQocG9zKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihwb3MsIDApLFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fYWRkSW50ZWdlcihfX2NvcmVfX2FkZEludGVnZXIoc2VsZkxlbmd0aEZuKHNlbGYpLCAxKSwgcG9zKVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0oX19jb3JlX191bklEYXRhKHN0YXJ0KSwgX19jb3JlX191bklEYXRhKGVuZCkpXG5cdFx0XHR9KF9fY29yZV9fdW5CRGF0YShzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX3N0YXJ0c193aXRoXCIsIFxuXHRgKHNlbGYsIHNlbGZMZW5ndGhGbikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQocHJlZml4KSAtPiB7XG5cdFx0XHRcdChwcmVmaXgpIC0+IHtcblx0XHRcdFx0XHQobiwgbSkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihuLCBtKSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzQnl0ZVN0cmluZyhwcmVmaXgsIF9fY29yZV9fc2xpY2VCeXRlU3RyaW5nKDAsIG0sIHNlbGYpKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9KHNlbGZMZW5ndGhGbihzZWxmKSwgX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcocHJlZml4KSlcblx0XHRcdFx0fShfX2NvcmVfX3VuQkRhdGEocHJlZml4KSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5CRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fZW5kc193aXRoXCIsXG5cdGAoc2VsZiwgc2VsZkxlbmd0aEZuKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChzdWZmaXgpIC0+IHtcblx0XHRcdFx0KHN1ZmZpeCkgLT4ge1xuXHRcdFx0XHRcdChuLCBtKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKG4sIG0pLFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7ZmFsc2V9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNCeXRlU3RyaW5nKHN1ZmZpeCwgX19jb3JlX19zbGljZUJ5dGVTdHJpbmcoX19jb3JlX19zdWJ0cmFjdEludGVnZXIobiwgbSksIG0sIHNlbGYpKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9KHNlbGZMZW5ndGhGbihzZWxmKSwgX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcoc3VmZml4KSlcblx0XHRcdFx0fShfX2NvcmVfX3VuQkRhdGEoc3VmZml4KSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5CRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRzXCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX3NuZFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9faGVhZExpc3QoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRzKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19maWVsZHNfYWZ0ZXJfMFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX3RhaWxMaXN0KF9faGVsaW9zX19jb21tb25fX2ZpZWxkcyhzZWxmKSlcblx0fWApKTtcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCAyMDsgaSsrKSB7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGBfX2hlbGlvc19fY29tbW9uX19maWVsZF8ke2kudG9TdHJpbmcoKX1gLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX2hlYWRMaXN0KF9faGVsaW9zX19jb21tb25fX2ZpZWxkc19hZnRlcl8keyhpLTEpLnRvU3RyaW5nKCl9KHNlbGYpKVxuXHR9YCkpO1xuXHRcdGFkZChuZXcgUmF3RnVuYyhgX19oZWxpb3NfX2NvbW1vbl9fZmllbGRzX2FmdGVyXyR7aS50b1N0cmluZygpfWAsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fdGFpbExpc3QoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRzX2FmdGVyXyR7KGktMSkudG9TdHJpbmcoKX0oc2VsZikpXG5cdH1gKSk7XG5cdH1cblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fdHVwbGVfZmllbGRfMFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9fdHVwbGVfZmllbGRzX2FmdGVyXzBcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fdGFpbExpc3QoX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRmb3IgKGxldCBpID0gMTsgaSA8IDIwOyBpKyspIHtcblx0XHRhZGQobmV3IFJhd0Z1bmMoYF9faGVsaW9zX19jb21tb25fX3R1cGxlX2ZpZWxkXyR7aS50b1N0cmluZygpfWAsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9faGVhZExpc3QoX19oZWxpb3NfX2NvbW1vbl9fdHVwbGVfZmllbGRzX2FmdGVyXyR7KGktMSkudG9TdHJpbmcoKX0oc2VsZikpXG5cdH1gKSk7XG5cdFx0YWRkKG5ldyBSYXdGdW5jKGBfX2hlbGlvc19fY29tbW9uX190dXBsZV9maWVsZHNfYWZ0ZXJfJHtpLnRvU3RyaW5nKCl9YCxcblx0YChzZWxmKSAtPiB7XG5cdFx0X19jb3JlX190YWlsTGlzdChfX2hlbGlvc19fY29tbW9uX190dXBsZV9maWVsZHNfYWZ0ZXJfJHsoaS0xKS50b1N0cmluZygpfShzZWxmKSlcblx0fWApKTtcblx0fVxuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19saXN0XzBcIiwgXCJfX2NvcmVfX21rTmlsRGF0YSgoKSlcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY29tbW9uX19saXN0XzFcIiwgXG5cdGAoYSkgLT4ge1xuXHRcdF9fY29yZV9fbWtDb25zKGEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMClcblx0fWApKTtcblx0Zm9yIChsZXQgaSA9IDI7IGkgPCAyMDsgaSsrKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3N0cmluZ1tdfVxuXHRcdCAqL1xuXHRcdGxldCBhcmdzID0gW107XG5cblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuXHRcdFx0YXJncy5wdXNoKGBhcmcke2oudG9TdHJpbmcoKX1gKTtcblx0XHR9XG5cblx0XHRsZXQgd29GaXJzdCA9IGFyZ3Muc2xpY2UoKVxuXHRcdGxldCBmaXJzdCA9IGFzc2VydERlZmluZWQod29GaXJzdC5zaGlmdCgpKTtcblxuXHRcdGFkZChuZXcgUmF3RnVuYyhgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8ke2kudG9TdHJpbmcoKX1gLFxuXHRgKCR7YXJncy5qb2luKFwiLCBcIil9KSAtPiB7XG5cdFx0X19jb3JlX19ta0NvbnMoJHtmaXJzdH0sIF9faGVsaW9zX19jb21tb25fX2xpc3RfJHsoaS0xKS50b1N0cmluZygpfSgke3dvRmlyc3Quam9pbihcIiwgXCIpfSkpXG5cdH1gKSk7XG5cdH1cblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NvbW1vbl9faGFzaF9kYXR1bV9kYXRhXCIsIFxuXHRgKGRhdGEpIC0+IHtcblx0XHRfX2NvcmVfX2JEYXRhKF9fY29yZV9fYmxha2UyYl8yNTYoX19jb3JlX19zZXJpYWxpc2VEYXRhKGRhdGEpKSlcblx0fWApKTtcblxuXG5cdC8vIEdsb2JhbCBidWlsdGluIGZ1bmN0aW9uc1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fcHJpbnRcIiwgXG5cdGAobXNnKSAtPiB7XG5cdFx0X19jb3JlX190cmFjZShfX2hlbGlvc19fY29tbW9uX191blN0cmluZ0RhdGEobXNnKSwgKCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19lcnJvclwiLFxuXHRgKG1zZykgLT4ge1xuXHRcdF9fY29yZV9fdHJhY2UoXG5cdFx0XHRfX2hlbGlvc19fY29tbW9uX191blN0cmluZ0RhdGEobXNnKSwgXG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdGVycm9yKFwiZXJyb3IgdGhyb3duIGJ5IHVzZXItY29kZVwiKVxuXHRcdFx0fVxuXHRcdCkoKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYXNzZXJ0XCIsXG5cdGAoY29uZCwgbXNnKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0Y29uZCxcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0KClcblx0XHRcdH0sXG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fdHJhY2UoXG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fdW5TdHJpbmdEYXRhKG1zZyksXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0ZXJyb3IoXCJhc3NlcnQgZmFpbGVkXCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpKClcblx0fWApKTtcblxuXG5cdC8vIEludCBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19faW50XCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19fX25lZ1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX2lEYXRhKF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShzZWxmKSwgLTEpKVx0XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX19fcG9zXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHlcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19fX2FkZFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2lEYXRhKF9fY29yZV9fYWRkSW50ZWdlcihfX2NvcmVfX3VuSURhdGEoYSksIF9fY29yZV9fdW5JRGF0YShiKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX19fc3ViXCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9fY29yZV9faURhdGEoX19jb3JlX19zdWJ0cmFjdEludGVnZXIoX19jb3JlX191bklEYXRhKGEpLCBfX2NvcmVfX3VuSURhdGEoYikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19fX211bFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2lEYXRhKF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShhKSwgX19jb3JlX191bklEYXRhKGIpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fX19kaXZcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19pRGF0YShfX2NvcmVfX2RpdmlkZUludGVnZXIoX19jb3JlX191bklEYXRhKGEpLCBfX2NvcmVfX3VuSURhdGEoYikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19fX21vZFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2lEYXRhKF9fY29yZV9fbW9kSW50ZWdlcihfX2NvcmVfX3VuSURhdGEoYSksIF9fY29yZV9fdW5JRGF0YShiKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX19fZ2VxXCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX25vdChfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihfX2NvcmVfX3VuSURhdGEoYSksIF9fY29yZV9fdW5JRGF0YShiKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX19fZ3RcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fbm90KF9fY29yZV9fbGVzc1RoYW5FcXVhbHNJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShhKSwgX19jb3JlX191bklEYXRhKGIpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fX19sZXFcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19sZXNzVGhhbkVxdWFsc0ludGVnZXIoX19jb3JlX191bklEYXRhKGEpLCBfX2NvcmVfX3VuSURhdGEoYikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX19fbHRcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoX19jb3JlX191bklEYXRhKGEpLCBfX2NvcmVfX3VuSURhdGEoYikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX21pblwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihfX2NvcmVfX3VuSURhdGEoYSksIF9fY29yZV9fdW5JRGF0YShiKSksXG5cdFx0XHRhLFxuXHRcdFx0YlxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fbWF4XCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShhKSwgX19jb3JlX191bklEYXRhKGIpKSxcblx0XHRcdGIsXG5cdFx0XHRhXG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19ib3VuZF9taW5cIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KG90aGVyKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19faW50X19tYXgoc2VsZiwgb3RoZXIpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19ib3VuZF9tYXhcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KG90aGVyKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19faW50X19taW4oc2VsZiwgb3RoZXIpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19ib3VuZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQobWluLCBtYXgpIC0+IHtcblx0XHRcdF9faGVsaW9zX19pbnRfX21heChfX2hlbGlvc19faW50X19taW4oc2VsZiwgbWF4KSwgbWluKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fYWJzXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdChpKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihpLCAwKSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lEYXRhKF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKGksIC0xKSlcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdHNlbGZcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fShfX2NvcmVfX3VuSURhdGEoc2VsZikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19lbmNvZGVfemlnemFnXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdChpKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9faURhdGEoXG5cdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoaSwgMCksXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fc3VidHJhY3RJbnRlZ2VyKF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKGksIC0yKSwgMSlcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKGksIDIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdClcblx0XHRcdH0oX19jb3JlX191bklEYXRhKHNlbGYpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fZGVjb2RlX3ppZ3phZ1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHQoaSkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoaSwgMCksXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0ZXJyb3IoXCJleHBlY3RlZCBwb3NpdGl2ZSBpbnRcIilcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faURhdGEoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19tb2RJbnRlZ2VyKGksIDIpLCAwKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2RpdmlkZUludGVnZXIoaSwgMilcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZGl2aWRlSW50ZWdlcihfX2NvcmVfX2FkZEludGVnZXIoaSwgMSksIC0yKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH0oX19jb3JlX191bklEYXRhKHNlbGYpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fdG9fYm9vbFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoX19jb3JlX19lcXVhbHNJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShzZWxmKSwgMCksIGZhbHNlLCB0cnVlKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fdG9faGV4XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdFx0X19jb3JlX19iRGF0YShcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoc2VsZiwgMCksXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2NvbnNCeXRlU3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRcdFx0NDUsXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKHNlbGYsIC0xKSwgIylcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsICMpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocmVjdXJzZSwgc2VsZiwgYnl0ZXMpIC0+IHtcblx0XHRcdFx0XHRcdChkaWdpdCkgLT4ge1xuXHRcdFx0XHRcdFx0XHQoYnl0ZXMpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihzZWxmLCAxNiksXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7Ynl0ZXN9LFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fZGl2aWRlSW50ZWdlcihzZWxmLCAxNiksIGJ5dGVzKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9KFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fY29uc0J5dGVTdHJpbmcoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKGRpZ2l0LCAxMCksIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2FkZEludGVnZXIoZGlnaXQsIDQ4KSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fYWRkSW50ZWdlcihkaWdpdCwgODcpXG5cdFx0XHRcdFx0XHRcdFx0XHQpLCBcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9KF9fY29yZV9fbW9kSW50ZWdlcihzZWxmLCAxNikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuSURhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19jb21tb25fX0JBU0U1OF9BTFBIQUJFVFwiLCBcIiMzMTMyMzMzNDM1MzYzNzM4Mzk0MTQyNDM0NDQ1NDY0NzQ4NGE0YjRjNGQ0ZTUwNTE1MjUzNTQ1NTU2NTc1ODU5NWE2MTYyNjM2NDY1NjY2NzY4Njk2YTZiNmQ2ZTZmNzA3MTcyNzM3NDc1NzY3Nzc4Nzk3YVwiKSlcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fdG9fYmFzZTU4XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fYkRhdGEoXG5cdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoc2VsZiwgMCksXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdGVycm9yKFwiZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyXCIpXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgc2VsZiwgIylcblx0XHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0XHQocmVjdXJzZSwgc2VsZiwgYnl0ZXMpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdChkaWdpdCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQoYnl0ZXMpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihzZWxmLCA1OCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fZGl2aWRlSW50ZWdlcihzZWxmLCA1OCksIGJ5dGVzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fY29uc0J5dGVTdHJpbmcoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2luZGV4Qnl0ZVN0cmluZyhfX2hlbGlvc19fY29tbW9uX19CQVNFNThfQUxQSEFCRVQsIGRpZ2l0KSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fbW9kSW50ZWdlcihzZWxmLCA1OCkpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5JRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fQkFTRTU4X0lOVkVSU0VfQUxQSEFCRVRfMVwiLCBcIiNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjAwMDEwMjAzMDQwNTA2MDcwOGZmZmZmZmZmZmZmZlwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX0JBU0U1OF9JTlZFUlNFX0FMUEhBQkVUXzJcIiwgXCIjZmYwOTBhMGIwYzBkMGUwZjEwZmYxMTEyMTMxNDE1ZmYxNjE3MTgxOTFhMWIxYzFkMWUxZjIwZmZmZmZmZmZmZmZmMjEyMjIzMjQyNTI2MjcyODI5MmEyYmZmMmMyZDJlMmYzMDMxMzIzMzM0MzUzNjM3MzgzOWZmZmZmZmZmZmZcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19pbnZlcnRfYmFzZTU4X2NoYXJcIiwgXG5cdGAoY2hhcikgLT4ge1xuXHRcdChkaWdpdCkgLT4ge1xuXHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoZGlnaXQsIDB4ZmYpLFxuXHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0ZXJyb3IoXCJpbnZhbGlkIGJhc2U1OCBjaGFyYWN0ZXJcIilcblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdGRpZ2l0XG5cdFx0XHRcdH1cblx0XHRcdCkoKVxuXHRcdH0oXG5cdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKGNoYXIsIDY0KSxcblx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9faW5kZXhCeXRlU3RyaW5nKF9faGVsaW9zX19pbnRfX0JBU0U1OF9JTlZFUlNFX0FMUEhBQkVUXzEsIGNoYXIpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihjaGFyLCAxMjgpLFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2luZGV4Qnl0ZVN0cmluZyhcblx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19faW50X19CQVNFNThfSU5WRVJTRV9BTFBIQUJFVF8yLFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fc3VidHJhY3RJbnRlZ2VyKGNoYXIsIDY0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHQweGZmXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdCkoKVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fZnJvbV9iYXNlNThcIixcblx0YChzdHIpIC0+IHtcblx0XHQoYnl0ZXMpIC0+IHtcblx0XHRcdF9fY29yZV9faURhdGEoXG5cdFx0XHRcdChuKSAtPiB7XG5cdFx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgMCwgMSwgX19jb3JlX19zdWJ0cmFjdEludGVnZXIobiwgMSkpXG5cdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdChyZWN1cnNlLCBhY2MsIHBvdywgaSkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKGksIC0xKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY2Ncblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdChuZXdfYWNjKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgbmV3X2FjYywgX19jb3JlX19tdWx0aXBseUludGVnZXIocG93LCA1OCksIF9fY29yZV9fc3VidHJhY3RJbnRlZ2VyKGksIDEpKVxuXHRcdFx0XHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19hZGRJbnRlZ2VyKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjYyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX211bHRpcGx5SW50ZWdlcihcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19pbnRfX2ludmVydF9iYXNlNThfY2hhcihcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pbmRleEJ5dGVTdHJpbmcoYnl0ZXMsIGkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0oX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcoYnl0ZXMpKVxuXHRcdFx0KVxuXHRcdH0oX19jb3JlX191bkJEYXRhKHN0cikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX3Nob3dcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShfX2NvcmVfX2RlY29kZVV0ZjgoXG5cdFx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoc2VsZiwgMCksXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX2NvbnNCeXRlU3RyaW5nKDQ1LCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKHNlbGYsIC0xKSkpfSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge3JlY3Vyc2UocmVjdXJzZSwgc2VsZil9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9KFxuXHRcdFx0XHRcdFx0KHJlY3Vyc2UsIGkpIC0+IHtcblx0XHRcdFx0XHRcdFx0KGJ5dGVzKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoaSwgMTApLFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2J5dGVzfSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX2FwcGVuZEJ5dGVTdHJpbmcocmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX2RpdmlkZUludGVnZXIoaSwgMTApKSwgYnl0ZXMpfVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fY29uc0J5dGVTdHJpbmcoX19jb3JlX19hZGRJbnRlZ2VyKF9fY29yZV9fbW9kSW50ZWdlcihpLCAxMCksIDQ4KSwgIykpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bklEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19wYXJzZV9kaWdpdFwiLFxuXHRgKGRpZ2l0KSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0X19jb3JlX19sZXNzVGhhbkVxdWFsc0ludGVnZXIoZGlnaXQsIDU3KSxcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5FcXVhbHNJbnRlZ2VyKDQ4LCBkaWdpdCksXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19zdWJ0cmFjdEludGVnZXIoZGlnaXQsIDQ4KVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0ZXJyb3IoXCJub3QgYSBkaWdpdFwiKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSgpXG5cdFx0XHR9LFxuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRlcnJvcihcIm5vdCBhIGRpZ2l0XCIpXG5cdFx0XHR9XG5cdFx0KSgpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX3BhcnNlXCIsXG5cdGAoc3RyaW5nKSAtPiB7XG5cdFx0KGJ5dGVzKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2lEYXRhKFxuXHRcdFx0XHQobiwgYjApIC0+IHtcblx0XHRcdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoYjAsIDQ4KSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihuLCAxKSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0MFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3IoXCJ6ZXJvIHBhZGRlZCBpbnRlZ2VyIGNhbid0IGJlIHBhcnNlZFwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKGIwLCA0NSksXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19pbmRleEJ5dGVTdHJpbmcoYnl0ZXMsIDEpLCA0OCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3IoXCItMCBub3QgYWxsb3dlZFwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19tdWx0aXBseUludGVnZXIoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgMCwgMSksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC0xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgMCwgMClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdChyZWN1cnNlLCBhY2MsIGkpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihpLCBuKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY2Ncblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdChuZXdfYWNjKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgbmV3X2FjYywgX19jb3JlX19hZGRJbnRlZ2VyKGksIDEpKVxuXHRcdFx0XHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19hZGRJbnRlZ2VyKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKGFjYywgMTApLCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19faW50X19wYXJzZV9kaWdpdChfX2NvcmVfX2luZGV4Qnl0ZVN0cmluZyhieXRlcywgaSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShfX2NvcmVfX2xlbmd0aE9mQnl0ZVN0cmluZyhieXRlcyksIF9fY29yZV9faW5kZXhCeXRlU3RyaW5nKGJ5dGVzLCAwKSlcblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5CRGF0YShzdHJpbmcpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faW50X19mcm9tX2JpZ19lbmRpYW5cIixcblx0YChieXRlcykgLT4ge1xuXHRcdChieXRlcykgLT4ge1xuXHRcdFx0X19jb3JlX19pRGF0YShcblx0XHRcdFx0KG4pIC0+IHtcblx0XHRcdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCAwLCAxLCBfX2NvcmVfX3N1YnRyYWN0SW50ZWdlcihuLCAxKSlcblx0XHRcdFx0XHR9KFxuXHRcdFx0XHRcdFx0KHJlY3Vyc2UsIGFjYywgcG93LCBpKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoaSwgLTEpLFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjY1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0KG5ld19hY2MpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCBuZXdfYWNjLCBfX2NvcmVfX211bHRpcGx5SW50ZWdlcihwb3csIDI1NiksIF9fY29yZV9fc3VidHJhY3RJbnRlZ2VyKGksIDEpKVxuXHRcdFx0XHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19hZGRJbnRlZ2VyKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjYyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX211bHRpcGx5SW50ZWdlcihfX2NvcmVfX2luZGV4Qnl0ZVN0cmluZyhieXRlcywgaSksIHBvdylcblx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9KF9fY29yZV9fbGVuZ3RoT2ZCeXRlU3RyaW5nKGJ5dGVzKSlcblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5CRGF0YShieXRlcykpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19pbnRfX2Zyb21fbGl0dGxlX2VuZGlhblwiLCBcblx0YChieXRlcykgLT4ge1xuXHRcdChieXRlcykgLT4ge1xuXHRcdFx0X19jb3JlX19pRGF0YShcblx0XHRcdFx0KG4pIC0+IHtcblx0XHRcdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCAwLCAxLCAwKVxuXHRcdFx0XHRcdH0oXG5cdFx0XHRcdFx0XHQocmVjdXJzZSwgYWNjLCBwb3csIGkpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihpLCBuKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY2Ncblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdChuZXdfYWNjKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgbmV3X2FjYywgX19jb3JlX19tdWx0aXBseUludGVnZXIocG93LCAyNTYpLCBfX2NvcmVfX2FkZEludGVnZXIoaSwgMSkpXG5cdFx0XHRcdFx0XHRcdFx0XHR9KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2FkZEludGVnZXIoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWNjLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbXVsdGlwbHlJbnRlZ2VyKF9fY29yZV9faW5kZXhCeXRlU3RyaW5nKGJ5dGVzLCBpKSwgcG93KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0oX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcoYnl0ZXMpKVxuXHRcdFx0KVxuXHRcdH0oX19jb3JlX191bkJEYXRhKGJ5dGVzKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fdG9fYmlnX2VuZGlhblwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoc2VsZiwgMCksXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0ZXJyb3IoXCJjYW4ndCBjb252ZXJ0IG5lZ2F0aXZlIG51bWJlciB0byBiaWcgZW5kaWFuIGJ5dGVhcnJheVwiKVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19jb3JlX19iRGF0YShyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsICMpKVxuXHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGJ5dGVzKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0KGJ5dGVzKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKHNlbGYsIDI1NiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRieXRlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVjdXJzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2RpdmlkZUludGVnZXIoc2VsZiwgMjU2KSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fY29uc0J5dGVTdHJpbmcoc2VsZiwgYnl0ZXMpKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5JRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2ludF9fdG9fbGl0dGxlX2VuZGlhblwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0X19jb3JlX19sZXNzVGhhbkludGVnZXIoc2VsZiwgMCksXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0ZXJyb3IoXCJjYW4ndCBjb252ZXJ0IG5lZ2F0aXZlIG51bWJlciB0byBiaWcgZW5kaWFuIGJ5dGVhcnJheVwiKVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19jb3JlX19iRGF0YShyZWN1cnNlKHJlY3Vyc2UsIHNlbGYpKVxuXHRcdFx0XHRcdFx0fShcblx0XHRcdFx0XHRcdFx0KHJlY3Vyc2UsIHNlbGYpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2NvbnNCeXRlU3RyaW5nKHNlbGYsXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKHNlbGYsIDI1NiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQjXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fZGl2aWRlSW50ZWdlcihzZWxmLCAyNTYpKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bklEYXRhKHNlbGYpKVxuXHR9YCkpXG5cblxuXHQvLyBCb29sIGJ1aWx0aW5zXG5cdGFkZChuZXcgUmF3RnVuYyhgX19oZWxpb3NfX2Jvb2xfX19fZXFgLCBcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKGEsIGIsIF9faGVsaW9zX19jb21tb25fX25vdChiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKGBfX2hlbGlvc19fYm9vbF9fX19uZXFgLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoYSwgX19oZWxpb3NfX2NvbW1vbl9fbm90KGIpLCBiKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoYF9faGVsaW9zX19ib29sX19zZXJpYWxpemVgLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fc2VyaWFsaXplKF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoYF9faGVsaW9zX19ib29sX19mcm9tX2RhdGFgLFxuXHRgKGRhdGEpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGRhdGEpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sX19hbmRcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0YSgpLCBcblx0XHRcdCgpIC0+IHtiKCl9LCBcblx0XHRcdCgpIC0+IHtmYWxzZX1cblx0XHQpKClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xfX29yXCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdGEoKSwgXG5cdFx0XHQoKSAtPiB7dHJ1ZX0sXG5cdFx0XHQoKSAtPiB7YigpfVxuXHRcdCkoKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbF9fX19ub3RcIiwgXCJfX2hlbGlvc19fY29tbW9uX19ub3RcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbF9fdG9faW50XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdF9fY29yZV9faURhdGEoX19jb3JlX19pZlRoZW5FbHNlKHNlbGYsIDEsIDApKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xfX3Nob3dcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShfX2NvcmVfX2lmVGhlbkVsc2Uoc2VsZiwgXCJ0cnVlXCIsIFwiZmFsc2VcIikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbF9fdHJhY2VcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHByZWZpeCkgLT4ge1xuXHRcdFx0X19jb3JlX190cmFjZShcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fdW5TdHJpbmdEYXRhKFxuXHRcdFx0XHRcdF9faGVsaW9zX19zdHJpbmdfX19fYWRkKFxuXHRcdFx0XHRcdFx0cHJlZml4LFxuXHRcdFx0XHRcdFx0X19oZWxpb3NfX2Jvb2xfX3Nob3coc2VsZikoKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KSwgXG5cdFx0XHRcdHNlbGZcblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cblxuXHQvLyBTdHJpbmcgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0cmluZ1wiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0cmluZ19fX19hZGRcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShfX2NvcmVfX2FwcGVuZFN0cmluZyhfX2hlbGlvc19fY29tbW9uX191blN0cmluZ0RhdGEoYSksIF9faGVsaW9zX19jb21tb25fX3VuU3RyaW5nRGF0YShiKSkpXHRcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0cmluZ19fc3RhcnRzX3dpdGhcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zdGFydHNfd2l0aFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zdHJpbmdfX2VuZHNfd2l0aFwiLCBcIl9faGVsaW9zX19ieXRlYXJyYXlfX2VuZHNfd2l0aFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zdHJpbmdfX2VuY29kZV91dGY4XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fYkRhdGEoX19jb3JlX19lbmNvZGVVdGY4KHNlbGYpKVxuXHRcdFx0fVxuXHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fdW5TdHJpbmdEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXG5cblx0Ly8gQnl0ZUFycmF5IGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX19ieXRlYXJyYXlcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXlfX19fYWRkXCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9fY29yZV9fYkRhdGEoX19jb3JlX19hcHBlbmRCeXRlU3RyaW5nKF9fY29yZV9fdW5CRGF0YShhKSwgX19jb3JlX191bkJEYXRhKGIpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19nZXFcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fbm90KF9fY29yZV9fbGVzc1RoYW5CeXRlU3RyaW5nKF9fY29yZV9fdW5CRGF0YShhKSwgX19jb3JlX191bkJEYXRhKGIpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19ndFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoX19jb3JlX19sZXNzVGhhbkVxdWFsc0J5dGVTdHJpbmcoX19jb3JlX191bkJEYXRhKGEpLCBfX2NvcmVfX3VuQkRhdGEoYikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5X19fX2xlcVwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2xlc3NUaGFuRXF1YWxzQnl0ZVN0cmluZyhfX2NvcmVfX3VuQkRhdGEoYSksIF9fY29yZV9fdW5CRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19sdFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2xlc3NUaGFuQnl0ZVN0cmluZyhfX2NvcmVfX3VuQkRhdGEoYSksIF9fY29yZV9fdW5CRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fbGVuZ3RoXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9faURhdGEoX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcoX19jb3JlX191bkJEYXRhKHNlbGYpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fc2xpY2VcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fc2xpY2VfYnl0ZWFycmF5KHNlbGYsIF9fY29yZV9fbGVuZ3RoT2ZCeXRlU3RyaW5nKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zdGFydHNfd2l0aFwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RhcnRzX3dpdGgoc2VsZiwgX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXlfX2VuZHNfd2l0aFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX19lbmRzX3dpdGgoc2VsZiwgX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXlfX3ByZXBlbmRcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdChieXRlKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2JEYXRhKFxuXHRcdFx0XHRfX2NvcmVfX2NvbnNCeXRlU3RyaW5nKFxuXHRcdFx0XHRcdF9fY29yZV9fdW5JRGF0YShieXRlKSxcblx0XHRcdFx0XHRfX2NvcmVfX3VuQkRhdGEoc2VsZilcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fc2hhMlwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2JEYXRhKF9fY29yZV9fc2hhMl8yNTYoc2VsZikpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuQkRhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXlfX3NoYTNcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19jb3JlX19iRGF0YShfX2NvcmVfX3NoYTNfMjU2KHNlbGYpKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkJEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5X19ibGFrZTJiXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fYkRhdGEoX19jb3JlX19ibGFrZTJiXzI1NihzZWxmKSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5CRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheV9fZGVjb2RlX3V0ZjhcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShfX2NvcmVfX2RlY29kZVV0Zjgoc2VsZikpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuQkRhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXlfX3Nob3dcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKHJlY3Vyc2UocmVjdXJzZSwgc2VsZikpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIHNlbGYpIC0+IHtcblx0XHRcdFx0XHRcdChuKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcigwLCBuKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2FwcGVuZFN0cmluZyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19kZWNvZGVVdGY4KChoZXhCeXRlcykgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihfX2NvcmVfX2xlbmd0aE9mQnl0ZVN0cmluZyhoZXhCeXRlcyksIDEpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19jb25zQnl0ZVN0cmluZyg0OCwgaGV4Qnl0ZXMpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aGV4Qnl0ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0oX19jb3JlX191bkJEYXRhKF9faGVsaW9zX19pbnRfX3RvX2hleChfX2NvcmVfX2lEYXRhKF9fY29yZV9faW5kZXhCeXRlU3RyaW5nKHNlbGYsIDApKSkoKSkpKSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgX19jb3JlX19zbGljZUJ5dGVTdHJpbmcoMSwgbiwgc2VsZikpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdH0oX19jb3JlX19sZW5ndGhPZkJ5dGVTdHJpbmcoc2VsZikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuQkRhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXkzMl9fX19lcVwiLCBcIl9faGVsaW9zX19ieXRlYXJyYXlfX19fZXFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX19fbmVxXCIsIFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19uZXFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX3NlcmlhbGl6ZVwiLCBcIl9faGVsaW9zX19ieXRlYXJyYXlfX3NlcmlhbGl6ZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXkzMl9fX19hZGRcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19fX2FkZFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXkzMl9fbGVuZ3RoXCIsIFwiKF8pIC0+IHtfX2NvcmVfX2lEYXRhKDMyKX1cIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX3NsaWNlXCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX19zbGljZV9ieXRlYXJyYXkoc2VsZiwgKHNlbGYpIC0+IHszMn0pXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXkzMl9fc3RhcnRzX3dpdGhcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX3N0YXJ0c193aXRoKHNlbGYsIChzZWxmKSAtPiB7MzJ9KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX2VuZHNfd2l0aFwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fZW5kc193aXRoKHNlbGYsIChzZWxmKSAtPiB7MzJ9KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX3NoYTJcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zaGEyXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2J5dGVhcnJheTMyX19zaGEzXCIsIFwiX19oZWxpb3NfX2J5dGVhcnJheV9fc2hhM1wiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ieXRlYXJyYXkzMl9fYmxha2UyYlwiLCBcIl9faGVsaW9zX19ieXRlYXJyYXlfX2JsYWtlMmJcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX2RlY29kZV91dGY4XCIsIFwiX19oZWxpb3NfX2J5dGVhcnJheV9fZGVjb2RlX3V0ZjhcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYnl0ZWFycmF5MzJfX3Nob3dcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zaG93XCIpKTtcblxuXG5cdC8vIExpc3QgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX2xpc3RcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X19uZXdcIixcblx0YChuLCBmbikgLT4ge1xuXHRcdChuKSAtPiB7XG5cdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2xpc3REYXRhKHJlY3Vyc2UocmVjdXJzZSwgMCkpXG5cdFx0XHR9KFxuXHRcdFx0XHQocmVjdXJzZSwgaSkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdF9fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKGksIG4pLFxuXHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtDb25zKGZuKF9fY29yZV9faURhdGEoaSkpLCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fYWRkSW50ZWdlcihpLCAxKSkpfSxcblx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rTmlsRGF0YSgoKSl9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5JRGF0YShuKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX25ld19jb25zdFwiLFxuXHRgKG4sIGl0ZW0pIC0+IHtcblx0XHRfX2hlbGlvc19fbGlzdF9fbmV3KG4sIChpKSAtPiB7aXRlbX0pXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X19fX2FkZFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2xpc3REYXRhKF9faGVsaW9zX19jb21tb25fX2NvbmNhdChfX2NvcmVfX3VuTGlzdERhdGEoYSksIF9fY29yZV9fdW5MaXN0RGF0YShiKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X19sZW5ndGhcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fbGVuZ3RoKF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX2hlYWRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19jb3JlX19oZWFkTGlzdChfX2NvcmVfX3VuTGlzdERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X190YWlsXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fbGlzdERhdGEoX19jb3JlX190YWlsTGlzdChfX2NvcmVfX3VuTGlzdERhdGEoc2VsZikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9faXNfZW1wdHlcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19jb3JlX19udWxsTGlzdChzZWxmKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fZ2V0XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoaW5kZXgpIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsIF9fY29yZV9fdW5JRGF0YShpbmRleCkpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIHNlbGYsIGluZGV4KSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7ZXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2VcIil9LCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihpbmRleCwgMCksIFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtlcnJvcihcImluZGV4IG91dCBvZiByYW5nZVwiKX0sIFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKGluZGV4LCAwKSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX2hlYWRMaXN0KHNlbGYpfSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoc2VsZiksIF9fY29yZV9fc3VidHJhY3RJbnRlZ2VyKGluZGV4LCAxKSl9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCkoKX1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fZ2V0X3NpbmdsZXRvblwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2Nob29zZVVuaXQoXG5cdFx0XHRcdFx0X19oZWxpb3NfX2Fzc2VydChcblx0XHRcdFx0XHRcdF9fY29yZV9fbnVsbExpc3QoX19jb3JlX190YWlsTGlzdChzZWxmKSksXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwibm90IGEgc2luZ2xldG9uIGxpc3RcIilcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdF9fY29yZV9faGVhZExpc3Qoc2VsZilcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fYW55XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYW55KHNlbGYsIGZuKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fYWxsXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYWxsKHNlbGYsIGZuKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fcHJlcGVuZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGl0ZW0pIC0+IHtcblx0XHRcdFx0X19jb3JlX19saXN0RGF0YShfX2NvcmVfX21rQ29ucyhpdGVtLCBzZWxmKSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX2ZpbmRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19maW5kKHNlbGYsIGZuLCBfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX2ZpbmRfc2FmZVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZpbmRfc2FmZShzZWxmLCBmbiwgX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHkpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTGlzdERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X19maWx0ZXJcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2xpc3REYXRhKF9faGVsaW9zX19jb21tb25fX2ZpbHRlcl9saXN0KHNlbGYsIGZuKSlcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX2Zvcl9lYWNoXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIGxzdCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRsc3QsXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoKVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VVbml0KFxuXHRcdFx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19oZWFkTGlzdChsc3QpKSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChsc3QpKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTGlzdERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19saXN0X19mb2xkXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4sIHopIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fZm9sZChzZWxmLCBmbiwgeilcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX2ZvbGRfbGF6eVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuLCB6KSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZvbGRfbGF6eShzZWxmLCBmbiwgeilcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2xpc3RfX21hcFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fbGlzdERhdGEoX19oZWxpb3NfX2NvbW1vbl9fbWFwKHNlbGYsIGZuLCBfX2NvcmVfX21rTmlsRGF0YSgoKSkpKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fbWFwX3RvX2Jvb2xcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbGlzdF9fbWFwKHNlbGYpKFxuXHRcdFx0XHQoaXRlbSkgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKGZuKGl0ZW0pKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbGlzdF9fc29ydFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0X19jb3JlX19saXN0RGF0YShfX2hlbGlvc19fY29tbW9uX19zb3J0KHNlbGYsIGNvbXApKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bkxpc3REYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX25ld1wiLCBcblx0YChuLCBmbikgLT4ge1xuXHRcdF9faGVsaW9zX19saXN0X19uZXcoXG5cdFx0XHRuLCBcblx0XHRcdChpKSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKGZuKGkpKVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19uZXdfY29uc3RcIiwgXG5cdGAobiwgaXRlbSkgLT4ge1xuXHRcdF9faGVsaW9zX19saXN0X19uZXdfY29uc3QobiwgX19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEoaXRlbSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fX19lcVwiLCBcIl9faGVsaW9zX19saXN0X19fX2VxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19fX25lcVwiLCBcIl9faGVsaW9zX19saXN0X19fX25lcVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fc2VyaWFsaXplXCIsIFwiX19oZWxpb3NfX2xpc3RfX3NlcmlhbGl6ZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZnJvbV9kYXRhXCIsIFwiX19oZWxpb3NfX2xpc3RfX2Zyb21fZGF0YVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fX19hZGRcIiwgXCJfX2hlbGlvc19fbGlzdF9fX19hZGRcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX2xlbmd0aFwiLCBcIl9faGVsaW9zX19saXN0X19sZW5ndGhcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX2hlYWRcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX2xpc3RfX2hlYWQoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fdGFpbFwiLCBcIl9faGVsaW9zX19saXN0X190YWlsXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19pc19lbXB0eVwiLCBcIl9faGVsaW9zX19saXN0X19pc19lbXB0eVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZ2V0XCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoaW5kZXgpIC0+IHtcblx0XHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX2xpc3RfX2dldChzZWxmKShpbmRleCkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX2dldF9zaW5nbGV0b25cIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShfX2hlbGlvc19fbGlzdF9fZ2V0X3NpbmdsZXRvbihzZWxmKSgpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19hbnlcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2xpc3RfX2FueShzZWxmKShcblx0XHRcdFx0KGl0ZW0pIC0+IHtcblx0XHRcdFx0XHRmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGl0ZW0pKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX2FsbFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19saXN0X19hbGwoc2VsZikoXG5cdFx0XHRcdChpdGVtKSAtPiB7XG5cdFx0XHRcdFx0Zm4oX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShpdGVtKSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19wcmVwZW5kXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChpdGVtKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbGlzdF9fcHJlcGVuZChzZWxmKShfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShpdGVtKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZmluZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoXG5cdFx0XHRcdF9faGVsaW9zX19saXN0X19maW5kKHNlbGYpKFxuXHRcdFx0XHRcdChpdGVtKSAtPiB7XG5cdFx0XHRcdFx0XHRmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGl0ZW0pKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19maW5kX3NhZmVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbGlzdF9fZmluZF9zYWZlKHNlbGYpKFxuXHRcdFx0XHQoaXRlbSkgLT4ge1xuXHRcdFx0XHRcdGZuKF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoaXRlbSkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZmlsdGVyXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2xpc3RfX2ZpbHRlcihzZWxmKShcblx0XHRcdFx0KGl0ZW0pIC0+IHtcblx0XHRcdFx0XHRmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGl0ZW0pKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX2Zvcl9lYWNoXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2xpc3RfX2Zvcl9lYWNoKHNlbGYpKFxuXHRcdFx0XHQoaXRlbSkgLT4ge1xuXHRcdFx0XHRcdGZuKF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoaXRlbSkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZm9sZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4sIHopIC0+IHtcblx0XHRcdF9faGVsaW9zX19saXN0X19mb2xkKHNlbGYpKFxuXHRcdFx0XHQocHJldiwgaXRlbSkgLT4ge1xuXHRcdFx0XHRcdGZuKHByZXYsIF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoaXRlbSkpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHpcblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fZm9sZF9sYXp5XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbiwgeikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2xpc3RfX2ZvbGRfbGF6eShzZWxmKShcblx0XHRcdFx0KGl0ZW0sIG5leHQpIC0+IHtcblx0XHRcdFx0XHRmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGl0ZW0pLCBuZXh0KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR6XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbGxpc3RfX21hcFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19saXN0X19tYXAoc2VsZikoXG5cdFx0XHRcdChpdGVtKSAtPiB7XG5cdFx0XHRcdFx0Zm4oX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShpdGVtKSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xsaXN0X19tYXBfdG9fYm9vbFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19saXN0X19tYXAoc2VsZikoXG5cdFx0XHRcdChpdGVtKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEoZm4oX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShpdGVtKSkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbGlzdF9fc29ydFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2xpc3REYXRhKF9faGVsaW9zX19jb21tb25fX3NvcnQoc2VsZiwgY29tcCkpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KGEsIGIpIC0+IHtcblx0XHRcdFx0XHRcdGNvbXAoX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShhKSwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShiKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5MaXN0RGF0YShzZWxmKSlcblx0fWApKTtcblxuXG5cdC8vIE1hcCBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fbWFwXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19fX2FkZFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX21hcERhdGEoX19oZWxpb3NfX2NvbW1vbl9fY29uY2F0KF9fY29yZV9fdW5NYXBEYXRhKGEpLCBfX2NvcmVfX3VuTWFwRGF0YShiKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX3ByZXBlbmRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fbWFwRGF0YShfX2NvcmVfX21rQ29ucyhfX2NvcmVfX21rUGFpckRhdGEoa2V5LCB2YWx1ZSksIHNlbGYpKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2hlYWRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGhlYWQpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soX19jb3JlX19mc3RQYWlyKGhlYWQpLCBfX2NvcmVfX3NuZFBhaXIoaGVhZCkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KF9fY29yZV9faGVhZExpc3QoX19jb3JlX191bk1hcERhdGEoc2VsZikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19oZWFkX2tleVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2hlYWRfdmFsdWVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19jb3JlX19zbmRQYWlyKF9fY29yZV9faGVhZExpc3QoX19jb3JlX191bk1hcERhdGEoc2VsZikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19sZW5ndGhcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fbGVuZ3RoKF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX190YWlsXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fbWFwRGF0YShfX2NvcmVfX3RhaWxMaXN0KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9faXNfZW1wdHlcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19jb3JlX19udWxsTGlzdChzZWxmKVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2dldFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoa2V5KSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fY29tbW9uX19tYXBfZ2V0KHNlbGYsIGtleSwgKHgpIC0+IHt4fSwgKCkgLT4ge2Vycm9yKFwia2V5IG5vdCBmb3VuZFwiKX0pXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19nZXRfc2FmZVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoa2V5KSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fY29tbW9uX19tYXBfZ2V0KFxuXHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0a2V5LCBcblx0XHRcdFx0KHgpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKHgpKVxuXHRcdFx0XHR9LCBcblx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgxLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzApXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2FsbFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2FsbChzZWxmLCBmbilcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19jb3JlX19mc3RQYWlyKHBhaXIpLCBfX2NvcmVfX3NuZFBhaXIocGFpcikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fYW55XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYW55KHNlbGYsIGZuKVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRmbihfX2NvcmVfX2ZzdFBhaXIocGFpciksIF9fY29yZV9fc25kUGFpcihwYWlyKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19kZWxldGVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChrZXkpIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEocmVjdXJzZShyZWN1cnNlLCBzZWxmKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocmVjdXJzZSwgc2VsZikgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRzZWxmLFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7c2VsZn0sXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoaGVhZCwgdGFpbCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoa2V5LCBfX2NvcmVfX2ZzdFBhaXIoaGVhZCkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCB0YWlsKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rQ29ucyhoZWFkLCByZWN1cnNlKHJlY3Vyc2UsIHRhaWwpKX1cblx0XHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHRcdH0oX19jb3JlX19oZWFkTGlzdChzZWxmKSwgX19jb3JlX190YWlsTGlzdChzZWxmKSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fZmlsdGVyXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0X19jb3JlX19tYXBEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpbHRlcl9tYXAoc2VsZiwgZm4pKVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRmbihfX2NvcmVfX2ZzdFBhaXIocGFpciksIF9fY29yZV9fc25kUGFpcihwYWlyKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19maW5kXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYsIGZuKVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChyZWN1cnNlLCBzZWxmLCBmbikgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge2Vycm9yKFwibm90IGZvdW5kXCIpfSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoaGVhZCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbihfX2NvcmVfX2ZzdFBhaXIoaGVhZCksIF9fY29yZV9fc25kUGFpcihoZWFkKSksIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhfX2NvcmVfX2ZzdFBhaXIoaGVhZCksIF9fY29yZV9fc25kUGFpcihoZWFkKSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KHNlbGYpLCBmbil9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3Qoc2VsZikpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2ZpbmRfc2FmZVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCBzZWxmLCBmbilcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocmVjdXJzZSwgc2VsZiwgZm4pIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdFx0c2VsZiwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoY2FsbGJhY2spIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCgpIC0+IHtlcnJvcihcIm5vdCBmb3VuZFwiKX0sIGZhbHNlKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoaGVhZCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbihfX2NvcmVfX2ZzdFBhaXIoaGVhZCksIF9fY29yZV9fc25kUGFpcihoZWFkKSksIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChjYWxsYmFjaykgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soX19jb3JlX19mc3RQYWlyKGhlYWQpLCBfX2NvcmVfX3NuZFBhaXIoaGVhZCkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge3JlY3Vyc2UocmVjdXJzZSwgX19jb3JlX190YWlsTGlzdChzZWxmKSwgZm4pfVxuXHRcdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdFx0fShfX2NvcmVfX2hlYWRMaXN0KHNlbGYpKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19maW5kX2tleVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZpbmQoXG5cdFx0XHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0XHRcdGZuLFxuXHRcdFx0XHRcdFx0X19jb3JlX19mc3RQYWlyXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRmbihfX2NvcmVfX2ZzdFBhaXIocGFpcikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fZmluZF9rZXlfc2FmZVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZpbmRfc2FmZShcblx0XHRcdFx0XHRcdHNlbGYsXG5cdFx0XHRcdFx0XHRmbixcblx0XHRcdFx0XHRcdF9fY29yZV9fZnN0UGFpclxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19jb3JlX19mc3RQYWlyKHBhaXIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2ZpbmRfdmFsdWVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19maW5kKFxuXHRcdFx0XHRcdFx0c2VsZiwgXG5cdFx0XHRcdFx0XHRmbixcblx0XHRcdFx0XHRcdF9fY29yZV9fc25kUGFpclxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19jb3JlX19zbmRQYWlyKHBhaXIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2ZpbmRfdmFsdWVfc2FmZVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZpbmRfc2FmZShcblx0XHRcdFx0XHRcdHNlbGYsXG5cdFx0XHRcdFx0XHRmbixcblx0XHRcdFx0XHRcdF9fY29yZV9fc25kUGFpclxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19jb3JlX19zbmRQYWlyKHBhaXIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX21hcFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fbWFwRGF0YShfX2hlbGlvc19fY29tbW9uX19tYXAoc2VsZiwgZm4sIF9fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSkpKVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHQobWFwcGVkX3BhaXIpIC0+IHtcblx0XHRcdFx0XHRcdFx0bWFwcGVkX3BhaXIoXG5cdFx0XHRcdFx0XHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtQYWlyRGF0YShrZXksIHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0fShmbihfX2NvcmVfX2ZzdFBhaXIocGFpciksIF9fY29yZV9fc25kUGFpcihwYWlyKSkpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fbWFwX3RvX2Jvb2xcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEoX19oZWxpb3NfX2NvbW1vbl9fbWFwKHNlbGYsIGZuLCBfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0KG1hcHBlZF9wYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRcdG1hcHBlZF9wYWlyKFxuXHRcdFx0XHRcdFx0XHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rUGFpckRhdGEoa2V5LCBfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YSh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9KGZuKF9fY29yZV9fZnN0UGFpcihwYWlyKSwgX19jb3JlX19zbmRQYWlyKHBhaXIpKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fbWFwX19mb2xkXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4sIHopIC0+IHtcblx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fZm9sZChzZWxmLCBmbiwgeilcblx0XHRcdFx0fShcblx0XHRcdFx0XHQoeiwgcGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oeiwgX19jb3JlX19mc3RQYWlyKHBhaXIpLCBfX2NvcmVfX3NuZFBhaXIocGFpcikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2ZvbGRfbGF6eVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuLCB6KSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZvbGRfbGF6eShzZWxmLCBmbiwgeilcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpciwgbmV4dCkgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19jb3JlX19mc3RQYWlyKHBhaXIpLCBfX2NvcmVfX3NuZFBhaXIocGFpciksIG5leHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19tYXBfX2Zvcl9lYWNoXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIHNlbGYpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIG1hcCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRtYXAsXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoKVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0KGhlYWQpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlVW5pdChcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4oX19jb3JlX19mc3RQYWlyKGhlYWQpLCBfX2NvcmVfX3NuZFBhaXIoaGVhZCkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3QobWFwKSlcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3QobWFwKSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fc2V0XCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEocmVjdXJzZShyZWN1cnNlLCBzZWxmKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocmVjdXJzZSwgc2VsZikgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRzZWxmLFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19ta0NvbnMoX19jb3JlX19ta1BhaXJEYXRhKGtleSwgdmFsdWUpLCBfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpKVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0KGhlYWQsIHRhaWwpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNEYXRhKGtleSwgX19jb3JlX19mc3RQYWlyKGhlYWQpKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKF9fY29yZV9fbWtQYWlyRGF0YShrZXksIHZhbHVlKSwgdGFpbClcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKGhlYWQsIHJlY3Vyc2UocmVjdXJzZSwgdGFpbCkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHRcdH0oX19jb3JlX19oZWFkTGlzdChzZWxmKSwgX19jb3JlX190YWlsTGlzdChzZWxmKSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX21hcF9fc29ydFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEoX19oZWxpb3NfX2NvbW1vbl9fc29ydChzZWxmLCBjb21wKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQoYSwgYikgLT4ge1xuXHRcdFx0XHRcdFx0Y29tcChfX2NvcmVfX2ZzdFBhaXIoYSksIF9fY29yZV9fc25kUGFpcihhKSwgX19jb3JlX19mc3RQYWlyKGIpLCBfX2NvcmVfX3NuZFBhaXIoYikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX19fZXFcIiwgXCJfX2hlbGlvc19fbWFwX19fX2VxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX19fbmVxXCIsIFwiX19oZWxpb3NfX21hcF9fX19uZXFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fc2VyaWFsaXplXCIsIFwiX19oZWxpb3NfX21hcF9fc2VyaWFsaXplXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2Zyb21fZGF0YVwiLCBcIl9faGVsaW9zX19tYXBfX2Zyb21fZGF0YVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19fX2FkZFwiLCBcIl9faGVsaW9zX19tYXBfX19fYWRkXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX3ByZXBlbmRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fbWFwRGF0YShcblx0XHRcdFx0XHRfX2NvcmVfX21rQ29ucyhcblx0XHRcdFx0XHRcdF9fY29yZV9fbWtQYWlyRGF0YShrZXksIF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHZhbHVlKSksXG5cdFx0XHRcdFx0XHRzZWxmXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2hlYWRcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGhlYWQpIC0+IHtcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soX19jb3JlX19mc3RQYWlyKGhlYWQpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9fY29yZV9fc25kUGFpcihoZWFkKSkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KF9fY29yZV9faGVhZExpc3QoX19jb3JlX191bk1hcERhdGEoc2VsZikpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9faGVhZF9rZXlcIiwgXCJfX2hlbGlvc19fbWFwX19oZWFkX2tleVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19oZWFkX3ZhbHVlXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX21hcF9faGVhZF92YWx1ZShzZWxmKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2xlbmd0aFwiLCBcIl9faGVsaW9zX19tYXBfX2xlbmd0aFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX190YWlsXCIsIFwiX19oZWxpb3NfX21hcF9fdGFpbFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19pc19lbXB0eVwiLCBcIl9faGVsaW9zX19tYXBfX2lzX2VtcHR5XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2dldFwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0KGtleSkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShfX2hlbGlvc19fbWFwX19nZXQoc2VsZikoa2V5KSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19hbGxcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbWFwX19hbGwoc2VsZikoXG5cdFx0XHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRcdFx0Zm4oa2V5LCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2FueVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19tYXBfX2FueShzZWxmKShcblx0XHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRmbihrZXksIF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fZGVsZXRlXCIsIFwiX19oZWxpb3NfX21hcF9fZGVsZXRlXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xtYXBfX2ZpbHRlclwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19tYXBfX2ZpbHRlcihzZWxmKShcblx0XHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRmbihrZXksIF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fZmluZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHQocmVzdWx0KSAtPiB7XG5cdFx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0XHRyZXN1bHQoKGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soa2V5LCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKHZhbHVlKSlcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KF9faGVsaW9zX19tYXBfX2ZpbmQoc2VsZikoZm4pKVxuXHRcdFx0fShcblx0XHRcdFx0KGZzdCwgc25kKSAtPiB7XG5cdFx0XHRcdFx0Zm4oZnN0LCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKHNuZCkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19maW5kX3NhZmVcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KHJlc3VsdG9rKSAtPiB7XG5cdFx0XHRcdFx0KGNhbGxiYWNrKSAtPiB7XG5cdFx0XHRcdFx0XHRyZXN1bHRvaygocmVzdWx0LCBvaykgLT4ge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHQoaW5uZXJfY2FsbGJhY2spIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0KCkoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlubmVyX2NhbGxiYWNrKGtleSwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YSh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSwgXG5cdFx0XHRcdFx0XHRcdFx0b2tcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0oX19oZWxpb3NfX21hcF9fZmluZF9zYWZlKHNlbGYpKGZuKSlcblx0XHRcdH0oXG5cdFx0XHRcdChmc3QsIHNuZCkgLT4ge1xuXHRcdFx0XHRcdGZuKGZzdCwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShzbmQpKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fZmluZF9rZXlcIiwgXCJfX2hlbGlvc19fbWFwX19maW5kX2tleVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19maW5kX2tleV9zYWZlXCIsIFwiX19oZWxpb3NfX21hcF9fZmluZF9rZXlfc2FmZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19maW5kX3ZhbHVlXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fZmluZChcblx0XHRcdFx0XHRcdHNlbGYsIFxuXHRcdFx0XHRcdFx0Zm4sXG5cdFx0XHRcdFx0XHQocmVzdWx0KSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19jb3JlX19zbmRQYWlyKHJlc3VsdCkpXG5cdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHBhaXIpIC0+IHtcblx0XHRcdFx0XHRcdGZuKF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19jb3JlX19zbmRQYWlyKHBhaXIpKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKHNlbGYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fZmluZF92YWx1ZV9zYWZlXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChzZWxmKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fZmluZF9zYWZlKFxuXHRcdFx0XHRcdFx0c2VsZiwgXG5cdFx0XHRcdFx0XHRmbixcblx0XHRcdFx0XHRcdChyZXN1bHQpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19jb3JlX19zbmRQYWlyKHJlc3VsdClcblx0XHRcdFx0XHRcdH1cdFxuXHRcdFx0XHRcdClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0Zm4oX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShfX2NvcmVfX3NuZFBhaXIocGFpcikpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19tYXBcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEoX19oZWxpb3NfX2NvbW1vbl9fbWFwKHNlbGYsIGZuLCBfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdFx0KG1hcHBlZF9wYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRcdG1hcHBlZF9wYWlyKFxuXHRcdFx0XHRcdFx0XHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rUGFpckRhdGEoa2V5LCB2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0oZm4oX19jb3JlX19mc3RQYWlyKHBhaXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9fY29yZV9fc25kUGFpcihwYWlyKSkpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19tYXBfdG9fYm9vbFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoc2VsZikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdChmbikgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fbWFwRGF0YShfX2hlbGlvc19fY29tbW9uX19tYXAoc2VsZiwgZm4sIF9fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSkpKVxuXHRcdFx0XHR9KFxuXHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHQobWFwcGVkX3BhaXIpIC0+IHtcblx0XHRcdFx0XHRcdFx0bWFwcGVkX3BhaXIoXG5cdFx0XHRcdFx0XHRcdFx0KGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtQYWlyRGF0YShrZXksIF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHZhbHVlKSlcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0oZm4oX19jb3JlX19mc3RQYWlyKHBhaXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9fY29yZV9fc25kUGFpcihwYWlyKSkpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19mb2xkXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbiwgeikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX21hcF9fZm9sZChzZWxmKShcblx0XHRcdFx0KHByZXYsIGtleSwgdmFsdWUpIC0+IHtcblx0XHRcdFx0XHRmbihwcmV2LCBrZXksIF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEodmFsdWUpKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR6XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fZm9sZF9sYXp5XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbiwgeikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX21hcF9fZm9sZF9sYXp5KHNlbGYpKFxuXHRcdFx0XHQoa2V5LCB2YWx1ZSwgbmV4dCkgLT4ge1xuXHRcdFx0XHRcdGZuKGtleSwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YSh2YWx1ZSksIG5leHQpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHpcblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19mb3JfZWFjaFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoZm4pIC0+IHtcblx0XHRcdF9faGVsaW9zX19tYXBfX2Zvcl9lYWNoKHNlbGYpKFxuXHRcdFx0XHQoa2V5LCB2YWx1ZSkgLT4ge1xuXHRcdFx0XHRcdGZuKGtleSwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YSh2YWx1ZSkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sbWFwX19zZXRcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdChrZXksIHZhbHVlKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbWFwX19zZXQoc2VsZikoa2V5LCBfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YSh2YWx1ZSkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG1hcF9fc29ydFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoY29tcCkgLT4ge1xuXHRcdFx0KGNvbXApIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX21hcF9fc29ydChzZWxmKShjb21wKVxuXHRcdFx0fShcblx0XHRcdFx0KGFrLCBhdiwgYmssIGJ2KSAtPiB7XG5cdFx0XHRcdFx0Y29tcChhaywgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShhdiksIGJrLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGJ2KSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblxuXG5cdC8vIE9wdGlvbltUXSBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fb3B0aW9uXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3B0aW9uX19tYXBcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbikgLT4ge1xuXHRcdFx0KHBhaXIpIC0+IHtcblx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihfX2NvcmVfX2ZzdFBhaXIocGFpciksIDApLFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9faGVsaW9zX19vcHRpb25fX3NvbWVfX25ldyhmbihfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihwYWlyKSkpKVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0X19oZWxpb3NfX29wdGlvbl9fbm9uZV9fbmV3KClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fShfX2NvcmVfX3VuQ29uc3RyRGF0YShzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19vcHRpb25fX21hcF90b19ib29sXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChmbikgLT4ge1xuXHRcdFx0KGZuKSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX19vcHRpb25fX21hcChzZWxmKShmbilcblx0XHRcdH0oXG5cdFx0XHRcdChkYXRhKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEoZm4oZGF0YSkpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19vcHRpb25fX3Vud3JhcFwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChzZWxmKVxuXHRcdH1cblx0fWApKTtcblxuXG5cdC8vIE9wdGlvbltUXTo6U29tZVxuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX29wdGlvbl9fc29tZVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX29wdGlvbl9fc29tZV9fbmV3XCIsXG5cdGAoZGF0YSkgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoZGF0YSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19vcHRpb25fX3NvbWVfX2Nhc3RcIixcblx0YChkYXRhKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fYXNzZXJ0X2NvbnN0cl9pbmRleChkYXRhLCAwKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3B0aW9uX19zb21lX19zb21lXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdFxuXG5cdC8vIE9wdGlvbltUXTo6Tm9uZVxuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX29wdGlvbl9fbm9uZVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX29wdGlvbl9fbm9uZV9fbmV3XCIsXG5cdGAoKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX29wdGlvbl9fbm9uZV9fY2FzdFwiLFxuXHRgKGRhdGEpIC0+IHtcblx0XHRfX2hlbGlvc19fY29tbW9uX19hc3NlcnRfY29uc3RyX2luZGV4KGRhdGEsIDEpXG5cdH1gKSk7XG5cblxuXHQvLyBPcHRpb25bQm9vbF1cblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX19fZXFcIiwgXCJfX2hlbGlvc19fb3B0aW9uX19fX2VxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX19fbmVxXCIsIFwiX19oZWxpb3NfX29wdGlvbl9fX19uZXFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG9wdGlvbl9fc2VyaWFsaXplXCIsIFwiX19oZWxpb3NfX29wdGlvbl9fc2VyaWFsaXplXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX2Zyb21fZGF0YVwiLCBcIl9faGVsaW9zX19vcHRpb25fX2Zyb21fZGF0YVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX191bndyYXBcIiwgYFxuXHQoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19tYXBcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX29wdGlvbl9fbWFwKHNlbGYpKGZuKVxuXHRcdFx0fShcblx0XHRcdFx0KGRhdGEpIC0+IHtcblx0XHRcdFx0XHRmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGRhdGEpKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG9wdGlvbl9fbWFwX3RvX2Jvb2xcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGZuKSAtPiB7XG5cdFx0XHQoZm4pIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX29wdGlvbl9fbWFwKHNlbGYpKGZuKVxuXHRcdFx0fShcblx0XHRcdFx0KGRhdGEpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShmbihfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKGRhdGEpKSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblxuXHRcblx0Ly8gT3B0aW9uW0Jvb2xdOjpTb21lXG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19zb21lX19fX2VxXCIsIFwiX19oZWxpb3NfX29wdGlvbl9fc29tZV9fX19lcVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19zb21lX19fX25lcVwiLCBcIl9faGVsaW9zX19vcHRpb25fX3NvbWVfX19fbmVxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX3NvbWVfX3NlcmlhbGl6ZVwiLCBcIl9faGVsaW9zX19vcHRpb25fX3NvbWVfX3NlcmlhbGl6ZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19zb21lX19uZXdcIiwgXG5cdGAoYikgLT4ge1xuXHRcdF9faGVsaW9zX19vcHRpb25fX3NvbWVfX25ldyhfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX3NvbWVfX2Nhc3RcIiwgXCJfX2hlbGlvc19fb3B0aW9uX19zb21lX19jYXN0XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX3NvbWVfX3NvbWVcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX29wdGlvbl9fc29tZV9fc29tZShzZWxmKSlcblx0fWApKTtcblxuXHRcblx0Ly8gT3B0aW9uW0Jvb2xdOjpOb25lXG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19ub25lX19fX2VxXCIsICAgICAgXCJfX2hlbGlvc19fb3B0aW9uX19ub25lX19fX2VxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX25vbmVfX19fbmVxXCIsICAgICBcIl9faGVsaW9zX19vcHRpb25fX25vbmVfX19fbmVxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2Jvb2xvcHRpb25fX25vbmVfX3NlcmlhbGl6ZVwiLCBcIl9faGVsaW9zX19vcHRpb25fX25vbmVfX3NlcmlhbGl6ZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19ib29sb3B0aW9uX19ub25lX19uZXdcIiwgICAgICAgXCJfX2hlbGlvc19fb3B0aW9uX19ub25lX19uZXdcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYm9vbG9wdGlvbl9fbm9uZV9fY2FzdFwiLCAgICAgIFwiX19oZWxpb3NfX29wdGlvbl9fbm9uZV9fY2FzdFwiKSk7XG5cblx0XG5cdC8vIEhhc2ggYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX2hhc2hcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19oYXNoX19fX2x0XCIsIFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19sdFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19oYXNoX19fX2xlcVwiLCBcIl9faGVsaW9zX19ieXRlYXJyYXlfX19fbGVxXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2hhc2hfX19fZ3RcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19fX2d0XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2hhc2hfX19fZ2VxXCIsIFwiX19oZWxpb3NfX2J5dGVhcnJheV9fX19nZXFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19faGFzaF9fbmV3XCIsIGBfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2hhc2hfX3Nob3dcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zaG93XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2hhc2hfX0NVUlJFTlRcIiwgXCJfX2NvcmVfX2JEYXRhKCMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwKVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19oYXNoX19mcm9tX3NjcmlwdF9oYXNoXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHlcIikpO1xuXG5cdFxuXHQvLyBTY3JpcHRIYXNoIGJ1aWx0aW5cblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3NjcmlwdGhhc2hcIik7XG5cblxuXHQvLyBQdWJLZXkgYnVpbHRpblxuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fcHVia2V5XCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fcHVia2V5X19uZXdcIiwgXCJfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19wdWJrZXlfX3Nob3dcIiwgXCJfX2hlbGlvc19fYnl0ZWFycmF5X19zaG93XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3B1YmtleV9fdmVyaWZ5XCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHQobWVzc2FnZSwgc2lnbmF0dXJlKSAtPiB7XG5cdFx0XHRfX2NvcmVfX3ZlcmlmeUVkMjU1MTlTaWduYXR1cmUoX19jb3JlX191bkJEYXRhKHNlbGYpLCBfX2NvcmVfX3VuQkRhdGEobWVzc2FnZSksIF9fY29yZV9fdW5CRGF0YShzaWduYXR1cmUpKVxuXHRcdH1cblx0fWApKTtcblxuXG5cdC8vIFNjcmlwdENvbnRleHQgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19uZXdfc3BlbmRpbmdcIixcblx0YCh0eCwgb3V0cHV0X2lkKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdHR4LFxuXHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShvdXRwdXRfaWQpKVxuXHRcdCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19uZXdfbWludGluZ1wiLFxuXHRgKHR4LCBtcGgpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdFx0dHgsXG5cdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKG1waCkpXG5cdFx0KSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX25ld19yZXdhcmRpbmdcIixcblx0YCh0eCwgY3JlZCkgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHR0eCxcblx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgyLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoY3JlZCkpXG5cdFx0KSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX25ld19jZXJ0aWZ5aW5nXCIsXG5cdGAodHgsIGRjZXJ0KSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdHR4LFxuXHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDMsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShkY2VydCkpXG5cdFx0KSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX3R4XCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19wdXJwb3NlXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19nZXRfY3VycmVudF9pbnB1dFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHQoaWQpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2xpc3RfX2ZpbmQoX19oZWxpb3NfX3R4X19pbnB1dHMoX19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX3R4KHNlbGYpKSkoXG5cdFx0XHRcdFx0KGlucHV0KSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoX19oZWxpb3NfX3R4aW5wdXRfX291dHB1dF9pZChpbnB1dCksIGlkKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fShfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X3NwZW5kaW5nX3B1cnBvc2Vfb3V0cHV0X2lkKHNlbGYpKCkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X2NvbnRfb3V0cHV0c1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHQodmgpIC0+IHtcblx0XHRcdFx0KG91dHB1dHMpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fbGlzdF9fZmlsdGVyKG91dHB1dHMpKFxuXHRcdFx0XHRcdFx0KG91dHB1dCkgLT4ge1xuXHRcdFx0XHRcdFx0XHQoY3JlZGVudGlhbCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihfX2NvcmVfX2ZzdFBhaXIocGFpciksIDApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihwYWlyKSksIHZoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fdW5Db25zdHJEYXRhKGNyZWRlbnRpYWwpKVxuXHRcdFx0XHRcdFx0XHR9KF9faGVsaW9zX19hZGRyZXNzX19jcmVkZW50aWFsKF9faGVsaW9zX190eG91dHB1dF9fYWRkcmVzcyhvdXRwdXQpKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0oX19oZWxpb3NfX3R4X19vdXRwdXRzKF9faGVsaW9zX19zY3JpcHRjb250ZXh0X190eChzZWxmKSkpXG5cdFx0XHR9KF9faGVsaW9zX19zY3JpcHRjb250ZXh0X19nZXRfY3VycmVudF92YWxpZGF0b3JfaGFzaChzZWxmKSgpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX2dldF9zcGVuZGluZ19wdXJwb3NlX291dHB1dF9pZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fY29tbW9uX19maWVsZF8wKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEoc2VsZikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X2N1cnJlbnRfdmFsaWRhdG9yX2hhc2hcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX2NyZWRlbnRpYWxfX3ZhbGlkYXRvcl9faGFzaChcblx0XHRcdFx0X19oZWxpb3NfX2NyZWRlbnRpYWxfX3ZhbGlkYXRvcl9fY2FzdChcblx0XHRcdFx0XHRfX2hlbGlvc19fYWRkcmVzc19fY3JlZGVudGlhbChcblx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9fYWRkcmVzcyhcblx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3R4aW5wdXRfX291dHB1dChcblx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X2N1cnJlbnRfaW5wdXQoc2VsZikoKVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X2N1cnJlbnRfbWludGluZ19wb2xpY3lfaGFzaFwiLCBcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19nZXRfc3BlbmRpbmdfcHVycG9zZV9vdXRwdXRfaWRcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc2NyaXB0Y29udGV4dF9fZ2V0X3N0YWtpbmdfcHVycG9zZVwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3NjcmlwdGNvbnRleHRfX3B1cnBvc2Uoc2VsZilcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRjb250ZXh0X19nZXRfc2NyaXB0X3B1cnBvc2VcIiwgXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdF9faGVsaW9zX19zY3JpcHRjb250ZXh0X19wdXJwb3NlKHNlbGYpXG5cdFx0fVxuXHR9YCkpO1xuXG5cblx0Ly8gU3Rha2luZ1B1cnBvc2UgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0YWtpbmdwdXJwb3NlXCIpO1xuXG5cblx0Ly8gU3Rha2luZ1B1cnBvc2U6OlJld2FyZGluZyBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0YWtpbmdwdXJwb3NlX19yZXdhcmRpbmdcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zdGFraW5ncHVycG9zZV9fcmV3YXJkaW5nX19jcmVkZW50aWFsXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cblx0XG5cdC8vIFN0YWtpbmdQdXJwb3NlOjpDZXJ0aWZ5aW5nIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fc3Rha2luZ3B1cnBvc2VfX2NlcnRpZnlpbmdcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zdGFraW5ncHVycG9zZV9fY2VydGlmeWluZ19fZGNlcnRcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8wXCIpKTtcblxuXG5cdC8vIFNjcmlwdFB1cnBvc2UgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19uZXdfbWludGluZ1wiLFxuXHRgKG1pbnRpbmdQb2xpY3lIYXNoKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShtaW50aW5nUG9saWN5SGFzaCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19uZXdfc3BlbmRpbmdcIixcblx0YChvdXRwdXRfaWQpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMSwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKG91dHB1dF9pZCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19uZXdfcmV3YXJkaW5nXCIsXG5cdGAoY3JlZCkgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgyLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoY3JlZCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19uZXdfY2VydGlmeWluZ1wiLFxuXHRgKGRjZXJ0KSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDMsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShkY2VydCkpXG5cdH1gKSk7XG5cblxuXHQvLyBTY3JpcHRQdXJwb3NlOjpNaW50aW5nIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fc2NyaXB0cHVycG9zZV9fbWludGluZ1wiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VfX21pbnRpbmdfX3BvbGljeV9oYXNoXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cblx0XG5cdC8vIFNjcmlwdFB1cnBvc2U6OlNwZW5kaW5nIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fc2NyaXB0cHVycG9zZV9fc3BlbmRpbmdcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19zY3JpcHRwdXJwb3NlX19zcGVuZGluZ19fb3V0cHV0X2lkXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cblx0XG5cdC8vIFNjcmlwdFB1cnBvc2U6OlJld2FyZGluZyBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VfX3Jld2FyZGluZ1wiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VfX3Jld2FyZGluZ19fY3JlZGVudGlhbFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXG5cdFxuXHQvLyBTY3JpcHRQdXJwb3NlOjpDZXJ0aWZ5aW5nIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fc2NyaXB0cHVycG9zZV9fY2VydGlmeWluZ1wiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3NjcmlwdHB1cnBvc2VfX2NlcnRpZnlpbmdfX2RjZXJ0XCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cblxuXHQvLyBEQ2VydCBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fZGNlcnRcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kY2VydF9fbmV3X3JlZ2lzdGVyXCIsXG5cdGAoY3JlZCkgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoY3JlZCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kY2VydF9fbmV3X2RlcmVnaXN0ZXJcIixcblx0YChjcmVkKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShjcmVkKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19uZXdfZGVsZWdhdGVcIixcblx0YChjcmVkLCBwb29sX2lkKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDIsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihjcmVkLCBwb29sX2lkKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19uZXdfcmVnaXN0ZXJfcG9vbFwiLFxuXHRgKGlkLCB2cmYpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMywgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKGlkLCB2cmYpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZGNlcnRfX25ld19yZXRpcmVfcG9vbFwiLFxuXHRgKGlkLCBlcG9jaCkgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSg0LCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoaWQsIGVwb2NoKSlcblx0fWApKTtcblxuXG5cdC8vIERDZXJ0OjpSZWdpc3RlciBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX2RjZXJ0X19yZWdpc3RlclwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19yZWdpc3Rlcl9fY3JlZGVudGlhbFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXG5cblx0Ly8gRENlcnQ6OkRlcmVnaXN0ZXIgYnVpbHRpbnNcblx0YWRkRW51bURhdGFGdW5jcyhcIl9faGVsaW9zX19kY2VydF9fZGVyZWdpc3RlclwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19kZXJlZ2lzdGVyX19jcmVkZW50aWFsXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cblxuXHQvLyBEQ2VydDo6RGVsZWdhdGUgYnVpbHRpbnNcblx0YWRkRW51bURhdGFGdW5jcyhcIl9faGVsaW9zX19kY2VydF9fZGVsZWdhdGVcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kY2VydF9fZGVsZWdhdGVfX2RlbGVnYXRvclwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZGNlcnRfX2RlbGVnYXRlX19wb29sX2lkXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMVwiKSk7XG5cblxuXHQvLyBEQ2VydDo6UmVnaXN0ZXJQb29sIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fZGNlcnRfX3JlZ2lzdGVycG9vbFwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19yZWdpc3RlcnBvb2xfX3Bvb2xfaWRcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8wXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19yZWdpc3RlcnBvb2xfX3Bvb2xfdnJmXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMVwiKSk7XG5cblxuXHQvLyBEQ2VydDo6UmV0aXJlUG9vbCBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX2RjZXJ0X19yZXRpcmVwb29sXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZGNlcnRfX3JldGlyZXBvb2xfX3Bvb2xfaWRcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8wXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RjZXJ0X19yZXRpcmVwb29sX19lcG9jaFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzFcIikpO1xuXG5cblx0Ly8gVHggYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3R4XCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX25ld1wiLFxuXHRgKGlucHV0cywgcmVmX2lucHV0cywgb3V0cHV0cywgZmVlLCBtaW50ZWQsIGRjZXJ0cywgd2l0aGRyYXdhbHMsIHZhbGlkaXR5LCBzaWduYXRvcmllcywgcmVkZWVtZXJzLCBkYXR1bXMpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xMihcblx0XHRcdGlucHV0cyxcblx0XHRcdHJlZl9pbnB1dHMsXG5cdFx0XHRvdXRwdXRzLFxuXHRcdFx0ZmVlLFxuXHRcdFx0bWludGVkLFxuXHRcdFx0ZGNlcnRzLFxuXHRcdFx0d2l0aGRyYXdhbHMsXG5cdFx0XHR2YWxpZGl0eSxcblx0XHRcdHNpZ25hdG9yaWVzLFxuXHRcdFx0cmVkZWVtZXJzLFxuXHRcdFx0ZGF0dW1zLFxuXHRcdFx0X19oZWxpb3NfX3R4aWRfX0NVUlJFTlRcblx0XHQpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX2lucHV0c1wiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3JlZl9pbnB1dHNcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8xXCIpKVxuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX291dHB1dHNcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8yXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19mZWVcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8zXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19taW50ZWRcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF80XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19kY2VydHNcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF81XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X193aXRoZHJhd2Fsc1wiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzZcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3RpbWVfcmFuZ2VcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF83XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19zaWduYXRvcmllc1wiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzhcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3JlZGVlbWVyc1wiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzlcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX2RhdHVtc1wiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEwXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19pZFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzExXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19maW5kX2RhdHVtX2hhc2hcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGRhdHVtKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2ZzdFBhaXIoX19oZWxpb3NfX2NvbW1vbl9fZmluZChcblx0XHRcdFx0X19jb3JlX191bk1hcERhdGEoX19oZWxpb3NfX3R4X19kYXR1bXMoc2VsZikpLFxuXHRcdFx0XHQocGFpcikgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX3NuZFBhaXIocGFpciksIGRhdHVtKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eVxuXHRcdFx0KSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eF9fZ2V0X2RhdHVtX2RhdGFcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KG91dHB1dCkgLT4ge1xuXHRcdFx0KHBhaXIpIC0+IHtcblx0XHRcdFx0KGlkeCkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihpZHgsIDEpLFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fbWFwX19nZXQoX19oZWxpb3NfX3R4X19kYXR1bXMoc2VsZikpKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKHBhaXIpKSlcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoaWR4LCAyKSxcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihwYWlyKSlcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtlcnJvcihcIm91dHB1dCBkb2Vzbid0IGhhdmUgYSBkYXR1bVwiKX1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH0oX19jb3JlX19mc3RQYWlyKHBhaXIpKVxuXHRcdFx0fShfX2NvcmVfX3VuQ29uc3RyRGF0YShfX2hlbGlvc19fdHhvdXRwdXRfX2RhdHVtKG91dHB1dCkpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19maWx0ZXJfb3V0cHV0c1wiLFxuXHRgKHNlbGYsIGZuKSAtPiB7XG5cdFx0X19jb3JlX19saXN0RGF0YShcblx0XHRcdF9faGVsaW9zX19jb21tb25fX2ZpbHRlcl9saXN0KFxuXHRcdFx0XHRfX2NvcmVfX3VuTGlzdERhdGEoX19oZWxpb3NfX3R4X19vdXRwdXRzKHNlbGYpKSwgXG5cdFx0XHRcdGZuXG5cdFx0XHQpXG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX291dHB1dHNfc2VudF90b1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQocHViS2V5SGFzaCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3R4X19maWx0ZXJfb3V0cHV0cyhzZWxmLCAob3V0cHV0KSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faXNfc2VudF90byhvdXRwdXQpKHB1YktleUhhc2gpXG5cdFx0XHR9KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19vdXRwdXRzX3NlbnRfdG9fZGF0dW1cIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHB1YktleUhhc2gsIGRhdHVtLCBpc0lubGluZSkgLT4ge1xuXHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRpc0lubGluZSxcblx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX190eF9fb3V0cHV0c19zZW50X3RvX2lubGluZV9kYXR1bShzZWxmLCBwdWJLZXlIYXNoLCBkYXR1bSlcblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX190eF9fb3V0cHV0c19zZW50X3RvX2RhdHVtX2hhc2goc2VsZiwgcHViS2V5SGFzaCwgZGF0dW0pXG5cdFx0XHRcdH1cblx0XHRcdCkoKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19vdXRwdXRzX3NlbnRfdG9fZGF0dW1faGFzaFwiLFxuXHRgKHNlbGYsIHB1YktleUhhc2gsIGRhdHVtKSAtPiB7XG5cdFx0KGRhdHVtSGFzaCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3R4X19maWx0ZXJfb3V0cHV0cyhcblx0XHRcdFx0c2VsZiwgXG5cdFx0XHRcdChvdXRwdXQpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fYm9vbF9fYW5kKFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX2lzX3NlbnRfdG8ob3V0cHV0KShwdWJLZXlIYXNoKVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3R4b3V0cHV0X19oYXNfZGF0dW1faGFzaChvdXRwdXQsIGRhdHVtSGFzaClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9faGVsaW9zX19jb21tb25fX2hhc2hfZGF0dW1fZGF0YShkYXR1bSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eF9fb3V0cHV0c19zZW50X3RvX2lubGluZV9kYXR1bVwiLFxuXHRgKHNlbGYsIHB1YktleUhhc2gsIGRhdHVtKSAtPiB7XG5cdFx0X19oZWxpb3NfX3R4X19maWx0ZXJfb3V0cHV0cyhcblx0XHRcdHNlbGYsIFxuXHRcdFx0KG91dHB1dCkgLT4ge1xuXHRcdFx0XHRfX2hlbGlvc19fYm9vbF9fYW5kKFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faXNfc2VudF90byhvdXRwdXQpKHB1YktleUhhc2gpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX2hhc19pbmxpbmVfZGF0dW0ob3V0cHV0LCBkYXR1bSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eF9fb3V0cHV0c19sb2NrZWRfYnlcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHZhbGlkYXRvckhhc2gpIC0+IHtcblx0XHRcdF9faGVsaW9zX190eF9fZmlsdGVyX291dHB1dHMoc2VsZiwgKG91dHB1dCkgLT4ge1xuXHRcdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX2lzX2xvY2tlZF9ieShvdXRwdXQpKHZhbGlkYXRvckhhc2gpXG5cdFx0XHR9KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19vdXRwdXRzX2xvY2tlZF9ieV9kYXR1bVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQodmFsaWRhdG9ySGFzaCwgZGF0dW0sIGlzSW5saW5lKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdGlzSW5saW5lLFxuXHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX3R4X19vdXRwdXRzX2xvY2tlZF9ieV9pbmxpbmVfZGF0dW0oc2VsZiwgdmFsaWRhdG9ySGFzaCwgZGF0dW0pXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fdHhfX291dHB1dHNfbG9ja2VkX2J5X2RhdHVtX2hhc2goc2VsZiwgdmFsaWRhdG9ySGFzaCwgZGF0dW0pXG5cdFx0XHRcdH1cblx0XHRcdCkoKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19vdXRwdXRzX2xvY2tlZF9ieV9kYXR1bV9oYXNoXCIsXG5cdGAoc2VsZiwgdmFsaWRhdG9ySGFzaCwgZGF0dW0pIC0+IHtcblx0XHQoZGF0dW1IYXNoKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fdHhfX2ZpbHRlcl9vdXRwdXRzKFxuXHRcdFx0XHRzZWxmLCBcblx0XHRcdFx0KG91dHB1dCkgLT4ge1xuXHRcdFx0XHRcdF9faGVsaW9zX19ib29sX19hbmQoXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faXNfbG9ja2VkX2J5KG91dHB1dCkodmFsaWRhdG9ySGFzaClcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faGFzX2RhdHVtX2hhc2gob3V0cHV0LCBkYXR1bUhhc2gpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fShfX2hlbGlvc19fY29tbW9uX19oYXNoX2RhdHVtX2RhdGEoZGF0dW0pKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX291dHB1dHNfbG9ja2VkX2J5X2lubGluZV9kYXR1bVwiLFxuXHRgKHNlbGYsIHZhbGlkYXRvckhhc2gsIGRhdHVtKSAtPiB7XG5cdFx0X19oZWxpb3NfX3R4X19maWx0ZXJfb3V0cHV0cyhcblx0XHRcdHNlbGYsIFxuXHRcdFx0KG91dHB1dCkgLT4ge1xuXHRcdFx0XHRfX2hlbGlvc19fYm9vbF9fYW5kKFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faXNfbG9ja2VkX2J5KG91dHB1dCkodmFsaWRhdG9ySGFzaClcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdF9faGVsaW9zX190eG91dHB1dF9faGFzX2lubGluZV9kYXR1bShvdXRwdXQsIGRhdHVtKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X192YWx1ZV9zZW50X3RvXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChwdWJLZXlIYXNoKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX3N1bV92YWx1ZXMoX19oZWxpb3NfX3R4X19vdXRwdXRzX3NlbnRfdG8oc2VsZikocHViS2V5SGFzaCkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3ZhbHVlX3NlbnRfdG9fZGF0dW1cIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KHB1YktleUhhc2gsIGRhdHVtLCBpc0lubGluZSkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3R4b3V0cHV0X19zdW1fdmFsdWVzKF9faGVsaW9zX190eF9fb3V0cHV0c19zZW50X3RvX2RhdHVtKHNlbGYpKHB1YktleUhhc2gsIGRhdHVtLCBpc0lubGluZSkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3ZhbHVlX2xvY2tlZF9ieVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQodmFsaWRhdG9ySGFzaCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3R4b3V0cHV0X19zdW1fdmFsdWVzKF9faGVsaW9zX190eF9fb3V0cHV0c19sb2NrZWRfYnkoc2VsZikodmFsaWRhdG9ySGFzaCkpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhfX3ZhbHVlX2xvY2tlZF9ieV9kYXR1bVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQodmFsaWRhdG9ySGFzaCwgZGF0dW0sIGlzSW5saW5lKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX3N1bV92YWx1ZXMoX19oZWxpb3NfX3R4X19vdXRwdXRzX2xvY2tlZF9ieV9kYXR1bShzZWxmKSh2YWxpZGF0b3JIYXNoLCBkYXR1bSwgaXNJbmxpbmUpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4X19pc19zaWduZWRfYnlcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KGhhc2gpIC0+IHtcblx0XHRcdF9faGVsaW9zX19jb21tb25fX2FueShcblx0XHRcdFx0X19jb3JlX191bkxpc3REYXRhKF9faGVsaW9zX190eF9fc2lnbmF0b3JpZXMoc2VsZikpLFxuXHRcdFx0XHQoc2lnbmF0b3J5KSAtPiB7XG5cdFx0XHRcdFx0X19jb3JlX19lcXVhbHNEYXRhKHNpZ25hdG9yeSwgaGFzaClcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblxuXG5cdC8vIFR4SWQgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3R4aWRcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eGlkX19ieXRlc1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHRfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShzZWxmKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eGlkX19fX2x0XCIsIFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2hlbGlvc19fYnl0ZWFycmF5X19fX2x0KF9faGVsaW9zX190eGlkX19ieXRlcyhhKSwgX19oZWxpb3NfX3R4aWRfX2J5dGVzKGIpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhpZF9fX19sZXFcIiwgXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9faGVsaW9zX19ieXRlYXJyYXlfX19fbGVxKF9faGVsaW9zX190eGlkX19ieXRlcyhhKSwgX19oZWxpb3NfX3R4aWRfX2J5dGVzKGIpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhpZF9fX19ndFwiLCBcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2J5dGVhcnJheV9fX19ndChfX2hlbGlvc19fdHhpZF9fYnl0ZXMoYSksIF9faGVsaW9zX190eGlkX19ieXRlcyhiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4aWRfX19fZ2VxXCIsIFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2hlbGlvc19fYnl0ZWFycmF5X19fX2dlcShfX2hlbGlvc19fdHhpZF9fYnl0ZXMoYSksIF9faGVsaW9zX190eGlkX19ieXRlcyhiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4aWRfX25ld1wiLFxuXHRgKGJ5dGVzKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShieXRlcykpIFxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhpZF9fQ1VSUkVOVFwiLCBcIl9faGVsaW9zX190eGlkX19uZXcoX19jb3JlX19iRGF0YSgjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCkpXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4aWRfX3Nob3dcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0X19oZWxpb3NfX2J5dGVhcnJheV9fc2hvdyhfX2hlbGlvc19fdHhpZF9fYnl0ZXMoc2VsZikpXG5cdH1gKSk7XG5cblxuXHQvLyBUeElucHV0IGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX190eGlucHV0XCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhpbnB1dF9fbmV3XCIsXG5cdGAob3V0cHV0X2lkLCBvdXRwdXQpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKG91dHB1dF9pZCwgb3V0cHV0KSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4aW5wdXRfX291dHB1dF9pZFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhpbnB1dF9fb3V0cHV0XCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMVwiKSk7XG5cdFxuXG5cdC8vIFR4T3V0cHV0IGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX190eG91dHB1dFwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19uZXdcIiwgXG5cdGAoYWRkcmVzcywgdmFsdWUsIGRhdHVtKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfNChhZGRyZXNzLCB2YWx1ZSwgZGF0dW0sIF9faGVsaW9zX19vcHRpb25fX25vbmVfX25ldygpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19hZGRyZXNzXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dF9fdmFsdWVcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8xXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19kYXR1bVwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzJcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhvdXRwdXRfX3JlZl9zY3JpcHRfaGFzaFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzNcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhvdXRwdXRfX2dldF9kYXR1bV9oYXNoXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdChwYWlyKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19mc3RQYWlyKHBhaXIpLCAxKSxcblx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19oZWFkTGlzdChfX2NvcmVfX3NuZFBhaXIocGFpcikpfSxcblx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19iRGF0YSgjKX1cblx0XHRcdFx0KSgpXG5cdFx0XHR9KF9fY29yZV9fdW5Db25zdHJEYXRhKF9faGVsaW9zX190eG91dHB1dF9fZGF0dW0oc2VsZikpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19oYXNfZGF0dW1faGFzaFwiLFxuXHRgKHNlbGYsIGRhdHVtSGFzaCkgLT4ge1xuXHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2hlbGlvc19fdHhvdXRwdXRfX2dldF9kYXR1bV9oYXNoKHNlbGYpKCksIGRhdHVtSGFzaClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19oYXNfaW5saW5lX2RhdHVtXCIsXG5cdGAoc2VsZiwgZGF0dW0pIC0+IHtcblx0XHQocGFpcikgLT4ge1xuXHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19mc3RQYWlyKHBhaXIpLCAyKSxcblx0XHRcdFx0KCkgLT4ge19fY29yZV9fZXF1YWxzRGF0YShkYXR1bSwgX19jb3JlX19oZWFkTGlzdChfX2NvcmVfX3NuZFBhaXIocGFpcikpKX0sXG5cdFx0XHRcdCgpIC0+IHtmYWxzZX1cblx0XHRcdCkoKVxuXHRcdH0oX19jb3JlX191bkNvbnN0ckRhdGEoX19oZWxpb3NfX3R4b3V0cHV0X19kYXR1bShzZWxmKSkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dF9faXNfbG9ja2VkX2J5XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChoYXNoKSAtPiB7XG5cdFx0XHQoY3JlZGVudGlhbCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0X19oZWxpb3NfX2NyZWRlbnRpYWxfX2lzX3ZhbGlkYXRvcihjcmVkZW50aWFsKSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoXG5cdFx0XHRcdFx0XHRcdGhhc2gsIFxuXHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yX19oYXNoKFxuXHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19jcmVkZW50aWFsX192YWxpZGF0b3JfX2Nhc3QoY3JlZGVudGlhbClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfVxuXHRcdFx0XHQpKClcblx0XHRcdH0oX19oZWxpb3NfX2FkZHJlc3NfX2NyZWRlbnRpYWwoX19oZWxpb3NfX3R4b3V0cHV0X19hZGRyZXNzKHNlbGYpKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dF9faXNfc2VudF90b1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQocGtoKSAtPiB7XG5cdFx0XHQoY3JlZGVudGlhbCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0X19oZWxpb3NfX2NyZWRlbnRpYWxfX2lzX3B1YmtleShjcmVkZW50aWFsKSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoXG5cdFx0XHRcdFx0XHRcdHBraCwgXG5cdFx0XHRcdFx0XHRcdF9faGVsaW9zX19jcmVkZW50aWFsX19wdWJrZXlfX2hhc2goXG5cdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX2NyZWRlbnRpYWxfX3B1YmtleV9fY2FzdChjcmVkZW50aWFsKVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQoKSAtPiB7ZmFsc2V9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fShfX2hlbGlvc19fYWRkcmVzc19fY3JlZGVudGlhbChfX2hlbGlvc19fdHhvdXRwdXRfX2FkZHJlc3Moc2VsZikpKVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0X19zdW1fdmFsdWVzXCIsXG5cdGAob3V0cHV0cykgLT4ge1xuXHRcdF9faGVsaW9zX19saXN0X19mb2xkKG91dHB1dHMpKFxuXHRcdFx0KHByZXYsIHR4T3V0cHV0KSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX192YWx1ZV9fX19hZGQoXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRfX2hlbGlvc19fdHhvdXRwdXRfX3ZhbHVlKHR4T3V0cHV0KVxuXHRcdFx0XHQpXG5cdFx0XHR9LCBcblx0XHRcdF9faGVsaW9zX192YWx1ZV9fWkVST1xuXHRcdClcdFxuXHR9YCkpO1xuXG5cblx0Ly8gT3V0cHV0RGF0dW1cblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX291dHB1dGRhdHVtXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX25ld19ub25lXCIsXG5cdGAoKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19uZXdfaGFzaFwiLFxuXHRgKGhhc2gpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMSwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKGhhc2gpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX25ld19pbmxpbmVcIixcblx0YChkYXRhKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDIsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShkYXRhKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19uZXdfaW5saW5lX2Zyb21fYm9vbFwiLFxuXHRgKGIpIC0+IHtcblx0XHRfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX25ld19pbmxpbmUoX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19nZXRfaW5saW5lX2RhdGFcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0KHBhaXIpIC0+IHtcblx0XHRcdFx0KGluZGV4LCBmaWVsZHMpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoaW5kZXgsIDIpLFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2hlYWRMaXN0KGZpZWxkcylcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdGVycm9yKFwibm90IGFuIGlubGluZSBkYXR1bVwiKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCkoKVxuXHRcdFx0XHR9KF9fY29yZV9fZnN0UGFpcihwYWlyKSwgX19jb3JlX19zbmRQYWlyKHBhaXIpKVxuXHRcdFx0fShfX2NvcmVfX3VuQ29uc3RyRGF0YShzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cblxuXHQvLyBPdXRwdXREYXR1bTo6Tm9uZVxuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19ub25lXCIpO1xuXHRcblxuXHQvLyBPdXRwdXREYXR1bTo6SGFzaFxuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX291dHB1dGRhdHVtX19oYXNoXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX2hhc2hfX2hhc2hcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8wXCIpKTtcblxuXG5cdC8vIE91dHB1dERhdHVtOjpJbmxpbmVcblx0YWRkRW51bURhdGFGdW5jcyhcIl9faGVsaW9zX19vdXRwdXRkYXR1bV9faW5saW5lXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fb3V0cHV0ZGF0dW1fX2lubGluZV9fZGF0YVwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXG5cblx0Ly8gUmF3RGF0YVxuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fZGF0YVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2RhdGFfX3RhZ1wiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0X19jb3JlX19pRGF0YShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoc2VsZikpKVxuXHR9YCkpO1xuXG5cblx0Ly8gVHhPdXRwdXRJZFxuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fdHhvdXRwdXRpZFwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0aWRfX3R4X2lkXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dGlkX19pbmRleFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzFcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhvdXRwdXRpZF9fY29tcFwiLCBcblx0YChhLCBiLCBjb21wX3R4aWQsIGNvbXBfaW5kZXgpIC0+IHtcblx0XHQoYV90eGlkLCBhX2luZGV4KSAtPiB7XG5cdFx0XHQoYl90eGlkLCBiX2luZGV4KSAtPiB7XG5cdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoYV90eGlkLCBiX3R4aWQpLFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdGNvbXBfaW5kZXgoYV9pbmRleCwgYl9pbmRleClcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdGNvbXBfdHhpZChhX3R4aWQsIGJfdHhpZClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkoKVxuXHRcdFx0fShfX2hlbGlvc19fdHhvdXRwdXRpZF9fdHhfaWQoYiksIF9faGVsaW9zX190eG91dHB1dGlkX19pbmRleChiKSlcblx0XHR9KF9faGVsaW9zX190eG91dHB1dGlkX190eF9pZChhKSwgX19oZWxpb3NfX3R4b3V0cHV0aWRfX2luZGV4KGEpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhvdXRwdXRpZF9fX19sdFwiLCBcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX3R4b3V0cHV0aWRfX2NvbXAoYSwgYiwgX19oZWxpb3NfX3R4aWRfX19fbHQsIF9faGVsaW9zX19pbnRfX19fbHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dGlkX19fX2xlcVwiLCBcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX3R4b3V0cHV0aWRfX2NvbXAoYSwgYiwgX19oZWxpb3NfX3R4aWRfX19fbGVxLCBfX2hlbGlvc19faW50X19fX2xlcSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3R4b3V0cHV0aWRfX19fZ3RcIiwgXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9faGVsaW9zX190eG91dHB1dGlkX19jb21wKGEsIGIsIF9faGVsaW9zX190eGlkX19fX2d0LCBfX2hlbGlvc19faW50X19fX2d0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdHhvdXRwdXRpZF9fX19nZXFcIiwgXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9faGVsaW9zX190eG91dHB1dGlkX19jb21wKGEsIGIsIF9faGVsaW9zX190eGlkX19fX2dlcSwgX19oZWxpb3NfX2ludF9fX19nZXEpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190eG91dHB1dGlkX19uZXdcIixcblx0YCh0eF9pZCwgaWR4KSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMih0eF9pZCwgaWR4KSlcblx0fWApKTtcblxuXG5cdC8vIEFkZHJlc3Ncblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX2FkZHJlc3NcIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19hZGRyZXNzX19uZXdcIiwgXG5cdGAoY3JlZCwgc3Rha2luZ19jcmVkKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihjcmVkLCBzdGFraW5nX2NyZWQpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYWRkcmVzc19fbmV3X2VtcHR5XCIsXG5cdGAoKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihfX2hlbGlvc19fY3JlZGVudGlhbF9fbmV3X3B1YmtleShfX2NvcmVfX2JEYXRhKCMpKSwgX19oZWxpb3NfX29wdGlvbl9fbm9uZV9fbmV3KCkpKVxuXHR9YCkpXG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19hZGRyZXNzX19jcmVkZW50aWFsXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19hZGRyZXNzX19zdGFraW5nX2NyZWRlbnRpYWxcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8xXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2FkZHJlc3NfX2lzX3N0YWtlZFwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoX19jb3JlX19mc3RQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEoc2VsZikpKSwgMClcblx0XHR9XG5cdH1gKSk7XG5cblxuXHQvLyBDcmVkZW50aWFsIGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX19jcmVkZW50aWFsXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fbmV3X3B1YmtleVwiLFxuXHRgKGhhc2gpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKGhhc2gpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fbmV3X3ZhbGlkYXRvclwiLFxuXHRgKGhhc2gpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMSwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8xKGhhc2gpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9faXNfcHVia2V5XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoc2VsZikpLCAwKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9faXNfdmFsaWRhdG9yXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoc2VsZikpLCAxKVxuXHR9YCkpO1xuXG5cblx0Ly8gQ3JlZGVudGlhbDo6UHViS2V5IGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fcHVia2V5XCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fcHVia2V5X19jYXN0XCIsXG5cdGAoZGF0YSkgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX2Fzc2VydF9jb25zdHJfaW5kZXgoZGF0YSwgMClcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NyZWRlbnRpYWxfX3B1YmtleV9faGFzaFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXG5cblx0Ly8gQ3JlZGVudGlhbDo6VmFsaWRhdG9yIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yX19jYXN0XCIsXG5cdGAoZGF0YSkgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX2Fzc2VydF9jb25zdHJfaW5kZXgoZGF0YSwgMSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2NyZWRlbnRpYWxfX3ZhbGlkYXRvcl9faGFzaFwiLCBcIl9faGVsaW9zX19jb21tb25fX2ZpZWxkXzBcIikpO1xuXG5cblx0Ly8gU3Rha2luZ0hhc2ggYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc3Rha2luZ2hhc2hfX25ld19zdGFrZWtleVwiLCBcIl9faGVsaW9zX19jcmVkZW50aWFsX19uZXdfcHVia2V5XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX19uZXdfdmFsaWRhdG9yXCIsIFwiX19oZWxpb3NfX2NyZWRlbnRpYWxfX25ld192YWxpZGF0b3JcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc3Rha2luZ2hhc2hfX2lzX3N0YWtla2V5XCIsIFwiX19oZWxpb3NfX2NyZWRlbnRpYWxfX2lzX3N0YWtla2V5XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX19pc192YWxpZGF0b3JcIiwgXCJfX2hlbGlvc19fY3JlZGVudGlhbF9faXNfdmFsaWRhdG9yXCIpKTtcblxuXG5cdC8vIFN0YWtpbmdIYXNoOjpTdGFrZUtleSBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX19zdGFrZWtleVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX19zdGFrZWtleV9fY2FzdFwiLCBcIl9faGVsaW9zX19jcmVkZW50aWFsX19wdWJrZXlfX2Nhc3RcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc3Rha2luZ2hhc2hfX3N0YWtla2V5X19oYXNoXCIsIFwiX19oZWxpb3NfX2NyZWRlbnRpYWxfX3B1YmtleV9faGFzaFwiKSk7XG5cblxuXHQvLyBTdGFraW5nSGFzaDo6VmFsaWRhdG9yIGJ1aWx0aW5zXG5cdGFkZEVudW1EYXRhRnVuY3MoXCJfX2hlbGlvc19fc3Rha2luZ2hhc2hfX3ZhbGlkYXRvclwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX192YWxpZGF0b3JfX2Nhc3RcIiwgXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yX19jYXN0XCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdoYXNoX192YWxpZGF0b3JfX2hhc2hcIiwgXCJfX2hlbGlvc19fY3JlZGVudGlhbF9fdmFsaWRhdG9yX19oYXNoXCIpKTtcblxuXG5cdC8vIFN0YWtpbmdDcmVkZW50aWFsIGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX19zdGFraW5nY3JlZGVudGlhbFwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdjcmVkZW50aWFsX19uZXdfaGFzaFwiLCBcblx0YChjcmVkKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShjcmVkKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3N0YWtpbmdjcmVkZW50aWFsX19uZXdfcHRyXCIsIFxuXHRgKGksIGosIGspIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMSwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8zKGksIGosIGspKVxuXHR9YCkpO1xuXG5cdFxuXHQvLyBTdGFraW5nQ3JlZGVudGlhbDo6SGFzaCBidWlsdGluc1xuXHRhZGRFbnVtRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3N0YWtpbmdjcmVkZW50aWFsX19oYXNoXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fc3Rha2luZ2NyZWRlbnRpYWxfX2hhc2hfX2hhc2hcIiwgXCJfX2hlbGlvc19fY29tbW9uX19maWVsZF8wXCIpKTtcblxuXG5cdC8vIFN0YWtpbmdDcmVkZW50aWFsOjpQdHIgYnVpbHRpbnNcblx0YWRkRW51bURhdGFGdW5jcyhcIl9faGVsaW9zX19zdGFraW5nY3JlZGVudGlhbF9fcHRyXCIpO1xuXG5cblx0Ly8gVGltZSBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fdGltZVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVfX25ld1wiLCBgX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHlgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lX19fX2FkZFwiLCBgX19oZWxpb3NfX2ludF9fX19hZGRgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lX19fX3N1YlwiLCBgX19oZWxpb3NfX2ludF9fX19zdWJgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lX19fX3N1Yl9hbHRcIiwgYF9faGVsaW9zX19pbnRfX19fc3ViYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdGltZV9fX19nZXFcIiwgYF9faGVsaW9zX19pbnRfX19fZ2VxYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdGltZV9fX19ndFwiLCBgX19oZWxpb3NfX2ludF9fX19ndGApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVfX19fbGVxXCIsIGBfX2hlbGlvc19faW50X19fX2xlcWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVfX19fbHRcIiwgYF9faGVsaW9zX19pbnRfX19fbHRgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lX19zaG93XCIsIGBfX2hlbGlvc19faW50X19zaG93YCkpO1xuXG5cblx0Ly8gRHVyYXRpbiBidWlsdGluc1xuXHRhZGREYXRhRnVuY3MoXCJfX2hlbGlvc19fZHVyYXRpb25cIik7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fbmV3XCIsIGBfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2R1cmF0aW9uX19fX2FkZFwiLCBgX19oZWxpb3NfX2ludF9fX19hZGRgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fX19zdWJcIiwgYF9faGVsaW9zX19pbnRfX19fc3ViYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZHVyYXRpb25fX19fbXVsXCIsIGBfX2hlbGlvc19faW50X19fX211bGApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2R1cmF0aW9uX19fX2RpdlwiLCBgX19oZWxpb3NfX2ludF9fX19kaXZgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fX19kaXZfYWx0XCIsIGBfX2hlbGlvc19faW50X19fX2RpdmApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2R1cmF0aW9uX19fX21vZFwiLCBgX19oZWxpb3NfX2ludF9fX19tb2RgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fX19nZXFcIiwgYF9faGVsaW9zX19pbnRfX19fZ2VxYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZHVyYXRpb25fX19fZ3RcIiwgYF9faGVsaW9zX19pbnRfX19fZ3RgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fX19sZXFcIiwgYF9faGVsaW9zX19pbnRfX19fbGVxYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZHVyYXRpb25fX19fbHRcIiwgYF9faGVsaW9zX19pbnRfX19fbHRgKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fU0VDT05EXCIsIFwiX19jb3JlX19pRGF0YSgxMDAwKVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fTUlOVVRFXCIsIFwiX19jb3JlX19pRGF0YSg2MDAwMClcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fZHVyYXRpb25fX0hPVVJcIiwgXCJfX2NvcmVfX2lEYXRhKDM2MDAwMDApXCIpKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX2R1cmF0aW9uX19EQVlcIiwgXCJfX2NvcmVfX2lEYXRhKDg2NDAwMDAwKVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19kdXJhdGlvbl9fV0VFS1wiLCBcIl9fY29yZV9faURhdGEoNjA0ODAwMDAwKVwiKSk7XG5cblxuXHQvLyBUaW1lUmFuZ2UgYnVpbHRpbnNcblx0YWRkRGF0YUZ1bmNzKFwiX19oZWxpb3NfX3RpbWVyYW5nZVwiKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fbmV3XCIsIGBcblx0KGEsIGIpIC0+IHtcblx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShhKSksXG5cdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHRydWUpXG5cdFx0XHQpKSxcblx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgxLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoYikpLFxuXHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YSh0cnVlKVxuXHRcdFx0KSlcblx0XHQpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdGltZXJhbmdlX19BTFdBWVNcIiwgYFxuXHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wKSxcblx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHRydWUpXG5cdFx0KSksXG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgyLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzApLFxuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEodHJ1ZSlcblx0XHQpKVxuXHQpKWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fTkVWRVJcIiwgYFxuXHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMiwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wKSxcblx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHRydWUpXG5cdFx0KSksXG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzApLFxuXHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEodHJ1ZSlcblx0XHQpKVxuXHQpKWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fZnJvbVwiLCBgXG5cdChhKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHRcdF9fY29yZV9fY29uc3RyRGF0YSgxLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzEoYSkpLFxuXHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YSh0cnVlKVxuXHRcdFx0KSksXG5cdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMiwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wKSxcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEodHJ1ZSlcblx0XHRcdCkpXG5cdFx0KSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fdG9cIiwgYFxuXHQoYikgLT4ge1xuXHRcdF9fY29yZV9fY29uc3RyRGF0YSgwLCBfX2hlbGlvc19fY29tbW9uX19saXN0XzIoXG5cdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8yKFxuXHRcdFx0XHRfX2NvcmVfX2NvbnN0ckRhdGEoMCwgX19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wKSxcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGEodHJ1ZSlcblx0XHRcdCkpLFxuXHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihcblx0XHRcdFx0X19jb3JlX19jb25zdHJEYXRhKDEsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMShiKSksXG5cdFx0XHRcdF9faGVsaW9zX19jb21tb25fX2Jvb2xEYXRhKHRydWUpXG5cdFx0XHQpKVxuXHRcdCkpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lcmFuZ2VfX2lzX2JlZm9yZVwiLCBcblx0YChzZWxmKSAtPiB7XG5cdFx0KHQpIC0+IHtcblx0XHRcdCh1cHBlcikgLT4ge1xuXHRcdFx0XHQoZXh0ZW5kZWQsIGNsb3NlZCkgLT4ge1xuXHRcdFx0XHRcdChleHRUeXBlKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihleHRUeXBlLCAyKSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihleHRUeXBlLCAwKSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHt0cnVlfSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3NlZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19sZXNzVGhhbkludGVnZXIoX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSwgX19jb3JlX191bklEYXRhKHQpKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbGVzc1RoYW5FcXVhbHNJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YShfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKSksIF9fY29yZV9fdW5JRGF0YSh0KSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9KF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKVxuXHRcdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAodXBwZXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEodXBwZXIpKSlcblx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMShzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lcmFuZ2VfX2lzX2FmdGVyXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCh0KSAtPiB7XG5cdFx0XHQobG93ZXIpIC0+IHtcblx0XHRcdFx0KGV4dGVuZGVkLCBjbG9zZWQpIC0+IHtcblx0XHRcdFx0XHQoZXh0VHlwZSkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoZXh0VHlwZSwgMCksXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtmYWxzZX0sXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoZXh0VHlwZSwgMiksXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7dHJ1ZX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKF9fY29yZV9fdW5JRGF0YSh0KSwgX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSl9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX2xlc3NUaGFuRXF1YWxzSW50ZWdlcihfX2NvcmVfX3VuSURhdGEodCksIF9fY29yZV9fdW5JRGF0YShfX2NvcmVfX2hlYWRMaXN0KF9fY29yZV9fc25kUGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKSkpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoZXh0ZW5kZWQpKSlcblx0XHRcdFx0fShfX2hlbGlvc19fY29tbW9uX19maWVsZF8wKGxvd2VyKSwgX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YShfX2hlbGlvc19fY29tbW9uX19maWVsZF8xKGxvd2VyKSkpXG5cdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAoc2VsZikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdGltZXJhbmdlX19jb250YWluc1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQodCkgLT4ge1xuXHRcdFx0KGxvd2VyKSAtPiB7XG5cdFx0XHRcdChleHRlbmRlZCwgY2xvc2VkKSAtPiB7XG5cdFx0XHRcdFx0KGxvd2VyRXh0VHlwZSwgY2hlY2tVcHBlcikgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIobG93ZXJFeHRUeXBlLCAyKSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihsb3dlckV4dFR5cGUsIDApLFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2NoZWNrVXBwZXIoKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19sZXNzVGhhbkVxdWFsc0ludGVnZXIoX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSwgX19jb3JlX191bklEYXRhKHQpKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19sZXNzVGhhbkludGVnZXIoX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSwgX19jb3JlX191bklEYXRhKHQpKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2NoZWNrVXBwZXIoKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX191bkNvbnN0ckRhdGEoZXh0ZW5kZWQpKSwgKCkgLT4ge1xuXHRcdFx0XHRcdFx0KHVwcGVyKSAtPiB7XG5cdFx0XHRcdFx0XHRcdChleHRlbmRlZCwgY2xvc2VkKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0KHVwcGVyRXh0VHlwZSkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIodXBwZXJFeHRUeXBlLCAwKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2ZhbHNlfSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcih1cHBlckV4dFR5cGUsIDIpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge3RydWV9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbGVzc1RoYW5FcXVhbHNJbnRlZ2VyKF9fY29yZV9fdW5JRGF0YSh0KSwgX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSl9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbGVzc1RoYW5JbnRlZ2VyKF9fY29yZV9fdW5JRGF0YSh0KSwgX19jb3JlX191bklEYXRhKF9fY29yZV9faGVhZExpc3QoX19jb3JlX19zbmRQYWlyKF9fY29yZV9fdW5Db25zdHJEYXRhKGV4dGVuZGVkKSkpKSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKVxuXHRcdFx0XHRcdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAodXBwZXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEodXBwZXIpKSlcblx0XHRcdFx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMShzZWxmKSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAobG93ZXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEobG93ZXIpKSlcblx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX190aW1lcmFuZ2VfX3N0YXJ0XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChfX2hlbGlvc19fY29tbW9uX19maWVsZF8wKHNlbGYpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fZW5kXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChfX2hlbGlvc19fY29tbW9uX19maWVsZF8xKHNlbGYpKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3RpbWVyYW5nZV9fc2hvd1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHQoc2hvd19leHRlbmRlZCkgLT4ge1xuXHRcdFx0XHRfX2hlbGlvc19fc3RyaW5nX19fX2FkZChcblx0XHRcdFx0XHQobG93ZXIpIC0+IHtcblx0XHRcdFx0XHRcdChleHRlbmRlZCwgY2xvc2VkKSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9faGVsaW9zX19zdHJpbmdfX19fYWRkKFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3NlZCxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwiW1wiKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShcIihcIil9XG5cdFx0XHRcdFx0XHRcdFx0KSgpLFxuXHRcdFx0XHRcdFx0XHRcdHNob3dfZXh0ZW5kZWQoZXh0ZW5kZWQpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChsb3dlciksIF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMShsb3dlcikpKVxuXHRcdFx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChzZWxmKSksXG5cdFx0XHRcdFx0X19oZWxpb3NfX3N0cmluZ19fX19hZGQoXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwiLFwiKSxcblx0XHRcdFx0XHRcdCh1cHBlcikgLT4ge1xuXHRcdFx0XHRcdFx0XHQoZXh0ZW5kZWQsIGNsb3NlZCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19zdHJpbmdfX19fYWRkKFxuXHRcdFx0XHRcdFx0XHRcdFx0c2hvd19leHRlbmRlZChleHRlbmRlZCksXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3NlZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGEoXCJdXCIpfSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGEoXCIpXCIpfVxuXHRcdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAodXBwZXIpLCBfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEodXBwZXIpKSlcblx0XHRcdFx0XHRcdH0oX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMShzZWxmKSlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdH0oXG5cdFx0XHRcdChleHRlbmRlZCkgLT4ge1xuXHRcdFx0XHRcdChleHRUeXBlKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihleHRUeXBlLCAwKSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge19faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGEoXCItaW5mXCIpfSxcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzSW50ZWdlcihleHRUeXBlLCAyKSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwiK2luZlwiKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChmaWVsZHMpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19faW50X19zaG93KF9fY29yZV9faGVhZExpc3QoZmllbGRzKSkoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KF9fY29yZV9fc25kUGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9KF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX3VuQ29uc3RyRGF0YShleHRlbmRlZCkpKVxuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpXG5cblxuXHQvLyBBc3NldENsYXNzIGJ1aWx0aW5zXG5cdGFkZERhdGFGdW5jcyhcIl9faGVsaW9zX19hc3NldGNsYXNzXCIpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYXNzZXRjbGFzc19fQURBXCIsIGBfX2hlbGlvc19fYXNzZXRjbGFzc19fbmV3KF9fY29yZV9fYkRhdGEoIyksIF9fY29yZV9fYkRhdGEoIykpYCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYXNzZXRjbGFzc19fbmV3XCIsXG5cdGAobXBoLCB0b2tlbl9uYW1lKSAtPiB7XG5cdFx0X19jb3JlX19jb25zdHJEYXRhKDAsIF9faGVsaW9zX19jb21tb25fX2xpc3RfMihtcGgsIHRva2VuX25hbWUpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fYXNzZXRjbGFzc19fbXBoXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMFwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX19hc3NldGNsYXNzX190b2tlbl9uYW1lXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMVwiKSk7XG5cblxuXHQvLyBWYWx1ZSBidWlsdGluc1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX3NlcmlhbGl6ZVwiLCBcIl9faGVsaW9zX19jb21tb25fX3NlcmlhbGl6ZVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZnJvbV9kYXRhXCIsIFwiX19oZWxpb3NfX2NvbW1vbl9faWRlbnRpdHlcIikpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX1pFUk9cIiwgYF9fY29yZV9fbWFwRGF0YShfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpKWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3ZhbHVlX19sb3ZlbGFjZVwiLFxuXHRgKGkpIC0+IHtcblx0XHRfX2hlbGlvc19fdmFsdWVfX25ldyhfX2hlbGlvc19fYXNzZXRjbGFzc19fQURBLCBpKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX25ld1wiLFxuXHRgKGFzc2V0Q2xhc3MsIGkpIC0+IHtcblx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRfX2NvcmVfX2VxdWFsc0ludGVnZXIoMCwgX19jb3JlX191bklEYXRhKGkpKSxcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX3ZhbHVlX19aRVJPXG5cdFx0XHR9LFxuXHRcdFx0KCkgLT4ge1xuXHRcdFx0XHQobWludGluZ1BvbGljeUhhc2gsIHRva2VuTmFtZSkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fbWFwRGF0YShcblx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rUGFpckRhdGEoXG5cdFx0XHRcdFx0XHRcdFx0bWludGluZ1BvbGljeUhhc2gsIFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWFwRGF0YShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rUGFpckRhdGEodG9rZW5OYW1lLCBpKSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSlcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdCksIFxuXHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9KF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAoYXNzZXRDbGFzcyksIF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEoYXNzZXRDbGFzcykpXG5cdFx0XHR9XG5cdFx0KSgpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZnJvbV9tYXBcIiwgXCJfX2hlbGlvc19fY29tbW9uX19pZGVudGl0eVwiKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fdG9fbWFwXCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHRzZWxmXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2dldF9tYXBfa2V5c1wiLFxuXHRgKG1hcCkgLT4ge1xuXHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIG1hcClcblx0XHR9KFxuXHRcdFx0KHJlY3Vyc2UsIG1hcCkgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0bWFwLCBcblx0XHRcdFx0XHQoKSAtPiB7X19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wfSwgXG5cdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtDb25zKF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX2hlYWRMaXN0KG1hcCkpLCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3QobWFwKSkpfVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fbWVyZ2VfbWFwX2tleXNcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0KGFLZXlzKSAtPiB7XG5cdFx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0XHQodW5pcXVlQktleXMpIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19jb25jYXQoYUtleXMsIHVuaXF1ZUJLZXlzKVxuXHRcdFx0XHR9KHJlY3Vyc2UocmVjdXJzZSwgYUtleXMsIGIpKVxuXHRcdFx0fShcblx0XHRcdFx0KHJlY3Vyc2UsIGtleXMsIG1hcCkgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdG1hcCwgXG5cdFx0XHRcdFx0XHQoKSAtPiB7X19oZWxpb3NfX2NvbW1vbl9fbGlzdF8wfSwgXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdChrZXkpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19pc19pbl9ieXRlYXJyYXlfbGlzdChhS2V5cywga2V5KSwgXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBrZXlzLCBfX2NvcmVfX3RhaWxMaXN0KG1hcCkpfSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rQ29ucyhrZXksIHJlY3Vyc2UocmVjdXJzZSwga2V5cywgX19jb3JlX190YWlsTGlzdChtYXApKSl9XG5cdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdH0oX19jb3JlX19mc3RQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSkpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9faGVsaW9zX192YWx1ZV9fZ2V0X21hcF9rZXlzKGEpKVxuXHR9YCkpO1xuXG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZ2V0X2lubmVyX21hcFwiLFxuXHRgKG1hcCwgbXBoKSAtPiB7XG5cdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgbWFwKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgbWFwKSAtPiB7XG5cdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRtYXAsIFxuXHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX21rTmlsUGFpckRhdGEoKCkpfSxcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSwgbXBoKSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX3VuTWFwRGF0YShfX2NvcmVfX3NuZFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSl9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KG1hcCkpfVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZ2V0X2lubmVyX21hcF9pbnRcIixcblx0YChtYXAsIGtleSkgLT4ge1xuXHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRyZWN1cnNlKHJlY3Vyc2UsIG1hcCwga2V5KVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwgbWFwLCBrZXkpIC0+IHtcblx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdG1hcCwgXG5cdFx0XHRcdFx0KCkgLT4gezB9LCBcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSwga2V5KSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX3VuSURhdGEoX19jb3JlX19zbmRQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSkpfSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3QobWFwKSwga2V5KX1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSgpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2FkZF9vcl9zdWJ0cmFjdF9pbm5lclwiLFxuXHRgKG9wKSAtPiB7XG5cdFx0KGEsIGIpIC0+IHtcblx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdHJlY3Vyc2UocmVjdXJzZSwgX19oZWxpb3NfX3ZhbHVlX19tZXJnZV9tYXBfa2V5cyhhLCBiKSwgX19jb3JlX19ta05pbFBhaXJEYXRhKCgpKSlcblx0XHRcdH0oXG5cdFx0XHRcdChyZWN1cnNlLCBrZXlzLCByZXN1bHQpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0XHRrZXlzLCBcblx0XHRcdFx0XHRcdCgpIC0+IHtyZXN1bHR9LCBcblx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0KGtleSwgdGFpbCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdChzdW0pIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNJbnRlZ2VyKHN1bSwgMCksIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7dGFpbH0sIFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19ta0NvbnMoX19jb3JlX19ta1BhaXJEYXRhKGtleSwgX19jb3JlX19pRGF0YShzdW0pKSwgdGFpbCl9XG5cdFx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0XHR9KG9wKF9faGVsaW9zX192YWx1ZV9fZ2V0X2lubmVyX21hcF9pbnQoYSwga2V5KSwgX19oZWxpb3NfX3ZhbHVlX19nZXRfaW5uZXJfbWFwX2ludChiLCBrZXkpKSlcblx0XHRcdFx0XHRcdFx0fShfX2NvcmVfX2hlYWRMaXN0KGtleXMpLCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoa2V5cyksIHJlc3VsdCkpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fYWRkX29yX3N1YnRyYWN0XCIsXG5cdGAob3AsIGEsIGIpIC0+IHtcblx0XHQoYSwgYikgLT4ge1xuXHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0X19jb3JlX19tYXBEYXRhKHJlY3Vyc2UocmVjdXJzZSwgX19oZWxpb3NfX3ZhbHVlX19tZXJnZV9tYXBfa2V5cyhhLCBiKSwgX19jb3JlX19ta05pbFBhaXJEYXRhKCgpKSkpXG5cdFx0XHR9KFxuXHRcdFx0XHQocmVjdXJzZSwga2V5cywgcmVzdWx0KSAtPiB7XG5cdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0a2V5cywgXG5cdFx0XHRcdFx0XHQoKSAtPiB7cmVzdWx0fSwgXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdChrZXksIHRhaWwpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHQoaXRlbSkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtLCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge3RhaWx9LCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtDb25zKF9fY29yZV9fbWtQYWlyRGF0YShrZXksIF9fY29yZV9fbWFwRGF0YShpdGVtKSksIHRhaWwpfVxuXHRcdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdFx0fShfX2hlbGlvc19fdmFsdWVfX2FkZF9vcl9zdWJ0cmFjdF9pbm5lcihvcCkoX19oZWxpb3NfX3ZhbHVlX19nZXRfaW5uZXJfbWFwKGEsIGtleSksIF9faGVsaW9zX192YWx1ZV9fZ2V0X2lubmVyX21hcChiLCBrZXkpKSlcblx0XHRcdFx0XHRcdFx0fShfX2NvcmVfX2hlYWRMaXN0KGtleXMpLCByZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoa2V5cyksIHJlc3VsdCkpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKGEpLCBfX2NvcmVfX3VuTWFwRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3ZhbHVlX19tYXBfcXVhbnRpdGllc1wiLFxuXHRgKHNlbGYsIG9wKSAtPiB7XG5cdFx0KHNlbGYpIC0+IHtcblx0XHRcdChyZWN1cnNlSW5uZXIpIC0+IHtcblx0XHRcdFx0KHJlY3Vyc2VPdXRlcikgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fbWFwRGF0YShyZWN1cnNlT3V0ZXIocmVjdXJzZU91dGVyLCBzZWxmKSlcblx0XHRcdFx0fShcblx0XHRcdFx0XHQocmVjdXJzZU91dGVyLCBvdXRlcikgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRvdXRlcixcblx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSl9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0KGhlYWQpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX21rUGFpckRhdGEoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19mc3RQYWlyKGhlYWQpLCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX21hcERhdGEocmVjdXJzZUlubmVyKHJlY3Vyc2VJbm5lciwgX19jb3JlX191bk1hcERhdGEoX19jb3JlX19zbmRQYWlyKGhlYWQpKSkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCksICBcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVjdXJzZU91dGVyKHJlY3Vyc2VPdXRlciwgX19jb3JlX190YWlsTGlzdChvdXRlcikpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0fShfX2NvcmVfX2hlYWRMaXN0KG91dGVyKSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9KFxuXHRcdFx0XHQocmVjdXJzZUlubmVyLCBpbm5lcikgLT4ge1xuXHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdGlubmVyLFxuXHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fbWtOaWxQYWlyRGF0YSgoKSl9LFxuXHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHQoaGVhZCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fbWtDb25zKFxuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19ta1BhaXJEYXRhKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2ZzdFBhaXIoaGVhZCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faURhdGEob3AoX19jb3JlX191bklEYXRhKF9fY29yZV9fc25kUGFpcihoZWFkKSkpKVxuXHRcdFx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlY3Vyc2VJbm5lcihyZWN1cnNlSW5uZXIsIF9fY29yZV9fdGFpbExpc3QoaW5uZXIpKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0fShfX2NvcmVfX2hlYWRMaXN0KGlubmVyKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpKClcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fY29tcGFyZV9pbm5lclwiLFxuXHRgKGNvbXAsIGEsIGIpIC0+IHtcblx0XHQocmVjdXJzZSkgLT4ge1xuXHRcdFx0cmVjdXJzZShyZWN1cnNlLCBfX2hlbGlvc19fdmFsdWVfX21lcmdlX21hcF9rZXlzKGEsIGIpKVxuXHRcdH0oXG5cdFx0XHQocmVjdXJzZSwga2V5cykgLT4ge1xuXHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0a2V5cywgXG5cdFx0XHRcdFx0KCkgLT4ge3RydWV9LCBcblx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHQoa2V5KSAtPiB7XG5cdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoY29tcChfX2hlbGlvc19fdmFsdWVfX2dldF9pbm5lcl9tYXBfaW50KGEsIGtleSksIF9faGVsaW9zX192YWx1ZV9fZ2V0X2lubmVyX21hcF9pbnQoYiwga2V5KSkpLCBcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7ZmFsc2V9LCBcblx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KGtleXMpKX1cblx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3Qoa2V5cykpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fY29tcGFyZVwiLFxuXHRgKGNvbXAsIGEsIGIpIC0+IHtcblx0XHQoYSwgYikgLT4ge1xuXHRcdFx0KHJlY3Vyc2UpIC0+IHtcblx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCBfX2hlbGlvc19fdmFsdWVfX21lcmdlX21hcF9rZXlzKGEsIGIpKVxuXHRcdFx0fShcblx0XHRcdFx0KHJlY3Vyc2UsIGtleXMpIC0+IHtcblx0XHRcdFx0XHRfX2NvcmVfX2Nob29zZUxpc3QoXG5cdFx0XHRcdFx0XHRrZXlzLCBcblx0XHRcdFx0XHRcdCgpIC0+IHt0cnVlfSwgXG5cdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdChrZXkpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX192YWx1ZV9fY29tcGFyZV9pbm5lcihcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21wLCBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fdmFsdWVfX2dldF9pbm5lcl9tYXAoYSwga2V5KSwgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3ZhbHVlX19nZXRfaW5uZXJfbWFwKGIsIGtleSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0KSwgXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7ZmFsc2V9LCBcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3Qoa2V5cykpfVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9KF9fY29yZV9faGVhZExpc3Qoa2V5cykpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KSgpXG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHR9KF9fY29yZV9fdW5NYXBEYXRhKGEpLCBfX2NvcmVfX3VuTWFwRGF0YShiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3ZhbHVlX19fX2VxXCIsXG5cdGAoYSwgYikgLT4ge1xuXHRcdF9faGVsaW9zX192YWx1ZV9fY29tcGFyZShfX2NvcmVfX2VxdWFsc0ludGVnZXIsIGEsIGIpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19uZXFcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2NvbW1vbl9fbm90KF9faGVsaW9zX192YWx1ZV9fX19lcShhLCBiKSlcblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3ZhbHVlX19fX2FkZFwiLFxuXHRgKGEsIGIpIC0+IHtcblx0XHRfX2hlbGlvc19fdmFsdWVfX2FkZF9vcl9zdWJ0cmFjdChfX2NvcmVfX2FkZEludGVnZXIsIGEsIGIpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19zdWJcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX3ZhbHVlX19hZGRfb3Jfc3VidHJhY3QoX19jb3JlX19zdWJ0cmFjdEludGVnZXIsIGEsIGIpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19tdWxcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0KHNjYWxlKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fdmFsdWVfX21hcF9xdWFudGl0aWVzKGEsIChxdHkpIC0+IHtfX2NvcmVfX211bHRpcGx5SW50ZWdlcihxdHksIHNjYWxlKX0pXG5cdFx0fShfX2NvcmVfX3VuSURhdGEoYikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19kaXZcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0KGRlbikgLT4ge1xuXHRcdFx0X19oZWxpb3NfX3ZhbHVlX19tYXBfcXVhbnRpdGllcyhhLCAocXR5KSAtPiB7X19jb3JlX19kaXZpZGVJbnRlZ2VyKHF0eSwgZGVuKX0pXG5cdFx0fShfX2NvcmVfX3VuSURhdGEoYikpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19nZXFcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX3ZhbHVlX19jb21wYXJlKChhX3F0eSwgYl9xdHkpIC0+IHtfX2hlbGlvc19fY29tbW9uX19ub3QoX19jb3JlX19sZXNzVGhhbkludGVnZXIoYV9xdHksIGJfcXR5KSl9LCBhLCBiKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2NvbnRhaW5zXCIsIGBcblx0KHNlbGYpIC0+IHtcblx0XHQodmFsdWUpIC0+IHtcblx0XHRcdF9faGVsaW9zX192YWx1ZV9fX19nZXEoc2VsZiwgdmFsdWUpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX19fZ3RcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2Jvb2xfX2FuZChcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fbm90KFxuXHRcdFx0XHRcdF9faGVsaW9zX19ib29sX19hbmQoXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fdmFsdWVfX2lzX3plcm8oYSksXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fdmFsdWVfX2lzX3plcm8oYilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdH0sXG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX192YWx1ZV9fY29tcGFyZShcblx0XHRcdFx0XHQoYV9xdHksIGJfcXR5KSAtPiB7XG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoX19jb3JlX19sZXNzVGhhbkVxdWFsc0ludGVnZXIoYV9xdHksIGJfcXR5KSlcblx0XHRcdFx0XHR9LCBcblx0XHRcdFx0XHRhLCBcblx0XHRcdFx0XHRiXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHQpXG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fX19sZXFcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX3ZhbHVlX19jb21wYXJlKF9fY29yZV9fbGVzc1RoYW5FcXVhbHNJbnRlZ2VyLCBhLCBiKVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX19fbHRcIixcblx0YChhLCBiKSAtPiB7XG5cdFx0X19oZWxpb3NfX2Jvb2xfX2FuZChcblx0XHRcdCgpIC0+IHtcblx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fbm90KFxuXHRcdFx0XHRcdF9faGVsaW9zX19ib29sX19hbmQoXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fdmFsdWVfX2lzX3plcm8oYSksXG5cdFx0XHRcdFx0XHRfX2hlbGlvc19fdmFsdWVfX2lzX3plcm8oYilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHRcdH0sXG5cdFx0XHQoKSAtPiB7XG5cdFx0XHRcdF9faGVsaW9zX192YWx1ZV9fY29tcGFyZShcblx0XHRcdFx0XHQoYV9xdHksIGJfcXR5KSAtPiB7XG5cdFx0XHRcdFx0XHRfX2NvcmVfX2xlc3NUaGFuSW50ZWdlcihhX3F0eSwgYl9xdHkpXG5cdFx0XHRcdFx0fSwgXG5cdFx0XHRcdFx0YSwgXG5cdFx0XHRcdFx0YlxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0KVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2lzX3plcm9cIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19jb3JlX19udWxsTGlzdChfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZ2V0XCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChhc3NldENsYXNzKSAtPiB7XG5cdFx0XHQobWFwLCBtaW50aW5nUG9saWN5SGFzaCwgdG9rZW5OYW1lKSAtPiB7XG5cdFx0XHRcdChvdXRlciwgaW5uZXIpIC0+IHtcblx0XHRcdFx0XHRvdXRlcihvdXRlciwgaW5uZXIsIG1hcClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQob3V0ZXIsIGlubmVyLCBtYXApIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdFx0bWFwLCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge2Vycm9yKFwicG9saWN5IG5vdCBmb3VuZFwiKX0sIFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNEYXRhKF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX2hlYWRMaXN0KG1hcCkpLCBtaW50aW5nUG9saWN5SGFzaCksIFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2lubmVyKGlubmVyLCBfX2NvcmVfX3VuTWFwRGF0YShfX2NvcmVfX3NuZFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSkpfSwgXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7b3V0ZXIob3V0ZXIsIGlubmVyLCBfX2NvcmVfX3RhaWxMaXN0KG1hcCkpfVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9LCAoaW5uZXIsIG1hcCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRtYXAsIFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7ZXJyb3IoXCJ0b2tlbk5hbWUgbm90IGZvdW5kXCIpfSwgXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoX19jb3JlX19mc3RQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSksIHRva2VuTmFtZSksXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7X19jb3JlX19zbmRQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSl9LFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge2lubmVyKGlubmVyLCBfX2NvcmVfX3RhaWxMaXN0KG1hcCkpfVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZiksIF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzAoYXNzZXRDbGFzcyksIF9faGVsaW9zX19jb21tb25fX2ZpZWxkXzEoYXNzZXRDbGFzcykpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2dldF9zYWZlXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdChhc3NldENsYXNzKSAtPiB7XG5cdFx0XHQobWFwLCBtaW50aW5nUG9saWN5SGFzaCwgdG9rZW5OYW1lKSAtPiB7XG5cdFx0XHRcdChvdXRlciwgaW5uZXIpIC0+IHtcblx0XHRcdFx0XHRvdXRlcihvdXRlciwgaW5uZXIsIG1hcClcblx0XHRcdFx0fShcblx0XHRcdFx0XHQob3V0ZXIsIGlubmVyLCBtYXApIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdFx0bWFwLCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9faURhdGEoMCl9LCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSwgbWludGluZ1BvbGljeUhhc2gpLCBcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtpbm5lcihpbm5lciwgX19jb3JlX191bk1hcERhdGEoX19jb3JlX19zbmRQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSkpKX0sIFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge291dGVyKG91dGVyLCBpbm5lciwgX19jb3JlX190YWlsTGlzdChtYXApKX1cblx0XHRcdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0fSwgKGlubmVyLCBtYXApIC0+IHtcblx0XHRcdFx0XHRcdF9fY29yZV9fY2hvb3NlTGlzdChcblx0XHRcdFx0XHRcdFx0bWFwLCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9faURhdGEoMCl9LCBcblx0XHRcdFx0XHRcdFx0KCkgLT4ge1xuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9fY29yZV9fZXF1YWxzRGF0YShfX2NvcmVfX2ZzdFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKSwgdG9rZW5OYW1lKSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtfX2NvcmVfX3NuZFBhaXIoX19jb3JlX19oZWFkTGlzdChtYXApKX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7aW5uZXIoaW5uZXIsIF9fY29yZV9fdGFpbExpc3QobWFwKSl9XG5cdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSwgX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMChhc3NldENsYXNzKSwgX19oZWxpb3NfX2NvbW1vbl9fZmllbGRfMShhc3NldENsYXNzKSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZ2V0X2xvdmVsYWNlXCIsXG5cdGAoc2VsZikgLT4ge1xuXHRcdCgpIC0+IHtcblx0XHRcdF9faGVsaW9zX192YWx1ZV9fZ2V0X3NhZmUoc2VsZikoX19oZWxpb3NfX2Fzc2V0Y2xhc3NfX0FEQSlcblx0XHR9XG5cdH1gKSk7XG5cdGFkZChuZXcgUmF3RnVuYyhcIl9faGVsaW9zX192YWx1ZV9fZ2V0X2Fzc2V0c1wiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQoKSAtPiB7XG5cdFx0XHRfX2hlbGlvc19fbWFwX19maWx0ZXIoc2VsZikoXG5cdFx0XHRcdChrZXksIF8pIC0+IHtcblx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19ub3QoX19jb3JlX19lcXVhbHNCeXRlU3RyaW5nKF9fY29yZV9fdW5CRGF0YShrZXkpLCAjKSlcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdH1cblx0fWApKTtcblx0YWRkKG5ldyBSYXdGdW5jKFwiX19oZWxpb3NfX3ZhbHVlX19nZXRfcG9saWN5XCIsIFxuXHRgKHNlbGYpIC0+IHtcblx0XHQobXBoKSAtPiB7XG5cdFx0XHQobWFwKSAtPiB7XG5cdFx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCBtYXApXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIG1hcCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRtYXAsXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtlcnJvcihcInBvbGljeSBub3QgZm91bmRcIil9LFxuXHRcdFx0XHRcdFx0XHQoKSAtPiB7XG5cdFx0XHRcdFx0XHRcdFx0X19jb3JlX19pZlRoZW5FbHNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0X19jb3JlX19lcXVhbHNEYXRhKF9fY29yZV9fZnN0UGFpcihfX2NvcmVfX2hlYWRMaXN0KG1hcCkpLCBtcGgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0KCkgLT4ge19fY29yZV9fc25kUGFpcihfX2NvcmVfX2hlYWRMaXN0KG1hcCkpfSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtyZWN1cnNlKHJlY3Vyc2UsIF9fY29yZV9fdGFpbExpc3QobWFwKSl9XG5cdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0fShfX2NvcmVfX3VuTWFwRGF0YShzZWxmKSlcblx0XHR9IFxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX2NvbnRhaW5zX3BvbGljeVwiLFxuXHRgKHNlbGYpIC0+IHtcblx0XHQobXBoKSAtPiB7XG5cdFx0XHQobWFwKSAtPiB7XG5cdFx0XHRcdChyZWN1cnNlKSAtPiB7XG5cdFx0XHRcdFx0cmVjdXJzZShyZWN1cnNlLCBtYXApXG5cdFx0XHRcdH0oXG5cdFx0XHRcdFx0KHJlY3Vyc2UsIG1hcCkgLT4ge1xuXHRcdFx0XHRcdFx0X19jb3JlX19jaG9vc2VMaXN0KFxuXHRcdFx0XHRcdFx0XHRtYXAsXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtmYWxzZX0sXG5cdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2lmVGhlbkVsc2UoXG5cdFx0XHRcdFx0XHRcdFx0XHRfX2NvcmVfX2VxdWFsc0RhdGEoX19jb3JlX19mc3RQYWlyKF9fY29yZV9faGVhZExpc3QobWFwKSksIG1waCksXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7dHJ1ZX0sXG5cdFx0XHRcdFx0XHRcdFx0XHQoKSAtPiB7cmVjdXJzZShyZWN1cnNlLCBfX2NvcmVfX3RhaWxMaXN0KG1hcCkpfVxuXHRcdFx0XHRcdFx0XHRcdCkoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH0oX19jb3JlX191bk1hcERhdGEoc2VsZikpXG5cdFx0fVxuXHR9YCkpO1xuXHRhZGQobmV3IFJhd0Z1bmMoXCJfX2hlbGlvc19fdmFsdWVfX3Nob3dcIixcblx0YChzZWxmKSAtPiB7XG5cdFx0KCkgLT4ge1xuXHRcdFx0X19oZWxpb3NfX21hcF9fZm9sZChzZWxmKShcblx0XHRcdFx0KHByZXYsIG1waCwgdG9rZW5zKSAtPiB7XG5cdFx0XHRcdFx0X19oZWxpb3NfX21hcF9fZm9sZCh0b2tlbnMpKFxuXHRcdFx0XHRcdFx0KHByZXYsIHRva2VuX25hbWUsIHF0eSkgLT4ge1xuXHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fc3RyaW5nX19fX2FkZChcblx0XHRcdFx0XHRcdFx0XHRwcmV2LFxuXHRcdFx0XHRcdFx0XHRcdF9fY29yZV9faWZUaGVuRWxzZShcblx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19ieXRlYXJyYXlfX19fZXEobXBoLCBfX2NvcmVfX2JEYXRhKCMpKSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3N0cmluZ19fX19hZGQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShcImxvdmVsYWNlOiBcIiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3N0cmluZ19fX19hZGQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19faW50X19zaG93KHF0eSkoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGEoXCJcXFxcblwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdCgpIC0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3N0cmluZ19fX19hZGQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX2J5dGVhcnJheV9fc2hvdyhtcGgpKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX3N0cmluZ19fX19hZGQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwiLlwiKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19zdHJpbmdfX19fYWRkKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fYnl0ZWFycmF5X19zaG93KHRva2VuX25hbWUpKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19zdHJpbmdfX19fYWRkKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19jb21tb25fX3N0cmluZ0RhdGEoXCI6IFwiKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2hlbGlvc19fc3RyaW5nX19fX2FkZChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9faGVsaW9zX19pbnRfX3Nob3cocXR5KSgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X19oZWxpb3NfX2NvbW1vbl9fc3RyaW5nRGF0YShcIlxcXFxuXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KSgpXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRwcmV2XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfX2hlbGlvc19fY29tbW9uX19zdHJpbmdEYXRhKFwiXCIpXG5cdFx0XHQpXG5cdFx0fVxuXHR9YCkpXG5cblx0cmV0dXJuIGRiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SVJ9IGlyIFxuICogQHJldHVybnMge0lSfVxuICogQHBhY2thZ2VcbiAqL1xuZnVuY3Rpb24gd3JhcFdpdGhSYXdGdW5jdGlvbnMoaXIpIHtcblx0bGV0IGRiID0gbWFrZVJhd0Z1bmN0aW9ucygpO1xuXG5cdC8vIG5vdGlmeSBzdGF0aXN0aWNzIG9mIGV4aXN0ZW5jZSBvZiBidWlsdGluIGluIGNvcnJlY3Qgb3JkZXJcblx0aWYgKG9uTm90aWZ5UmF3VXNhZ2UgIT09IG51bGwpIHtcblx0XHRmb3IgKGxldCBbbmFtZSwgX10gb2YgZGIpIHtcblx0XHRcdG9uTm90aWZ5UmF3VXNhZ2UobmFtZSwgMCk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IHJlID0gbmV3IFJlZ0V4cChcIl9faGVsaW9zW2EtekEtWjAtOV9dKlwiLCBcImdcIik7XG5cblx0bGV0IFtzcmMsIF9dID0gaXIuZ2VuZXJhdGVTb3VyY2UoKTtcblxuXHQvL2NvbnNvbGUubG9nKHNyYyk7XG5cblx0bGV0IG1hdGNoZXMgPSBzcmMubWF0Y2gocmUpO1xuXG5cdGxldCBtYXAgPSBuZXcgTWFwKCk7XG5cblx0aWYgKG1hdGNoZXMgIT09IG51bGwpIHtcblx0XHRmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG5cdFx0XHRpZiAoIW1hcC5oYXMobWF0Y2gpKSB7XG5cdFx0XHRcdGlmICghZGIuaGFzKG1hdGNoKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgYnVpbHRpbiAke21hdGNofSBub3QgZm91bmRgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBidWlsdGluID0gYXNzZXJ0RGVmaW5lZChkYi5nZXQobWF0Y2gpKTtcblxuXHRcdFx0XHRidWlsdGluLmxvYWQoZGIsIG1hcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIElSLndyYXBXaXRoRGVmaW5pdGlvbnMoaXIsIG1hcCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMjA6IElSIENvbnRleHQgb2JqZWN0c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogU2NvcGUgZm9yIElSIG5hbWVzLlxuICogV29ya3MgbGlrZSBhIHN0YWNrIG9mIG5hbWVkIHZhbHVlcyBmcm9tIHdoaWNoIGEgRGVicnVpam4gaW5kZXggY2FuIGJlIGRlcml2ZWRcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSU2NvcGUge1xuXHQjcGFyZW50O1xuXHQvKiogdmFyaWFibGUgbmFtZSAoY2FuIGJlIGVtcHR5IGlmIG5vIHVzYWJsZSB2YXJpYWJsZSBkZWZpbmVkIGF0IHRoaXMgbGV2ZWwpICovXG5cdCN2YXJpYWJsZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHs/SVJTY29wZX0gcGFyZW50IFxuXHQgKiBAcGFyYW0gez9JUlZhcmlhYmxlfSB2YXJpYWJsZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocGFyZW50LCB2YXJpYWJsZSkge1xuXHRcdHRoaXMuI3BhcmVudCA9IHBhcmVudDtcblx0XHR0aGlzLiN2YXJpYWJsZSA9IHZhcmlhYmxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIERlYnJ1aWpuIGluZGV4IG9mIGEgbmFtZWQgdmFsdWUuIEludGVybmFsIG1ldGhvZFxuXHQgKiBAcGFyYW0ge1dvcmQgfCBJUlZhcmlhYmxlfSBuYW1lIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggXG5cdCAqIEByZXR1cm5zIHtbbnVtYmVyLCBJUlZhcmlhYmxlXX1cblx0ICovXG5cdGdldEludGVybmFsKG5hbWUsIGluZGV4KSB7XG5cdFx0aWYgKHRoaXMuI3ZhcmlhYmxlICE9PSBudWxsICYmIChuYW1lIGluc3RhbmNlb2YgV29yZCAmJiB0aGlzLiN2YXJpYWJsZS50b1N0cmluZygpID09IG5hbWUudG9TdHJpbmcoKSkgfHwgKG5hbWUgaW5zdGFuY2VvZiBJUlZhcmlhYmxlICYmIHRoaXMuI3ZhcmlhYmxlID09IG5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gW2luZGV4LCB0aGlzLiN2YXJpYWJsZV07XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5hbWUucmVmZXJlbmNlRXJyb3IoYHZhcmlhYmxlICR7bmFtZS50b1N0cmluZygpfSBub3QgZm91bmRgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3BhcmVudC5nZXRJbnRlcm5hbChuYW1lLCBpbmRleCArIDEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBEZWJydWlqbiBpbmRleC5cblx0ICogQHBhcmFtIHtXb3JkIHwgSVJWYXJpYWJsZX0gbmFtZSBcblx0ICogQHJldHVybnMge1tudW1iZXIsIElSVmFyaWFibGVdfVxuXHQgKi9cblx0Z2V0KG5hbWUpIHtcblx0XHQvLyBvbmUtYmFzZWRcblx0XHRyZXR1cm4gdGhpcy5nZXRJbnRlcm5hbChuYW1lLCAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBuYW1lZCBidWlsdGluIGV4aXN0c1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHBhcmFtIHtib29sZWFufSBzdHJpY3QgLSBpZiB0cnVlIHRoZW4gdGhyb3dzIGFuIGVycm9yIGlmIGJ1aWx0aW4gZG9lc24ndCBleGlzdFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHN0YXRpYyBpc0J1aWx0aW4obmFtZSwgc3RyaWN0ID0gZmFsc2UpIHtcblx0XHRpZiAobmFtZS5zdGFydHNXaXRoKFwiX19jb3JlXCIpKSB7XG5cdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdHZvaWQgdGhpcy5maW5kQnVpbHRpbihuYW1lKTsgLy8gYXNzZXJ0IHRoYXQgYnVpbHRpbiBleGlzdHNcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaW5kZXggb2YgYSBuYW1lZCBidWlsdGluXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiBidWlsdGluIGRvZXNuJ3QgZXhpc3Rcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEByZXR1cm5zIFxuXHQgKi9cblx0c3RhdGljIGZpbmRCdWlsdGluKG5hbWUpIHtcblx0XHRsZXQgaSA9IFVQTENfQlVJTFRJTlMuZmluZEluZGV4KGluZm8gPT4geyByZXR1cm4gXCJfX2NvcmVfX1wiICsgaW5mby5uYW1lID09IG5hbWUgfSk7XG5cdFx0YXNzZXJ0KGkgIT0gLTEsIGAke25hbWV9IGlzIG5vdCBhIHJlYWwgYnVpbHRpbmApO1xuXHRcdHJldHVybiBpO1xuXHR9XG59XG5cbi8qKlxuICogSVIgY2xhc3MgdGhhdCByZXByZXNlbnRzIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSVJWYXJpYWJsZSBleHRlbmRzIFRva2VuIHtcblx0I25hbWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7V29yZH0gbmFtZVxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSkge1xuXHRcdHN1cGVyKG5hbWUuc2l0ZSk7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lLnRvU3RyaW5nKCk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPElSVmFyaWFibGUsIElSVmFyaWFibGU+fSBuZXdWYXJzIFxuXHQgKiBAcmV0dXJucyB7SVJWYXJpYWJsZX1cblx0ICovXG5cdGNvcHkobmV3VmFycykge1xuXHRcdGNvbnN0IG5ld1ZhciA9IG5ldyBJUlZhcmlhYmxlKHRoaXMuI25hbWUpO1xuXG5cdFx0bmV3VmFycy5zZXQodGhpcywgbmV3VmFyKTtcblxuXHRcdHJldHVybiBuZXdWYXI7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJUlZhbHVlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUlZhbHVlW119IGFyZ3MgXG5cdCAqIEByZXR1cm5zIHs/SVJWYWx1ZX1cblx0ICovXG5cdGNhbGwoYXJncykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRnZXQgdmFsdWUoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGEgbGl0ZXJhbCB2YWx1ZVwiKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSRnVuY1ZhbHVlIGV4dGVuZHMgSVJWYWx1ZSB7XG5cdCNjYWxsYmFjaztcblxuXHQvKipcblx0ICogQHBhcmFtIHsoYXJnczogSVJWYWx1ZVtdKSA9PiA/SVJWYWx1ZX0gY2FsbGJhY2tcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNjYWxsYmFjayA9IGNhbGxiYWNrO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJWYWx1ZVtdfSBhcmdzIFxuXHQgKiBAcmV0dXJucyB7P0lSVmFsdWV9XG5cdCAqL1xuXHRjYWxsKGFyZ3MpIHtcblx0XHRyZXR1cm4gdGhpcy4jY2FsbGJhY2soYXJncyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJUkxpdGVyYWxWYWx1ZSBleHRlbmRzIElSVmFsdWUge1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBsY1ZhbHVlfSB2YWx1ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSVJEZWZlcnJlZFZhbHVlIGV4dGVuZHMgSVJWYWx1ZSB7XG4gICAgI2RlZmVycmVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3VuZGVmaW5lZCB8IG51bGwgfCBJUlZhbHVlfVxuICAgICAqL1xuICAgICNjYWNoZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7KCkgPT4gP0lSVmFsdWV9IGRlZmVycmVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGVmZXJyZWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jZGVmZXJyZWQgPSBkZWZlcnJlZDtcbiAgICAgICAgdGhpcy4jY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SVJWYWx1ZVtdfSBhcmdzIFxuICAgICAqIEByZXR1cm5zIHs/SVJWYWx1ZX1cbiAgICAgKi9cbiAgICBjYWxsKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2NhY2hlID0gdGhpcy4jZGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuI2NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjYWNoZS5jYWxsKGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VXBsY1ZhbHVlfVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2NhY2hlID0gdGhpcy4jZGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuI2NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjYWNoZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIHZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSVJDYWxsU3RhY2sge1xuXHQjdGhyb3dSVEVycm9ycztcblx0I3BhcmVudDtcblx0I3ZhcmlhYmxlO1xuXHQjdmFsdWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdGhyb3dSVEVycm9yc1xuXHQgKiBAcGFyYW0gez9JUkNhbGxTdGFja30gcGFyZW50IFxuXHQgKiBAcGFyYW0gez9JUlZhcmlhYmxlfSB2YXJpYWJsZSBcblx0ICogQHBhcmFtIHs/SVJWYWx1ZX0gdmFsdWUgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0aHJvd1JURXJyb3JzLCBwYXJlbnQgPSBudWxsLCB2YXJpYWJsZSA9IG51bGwsIHZhbHVlID0gbnVsbCkge1xuXHRcdHRoaXMuI3Rocm93UlRFcnJvcnMgPSB0aHJvd1JURXJyb3JzO1xuXHRcdHRoaXMuI3BhcmVudCA9IHBhcmVudDtcblx0XHR0aGlzLiN2YXJpYWJsZSA9IHZhcmlhYmxlO1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgdGhyb3dSVEVycm9ycygpIHtcblx0XHRyZXR1cm4gdGhpcy4jdGhyb3dSVEVycm9ycztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSVmFyaWFibGV9IHZhcmlhYmxlIFxuXHQgKiBAcmV0dXJucyB7P0lSVmFsdWV9XG5cdCAqL1xuXHRnZXQodmFyaWFibGUpIHtcblx0XHRpZiAodGhpcy4jdmFyaWFibGUgIT09IG51bGwgJiYgdGhpcy4jdmFyaWFibGUgPT09IHZhcmlhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLiNwYXJlbnQuZ2V0KHZhcmlhYmxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZX0gdmFyaWFibGUgXG5cdCAqIEBwYXJhbSB7SVJWYWx1ZX0gdmFsdWUgXG5cdCAqIEByZXR1cm5zIHtJUkNhbGxTdGFja31cblx0ICovXG5cdHNldCh2YXJpYWJsZSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gbmV3IElSQ2FsbFN0YWNrKHRoaXMuI3Rocm93UlRFcnJvcnMsIHRoaXMsIHZhcmlhYmxlLCB2YWx1ZSk7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAyMTogSVIgQVNUIG9iamVjdHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge01hcDxJUlZhcmlhYmxlLCBJUkxpdGVyYWxFeHByPn0gSVJMaXRlcmFsUmVnaXN0cnlcbiAqL1xuXG5leHBvcnQgY2xhc3MgSVJOYW1lRXhwclJlZ2lzdHJ5IHtcblx0LyoqXG5cdCAqIEB0eXBlIHtNYXA8SVJWYXJpYWJsZSwgU2V0PElSTmFtZUV4cHI+Pn1cblx0ICovXG5cdCNtYXA7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTZXQ8SVJWYXJpYWJsZT59XG5cdCAqL1xuXHQjbWF5YmVJbnNpZGVMb29wO1xuXG5cdC8qKlxuXHQgKiBSZXNldCB3aGVuZXZlciByZWN1cnNpb24gaXMgZGV0ZWN0ZWQuXG5cdCAqIEB0eXBlIHtTZXQ8SVJWYXJpYWJsZT59XG5cdCAqL1xuXHQjdmFyaWFibGVzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxJUlZhcmlhYmxlLCBTZXQ8SVJOYW1lRXhwcj4+fSBtYXBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1hcCA9IG5ldyBNYXAoKSwgbWF5YmVJbnNpZGVMb29wID0gbmV3IFNldCgpKSB7XG5cdFx0dGhpcy4jbWFwID0gbWFwO1xuXHRcdHRoaXMuI21heWJlSW5zaWRlTG9vcCA9IG1heWJlSW5zaWRlTG9vcDtcblx0XHR0aGlzLiN2YXJpYWJsZXMgPSBuZXcgU2V0KCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByfSBuYW1lRXhwciBcblx0ICovXG5cdHJlZ2lzdGVyKG5hbWVFeHByKSB7XG5cdFx0aWYgKCFuYW1lRXhwci5pc0NvcmUoKSkge1xuXHRcdFx0Y29uc3QgdmFyaWFibGUgPSBuYW1lRXhwci52YXJpYWJsZTtcblxuXHRcdFx0aWYgKCF0aGlzLiNtYXAuaGFzKHZhcmlhYmxlKSkge1xuXHRcdFx0XHR0aGlzLiNtYXAuc2V0KHZhcmlhYmxlLCBuZXcgU2V0KFtuYW1lRXhwcl0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFzc2VydERlZmluZWQodGhpcy4jbWFwLmdldCh2YXJpYWJsZSkpLmFkZChuYW1lRXhwcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhbm90aGVyIHJlZmVyZW5jZSBpbiBjYXNlIG9mIHJlY3Vyc2lvblxuXHRcdFx0aWYgKCF0aGlzLiN2YXJpYWJsZXMuaGFzKHZhcmlhYmxlKSkge1xuXHRcdFx0XHR0aGlzLiNtYXliZUluc2lkZUxvb3AuYWRkKHZhcmlhYmxlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCB0byBwcmV2ZW50IGlubGluaW5nIHVwb24gcmVjdXJzaW9uXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZX0gdmFyaWFibGVcblx0ICovXG5cdHJlZ2lzdGVyVmFyaWFibGUodmFyaWFibGUpIHtcblx0XHR0aGlzLiN2YXJpYWJsZXMuYWRkKHZhcmlhYmxlKVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZX0gdmFyaWFibGUgXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRjb3VudFJlZmVyZW5jZXModmFyaWFibGUpIHtcblx0XHRjb25zdCBzZXQgPSB0aGlzLiNtYXAuZ2V0KHZhcmlhYmxlKTtcblxuXHRcdGlmIChzZXQgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHNldC5zaXplO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSVmFyaWFibGV9IHZhcmlhYmxlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdG1heWJlSW5zaWRlTG9vcCh2YXJpYWJsZSkge1xuXHRcdHJldHVybiB0aGlzLiNtYXliZUluc2lkZUxvb3AuaGFzKHZhcmlhYmxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgcmVjdXJzaW9uIGlzIGRldGVjdGVkXG5cdCAqIEByZXR1cm5zIHtJUk5hbWVFeHByUmVnaXN0cnl9XG5cdCAqL1xuXHRyZXNldFZhcmlhYmxlcygpIHtcblx0XHRyZXR1cm4gbmV3IElSTmFtZUV4cHJSZWdpc3RyeSh0aGlzLiNtYXAsIHRoaXMuI21heWJlSW5zaWRlTG9vcCk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIElSRXhwclJlZ2lzdHJ5IHtcblx0I25hbWVFeHBycztcblxuXHQvKipcblx0ICogQHR5cGUge01hcDxJUlZhcmlhYmxlLCBJUkV4cHI+fVxuXHQgKi9cblx0I2lubGluZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByUmVnaXN0cnl9IG5hbWVFeHBycyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG5hbWVFeHBycykge1xuXHRcdHRoaXMuI25hbWVFeHBycyA9IG5hbWVFeHBycztcblx0XHR0aGlzLiNpbmxpbmUgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUlZhcmlhYmxlfSB2YXJpYWJsZSBcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGNvdW50UmVmZXJlbmNlcyh2YXJpYWJsZSkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lRXhwcnMuY291bnRSZWZlcmVuY2VzKHZhcmlhYmxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSVmFyaWFibGV9IHZhcmlhYmxlIFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdG1heWJlSW5zaWRlTG9vcCh2YXJpYWJsZSkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lRXhwcnMubWF5YmVJbnNpZGVMb29wKHZhcmlhYmxlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSVmFyaWFibGV9IHZhcmlhYmxlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNJbmxpbmVhYmxlKHZhcmlhYmxlKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2lubGluZS5oYXModmFyaWFibGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZX0gdmFyaWFibGVcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdGdldElubGluZWFibGUodmFyaWFibGUpIHtcblx0XHRyZXR1cm4gYXNzZXJ0RGVmaW5lZCh0aGlzLiNpbmxpbmUuZ2V0KHZhcmlhYmxlKSkuY29weShuZXcgTWFwKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZX0gdmFyaWFibGUgXG5cdCAqIEBwYXJhbSB7SVJFeHByfSBleHByIFxuXHQgKi9cblx0YWRkSW5saW5lYWJsZSh2YXJpYWJsZSwgZXhwcikge1xuXHRcdHRoaXMuI2lubGluZS5zZXQodmFyaWFibGUsIGV4cHIpO1xuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBhbGwgSW50ZXJtZWRpYXRlIFJlcHJlc2VudGF0aW9uIGV4cHJlc3Npb25zXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJUkV4cHIgZXh0ZW5kcyBUb2tlbiB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzaXRlKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogRm9yIHByZXR0eSBwcmludGluZyB0aGUgSVJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpbmsgSVJOYW1lRXhwcnMgdG8gdmFyaWFibGVzXG5cdCAqIEBwYXJhbSB7SVJTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXMoc2NvcGUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFR1cm5zIGFsbCBJUkNvbnN0RXhwciBpc3RhbmNlcyBpbnRvIElSTGl0ZXJhbEV4cHIgaW5zdGFuY2VzXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrIFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0ZXZhbENvbnN0YW50cyhzdGFjaykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogRXZhbHVhdGVzIGFuIGV4cHJlc3Npb24gdG8gc29tZXRoaW5nIChob3BlZnVsbHkpIGxpdGVyYWxcblx0ICogUmV0dXJucyBudWxsIGlmIGl0IHRoZSByZXN1bHQgd291bGQgYmUgd29yc2UgdGhhbiB0aGUgY3VycmVudCBleHByZXNzaW9uXG5cdCAqIERvZXNuJ3QgcmV0dXJuIGFuIElSTGl0ZXJhbCBiZWNhdXNlIHRoZSByZXN1bHRpbmcgZXhwcmVzc2lvbiBtaWdodCBzdGlsbCBiZSBhbiBpbXByb3ZlbWVudCwgZXZlbiBpZiBpdCBpc24ndCBhIGxpdGVyYWxcblx0ICogQHBhcmFtIHtJUkNhbGxTdGFja30gc3RhY2tcblx0ICogQHJldHVybnMgez9JUlZhbHVlfVxuXHQgKi9cblx0ZXZhbChzdGFjaykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCB0byBpbmxpbmUgbGl0ZXJhbHMgYW5kIHRvIGV2YWx1YXRlIElSQ29yZUNhbGxFeHByIGluc3RhbmNlcyB3aXRoIG9ubHkgbGl0ZXJhbCBhcmdzLlxuXHQgKiBAcGFyYW0ge0lSTGl0ZXJhbFJlZ2lzdHJ5fSBsaXRlcmFsc1xuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0c2ltcGxpZnlMaXRlcmFscyhsaXRlcmFscykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCBiZWZvcmUgc2ltcGxpZnlUb3BvbG9neVxuXHQgKiBAcGFyYW0ge0lSTmFtZUV4cHJSZWdpc3RyeX0gbmFtZUV4cHJzXG5cdCAqL1xuXHRyZWdpc3Rlck5hbWVFeHBycyhuYW1lRXhwcnMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgZHVyaW5nIGlubGluaW5nL2V4cGFuc2lvbiB0byBtYWtlIHN1cmUgbXVsdGlwbGUgaW5saW5lcyBvZiBJUk5hbWVFeHByIGRvbid0IGludGVyZmVyZSB3aGVuIHNldHRpbmcgdGhlIERlYnJ1aWpuIGluZGV4XG5cdCAqIEBwYXJhbSB7TWFwPElSVmFyaWFibGUsIElSVmFyaWFibGU+fSBuZXdWYXJzXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRjb3B5KG5ld1ZhcnMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJFeHByUmVnaXN0cnl9IHJlZ2lzdHJ5IFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0c2ltcGxpZnlUb3BvbG9neShyZWdpc3RyeSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNUZXJtfVxuXHQgKi9cblx0dG9VcGxjKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnRlcm1lZGlhdGUgUmVwcmVzZW50YXRpb24gdmFyaWFibGUgcmVmZXJlbmNlIGV4cHJlc3Npb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSTmFtZUV4cHIgZXh0ZW5kcyBJUkV4cHIge1xuXHQjbmFtZTtcblxuXHQvKipcblx0ICogQHR5cGUgez9udW1iZXJ9IC0gY2FjaGVkIGRlYnJ1aWpuIGluZGV4IFxuXHQgKi9cblx0I2luZGV4O1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7P0lSVmFyaWFibGV9IC0gY2FjaGVkIHZhcmlhYmxlXG5cdCAqL1xuXHQjdmFyaWFibGU7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHs/SVJWYWx1ZX0gLSBjYWNoZWQgZXZhbCByZXN1bHQgKHJldXNlZCB3aGVuIGV2YWwgaXMgY2FsbGVkIHdpdGhpbiBzaW1wbGlmeUxpdGVyYWxzKVxuXHQgKi9cblx0I3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1dvcmR9IG5hbWUgXG5cdCAqIEBwYXJhbSB7P0lSVmFyaWFibGV9IHZhcmlhYmxlXG5cdCAqIEBwYXJhbSB7P0lSVmFsdWV9IHZhbHVlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihuYW1lLCB2YXJpYWJsZSA9IG51bGwsIHZhbHVlID0gbnVsbCkge1xuXHRcdHN1cGVyKG5hbWUuc2l0ZSk7XG5cdFx0YXNzZXJ0KG5hbWUudG9TdHJpbmcoKSAhPSBcIl9cIik7XG5cdFx0YXNzZXJ0KCFuYW1lLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChcInVuZGVmaW5lZFwiKSk7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jaW5kZXggPSBudWxsO1xuXHRcdHRoaXMuI3ZhcmlhYmxlID0gdmFyaWFibGU7XG5cdFx0dGhpcy4jdmFsdWUgPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IG5hbWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBpc1ZhcmlhYmxlKCkgc2hvdWxkIGJlIHVzZWQgdG8gY2hlY2sgaWYgYSBJUk5hbWVFeHByLnZhcmlhYmxlIGlzIGVxdWFsIHRvIGEgSVJWYXJpYWJsZSAoaW5jbHVkZXMgc3BlY2lhbCBoYW5kbGluZyBvZiBcIl9fY29yZSpcIilcblx0ICogQHR5cGUge0lSVmFyaWFibGV9XG5cdCAqL1xuXHRnZXQgdmFyaWFibGUoKSB7XG5cdFx0aWYgKHRoaXMuI3ZhcmlhYmxlID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlIHNob3VsZCBiZSBzZXQgKG5hbWU6ICR7dGhpcy5uYW1lfSlgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3ZhcmlhYmxlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzQ29yZSgpIHtcblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0cmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcIl9fY29yZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSVmFyaWFibGV9IHJlZiBcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1ZhcmlhYmxlKHJlZikge1xuXHRcdGlmICh0aGlzLmlzQ29yZSgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnZhcmlhYmxlID09PSByZWY7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZyhpbmRlbnQgPSBcIlwiKSB7XG5cdFx0cmV0dXJuIHRoaXMuI25hbWUudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSU2NvcGV9IHNjb3BlXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXMoc2NvcGUpIHtcblx0XHRpZiAoIXRoaXMubmFtZS5zdGFydHNXaXRoKFwiX19jb3JlXCIpKSB7XG5cdFx0XHRpZiAodGhpcy4jdmFyaWFibGUgPT0gbnVsbCB8fCB0aGlzLm5hbWUuc3RhcnRzV2l0aChcIl9fUEFSQU1cIikpIHtcblx0XHRcdFx0W3RoaXMuI2luZGV4LCB0aGlzLiN2YXJpYWJsZV0gPSBzY29wZS5nZXQodGhpcy4jbmFtZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRbdGhpcy4jaW5kZXgsIHRoaXMuI3ZhcmlhYmxlXSA9IHNjb3BlLmdldCh0aGlzLiN2YXJpYWJsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrIFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0ZXZhbENvbnN0YW50cyhzdGFjaykge1xuXHRcdGlmICh0aGlzLiN2YXJpYWJsZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLiN2YWx1ZSA9IHN0YWNrLmdldCh0aGlzLiN2YXJpYWJsZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkNhbGxTdGFja30gc3RhY2tcblx0ICogQHJldHVybnMgez9JUlZhbHVlfVxuXHQgKi9cblx0ZXZhbChzdGFjaykge1xuXHRcdGlmICh0aGlzLmlzQ29yZSgpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSRnVuY1ZhbHVlKChhcmdzKSA9PiB7XG5cdFx0XHRcdHJldHVybiBJUkNvcmVDYWxsRXhwci5ldmFsVmFsdWVzKHRoaXMuc2l0ZSwgc3RhY2sudGhyb3dSVEVycm9ycywgdGhpcy4jbmFtZS52YWx1ZS5zbGljZShcIl9fY29yZV9fXCIubGVuZ3RoKSwgYXJncyk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuI3ZhcmlhYmxlID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpYWJsZSBzaG91bGQgYmUgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwcmVmZXIgcmVzdWx0IGZyb20gc3RhY2ssIGFuZCB1c2UgY2FjaGVkIHJlc3VsdCBhcyBiYWNrdXBcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHN0YWNrLmdldCh0aGlzLiN2YXJpYWJsZSk7XG5cblx0XHRcdGlmIChyZXN1bHQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTGl0ZXJhbFJlZ2lzdHJ5fSBsaXRlcmFsc1xuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0c2ltcGxpZnlMaXRlcmFscyhsaXRlcmFscykge1xuXHRcdGlmICh0aGlzLiN2YXJpYWJsZSAhPT0gbnVsbCAmJiBsaXRlcmFscy5oYXModGhpcy4jdmFyaWFibGUpKSB7XG5cdFx0XHRyZXR1cm4gYXNzZXJ0RGVmaW5lZChsaXRlcmFscy5nZXQodGhpcy4jdmFyaWFibGUpKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuI3ZhbHVlIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuI3ZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByUmVnaXN0cnl9IG5hbWVFeHByc1xuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdFx0bmFtZUV4cHJzLnJlZ2lzdGVyKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPElSVmFyaWFibGUsIElSVmFyaWFibGU+fSBuZXdWYXJzXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRjb3B5KG5ld1ZhcnMpIHtcblx0XHRsZXQgdiA9IHRoaXMuI3ZhcmlhYmxlO1xuXG5cdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgbWF5YmVOZXdWYXIgPSBuZXdWYXJzLmdldCh2KTtcblxuXHRcdFx0aWYgKG1heWJlTmV3VmFyICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2ID0gbWF5YmVOZXdWYXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBJUk5hbWVFeHByKHRoaXMuI25hbWUsIHYsIHRoaXMuI3ZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRXhwclJlZ2lzdHJ5fSByZWdpc3RyeSBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5VG9wb2xvZ3kocmVnaXN0cnkpIHtcblx0XHRpZiAoIXRoaXMuaXNDb3JlKCkgJiYgcmVnaXN0cnkuaXNJbmxpbmVhYmxlKHRoaXMudmFyaWFibGUpKSB7XG5cdFx0XHRyZXR1cm4gcmVnaXN0cnkuZ2V0SW5saW5lYWJsZSh0aGlzLnZhcmlhYmxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtVcGxjVGVybX1cblx0ICovXG5cdHRvVXBsYygpIHtcblx0XHRpZiAodGhpcy5uYW1lLnN0YXJ0c1dpdGgoXCJfX2NvcmVcIikpIHtcblx0XHRcdHJldHVybiBJUkNvcmVDYWxsRXhwci5uZXdVcGxjQnVpbHRpbih0aGlzLnNpdGUsIHRoaXMubmFtZSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLiNpbmRleCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gdXNlIGEgZHVtbXkgaW5kZXggKGZvciBzaXplIGNhbGN1bGF0aW9uKVxuXHRcdFx0cmV0dXJuIG5ldyBVcGxjVmFyaWFibGUoXG5cdFx0XHRcdHRoaXMuc2l0ZSxcblx0XHRcdFx0bmV3IFVwbGNJbnQodGhpcy5zaXRlLCBCaWdJbnQoMCksIGZhbHNlKSxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgVXBsY1ZhcmlhYmxlKFxuXHRcdFx0XHR0aGlzLnNpdGUsXG5cdFx0XHRcdG5ldyBVcGxjSW50KHRoaXMuc2l0ZSwgQmlnSW50KHRoaXMuI2luZGV4KSwgZmFsc2UpLFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBJUiB3cmFwcGVyIGZvciBVcGxjVmFsdWVzLCByZXByZXNlbnRpbmcgbGl0ZXJhbHNcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSTGl0ZXJhbEV4cHIgZXh0ZW5kcyBJUkV4cHIge1xuXHQvKipcblx0ICogQHR5cGUge1VwbGNWYWx1ZX1cblx0ICovXG5cdCN2YWx1ZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjVmFsdWV9IHZhbHVlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcih2YWx1ZS5zaXRlKTtcblxuXHRcdHRoaXMuI3ZhbHVlID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNWYWx1ZX1cblx0ICovXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHRyZXR1cm4gdGhpcy4jdmFsdWUudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5raW5nIGRvZXNuJ3QgZG8gYW55dGhpbmcgZm9yIGxpdGVyYWxzXG5cdCAqIEBwYXJhbSB7SVJTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXMoc2NvcGUpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSQ2FsbFN0YWNrfSBzdGFja1xuXHQgKi9cblx0ZXZhbENvbnN0YW50cyhzdGFjaykge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrXG5cdCAqIEByZXR1cm5zIHs/SVJWYWx1ZX1cblx0ICovXG5cdGV2YWwoc3RhY2spIHtcblx0XHRyZXR1cm4gbmV3IElSTGl0ZXJhbFZhbHVlKHRoaXMudmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJMaXRlcmFsUmVnaXN0cnl9IGxpdGVyYWxzXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzaW1wbGlmeUxpdGVyYWxzKGxpdGVyYWxzKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByUmVnaXN0cnl9IG5hbWVFeHByc1xuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNYXA8SVJWYXJpYWJsZSwgSVJWYXJpYWJsZT59IG5ld1ZhcnNcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdGNvcHkobmV3VmFycykge1xuXHRcdHJldHVybiBuZXcgSVJMaXRlcmFsRXhwcih0aGlzLiN2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkV4cHJSZWdpc3RyeX0gcmVnaXN0cnkgXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNDb25zdH1cblx0ICovXG5cdHRvVXBsYygpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNDb25zdCh0aGlzLiN2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgSVJFeHByIHNpbXBsaWZ5IG1ldGhvZHMgYXJlbid0IGltcGxlbWVudGVkIGJlY2F1c2UgYW55IElSQ29uc3RFeHByIGluc3RhbmNlcyBzaG91bGQndmUgYmVlbiBlbGltaW5hdGVkIGR1cmluZyBldmFsQ29uc3RhbnRzLlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgSVJDb25zdEV4cHIgZXh0ZW5kcyBJUkV4cHIge1xuXHQjZXhwcjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlIFxuXHQgKiBAcGFyYW0ge0lSRXhwcn0gZXhwciBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGV4cHIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNleHByID0gZXhwcjtcblx0fVxuXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHRyZXR1cm4gYGNvbnN0KCR7dGhpcy4jZXhwci50b1N0cmluZyhpbmRlbnQpfSlgO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXMoc2NvcGUpIHtcblx0XHR0aGlzLiNleHByLnJlc29sdmVOYW1lcyhzY29wZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkNhbGxTdGFja30gc3RhY2tcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdGV2YWxDb25zdGFudHMoc3RhY2spIHtcblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLiNleHByLmV2YWwoc3RhY2spO1xuXG5cdFx0aWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSTGl0ZXJhbEV4cHIocmVzdWx0LnZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGV2YWx1YXRlIGNvbnN0XCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSQ2FsbFN0YWNrfSBzdGFjayBcblx0ICogQHJldHVybnMgez9JUlZhbHVlfVxuXHQgKi9cblx0ZXZhbChzdGFjaykge1xuXHRcdHJldHVybiB0aGlzLiNleHByLmV2YWwoc3RhY2spO1xuXHR9XG59XG5cbi8qKlxuICogSVIgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIHNvbWUgYXJncywgdGhhdCBhY3QgYXMgdGhlIGhlYWRlciwgYW5kIGEgYm9keSBleHByZXNzaW9uXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJUkZ1bmNFeHByIGV4dGVuZHMgSVJFeHByIHtcblx0I2FyZ3M7XG5cdCNib2R5O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGUgXG5cdCAqIEBwYXJhbSB7SVJWYXJpYWJsZVtdfSBhcmdzIFxuXHQgKiBAcGFyYW0ge0lSRXhwcn0gYm9keSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGFyZ3MsIGJvZHkpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNhcmdzID0gYXJncztcblx0XHR0aGlzLiNib2R5ID0gYXNzZXJ0RGVmaW5lZChib2R5KTtcblx0fVxuXG5cdGdldCBhcmdzKCkge1xuXHRcdHJldHVybiB0aGlzLiNhcmdzLnNsaWNlKCk7XG5cdH1cblxuXHRnZXQgYm9keSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jYm9keTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc09wdEFyZ3MoKSB7XG5cdFx0Y29uc3QgYiA9IHRoaXMuI2FyZ3Muc29tZShhID0+IGEubmFtZS5zdGFydHNXaXRoKFwiX191c2VvcHRfX1wiKSk7XG5cblx0XHRpZiAoYikge1xuXHRcdFx0cmV0dXJuIGI7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2JvZHkgaW5zdGFuY2VvZiBJUkZ1bmNFeHByKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jYm9keS5oYXNPcHRBcmdzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHRsZXQgaW5uZXJJbmRlbnQgPSAodGhpcy4jYm9keSBpbnN0YW5jZW9mIElSVXNlckNhbGxFeHByICYmIHRoaXMuI2JvZHkuYXJnRXhwcnMubGVuZ3RoID09IDEgJiYgdGhpcy4jYm9keS5mbkV4cHIgaW5zdGFuY2VvZiBJUkZ1bmNFeHByICYmIHRoaXMuI2JvZHkuZm5FeHByLmFyZ3NbMF0ubmFtZS5zdGFydHNXaXRoKFwiX19cIikpID8gaW5kZW50IDogaW5kZW50ICsgVEFCO1xuXG5cdFx0bGV0IHMgPSBcIihcIiArIHRoaXMuI2FyZ3MubWFwKG4gPT4gbi50b1N0cmluZygpKS5qb2luKFwiLCBcIikgKyBcIikgLT4ge1xcblwiICsgaW5uZXJJbmRlbnQ7XG5cdFx0cyArPSB0aGlzLiNib2R5LnRvU3RyaW5nKGlubmVySW5kZW50KTtcblx0XHRzICs9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIn1cIjtcblxuXHRcdHJldHVybiBzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXMoc2NvcGUpIHtcblx0XHQvLyBpbiB0aGUgemVyby1hcmcgY2FzZSBubyBEZWJydWlqbiBpbmRpY2VzIG5lZWQgdG8gYmUgYWRkZWQgYmVjYXVzZSB3ZSB1c2UgRGVsYXkvRm9yY2VcblxuXHRcdGZvciAobGV0IGFyZyBvZiB0aGlzLiNhcmdzKSB7XG5cdFx0XHRzY29wZSA9IG5ldyBJUlNjb3BlKHNjb3BlLCBhcmcpO1xuXHRcdH1cblxuXHRcdHRoaXMuI2JvZHkucmVzb2x2ZU5hbWVzKHNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSQ2FsbFN0YWNrfSBzdGFjayBcblx0ICovXG5cdGV2YWxDb25zdGFudHMoc3RhY2spIHtcblx0XHRyZXR1cm4gbmV3IElSRnVuY0V4cHIodGhpcy5zaXRlLCB0aGlzLmFyZ3MsIHRoaXMuI2JvZHkuZXZhbENvbnN0YW50cyhzdGFjaykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrXG5cdCAqIEByZXR1cm5zIHs/SVJWYWx1ZX1cblx0ICovXG5cdGV2YWwoc3RhY2spIHtcblx0XHRyZXR1cm4gbmV3IElSRnVuY1ZhbHVlKChhcmdzKSA9PiB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggIT0gdGhpcy4jYXJncy5sZW5ndGgpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5zaXRlLnN5bnRheEVycm9yKGBleHBlY3RlZCAke3RoaXMuI2FyZ3MubGVuZ3RofSBhcmcocyksIGdvdCAke2FyZ3MubGVuZ3RofSBhcmcocylgKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHN0YWNrID0gc3RhY2suc2V0KHRoaXMuI2FyZ3NbaV0sIGFyZ3NbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy4jYm9keS5ldmFsKHN0YWNrKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTGl0ZXJhbFJlZ2lzdHJ5fSBsaXRlcmFscyBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpIHtcblx0XHRyZXR1cm4gbmV3IElSRnVuY0V4cHIodGhpcy5zaXRlLCB0aGlzLmFyZ3MsIHRoaXMuI2JvZHkuc2ltcGxpZnlMaXRlcmFscyhsaXRlcmFscykpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByUmVnaXN0cnl9IG5hbWVFeHByc1xuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdFx0bmFtZUV4cHJzID0gbmFtZUV4cHJzLnJlc2V0VmFyaWFibGVzKCk7XG5cblx0XHR0aGlzLiNhcmdzLmZvckVhY2goYSA9PiBuYW1lRXhwcnMucmVnaXN0ZXJWYXJpYWJsZShhKSk7XG5cblx0XHR0aGlzLiNib2R5LnJlZ2lzdGVyTmFtZUV4cHJzKG5hbWVFeHBycyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNYXA8SVJWYXJpYWJsZSwgSVJWYXJpYWJsZT59IG5ld1ZhcnNcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdGNvcHkobmV3VmFycykge1xuXHRcdHJldHVybiBuZXcgSVJGdW5jRXhwcih0aGlzLnNpdGUsIHRoaXMuYXJncy5tYXAob2xkQXJnID0+IG9sZEFyZy5jb3B5KG5ld1ZhcnMpKSwgdGhpcy4jYm9keS5jb3B5KG5ld1ZhcnMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRXhwclJlZ2lzdHJ5fSByZWdpc3RyeSBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5VG9wb2xvZ3kocmVnaXN0cnkpIHtcblx0XHRyZXR1cm4gbmV3IElSRnVuY0V4cHIodGhpcy5zaXRlLCB0aGlzLmFyZ3MsIHRoaXMuI2JvZHkuc2ltcGxpZnlUb3BvbG9neShyZWdpc3RyeSkpO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAcmV0dXJucyB7VXBsY1Rlcm19XG5cdCAqL1xuXHR0b1VwbGMoKSB7XG5cdFx0bGV0IHRlcm0gPSB0aGlzLiNib2R5LnRvVXBsYygpO1xuXG5cdFx0aWYgKHRoaXMuI2FyZ3MubGVuZ3RoID09IDApIHtcblx0XHRcdC8vIGEgemVyby1hcmcgZnVuYyBpcyB0dXJuZWQgaW50byBhIFVwbGNEZWxheSB0ZXJtXG5cdFx0XHR0ZXJtID0gbmV3IFVwbGNEZWxheSh0aGlzLnNpdGUsIHRlcm0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy4jYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0ZXJtID0gbmV3IFVwbGNMYW1iZGEodGhpcy5zaXRlLCB0ZXJtLCB0aGlzLiNhcmdzW2ldLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXJtO1xuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBJUlVzZXJDYWxsRXhwciBhbmQgSVJDb3JlQ2FsbEV4cHJcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSQ2FsbEV4cHIgZXh0ZW5kcyBJUkV4cHIge1xuXHQjYXJnRXhwcnM7XG5cdCNwYXJlbnNTaXRlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtJUkV4cHJbXX0gYXJnRXhwcnMgXG5cdCAqIEBwYXJhbSB7U2l0ZX0gcGFyZW5zU2l0ZSBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIGFyZ0V4cHJzLCBwYXJlbnNTaXRlKSB7XG5cdFx0c3VwZXIoc2l0ZSk7XG5cdFx0dGhpcy4jYXJnRXhwcnMgPSBhcmdFeHBycztcblx0XHR0aGlzLiNwYXJlbnNTaXRlID0gcGFyZW5zU2l0ZTtcblx0XHRcblx0fVxuXG5cdGdldCBhcmdFeHBycygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJnRXhwcnMuc2xpY2UoKTtcblx0fVxuXG5cdGdldCBwYXJlbnNTaXRlKCkge1xuXHRcdHJldHVybiB0aGlzLiNwYXJlbnNTaXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnQgXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRhcmdzVG9TdHJpbmcoaW5kZW50ID0gXCJcIikge1xuXHRcdHJldHVybiB0aGlzLiNhcmdFeHBycy5tYXAoYXJnRXhwciA9PiBhcmdFeHByLnRvU3RyaW5nKGluZGVudCkpLmpvaW4oXCIsIFwiKVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJTY29wZX0gc2NvcGUgXG5cdCAqL1xuXHRyZXNvbHZlTmFtZXNJbkFyZ3Moc2NvcGUpIHtcblx0XHRmb3IgKGxldCBhcmdFeHByIG9mIHRoaXMuI2FyZ0V4cHJzKSB7XG5cdFx0XHRhcmdFeHByLnJlc29sdmVOYW1lcyhzY29wZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrIFxuXHQgKiBAcmV0dXJucyB7SVJFeHByW119XG5cdCAqL1xuXHRldmFsQ29uc3RhbnRzSW5BcmdzKHN0YWNrKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2FyZ0V4cHJzLm1hcChhID0+IGEuZXZhbENvbnN0YW50cyhzdGFjaykpO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAcGFyYW0ge0lSQ2FsbFN0YWNrfSBzdGFja1xuXHQgKiBAcmV0dXJucyB7P0lSVmFsdWVbXX0gXG5cdCAqL1xuXHRldmFsQXJncyhzdGFjaykge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtJUlZhbHVlW119XG5cdFx0ICovXG5cdFx0bGV0IGFyZ3MgPSBbXTtcblxuXHRcdGZvciAobGV0IGFyZ0V4cHIgb2YgdGhpcy5hcmdFeHBycykge1xuXHRcdFx0bGV0IGFyZ1ZhbCA9IGFyZ0V4cHIuZXZhbChzdGFjayk7XG5cdFx0XHRpZiAoYXJnVmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGFyZ3MucHVzaChhcmdWYWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3M7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkxpdGVyYWxSZWdpc3RyeX0gbGl0ZXJhbHNcblx0ICogQHJldHVybnMge0lSRXhwcltdfVxuXHQgKi9cblx0c2ltcGxpZnlMaXRlcmFsc0luQXJncyhsaXRlcmFscykge1xuXHRcdHJldHVybiB0aGlzLiNhcmdFeHBycy5tYXAoYSA9PiBhLnNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTmFtZUV4cHJSZWdpc3RyeX0gbmFtZUV4cHJzIFxuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnNJbkFyZ3MobmFtZUV4cHJzKSB7XG5cdFx0dGhpcy4jYXJnRXhwcnMuZm9yRWFjaChhID0+IGEucmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkV4cHJSZWdpc3RyeX0gcmVnaXN0cnkgXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJbXX1cblx0ICovXG5cdHNpbXBsaWZ5VG9wb2xvZ3lJbkFyZ3MocmVnaXN0cnkpIHtcblx0XHRyZXR1cm4gdGhpcy4jYXJnRXhwcnMubWFwKGEgPT4gYS5zaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjVGVybX0gdGVybVxuXHQgKiBAcmV0dXJucyB7VXBsY1Rlcm19XG5cdCAqL1xuXHR0b1VwbGNDYWxsKHRlcm0pIHtcblx0XHRpZiAodGhpcy4jYXJnRXhwcnMubGVuZ3RoID09IDApIHtcblx0XHRcdC8vIGFzc3VtaW5nIHVuZGVybHlpbmcgemVyby1hcmcgZnVuY3Rpb24gaGFzIGJlZW4gY29udmVydGVkIGludG8gYSBVcGxjRGVsYXkgdGVybVxuXHRcdFx0dGVybSA9IG5ldyBVcGxjRm9yY2UodGhpcy5zaXRlLCB0ZXJtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgYXJnRXhwciBvZiB0aGlzLiNhcmdFeHBycykge1xuXHRcdFx0XHR0ZXJtID0gbmV3IFVwbGNDYWxsKHRoaXMuc2l0ZSwgdGVybSwgYXJnRXhwci50b1VwbGMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlcm07XG5cdH1cbn1cblxuLyoqXG4gKiBJUiBmdW5jdGlvbiBjYWxsIG9mIGNvcmUgZnVuY3Rpb25zXG4gKiBAcGFja2FnZVxuICovXG5jbGFzcyBJUkNvcmVDYWxsRXhwciBleHRlbmRzIElSQ2FsbEV4cHIge1xuXHQjbmFtZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge0lSRXhwcltdfSBhcmdFeHBycyBcblx0ICogQHBhcmFtIHtTaXRlfSBwYXJlbnNTaXRlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSwgYXJnRXhwcnMsIHBhcmVuc1NpdGUpIHtcblx0XHRzdXBlcihuYW1lLnNpdGUsIGFyZ0V4cHJzLCBwYXJlbnNTaXRlKTtcblx0XHRhc3NlcnQobmFtZS52YWx1ZSAhPT0gXCJcIiAmJiBuYW1lLnZhbHVlICE9PSBcImVycm9yXCIpO1xuXHRcdHRoaXMuI25hbWUgPSBuYW1lO1xuXG5cdFx0YXNzZXJ0KHRoaXMuYnVpbHRpbk5hbWUgIT09IFwiXCIsIG5hbWUudmFsdWUpO1xuXHR9XG5cblx0Z2V0IGJ1aWx0aW5OYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLiNuYW1lLnRvU3RyaW5nKCkuc2xpY2UoOCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Nhc3QoKSB7XG5cdFx0bGV0IG5hbWUgPSB0aGlzLmJ1aWx0aW5OYW1lO1xuXG5cdFx0cmV0dXJuIG5hbWUgPT0gXCJpRGF0YVwiIHx8IG5hbWUgPT0gXCJiRGF0YVwiIHx8IG5hbWUgPT0gXCJ1bklEYXRhXCIgfHwgbmFtZSA9PSBcInVuQkRhdGFcIiB8fCBuYW1lID09IFwibWFwRGF0YVwiIHx8IG5hbWUgPT0gXCJ1bk1hcERhdGFcIiB8fCBuYW1lID09IFwibGlzdERhdGFcIiB8fCBuYW1lID09IFwidW5MaXN0RGF0YVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpbmRlbnRcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHRpZiAodGhpcy5idWlsdGluTmFtZSA9PSBcImlmVGhlbkVsc2VcIikge1xuXHRcdFx0cmV0dXJuIGAke3RoaXMuI25hbWUudG9TdHJpbmcoKX0oXFxuJHtpbmRlbnR9JHtUQUJ9JHt0aGlzLmFyZ0V4cHJzWzBdLnRvU3RyaW5nKGluZGVudCArIFRBQil9LFxcbiR7aW5kZW50fSR7VEFCfSR7dGhpcy5hcmdFeHByc1sxXS50b1N0cmluZyhpbmRlbnQgKyBUQUIpfSxcXG4ke2luZGVudH0ke1RBQn0ke3RoaXMuYXJnRXhwcnNbMl0udG9TdHJpbmcoaW5kZW50K1RBQil9XFxuJHtpbmRlbnR9KWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBgJHt0aGlzLiNuYW1lLnRvU3RyaW5nKCl9KCR7dGhpcy5hcmdzVG9TdHJpbmcoaW5kZW50KX0pYDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUlNjb3BlfSBzY29wZSBcblx0ICovXG5cdHJlc29sdmVOYW1lcyhzY29wZSkge1xuXHRcdHRoaXMucmVzb2x2ZU5hbWVzSW5BcmdzKHNjb3BlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpdGV9IHNpdGVcblx0ICogQHBhcmFtIHtib29sZWFufSB0aHJvd1JURXJyb3JzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBidWlsdGluTmFtZVxuXHQgKiBAcGFyYW0ge0lSVmFsdWVbXX0gYXJncyBcblx0ICogQHJldHVybnMgez9JUlZhbHVlfVxuXHQgKi9cblx0c3RhdGljIGV2YWxWYWx1ZXMoc2l0ZSwgdGhyb3dSVEVycm9ycywgYnVpbHRpbk5hbWUsIGFyZ3MpIHtcblx0XHRpZiAoYnVpbHRpbk5hbWUgPT0gXCJpZlRoZW5FbHNlXCIpIHtcblx0XHRcdGxldCBjb25kID0gYXJnc1swXS52YWx1ZTtcblx0XHRcdGlmIChjb25kICE9PSBudWxsICYmIGNvbmQgaW5zdGFuY2VvZiBVcGxjQm9vbCkge1xuXHRcdFx0XHRpZiAoY29uZC5ib29sKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3NbMV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3NbMl07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoYnVpbHRpbk5hbWUgPT0gXCJjaG9vc2VMaXN0XCIpIHtcblx0XHRcdGNvbnN0IGxzdCA9IGFyZ3NbMF0udmFsdWU7XG5cblx0XHRcdGlmIChsc3QgIT09IG51bGwgJiYgbHN0IGluc3RhbmNlb2YgVXBsY0xpc3QpIHtcblx0XHRcdFx0aWYgKGxzdC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiBhcmdzWzFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBhcmdzWzJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGJ1aWx0aW5OYW1lID09IFwidHJhY2VcIikge1xuXHRcdFx0cmV0dXJuIGFyZ3NbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGUge1VwbGNWYWx1ZVtdfVxuXHRcdFx0ICovXG5cdFx0XHRsZXQgYXJnVmFsdWVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGFyZyBvZiBhcmdzKSB7XG5cdFx0XHRcdGlmIChhcmcudmFsdWUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRhcmdWYWx1ZXMucHVzaChhcmcudmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGxldCByZXN1bHQgPSBVcGxjQnVpbHRpbi5ldmFsU3RhdGljKG5ldyBXb3JkKFNpdGUuZHVtbXkoKSwgYnVpbHRpbk5hbWUpLCBhcmdWYWx1ZXMpO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgSVJMaXRlcmFsVmFsdWUocmVzdWx0KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHQvLyBydW50aW1lIGVycm9ycyBsaWtlIGRpdmlzaW9uIGJ5IHplcm8gYXJlIGFsbG93ZWQgaWYgdGhyb3dSVEVycm9ycyBpcyBmYWxzZVxuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIFJ1bnRpbWVFcnJvcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3dSVEVycm9ycykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IGUuYWRkVHJhY2VTaXRlKHNpdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrIFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0ZXZhbENvbnN0YW50cyhzdGFjaykge1xuXHRcdHJldHVybiBuZXcgSVJDb3JlQ2FsbEV4cHIodGhpcy4jbmFtZSwgdGhpcy5ldmFsQ29uc3RhbnRzSW5BcmdzKHN0YWNrKSwgdGhpcy5wYXJlbnNTaXRlKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrXG5cdCAqIEByZXR1cm5zIHs/SVJWYWx1ZX1cblx0ICovXG5cdGV2YWwoc3RhY2spIHtcblx0XHRsZXQgYXJncyA9IHRoaXMuZXZhbEFyZ3Moc3RhY2spO1xuXG5cdFx0aWYgKGFyZ3MgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBJUkNvcmVDYWxsRXhwci5ldmFsVmFsdWVzKHRoaXMuc2l0ZSwgc3RhY2sudGhyb3dSVEVycm9ycywgdGhpcy5idWlsdGluTmFtZSwgYXJncyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJMaXRlcmFsUmVnaXN0cnl9IGxpdGVyYWxzXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzaW1wbGlmeUxpdGVyYWxzKGxpdGVyYWxzKSB7XG5cdFx0Y29uc3QgYXJncyA9IHRoaXMuc2ltcGxpZnlMaXRlcmFsc0luQXJncyhsaXRlcmFscyk7XG5cblx0XHRpZiAoYXJncy5sZW5ndGggPiAwICYmIGFyZ3MuZXZlcnkoYSA9PiBhIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwcikpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHJlcyA9IElSQ29yZUNhbGxFeHByLmV2YWxWYWx1ZXMoXG5cdFx0XHRcdFx0dGhpcy5zaXRlLFxuXHRcdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHRcdHRoaXMuYnVpbHRpbk5hbWUsXG5cdFx0XHRcdFx0YXJncy5tYXAoYSA9PiBuZXcgSVJMaXRlcmFsVmFsdWUoYXNzZXJ0Q2xhc3MoYSwgSVJMaXRlcmFsRXhwcikudmFsdWUpKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChyZXMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSVJMaXRlcmFsRXhwcihyZXMudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3dpdGNoKHRoaXMuYnVpbHRpbk5hbWUpIHtcblx0XHRcdGNhc2UgXCJhZGRJbnRlZ2VyXCI6IHtcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBmaXJzdCBvciBzZWNvbmQgYXJnIGV2YWx1YXRlcyB0byAwXG5cdFx0XHRcdFx0Y29uc3QgW2EsIGJdID0gYXJncztcblxuXHRcdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwciAmJiBhLnZhbHVlIGluc3RhbmNlb2YgVXBsY0ludCAmJiBhLnZhbHVlLmludCA9PSAwbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChiIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwciAmJiBiLnZhbHVlIGluc3RhbmNlb2YgVXBsY0ludCAmJiBiLnZhbHVlLmludCA9PSAwbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFwcGVuZEJ5dGVTdHJpbmdcIjoge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGVpdGhlciAxc3Qgb3IgMm5kIGFyZyBpcyB0aGUgZW1wdHkgYnl0ZWFycmF5XG5cdFx0XHRcdFx0Y29uc3QgW2EsIGJdID0gYXJncztcblx0XHRcdFx0XHRpZiAoYSBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgJiYgYS52YWx1ZSBpbnN0YW5jZW9mIFVwbGNCeXRlQXJyYXkgJiYgYS52YWx1ZS5ieXRlcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChiIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwciAmJiBiLnZhbHVlIGluc3RhbmNlb2YgVXBsY0J5dGVBcnJheSAmJiBiLnZhbHVlLmJ5dGVzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiYXBwZW5kU3RyaW5nXCI6IHtcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBlaXRoZXIgMXN0IG9yIDJuZCBhcmcgaXMgdGhlIGVtcHR5IHN0cmluZ1xuXHRcdFx0XHRcdGNvbnN0IFthLCBiXSA9IGFyZ3M7XG5cdFx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGEudmFsdWUgaW5zdGFuY2VvZiBVcGxjU3RyaW5nICYmIGEudmFsdWUuc3RyaW5nLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGIudmFsdWUgaW5zdGFuY2VvZiBVcGxjU3RyaW5nICYmIGIudmFsdWUuc3RyaW5nLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZGl2aWRlSW50ZWdlclwiOiB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgc2Vjb25kIGFyZyBpcyAxXG5cdFx0XHRcdFx0Y29uc3QgW2EsIGJdID0gYXJncztcblx0XHRcdFx0XHRpZiAoYiBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgJiYgYi52YWx1ZSBpbnN0YW5jZW9mIFVwbGNJbnQpIHtcblx0XHRcdFx0XHRcdGlmIChiLnZhbHVlLmludCA9PSAxbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYi52YWx1ZS5pbnQgPT0gMG4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBJUkNvcmVDYWxsRXhwcih0aGlzLiNuYW1lLCBhcmdzLCB0aGlzLnBhcmVuc1NpdGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJpZlRoZW5FbHNlXCI6IHtcblx0XHRcdFx0XHRjb25zdCBbY29uZCwgYSwgYl0gPSBhcmdzO1xuXG5cdFx0XHRcdFx0aWYgKGNvbmQgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGNvbmQudmFsdWUgaW5zdGFuY2VvZiBVcGxjQm9vbCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbmRpdGlvbiBpcyBhIGxpdGVyYWwsIG9uZSB0aGUgYnJhbmNoZXMgY2FuIGJlIHJldHVybmVkXG5cdFx0XHRcdFx0XHRpZiAoY29uZC52YWx1ZS5ib29sKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwciAmJiBhLnZhbHVlIGluc3RhbmNlb2YgVXBsY0Jvb2wgJiYgYiBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgJiYgYi52YWx1ZSBpbnN0YW5jZW9mIFVwbGNCb29sKSB7XG5cdFx0XHRcdFx0XHRpZiAoYS52YWx1ZS5ib29sICYmICFiLnZhbHVlLmJvb2wpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbmQ7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHQhYS52YWx1ZS5ib29sICYmIFxuXHRcdFx0XHRcdFx0XHRiLnZhbHVlLmJvb2wgJiYgXG5cdFx0XHRcdFx0XHRcdGNvbmQgaW5zdGFuY2VvZiBJUlVzZXJDYWxsRXhwciAmJiBcblx0XHRcdFx0XHRcdFx0Y29uZC5mbkV4cHIgaW5zdGFuY2VvZiBJUk5hbWVFeHByICYmIFxuXHRcdFx0XHRcdFx0XHRjb25kLmZuRXhwci5uYW1lID09PSBcIl9faGVsaW9zX19jb21tb25fX25vdFwiXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbmQuYXJnRXhwcnNbMF07XG5cdFx0XHRcdFx0XHR9XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibW9kSW50ZWdlclwiOiB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgc2Vjb25kIGFyZyBpcyAxXG5cdFx0XHRcdFx0Y29uc3QgW2EsIGJdID0gYXJncztcblx0XHRcdFx0XHRpZiAoYiBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgJiYgYi52YWx1ZSBpbnN0YW5jZW9mIFVwbGNJbnQgJiYgYi52YWx1ZS5pbnQgPT0gMW4pIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgSVJMaXRlcmFsRXhwcihuZXcgVXBsY0ludCh0aGlzLnNpdGUsIDBuKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm11bHRpcGx5SW50ZWdlclwiOiB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgZmlyc3QgYXJnIGlzIDAgb3IgMVxuXHRcdFx0XHRcdGNvbnN0IFthLCBiXSA9IGFyZ3M7XG5cdFx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGEudmFsdWUgaW5zdGFuY2VvZiBVcGxjSW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoYS52YWx1ZS5pbnQgPT0gMG4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGEudmFsdWUuaW50ID09IDFuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYiBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgJiYgYi52YWx1ZSBpbnN0YW5jZW9mIFVwbGNJbnQpIHtcblx0XHRcdFx0XHRcdGlmIChiLnZhbHVlLmludCA9PSAwbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYi52YWx1ZS5pbnQgPT0gMW4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInN1YnRyYWN0SW50ZWdlclwiOiB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgc2Vjb25kIGFyZyBldmFsdWF0ZXMgdG8gMFxuXHRcdFx0XHRcdGNvbnN0IFthLCBiXSA9IGFyZ3M7XG5cdFx0XHRcdFx0aWYgKGIgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGIudmFsdWUgaW5zdGFuY2VvZiBVcGxjSW50ICYmIGIudmFsdWUuaW50ID09IDBuKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3MuZXZlcnkoYSA9PiBhIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwcikpIHtcblx0XHRcdHJldHVybiBuZXcgSVJMaXRlcmFsRXhwcihcblx0XHRcdFx0VXBsY0J1aWx0aW4uZXZhbFN0YXRpYyhcblx0XHRcdFx0XHRuZXcgV29yZCh0aGlzLiNuYW1lLnNpdGUsIHRoaXMuYnVpbHRpbk5hbWUpLFxuXHRcdFx0XHRcdGFyZ3MubWFwKGEgPT4gYXNzZXJ0Q2xhc3MoYSwgSVJMaXRlcmFsRXhwcikudmFsdWUpXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgSVJDb3JlQ2FsbEV4cHIodGhpcy4jbmFtZSwgYXJncywgdGhpcy5wYXJlbnNTaXRlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUk5hbWVFeHByUmVnaXN0cnl9IG5hbWVFeHByc1xuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdFx0dGhpcy5yZWdpc3Rlck5hbWVFeHByc0luQXJncyhuYW1lRXhwcnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPElSVmFyaWFibGUsIElSVmFyaWFibGU+fSBuZXdWYXJzXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRjb3B5KG5ld1ZhcnMpIHtcblx0XHRyZXR1cm4gbmV3IElSQ29yZUNhbGxFeHByKHRoaXMuI25hbWUsIHRoaXMuYXJnRXhwcnMubWFwKGEgPT4gYS5jb3B5KG5ld1ZhcnMpKSwgdGhpcy5wYXJlbnNTaXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRXhwclJlZ2lzdHJ5fSByZWdpc3RyeSBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5VG9wb2xvZ3kocmVnaXN0cnkpIHtcblx0XHRjb25zdCBhcmdzID0gdGhpcy5zaW1wbGlmeVRvcG9sb2d5SW5BcmdzKHJlZ2lzdHJ5KTtcblxuXHRcdHN3aXRjaCh0aGlzLmJ1aWx0aW5OYW1lKSB7XG5cdFx0XHRjYXNlIFwiZW5jb2RlVXRmOFwiOlxuXHRcdFx0XHQvLyB3ZSBjYW4ndCBlbGltaW5hdGUgYSBjYWxsIHRvIGRlY29kZVV0ZjgsIGFzIGl0IG1pZ2h0IHRocm93IHNvbWUgZXJyb3JzXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRlY29kZVV0ZjhcIjoge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhcmcgaXMgYSBjYWxsIHRvIGVuY29kZVV0Zjhcblx0XHRcdFx0Y29uc3QgW2FyZ10gPSBhcmdzO1xuXHRcdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgSVJDb3JlQ2FsbEV4cHIgJiYgYXJnLmJ1aWx0aW5OYW1lID09IFwiZW5jb2RlVXRmOFwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZy5hcmdFeHByc1swXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XHRcdFxuXHRcdFx0Y2FzZSBcImVxdWFsc0RhdGFcIjoge1xuXHRcdFx0XHRjb25zdCBbYSwgYl0gPSBhcmdzO1xuXG5cdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJDb3JlQ2FsbEV4cHIgJiYgYiBpbnN0YW5jZW9mIElSQ29yZUNhbGxFeHByKSB7XG5cdFx0XHRcdFx0aWYgKGEuYnVpbHRpbk5hbWUgPT09IFwiaURhdGFcIiAmJiBiLmJ1aWx0aW5OYW1lID09PSBcImlEYXRhXCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgSVJDb3JlQ2FsbEV4cHIobmV3IFdvcmQodGhpcy5zaXRlLCBcIl9fY29yZV9fZXF1YWxzSW50ZWdlclwiKSwgW2EuYXJnRXhwcnNbMF0sIGIuYXJnRXhwcnNbMF1dLCB0aGlzLnBhcmVuc1NpdGUpO1x0XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhLmJ1aWx0aW5OYW1lID09PSBcImJEYXRhXCIgJiYgYi5idWlsdGluTmFtZSA9PT0gXCJiRGF0YVwiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IElSQ29yZUNhbGxFeHByKG5ldyBXb3JkKHRoaXMuc2l0ZSwgXCJfX2NvcmVfX2VxdWFsc0J5dGVTdHJpbmdcIiksIFthLmFyZ0V4cHJzWzBdLCBiLmFyZ0V4cHJzWzBdXSwgdGhpcy5wYXJlbnNTaXRlKTtcdFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYS5idWlsdGluTmFtZSA9PT0gXCJkZWNvZGVVdGY4XCIgJiYgYi5idWlsdGluTmFtZSA9PT0gXCJkZWNvZGVVdGY4XCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgSVJDb3JlQ2FsbEV4cHIobmV3IFdvcmQodGhpcy5zaXRlLCBcIl9fY29yZV9fZXF1YWxzU3RyaW5nXCIpLCBbYS5hcmdFeHByc1swXSwgYi5hcmdFeHByc1swXV0sIHRoaXMucGFyZW5zU2l0ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiaWZUaGVuRWxzZVwiOiB7XG5cdFx0XHRcdGNvbnN0IFtjb25kLCBhLCBiXSA9IGFyZ3M7XG5cblx0XHRcdFx0aWYgKGNvbmQgaW5zdGFuY2VvZiBJUkNvcmVDYWxsRXhwciAmJiBjb25kLmJ1aWx0aW5OYW1lID09PSBcIm51bGxMaXN0XCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IElSQ29yZUNhbGxFeHByKG5ldyBXb3JkKHRoaXMuc2l0ZSwgXCJfX2NvcmVfX2Nob29zZUxpc3RcIiksIFtjb25kLmFyZ0V4cHJzWzBdLCBhLCBiXSwgdGhpcy5wYXJlbnNTaXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBcInRyYWNlXCI6XG5cdFx0XHRcdHJldHVybiBhcmdzWzFdO1xuXHRcdFx0Y2FzZSBcInVuSURhdGFcIjoge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhcmcgaXMgYSBjYWxsIHRvIGlEYXRhXG5cdFx0XHRcdGNvbnN0IGEgPSBhcmdzWzBdO1xuXHRcdFx0XHRpZiAoYSBpbnN0YW5jZW9mIElSQ29yZUNhbGxFeHByICYmIGEuYnVpbHRpbk5hbWUgPT0gXCJpRGF0YVwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJpRGF0YVwiOiB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGFyZyBpcyBhIGNhbGwgdG8gdW5JRGF0YVxuXHRcdFx0XHRjb25zdCBhID0gYXJnc1swXTtcblx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkNvcmVDYWxsRXhwciAmJiBhLmJ1aWx0aW5OYW1lID09IFwidW5JRGF0YVwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJ1bkJEYXRhXCI6IHtcblx0XHRcdFx0Ly8gY2hlY2sgaWYgYXJnIGlzIGEgY2FsbCB0byBiRGF0YVxuXHRcdFx0XHRjb25zdCBhID0gYXJnc1swXTtcblx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkNvcmVDYWxsRXhwciAmJiBhLmJ1aWx0aW5OYW1lID09IFwiYkRhdGFcIikge1xuXHRcdFx0XHRcdHJldHVybiBhLmFyZ0V4cHJzWzBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiYkRhdGFcIjoge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhcmcgaXMgYSBjYWxsIHRvIHVuQkRhdGFcblx0XHRcdFx0Y29uc3QgYSA9IGFyZ3NbMF07XG5cdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJDb3JlQ2FsbEV4cHIgJiYgYS5idWlsdGluTmFtZSA9PSBcInVuQkRhdGFcIikge1xuXHRcdFx0XHRcdHJldHVybiBhLmFyZ0V4cHJzWzBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwidW5NYXBEYXRhXCI6IHtcblx0XHRcdFx0Ly8gY2hlY2sgaWYgYXJnIGlzIGNhbGwgdG8gbWFwRGF0YVxuXHRcdFx0XHRjb25zdCBhID0gYXJnc1swXTtcblx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkNvcmVDYWxsRXhwciAmJiBhLmJ1aWx0aW5OYW1lID09IFwibWFwRGF0YVwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBcIm1hcERhdGFcIjoge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhcmcgaXMgY2FsbCB0byB1bk1hcERhdGFcblx0XHRcdFx0Y29uc3QgYSA9IGFyZ3NbMF07XG5cdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJDb3JlQ2FsbEV4cHIgJiYgYS5idWlsdGluTmFtZSA9PSBcInVuTWFwRGF0YVwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJsaXN0RGF0YVwiOiB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGFyZyBpcyBjYWxsIHRvIHVuTGlzdERhdGFcblx0XHRcdFx0Y29uc3QgYSA9IGFyZ3NbMF07XG5cdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJDb3JlQ2FsbEV4cHIgJiYgYS5idWlsdGluTmFtZSA9PSBcInVuTGlzdERhdGFcIikge1xuXHRcdFx0XHRcdHJldHVybiBhLmFyZ0V4cHJzWzBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwidW5MaXN0RGF0YVwiOiB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGFyZyBpcyBjYWxsIHRvIGxpc3REYXRhXG5cdFx0XHRcdGNvbnN0IGEgPSBhcmdzWzBdO1xuXHRcdFx0XHRpZiAoYSBpbnN0YW5jZW9mIElSQ29yZUNhbGxFeHByICYmIGEuYnVpbHRpbk5hbWUgPT0gXCJsaXN0RGF0YVwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVx0XHRcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IElSQ29yZUNhbGxFeHByKHRoaXMuI25hbWUsIGFyZ3MsIHRoaXMucGFyZW5zU2l0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTaXRlfSBzaXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gZnVsbCBuYW1lIG9mIGJ1aWx0aW4sIGluY2x1ZGluZyBwcmVmaXhcblx0ICogQHJldHVybnMge1VwbGNUZXJtfVxuXHQgKi9cblx0c3RhdGljIG5ld1VwbGNCdWlsdGluKHNpdGUsIG5hbWUpIHtcblx0XHRsZXQgYnVpbHRpbk5hbWUgPSBuYW1lLnNsaWNlKFwiX19jb3JlX19cIi5sZW5ndGgpO1xuXHRcdGFzc2VydCghYnVpbHRpbk5hbWUuc3RhcnRzV2l0aChcIl9fY29yZV9fXCIpKTtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtVcGxjVGVybX1cblx0XHQgKi9cblx0XHRsZXQgdGVybSA9IG5ldyBVcGxjQnVpbHRpbihzaXRlLCBidWlsdGluTmFtZSk7XG5cblx0XHRsZXQgbkZvcmNlID0gVVBMQ19CVUlMVElOU1tJUlNjb3BlLmZpbmRCdWlsdGluKG5hbWUpXS5mb3JjZUNvdW50O1xuIFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbkZvcmNlOyBpKyspIHtcblx0XHRcdHRlcm0gPSBuZXcgVXBsY0ZvcmNlKHNpdGUsIHRlcm0pO1xuXHRcdH1cbiBcblx0XHRyZXR1cm4gdGVybTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VXBsY1Rlcm19XG5cdCAqL1xuXHR0b1VwbGMoKSB7XG5cdFx0bGV0IHRlcm0gPSBJUkNvcmVDYWxsRXhwci5uZXdVcGxjQnVpbHRpbih0aGlzLnNpdGUsIHRoaXMuI25hbWUudmFsdWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMudG9VcGxjQ2FsbCh0ZXJtKTtcblx0fVxufVxuXG4vKipcbiAqIElSIGZ1bmN0aW9uIGNhbGwgb2Ygbm9uLWNvcmUgZnVuY3Rpb25cbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSVXNlckNhbGxFeHByIGV4dGVuZHMgSVJDYWxsRXhwciB7XG5cdCNmbkV4cHI7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJFeHByfSBmbkV4cHIgXG5cdCAqIEBwYXJhbSB7SVJFeHByW119IGFyZ0V4cHJzIFxuXHQgKiBAcGFyYW0ge1NpdGV9IHBhcmVuc1NpdGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihmbkV4cHIsIGFyZ0V4cHJzLCBwYXJlbnNTaXRlKSB7XG5cdFx0c3VwZXIoZm5FeHByLnNpdGUsIGFyZ0V4cHJzLCBwYXJlbnNTaXRlKTtcblxuXHRcdHRoaXMuI2ZuRXhwciA9IGZuRXhwcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRXhwcn0gZm5FeHByIFxuXHQgKiBAcGFyYW0ge0lSRXhwcltdfSBhcmdFeHBycyBcblx0ICogQHBhcmFtIHtTaXRlfSBwYXJlbnNTaXRlIFxuXHQgKiBAcmV0dXJucyB7SVJVc2VyQ2FsbEV4cHJ9XG5cdCAqL1xuXHRzdGF0aWMgbmV3KGZuRXhwciwgYXJnRXhwcnMsIHBhcmVuc1NpdGUpIHtcblx0XHRpZiAoZm5FeHByIGluc3RhbmNlb2YgSVJBbm9uQ2FsbEV4cHIpIHtcblx0XHRcdHJldHVybiBuZXcgSVJOZXN0ZWRBbm9uQ2FsbEV4cHIoZm5FeHByLCBhcmdFeHBycywgcGFyZW5zU2l0ZSk7XG5cdFx0fSBlbHNlIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBJUkZ1bmNFeHByKSB7XG5cdFx0XHRpZiAoYXJnRXhwcnMubGVuZ3RoID09IDEgJiYgYXJnRXhwcnNbMF0gaW5zdGFuY2VvZiBJUkZ1bmNFeHByKSB7XG5cdFx0XHRcdGNvbnN0IGFyZ0V4cHIgPSBhcmdFeHByc1swXTtcblxuXHRcdFx0XHRpZiAoYXJnRXhwciBpbnN0YW5jZW9mIElSRnVuY0V4cHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IElSRnVuY0RlZkV4cHIoZm5FeHByLCBhcmdFeHByLCBwYXJlbnNTaXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IElSQW5vbkNhbGxFeHByKGZuRXhwciwgYXJnRXhwcnMsIHBhcmVuc1NpdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IElSVXNlckNhbGxFeHByKGZuRXhwciwgYXJnRXhwcnMsIHBhcmVuc1NpdGUpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBmbkV4cHIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2ZuRXhwcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50XG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHR0b1N0cmluZyhpbmRlbnQgPSBcIlwiKSB7XG5cdFx0bGV0IGNvbW1lbnQgPSAodGhpcy4jZm5FeHByIGluc3RhbmNlb2YgSVJGdW5jRXhwciAmJiB0aGlzLiNmbkV4cHIuYXJncy5sZW5ndGggPT0gMSAmJiB0aGlzLiNmbkV4cHIuYXJnc1swXS5uYW1lLnN0YXJ0c1dpdGgoXCJfX1wiKSkgPyBgLyoke3RoaXMuI2ZuRXhwci5hcmdzWzBdLm5hbWV9Ki9gIDogXCJcIjtcblxuXHRcdHJldHVybiBgJHt0aGlzLiNmbkV4cHIudG9TdHJpbmcoaW5kZW50KX0oJHtjb21tZW50fSR7dGhpcy5hcmdzVG9TdHJpbmcoaW5kZW50KX0pYDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSU2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0cmVzb2x2ZU5hbWVzKHNjb3BlKSB7XG5cdFx0dGhpcy4jZm5FeHByLnJlc29sdmVOYW1lcyhzY29wZSk7XG5cblx0XHRzdXBlci5yZXNvbHZlTmFtZXNJbkFyZ3Moc2NvcGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRldmFsQ29uc3RhbnRzKHN0YWNrKSB7XG5cdFx0cmV0dXJuIElSVXNlckNhbGxFeHByLm5ldyhcblx0XHRcdHRoaXMuI2ZuRXhwci5ldmFsQ29uc3RhbnRzKHN0YWNrKSxcblx0XHRcdHRoaXMuZXZhbENvbnN0YW50c0luQXJncyhzdGFjayksXG5cdFx0XHR0aGlzLnBhcmVuc1NpdGVcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrIFxuXHQgKiBAcmV0dXJucyB7P0lSVmFsdWV9XG5cdCAqL1xuXHRldmFsKHN0YWNrKSB7XG5cdFx0bGV0IGFyZ3MgPSB0aGlzLmV2YWxBcmdzKHN0YWNrKTtcblxuXHRcdGlmIChhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGZuID0gdGhpcy4jZm5FeHByLmV2YWwoc3RhY2spO1xuXG5cdFx0XHRpZiAoZm4gPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBmbi5jYWxsKGFyZ3MpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBSdW50aW1lRXJyb3IpIHtcblx0XHRcdFx0XHRcdGlmICghc3RhY2sudGhyb3dSVEVycm9ycykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGUuYWRkVHJhY2VTaXRlKHRoaXMuc2l0ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJMaXRlcmFsUmVnaXN0cnl9IGxpdGVyYWxzXG5cdCAqIEByZXR1cm5zIHsoSVJFeHByW10gfCBJUkxpdGVyYWxFeHByKX1cblx0ICovXG5cdHNpbXBsaWZ5TGl0ZXJhbHNJbkFyZ3NBbmRUcnlFdmFsKGxpdGVyYWxzKSB7XG5cdFx0Y29uc3QgYXJncyA9IHRoaXMuc2ltcGxpZnlMaXRlcmFsc0luQXJncyhsaXRlcmFscyk7XG5cblx0XHRpZiAoYXJncy5sZW5ndGggPiAwICYmIGFyZ3MuZXZlcnkoYSA9PiAoKGEgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByKSB8fCAoYSBpbnN0YW5jZW9mIElSRnVuY0V4cHIpKSkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGZuID0gdGhpcy4jZm5FeHByLmV2YWwobmV3IElSQ2FsbFN0YWNrKGZhbHNlKSk7XG5cblx0XHRcdFx0aWYgKGZuICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCByZXMgPSBmbi5jYWxsKFxuXHRcdFx0XHRcdFx0YXJncy5tYXAoYSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHYgPSBhLmV2YWwobmV3IElSQ2FsbFN0YWNrKGZhbHNlKSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGNhdWdodCBieSBvdXRlciBjYXRjaFxuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm51bGwgZXZhbCBzdWItcmVzdWx0XCIpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAocmVzICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgSVJMaXRlcmFsRXhwcihyZXMudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3M7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkxpdGVyYWxSZWdpc3RyeX0gbGl0ZXJhbHNcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpIHtcblx0XHRjb25zdCBhcmdzT3JMaXRlcmFsID0gdGhpcy5zaW1wbGlmeUxpdGVyYWxzSW5BcmdzQW5kVHJ5RXZhbChsaXRlcmFscyk7XG5cblx0XHRpZiAoYXJnc09yTGl0ZXJhbCBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIpIHtcblx0XHRcdHJldHVybiBhcmdzT3JMaXRlcmFsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBhcmdzID0gYXJnc09yTGl0ZXJhbDtcblxuXHRcdFx0cmV0dXJuIElSVXNlckNhbGxFeHByLm5ldyhcblx0XHRcdFx0dGhpcy4jZm5FeHByLnNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpLFxuXHRcdFx0XHRhcmdzLCBcblx0XHRcdFx0dGhpcy5wYXJlbnNTaXRlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTmFtZUV4cHJSZWdpc3RyeX0gbmFtZUV4cHJzIFxuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdFx0dGhpcy5yZWdpc3Rlck5hbWVFeHByc0luQXJncyhuYW1lRXhwcnMpO1xuXHRcdFxuXHRcdHRoaXMuI2ZuRXhwci5yZWdpc3Rlck5hbWVFeHBycyhuYW1lRXhwcnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPElSVmFyaWFibGUsIElSVmFyaWFibGU+fSBuZXdWYXJzIFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0Y29weShuZXdWYXJzKSB7XG5cdFx0cmV0dXJuIG5ldyBJUlVzZXJDYWxsRXhwcih0aGlzLiNmbkV4cHIuY29weShuZXdWYXJzKSwgdGhpcy5hcmdFeHBycy5tYXAoYSA9PiBhLmNvcHkobmV3VmFycykpLCB0aGlzLnBhcmVuc1NpdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJFeHByUmVnaXN0cnl9IHJlZ2lzdHJ5IFxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0c2ltcGxpZnlUb3BvbG9neShyZWdpc3RyeSkge1xuXHRcdGNvbnN0IGFyZ3MgPSB0aGlzLnNpbXBsaWZ5VG9wb2xvZ3lJbkFyZ3MocmVnaXN0cnkpO1xuXG5cdFx0aWYgKHRoaXMuI2ZuRXhwciBpbnN0YW5jZW9mIElSTmFtZUV4cHIpIHtcblx0XHRcdGlmICh0aGlzLiNmbkV4cHIuaXNDb3JlKCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBJUkNvcmVDYWxsRXhwcihuZXcgV29yZCh0aGlzLiNmbkV4cHIuc2l0ZSwgdGhpcy4jZm5FeHByLm5hbWUpLCBhcmdzLCB0aGlzLnBhcmVuc1NpdGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoICh0aGlzLiNmbkV4cHIubmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgXCJfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YVwiOiB7XG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIGFyZyBpcyBhIGNhbGwgdG8gX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YVxuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUlVzZXJDYWxsRXhwciAmJiBhLmZuRXhwciBpbnN0YW5jZW9mIElSTmFtZUV4cHIgJiYgYS5mbkV4cHIubmFtZSA9PSBcIl9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGFcIikge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBhLmFyZ0V4cHJzWzBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiX19oZWxpb3NfX2NvbW1vbl9fdW5Cb29sRGF0YVwiOiB7XG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIGFyZyBpcyBhIGNhbGwgdG8gX19oZWxpb3NfX2NvbW1vbl9fYm9vbERhdGFcblx0XHRcdFx0XHRcdFx0Y29uc3QgYSA9IGFyZ3NbMF07XG5cdFx0XHRcdFx0XHRcdGlmIChhIGluc3RhbmNlb2YgSVJVc2VyQ2FsbEV4cHIgJiYgYS5mbkV4cHIgaW5zdGFuY2VvZiBJUk5hbWVFeHByICYmIGEuZm5FeHByLm5hbWUgPT0gXCJfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJfX2hlbGlvc19fY29tbW9uX19ub3RcIjoge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUlVzZXJDYWxsRXhwciAmJiBhLmZuRXhwciBpbnN0YW5jZW9mIElSTmFtZUV4cHIgJiYgYS5mbkV4cHIubmFtZSA9PSBcIl9faGVsaW9zX19jb21tb25fX25vdFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGEuYXJnRXhwcnNbMF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJfX2hlbGlvc19fY29tbW9uX19jb25jYXRcIjoge1xuXHRcdFx0XHRcdFx0XHQvLyBjaGVjayBpZiBlaXRoZXIgMXN0IG9yIDJuZCBhcmcgaXMgdGhlIGVtcHR5IGxpc3Rcblx0XHRcdFx0XHRcdFx0Y29uc3QgW2EsIGJdID0gYXJncztcblx0XHRcdFx0XHRcdFx0aWYgKGEgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGEudmFsdWUgaW5zdGFuY2VvZiBVcGxjTGlzdCAmJiBhLnZhbHVlLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGIgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByICYmIGIudmFsdWUgaW5zdGFuY2VvZiBVcGxjTGlzdCAmJiBiLnZhbHVlLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIElSVXNlckNhbGxFeHByLm5ldyhcblx0XHRcdHRoaXMuI2ZuRXhwci5zaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KSxcblx0XHRcdGFyZ3MsXG5cdFx0XHR0aGlzLnBhcmVuc1NpdGVcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtVcGxjVGVybX1cblx0ICovXG5cdHRvVXBsYygpIHtcblx0XHRyZXR1cm4gc3VwZXIudG9VcGxjQ2FsbCh0aGlzLiNmbkV4cHIudG9VcGxjKCkpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBJUkFub25DYWxsRXhwciBleHRlbmRzIElSVXNlckNhbGxFeHByIHtcblx0I2Fub247XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJGdW5jRXhwcn0gZm5FeHByIFxuXHQgKiBAcGFyYW0ge0lSRXhwcltdfSBhcmdFeHBycyBcblx0ICogQHBhcmFtIHtTaXRlfSBwYXJlbnNTaXRlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoZm5FeHByLCBhcmdFeHBycywgcGFyZW5zU2l0ZSkge1xuXHRcdHN1cGVyKGZuRXhwciwgYXJnRXhwcnMsIHBhcmVuc1NpdGUpXG5cblx0XHR0aGlzLiNhbm9uID0gZm5FeHByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsIGZ1bmN0aW9uXG5cdCAqIEB0eXBlIHtJUkZ1bmNFeHByfVxuXHQgKi9cblx0Z2V0IGFub24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Fub247XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge0lSVmFyaWFibGVbXX1cblx0ICovXG5cdGdldCBhcmdWYXJpYWJsZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2Fub24uYXJncztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYXJncyB0byB0aGUgc3RhY2sgYXMgSVJEZWZlcnJlZFZhbHVlIGluc3RhbmNlc1xuXHQgKiBAcGFyYW0ge0lSQ2FsbFN0YWNrfSBzdGFja1xuXHQgKi9cblx0ZXZhbENvbnN0YW50cyhzdGFjaykge1xuXHRcdGNvbnN0IGFyZ0V4cHJzID0gdGhpcy5ldmFsQ29uc3RhbnRzSW5BcmdzKHN0YWNrKTtcblxuXHRcdGNvbnN0IHBhcmVudFN0YWNrID0gc3RhY2s7XG5cblx0XHRhcmdFeHBycy5mb3JFYWNoKChhcmdFeHByLCBpKSA9PiB7XG5cdFx0XHRzdGFjayA9IHN0YWNrLnNldCh0aGlzLmFyZ1ZhcmlhYmxlc1tpXSwgbmV3IElSRGVmZXJyZWRWYWx1ZSgoKSA9PiBhcmdFeHByLmV2YWwocGFyZW50U3RhY2spKSk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBhbm9uQm9keSA9IHRoaXMuI2Fub24uYm9keS5ldmFsQ29uc3RhbnRzKHN0YWNrKTtcblxuXHRcdGlmIChhbm9uQm9keSBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIpIHtcblx0XHRcdHJldHVybiBhbm9uQm9keTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIElSVXNlckNhbGxFeHByLm5ldyhcblx0XHRcdFx0bmV3IElSRnVuY0V4cHIoXG5cdFx0XHRcdFx0dGhpcy4jYW5vbi5zaXRlLFxuXHRcdFx0XHRcdHRoaXMuI2Fub24uYXJncyxcblx0XHRcdFx0XHRhbm9uQm9keVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRhcmdFeHBycyxcblx0XHRcdFx0dGhpcy5wYXJlbnNTaXRlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgbGl0ZXJhbCBhcmdzIHRvIHRoZSBtYXBcblx0ICogQHBhcmFtIHtJUkxpdGVyYWxSZWdpc3RyeX0gbGl0ZXJhbHNcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpIHtcblx0XHRjb25zdCBhcmdzT3JMaXRlcmFsID0gc3VwZXIuc2ltcGxpZnlMaXRlcmFsc0luQXJnc0FuZFRyeUV2YWwobGl0ZXJhbHMpO1xuXG5cdFx0aWYgKGFyZ3NPckxpdGVyYWwgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByKSB7XG5cdFx0XHRyZXR1cm4gYXJnc09yTGl0ZXJhbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgYXJncyA9IGFyZ3NPckxpdGVyYWw7XG5cblx0XHRcdGFyZ3MuZm9yRWFjaCgoYXJnLCBpKSA9PiB7XG5cdFx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBJUkxpdGVyYWxFeHByKSB7XG5cdFx0XHRcdFx0bGl0ZXJhbHMuc2V0KHRoaXMuYXJnVmFyaWFibGVzW2ldLCBhcmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgYW5vbkJvZHkgPSB0aGlzLiNhbm9uLmJvZHkuc2ltcGxpZnlMaXRlcmFscyhsaXRlcmFscyk7XG5cblx0XHRcdGlmIChhbm9uQm9keSBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIpIHtcblx0XHRcdFx0cmV0dXJuIGFub25Cb2R5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBJUkFub25DYWxsRXhwcihcblx0XHRcdFx0XHRuZXcgSVJGdW5jRXhwcihcblx0XHRcdFx0XHRcdHRoaXMuI2Fub24uc2l0ZSxcblx0XHRcdFx0XHRcdHRoaXMuI2Fub24uYXJncyxcblx0XHRcdFx0XHRcdGFub25Cb2R5XG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRcdHRoaXMucGFyZW5zU2l0ZVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTmFtZUV4cHJSZWdpc3RyeX0gbmFtZUV4cHJzIFxuXHQgKi9cblx0cmVnaXN0ZXJOYW1lRXhwcnMobmFtZUV4cHJzKSB7XG5cdFx0dGhpcy5yZWdpc3Rlck5hbWVFeHByc0luQXJncyhuYW1lRXhwcnMpO1xuXG5cdFx0dGhpcy5hcmdWYXJpYWJsZXMuZm9yRWFjaChhID0+IG5hbWVFeHBycy5yZWdpc3RlclZhcmlhYmxlKGEpKTtcblxuXHRcdHRoaXMuI2Fub24uYm9keS5yZWdpc3Rlck5hbWVFeHBycyhuYW1lRXhwcnMpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtJUkV4cHJSZWdpc3RyeX0gcmVnaXN0cnkgXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KSB7XG5cdFx0Y29uc3QgYXJncyA9IHRoaXMuc2ltcGxpZnlUb3BvbG9neUluQXJncyhyZWdpc3RyeSk7XG5cblx0XHQvLyByZW1vdmUgdW51c2VkIGFyZ3MsIGlubGluZSBhcmdzIHRoYXQgYXJlIG9ubHkgcmVmZXJlbmNlZCBvbmNlLCBpbmxpbmUgYWxsIElSTmFtZUV4cHJzLCBpbmxpbmUgZnVuY3Rpb24gd2l0aCBkZWZhdWx0IGFyZ3MgXG5cdFx0Y29uc3QgcmVtYWluaW5nSWRzID0gdGhpcy5hcmdWYXJpYWJsZXMubWFwKCh2YXJpYWJsZSwgaSkgPT4ge1xuXHRcdFx0Y29uc3QgbiA9IHJlZ2lzdHJ5LmNvdW50UmVmZXJlbmNlcyh2YXJpYWJsZSk7XG5cblx0XHRcdGNvbnN0IGFyZyA9IGFyZ3NbaV07XG5cblx0XHRcdGlmIChcblx0XHRcdFx0biA9PSAwIFxuXHRcdFx0XHR8fCAobiA9PSAxICYmICghcmVnaXN0cnkubWF5YmVJbnNpZGVMb29wKHZhcmlhYmxlKSB8fCBhcmcgaW5zdGFuY2VvZiBJUkZ1bmNFeHByKSkgXG5cdFx0XHRcdHx8IGFyZyBpbnN0YW5jZW9mIElSTmFtZUV4cHIgXG5cdFx0XHRcdHx8IChhcmcgaW5zdGFuY2VvZiBJUkZ1bmNFeHByICYmIGFyZy5oYXNPcHRBcmdzKCkpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKG4gPiAwKSB7XG5cdFx0XHRcdFx0Ly8gaW5saW5lXG5cdFx0XHRcdFx0cmVnaXN0cnkuYWRkSW5saW5lYWJsZSh2YXJpYWJsZSwgYXJnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH0pLmZpbHRlcihpID0+IGkgIT0gLTEpO1xuXG5cdFx0Y29uc3QgcmVtYWluaW5nVmFycyA9IHJlbWFpbmluZ0lkcy5tYXAoaSA9PiB0aGlzLmFyZ1ZhcmlhYmxlc1tpXSk7XG5cdFx0Y29uc3QgcmVtYWluaW5nRXhwcnMgPSByZW1haW5pbmdJZHMubWFwKGkgPT4gYXJnc1tpXSk7XG5cblx0XHRjb25zdCBhbm9uQm9keSA9IHRoaXMuI2Fub24uYm9keS5zaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KTtcblxuXHRcdGlmIChhbm9uQm9keSBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIgfHwgcmVtYWluaW5nRXhwcnMubGVuZ3RoID09IDApIHtcblx0XHRcdHJldHVybiBhbm9uQm9keTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBJUkFub25DYWxsRXhwcihcblx0XHRcdFx0bmV3IElSRnVuY0V4cHIoXG5cdFx0XHRcdFx0dGhpcy4jYW5vbi5zaXRlLFxuXHRcdFx0XHRcdHJlbWFpbmluZ1ZhcnMsXG5cdFx0XHRcdFx0YW5vbkJvZHlcblx0XHRcdFx0KSxcblx0XHRcdFx0cmVtYWluaW5nRXhwcnMsXG5cdFx0XHRcdHRoaXMucGFyZW5zU2l0ZVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIElSTmVzdGVkQW5vbkNhbGxFeHByIGV4dGVuZHMgSVJVc2VyQ2FsbEV4cHIge1xuXHQjYW5vbjtcblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkFub25DYWxsRXhwcn0gYW5vblxuXHQgKiBAcGFyYW0ge0lSRXhwcltdfSBvdXRlckFyZ0V4cHJzXG5cdCAqIEBwYXJhbSB7U2l0ZX0gcGFyZW5zU2l0ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoYW5vbiwgb3V0ZXJBcmdFeHBycywgcGFyZW5zU2l0ZSkge1xuXHRcdHN1cGVyKGFub24sIG91dGVyQXJnRXhwcnMsIHBhcmVuc1NpdGUpO1xuXG5cdFx0dGhpcy4jYW5vbiA9IGFub247XG5cdH1cblxuXHQvKipcblx0ICogRmxhdHRlbnMgY29uc2VjdXRpdmUgbmVzdGVkIGNhbGxzXG5cdCAqIEBwYXJhbSB7SVJFeHByUmVnaXN0cnl9IHJlZ2lzdHJ5XG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzaW1wbGlmeVRvcG9sb2d5KHJlZ2lzdHJ5KSB7XG5cdFx0Y29uc3QgYW5vbiA9IHRoaXMuI2Fub24uc2ltcGxpZnlUb3BvbG9neShyZWdpc3RyeSk7XG5cblx0XHRjb25zdCBhcmdzID0gdGhpcy5zaW1wbGlmeVRvcG9sb2d5SW5BcmdzKHJlZ2lzdHJ5KTtcblxuXHRcdGlmIChhbm9uIGluc3RhbmNlb2YgSVJBbm9uQ2FsbEV4cHIgJiYgYW5vbi5hbm9uLmJvZHkgaW5zdGFuY2VvZiBJUkZ1bmNFeHByKSB7XG5cdFx0XHQvLyBmbGF0dGVuXG5cdFx0XHRjb25zdCBhbGxBcmdzID0gYW5vbi5hcmdFeHBycy5zbGljZSgpLmNvbmNhdChhcmdzKTtcblx0XHRcdGNvbnN0IGFsbFZhcnMgPSBhbm9uLmFyZ1ZhcmlhYmxlcy5zbGljZSgpLmNvbmNhdChhbm9uLmFub24uYm9keS5hcmdzLnNsaWNlKCkpO1xuXG5cdFx0XHRhc3NlcnQoYWxsQXJncy5sZW5ndGggPT0gYWxsVmFycy5sZW5ndGgpO1xuXG5cdFx0XHRyZXR1cm4gSVJVc2VyQ2FsbEV4cHIubmV3KFxuXHRcdFx0XHRuZXcgSVJGdW5jRXhwcihcblx0XHRcdFx0XHRhbm9uLmFub24uYm9keS5zaXRlLFxuXHRcdFx0XHRcdGFsbFZhcnMsXG5cdFx0XHRcdFx0YW5vbi5hbm9uLmJvZHkuYm9keVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRhbGxBcmdzLFxuXHRcdFx0XHR0aGlzLnBhcmVuc1NpdGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBJUlVzZXJDYWxsRXhwci5uZXcoXG5cdFx0XHRcdGFub24sXG5cdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdHRoaXMucGFyZW5zU2l0ZVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIElSRnVuY0RlZkV4cHIgZXh0ZW5kcyBJUkFub25DYWxsRXhwciB7XG5cdCNkZWY7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJGdW5jRXhwcn0gZm5FeHByIFxuXHQgKiBAcGFyYW0ge0lSRnVuY0V4cHJ9IGRlZkV4cHIgXG5cdCAqIEBwYXJhbSB7U2l0ZX0gcGFyZW5zU2l0ZVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZm5FeHByLCBkZWZFeHByLCBwYXJlbnNTaXRlKSB7XG5cdFx0c3VwZXIoZm5FeHByLCBbZGVmRXhwcl0sIHBhcmVuc1NpdGUpO1xuXG5cdFx0dGhpcy4jZGVmID0gZGVmRXhwcjtcblx0fVxufVxuXG4vKipcbiAqIEludGVybWVkaWF0ZSBSZXByZXNlbnRhdGlvbiBlcnJvciBjYWxsICh3aXRoIG9wdGlvbmFsIGxpdGVyYWwgZXJyb3IgbWVzc2FnZSlcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSRXJyb3JDYWxsRXhwciBleHRlbmRzIElSRXhwciB7XG5cdCNtc2c7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U2l0ZX0gc2l0ZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNpdGUsIG1zZyA9IFwiXCIpIHtcblx0XHRzdXBlcihzaXRlKTtcblx0XHR0aGlzLiNtc2cgPSBtc2c7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGluZGVudCBcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKGluZGVudCA9IFwiXCIpIHtcblx0XHRyZXR1cm4gXCJlcnJvcigpXCI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUlNjb3BlfSBzY29wZSBcblx0ICovXG5cdHJlc29sdmVOYW1lcyhzY29wZSkge1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJDYWxsU3RhY2t9IHN0YWNrXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRldmFsQ29uc3RhbnRzKHN0YWNrKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkNhbGxTdGFja30gc3RhY2tcblx0ICogQHJldHVybnMgez9JUlZhbHVlfVxuXHQgKi9cblx0ZXZhbChzdGFjaykge1xuXHRcdGlmIChzdGFjay50aHJvd1JURXJyb3JzKSB7XG5cdFx0XHR0aHJvdyB0aGlzLnNpdGUucnVudGltZUVycm9yKHRoaXMuI21zZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTGl0ZXJhbFJlZ2lzdHJ5fSBsaXRlcmFscyBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdHNpbXBsaWZ5TGl0ZXJhbHMobGl0ZXJhbHMpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSTmFtZUV4cHJSZWdpc3RyeX0gbmFtZUV4cHJzXG5cdCAqL1xuXHRyZWdpc3Rlck5hbWVFeHBycyhuYW1lRXhwcnMpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxJUlZhcmlhYmxlLCBJUlZhcmlhYmxlPn0gbmV3VmFycyBcblx0ICogQHJldHVybnMge0lSRXhwcn1cblx0ICovXG5cdGNvcHkobmV3VmFycykge1xuXHRcdHJldHVybiBuZXcgSVJFcnJvckNhbGxFeHByKHRoaXMuc2l0ZSwgdGhpcy4jbXNnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lSRXhwclJlZ2lzdHJ5fSByZWdpc3RyeVxuXHQgKiBAcmV0dXJucyB7SVJFeHByfVxuXHQgKi9cblx0c2ltcGxpZnlUb3BvbG9neShyZWdpc3RyeSkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtVcGxjVGVybX1cblx0ICovXG5cdHRvVXBsYygpIHtcblx0XHRyZXR1cm4gbmV3IFVwbGNFcnJvcih0aGlzLnNpdGUsIHRoaXMuI21zZyk7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDIyOiBJUiBBU1QgYnVpbGQgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQnVpbGQgYW4gSW50ZXJtZWRpYXRlIFJlcHJlc2VudGF0aW9uIGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7VG9rZW5bXX0gdHMgXG4gKiBAcmV0dXJucyB7SVJFeHByfVxuICogQHBhY2thZ2VcbiAqL1xuZnVuY3Rpb24gYnVpbGRJUkV4cHIodHMpIHtcblx0LyoqIEB0eXBlIHs/SVJFeHByfSAqL1xuXHRsZXQgZXhwciA9IG51bGw7XG5cblx0d2hpbGUgKHRzLmxlbmd0aCA+IDApIHtcblx0XHRsZXQgdCA9IHRzLnNoaWZ0KCk7XG5cblx0XHRpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodC5pc0dyb3VwKFwiKFwiKSAmJiB0cy5sZW5ndGggPiAwICYmIHRzWzBdLmlzU3ltYm9sKFwiLT5cIikpIHtcblx0XHRcdFx0YXNzZXJ0KGV4cHIgPT09IG51bGwpO1xuXG5cdFx0XHRcdHRzLnVuc2hpZnQodCk7XG5cblx0XHRcdFx0ZXhwciA9IGJ1aWxkSVJGdW5jRXhwcih0cyk7XG5cdFx0XHR9IGVsc2UgaWYgKHQuaXNHcm91cChcIihcIikpIHtcblx0XHRcdFx0bGV0IGdyb3VwID0gdC5hc3NlcnRHcm91cCgpO1xuXG5cdFx0XHRcdGlmIChleHByID09PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKGdyb3VwLmZpZWxkcy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0ZXhwciA9IGJ1aWxkSVJFeHByKGdyb3VwLmZpZWxkc1swXSlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGdyb3VwLmZpZWxkcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0ZXhwciA9IG5ldyBJUkxpdGVyYWxFeHByKG5ldyBVcGxjVW5pdCh0LnNpdGUpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z3JvdXAuc3ludGF4RXJyb3IoXCJ1bmV4cGVjdGVkIHBhcmVudGhlc2VzIHdpdGggbXVsdGlwbGUgZmllbGRzXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdFx0XHRcdGZvciAobGV0IGYgb2YgZ3JvdXAuZmllbGRzKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goYnVpbGRJUkV4cHIoZikpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChleHByIGluc3RhbmNlb2YgSVJOYW1lRXhwciAmJiBleHByLm5hbWUuc3RhcnRzV2l0aChcIl9fY29yZVwiKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFJUlNjb3BlLmlzQnVpbHRpbihleHByLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGV4cHIuc2l0ZS5yZWZlcmVuY2VFcnJvcihgYnVpbHRpbiAnJHtleHByLm5hbWV9JyB1bmRlZmluZWRgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXhwciA9IG5ldyBJUkNvcmVDYWxsRXhwcihuZXcgV29yZChleHByLnNpdGUsIGV4cHIubmFtZSksIGFyZ3MsIHQuc2l0ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGV4cHIgPSBJUlVzZXJDYWxsRXhwci5uZXcoZXhwciwgYXJncywgdC5zaXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodC5pc1N5bWJvbChcIi1cIikpIHtcblx0XHRcdFx0Ly8gb25seSBtYWtlcyBzZW5zZSBuZXh0IHRvIEludGVnZXJMaXRlcmFsc1xuXHRcdFx0XHRsZXQgaW50ID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKTtcblx0XHRcdFx0aWYgKGludCBpbnN0YW5jZW9mIEludExpdGVyYWwpIHtcblx0XHRcdFx0XHRleHByID0gbmV3IElSTGl0ZXJhbEV4cHIobmV3IFVwbGNJbnQoaW50LnNpdGUsIGludC52YWx1ZSAqICgtMW4pKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgaW50LnNpdGUudHlwZUVycm9yKGBleHBlY3RlZCBsaXRlcmFsIGludCwgZ290ICR7aW50fWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBCb29sTGl0ZXJhbCkge1xuXHRcdFx0XHRhc3NlcnQoZXhwciA9PT0gbnVsbCk7XG5cdFx0XHRcdGV4cHIgPSBuZXcgSVJMaXRlcmFsRXhwcihuZXcgVXBsY0Jvb2wodC5zaXRlLCB0LnZhbHVlKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHQgaW5zdGFuY2VvZiBJbnRMaXRlcmFsKSB7XG5cdFx0XHRcdGFzc2VydChleHByID09PSBudWxsKTtcblx0XHRcdFx0ZXhwciA9IG5ldyBJUkxpdGVyYWxFeHByKG5ldyBVcGxjSW50KHQuc2l0ZSwgdC52YWx1ZSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0IGluc3RhbmNlb2YgQnl0ZUFycmF5TGl0ZXJhbCkge1xuXHRcdFx0XHRhc3NlcnQoZXhwciA9PT0gbnVsbCk7XG5cdFx0XHRcdGlmICh0LmJ5dGVzLmxlbmd0aCA9PSAwICYmIHRzWzBdICE9IHVuZGVmaW5lZCAmJiB0c1swXSBpbnN0YW5jZW9mIEJ5dGVBcnJheUxpdGVyYWwpIHtcblx0XHRcdFx0XHQvLyBsaXRlcmFsIGRhdGEgaXMgIyM8Li4uPlxuXHRcdFx0XHRcdGNvbnN0IG5leHQgPSBhc3NlcnREZWZpbmVkKHRzLnNoaWZ0KCkpO1xuXG5cdFx0XHRcdFx0aWYgKG5leHQgaW5zdGFuY2VvZiBCeXRlQXJyYXlMaXRlcmFsKSB7XG5cdFx0XHRcdFx0XHRleHByID0gbmV3IElSTGl0ZXJhbEV4cHIobmV3IFVwbGNEYXRhVmFsdWUobmV4dC5zaXRlLCBVcGxjRGF0YS5mcm9tQ2JvcihuZXh0LmJ5dGVzKSkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRleHByID0gbmV3IElSTGl0ZXJhbEV4cHIobmV3IFVwbGNCeXRlQXJyYXkodC5zaXRlLCB0LmJ5dGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIFN0cmluZ0xpdGVyYWwpIHtcblx0XHRcdFx0YXNzZXJ0KGV4cHIgPT09IG51bGwpO1xuXHRcdFx0XHRleHByID0gbmV3IElSTGl0ZXJhbEV4cHIobmV3IFVwbGNTdHJpbmcodC5zaXRlLCB0LnZhbHVlKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHQuaXNXb3JkKFwiY29uc3RcIikpIHtcblx0XHRcdFx0YXNzZXJ0KGV4cHIgPT09IG51bGwpO1xuXG5cdFx0XHRcdGxldCBtYXliZUdyb3VwID0gdHMuc2hpZnQoKTtcblx0XHRcdFx0aWYgKG1heWJlR3JvdXAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IHQuc2l0ZS5zeW50YXhFcnJvcihcImV4cGVjdGVkIHBhcmVucyBhZnRlciBjb25zdFwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgcGFyZW5zID0gbWF5YmVHcm91cC5hc3NlcnRHcm91cChcIihcIiwgMSk7XG5cdFx0XHRcdFx0bGV0IHB0cyA9IHBhcmVucy5maWVsZHNbMF07XG5cblx0XHRcdFx0XHRleHByID0gbmV3IElSQ29uc3RFeHByKHQuc2l0ZSwgYnVpbGRJUkV4cHIocHRzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodC5pc1dvcmQoXCJlcnJvclwiKSkge1xuXHRcdFx0XHRhc3NlcnQoZXhwciA9PT0gbnVsbCk7XG5cblx0XHRcdFx0bGV0IG1heWJlR3JvdXAgPSB0cy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAobWF5YmVHcm91cCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgdC5zaXRlLnN5bnRheEVycm9yKFwiZXhwZWN0ZWQgcGFyZW5zIGFmdGVyIGVycm9yXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBwYXJlbnMgPSBtYXliZUdyb3VwLmFzc2VydEdyb3VwKFwiKFwiLCAxKTtcblx0XHRcdFx0XHRsZXQgcHRzID0gcGFyZW5zLmZpZWxkc1swXTtcblxuXHRcdFx0XHRcdGlmIChwdHMubGVuZ3RoICE9IDEpIHtcblx0XHRcdFx0XHRcdHRocm93IHBhcmVucy5zeW50YXhFcnJvcihcImVycm9yIGNhbGwgZXhwZWN0cyBhIHNpbmdsZSBsaXRlcmFsIHN0cmluZyBtc2cgYXJnXCIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBtc2cgPSBwdHNbMF07XG5cdFx0XHRcdFx0aWYgKCEobXNnIGluc3RhbmNlb2YgU3RyaW5nTGl0ZXJhbCkpIHtcblx0XHRcdFx0XHRcdHRocm93IG1zZy5zeW50YXhFcnJvcihcImVycm9yIGNhbGwgZXhwZWN0cyBsaXRlcmFsIHN0cmluZyBtc2cgYXJnXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRleHByID0gbmV3IElSRXJyb3JDYWxsRXhwcih0LnNpdGUsIG1zZy52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodC5pc1dvcmQoKSkge1xuXHRcdFx0XHRhc3NlcnQoZXhwciA9PT0gbnVsbCk7XG5cdFx0XHRcdGV4cHIgPSBuZXcgSVJOYW1lRXhwcih0LmFzc2VydFdvcmQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmhhbmRsZWQgdW50eXBlZCB0b2tlbiBcIiArIHQudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGV4cHIgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHByIGlzIG51bGxcIik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGV4cHI7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBJUiBmdW5jdGlvbiBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1Rva2VuW119IHRzIFxuICogQHJldHVybnMge0lSRnVuY0V4cHJ9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSVJGdW5jRXhwcih0cykge1xuXHRsZXQgbWF5YmVQYXJlbnMgPSB0cy5zaGlmdCgpO1xuXHRpZiAobWF5YmVQYXJlbnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImVtcHR5IGZ1bmMgZXhwclwiKTtcblx0fSBlbHNlIHtcblx0XHRsZXQgcGFyZW5zID0gbWF5YmVQYXJlbnMuYXNzZXJ0R3JvdXAoXCIoXCIpO1xuXG5cdFx0YXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRTeW1ib2woXCItPlwiKTtcblx0XHRsZXQgYnJhY2VzID0gYXNzZXJ0RGVmaW5lZCh0cy5zaGlmdCgpKS5hc3NlcnRHcm91cChcIntcIik7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V29yZFtdfVxuXHRcdCAqL1xuXHRcdGxldCBhcmdOYW1lcyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgZiBvZiBwYXJlbnMuZmllbGRzKSB7XG5cdFx0XHRhc3NlcnQoZi5sZW5ndGggPT0gMSwgXCJleHBlY3RlZCBzaW5nbGUgd29yZCBwZXIgYXJnXCIpO1xuXHRcdFx0YXJnTmFtZXMucHVzaChmWzBdLmFzc2VydFdvcmQoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGJyYWNlcy5maWVsZHMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhyb3cgYnJhY2VzLnN5bnRheEVycm9yKFwidW5leHBlY3RlZCBjb21tYSBpbiBmdW5jdGlvbiBib2R5XCIpXG5cdFx0fSBlbHNlIGlmIChicmFjZXMuZmllbGRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0aHJvdyBicmFjZXMuc3ludGF4RXJyb3IoXCJlbXB0eSBmdW5jdGlvbiBib2R5XCIpXG5cdFx0fVxuXG5cdFx0bGV0IGJvZHlFeHByID0gYnVpbGRJUkV4cHIoYnJhY2VzLmZpZWxkc1swXSk7XG5cblx0XHRyZXR1cm4gbmV3IElSRnVuY0V4cHIocGFyZW5zLnNpdGUsIGFyZ05hbWVzLm1hcChhID0+IG5ldyBJUlZhcmlhYmxlKGEpKSwgYm9keUV4cHIpXG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDIzOiBJUiBQcm9ncmFtXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLyoqXG4gKiBXcmFwcGVyIGZvciBJUkZ1bmNFeHByLCBJUkNhbGxFeHByIG9yIElSTGl0ZXJhbEV4cHJcbiAqIEBwYWNrYWdlXG4gKi9cbmNsYXNzIElSUHJvZ3JhbSB7XG5cdCNleHByO1xuXHQjcHVycG9zZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkZ1bmNFeHByIHwgSVJDYWxsRXhwciB8IElSTGl0ZXJhbEV4cHJ9IGV4cHJcblx0ICogQHBhcmFtIHs/bnVtYmVyfSBwdXJwb3NlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihleHByLCBwdXJwb3NlKSB7XG5cdFx0dGhpcy4jZXhwciA9IGV4cHI7XG5cdFx0dGhpcy4jcHVycG9zZSA9IHB1cnBvc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJUkV4cHJ9IGV4cHIgXG5cdCAqIEByZXR1cm5zIHtJUkZ1bmNFeHByIHwgSVJDYWxsRXhwciB8IElSTGl0ZXJhbEV4cHJ9XG5cdCAqL1xuXHRzdGF0aWMgYXNzZXJ0VmFsaWRSb290KGV4cHIpIHtcblx0XHRpZiAoZXhwciBpbnN0YW5jZW9mIElSRnVuY0V4cHIgfHwgZXhwciBpbnN0YW5jZW9mIElSQ2FsbEV4cHIgfHwgZXhwciBpbnN0YW5jZW9mIElSTGl0ZXJhbEV4cHIpIHtcblx0XHRcdHJldHVybiBleHByO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIElSRXhwciB0eXBlIGZvciBJUlByb2dyYW1cIik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7SVJ9IGlyIFxuXHQgKiBAcGFyYW0gez9udW1iZXJ9IHB1cnBvc2Vcblx0ICogQHBhcmFtIHtib29sZWFufSBzaW1wbGlmeVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRocm93U2ltcGxpZnlSVEVycm9ycyAtIGlmIHRydWUgLT4gdGhyb3cgUnVudGltRXJyb3JzIGNhdWdodCBkdXJpbmcgZXZhbHVhdGlvbiBzdGVwc1xuXHQgKiBAcGFyYW0ge0lSU2NvcGV9IHNjb3BlXG5cdCAqIEByZXR1cm5zIHtJUlByb2dyYW19XG5cdCAqL1xuXHRzdGF0aWMgbmV3KGlyLCBwdXJwb3NlLCBzaW1wbGlmeSA9IGZhbHNlLCB0aHJvd1NpbXBsaWZ5UlRFcnJvcnMgPSBmYWxzZSwgc2NvcGUgPSBuZXcgSVJTY29wZShudWxsLCBudWxsKSkge1xuXHRcdGxldCBbaXJTcmMsIGNvZGVNYXBdID0gaXIuZ2VuZXJhdGVTb3VyY2UoKTtcblxuXHRcdGxldCBpclRva2VucyA9IHRva2VuaXplSVIoaXJTcmMsIGNvZGVNYXApO1xuXG5cdFx0bGV0IGV4cHIgPSBidWlsZElSRXhwcihpclRva2Vucyk7XG5cdFxuXHRcdGV4cHIucmVzb2x2ZU5hbWVzKHNjb3BlKTtcblxuXHRcdGV4cHIgPSBleHByLmV2YWxDb25zdGFudHMobmV3IElSQ2FsbFN0YWNrKHRocm93U2ltcGxpZnlSVEVycm9ycykpO1xuXG5cdFx0aWYgKHNpbXBsaWZ5KSB7XG5cdFx0XHQvLyBpbmxpbmUgbGl0ZXJhbHMgYW5kIGV2YWx1YXRlIGNvcmUgZXhwcmVzc2lvbnMgd2l0aCBvbmx5IGxpdGVyYWwgYXJncyAoc29tZSBjYW4gYmUgZXZhbHVhdGVkIHdpdGggb25seSBwYXJ0aWFsIGxpdGVyYWwgYXJncylcblx0XHRcdGV4cHIgPSB0aGlzLnNpbXBsaWZ5KGV4cHIpO1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGRlYnJ1aWpuIGluZGljZXMgYXJlIGNvcnJlY3Rcblx0XHRcdGV4cHIucmVzb2x2ZU5hbWVzKHNjb3BlKTtcblx0XHR9XG5cblx0XHRjb25zdCBwcm9ncmFtID0gbmV3IElSUHJvZ3JhbShJUlByb2dyYW0uYXNzZXJ0VmFsaWRSb290KGV4cHIpLCBwdXJwb3NlKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SVJFeHByfSBleHByXG5cdCAqIEByZXR1cm5zIHtJUkV4cHJ9XG5cdCAqL1xuXHRzdGF0aWMgc2ltcGxpZnkoZXhwcikge1xuXHRcdGxldCBkaXJ0eSA9IHRydWU7XG5cdFx0bGV0IG9sZFN0YXRlID0gZXhwci50b1N0cmluZygpO1xuXG5cdFx0d2hpbGUgKGRpcnR5KSB7XG5cdFx0XHRkaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRleHByID0gZXhwci5zaW1wbGlmeUxpdGVyYWxzKG5ldyBNYXAoKSk7XG5cblx0XHRcdGNvbnN0IG5hbWVFeHBycyA9IG5ldyBJUk5hbWVFeHByUmVnaXN0cnkoKTtcblxuXHRcdFx0ZXhwci5yZWdpc3Rlck5hbWVFeHBycyhuYW1lRXhwcnMpO1xuXG5cdFx0XHRleHByID0gZXhwci5zaW1wbGlmeVRvcG9sb2d5KG5ldyBJUkV4cHJSZWdpc3RyeShuYW1lRXhwcnMpKTtcblxuXHRcdFx0Y29uc3QgbmV3U3RhdGUgPSBleHByLnRvU3RyaW5nKCk7XG5cblx0XHRcdGlmIChuZXdTdGF0ZSAhPSBvbGRTdGF0ZSkge1xuXHRcdFx0XHRkaXJ0eSA9IHRydWU7XG5cdFx0XHRcdG9sZFN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV4cHI7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge0lSRnVuY0V4cHIgfCBJUkNhbGxFeHByIHwgSVJMaXRlcmFsRXhwcn1cblx0ICovXG5cdGdldCBleHByKCkge1xuXHRcdHJldHVybiB0aGlzLiNleHByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEB0eXBlIHs/bnVtYmVyfVxuXHQgKi9cblx0Z2V0IHB1cnBvc2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3B1cnBvc2U7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHR5cGUge1NpdGV9XG5cdCAqL1xuXHRnZXQgc2l0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZXhwci5zaXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjRGF0YX1cblx0ICovXG5cdGdldCBkYXRhKCkge1xuXHRcdGlmICh0aGlzLiNleHByIGluc3RhbmNlb2YgSVJMaXRlcmFsRXhwcikge1xuXHRcdFx0bGV0IHYgPSB0aGlzLiNleHByLnZhbHVlO1xuXG5cdFx0XHRyZXR1cm4gdi5kYXRhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyh0aGlzLiNleHByLnRvU3RyaW5nKCkpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgZGF0YSBsaXRlcmFsXCIpO1xuXHRcdH1cblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiNleHByLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNQcm9ncmFtfVxuXHQgKi9cblx0dG9VcGxjKCkge1xuXHRcdHJldHVybiBuZXcgVXBsY1Byb2dyYW0odGhpcy4jZXhwci50b1VwbGMoKSwgdGhpcy4jcHVycG9zZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGNhbGNTaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnRvVXBsYygpLmNhbGNTaXplKCk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIElSUGFyYW1ldHJpY1Byb2dyYW0ge1xuXHQjaXJQcm9ncmFtO1xuXHQjcGFyYW1ldGVycztcblxuXHQvKipcblx0ICogQHBhcmFtIHtJUlByb2dyYW19IGlyUHJvZ3JhbVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbWV0ZXJzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihpclByb2dyYW0sIHBhcmFtZXRlcnMpIHtcblx0XHR0aGlzLiNpclByb2dyYW0gPSBpclByb2dyYW07XG5cdFx0dGhpcy4jcGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtJUn0gaXIgXG5cdCAqIEBwYXJhbSB7P251bWJlcn0gcHVycG9zZVxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbWV0ZXJzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltcGxpZnlcblx0ICogQHJldHVybnMge0lSUGFyYW1ldHJpY1Byb2dyYW19XG5cdCAqL1xuXHRzdGF0aWMgbmV3KGlyLCBwdXJwb3NlLCBwYXJhbWV0ZXJzLCBzaW1wbGlmeSA9IGZhbHNlKSB7XG5cdFx0bGV0IHNjb3BlID0gbmV3IElSU2NvcGUobnVsbCwgbnVsbCk7XG5cblx0XHRwYXJhbWV0ZXJzLmZvckVhY2goKHAsIGkpID0+IHtcblx0XHRcdGNvbnN0IGludGVybmFsTmFtZSA9IGBfX1BBUkFNXyR7aX1gO1xuXG5cdFx0XHRzY29wZSA9IG5ldyBJUlNjb3BlKHNjb3BlLCBuZXcgSVJWYXJpYWJsZShuZXcgV29yZChTaXRlLmR1bW15KCksIGludGVybmFsTmFtZSkpKTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IGlyUHJvZ3JhbSA9IElSUHJvZ3JhbS5uZXcoaXIsIHB1cnBvc2UsIHNpbXBsaWZ5LCBmYWxzZSwgc2NvcGUpO1xuXG5cdFx0cmV0dXJuIG5ldyBJUlBhcmFtZXRyaWNQcm9ncmFtKGlyUHJvZ3JhbSwgcGFyYW1ldGVycyk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1VwbGNQcm9ncmFtfVxuXHQgKi9cblx0dG9VcGxjKCkge1xuXHRcdGxldCBleHByVXBsYyA9IHRoaXMuI2lyUHJvZ3JhbS5leHByLnRvVXBsYygpO1xuXG5cdFx0dGhpcy4jcGFyYW1ldGVycy5mb3JFYWNoKHAgPT4ge1xuXHRcdFx0ZXhwclVwbGMgPSBuZXcgVXBsY0xhbWJkYShTaXRlLmR1bW15KCksIGV4cHJVcGxjLCBwKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXcgVXBsY1Byb2dyYW0oZXhwclVwbGMsIHRoaXMuI2lyUHJvZ3JhbS5wdXJwb3NlKTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMjQ6IEhlbGlvcyBwcm9ncmFtXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgTW9kdWxlIGlzIGEgY29sbGVjdGlvbiBvZiBzdGF0ZW1lbnRzXG4gKi9cbmNsYXNzIE1vZHVsZSB7XG5cdCNuYW1lO1xuXHQjc3RhdGVtZW50cztcblxuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1N0YXRlbWVudFtdfSBzdGF0ZW1lbnRzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihuYW1lLCBzdGF0ZW1lbnRzKSB7XG5cdFx0dGhpcy4jbmFtZSA9IG5hbWU7XG5cdFx0dGhpcy4jc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG5cblx0XHR0aGlzLiNzdGF0ZW1lbnRzLmZvckVhY2gocyA9PiBzLnNldEJhc2VQYXRoKGBfX21vZHVsZV9fJHt0aGlzLiNuYW1lLnRvU3RyaW5nKCl9YCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYXdTcmNcblx0ICogQHBhcmFtIHs/bnVtYmVyfSBmaWxlSW5kZXggLSBhIHVuaXF1ZSBvcHRpb25hbCBpbmRleCBwYXNzZWQgaW4gZnJvbSBvdXRzaWRlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gYXNzb2NpYXRlIGEgVXNlckVycm9yIHdpdGggYSBzcGVjaWZpYyBmaWxlXG5cdCAqIEByZXR1cm5zIHtNb2R1bGV9XG5cdCAqL1xuXHRzdGF0aWMgbmV3KHJhd1NyYywgZmlsZUluZGV4ID0gbnVsbCkge1xuXHRcdGNvbnN0IHNyYyA9IG5ldyBTb3VyY2UocmF3U3JjLCBmaWxlSW5kZXgpO1xuXG5cdFx0Y29uc3QgdHMgPSB0b2tlbml6ZShzcmMpO1xuXG5cdFx0c3JjLnRocm93RXJyb3JzKCk7XG5cblx0XHRpZiAodHMgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInNob3VsZCd2ZSBiZWVuIHRocm93biBhYm92ZVwiKTtcblx0XHR9XG5cblx0XHRpZiAodHMubGVuZ3RoID09IDApIHtcblx0XHRcdHRocm93IFVzZXJFcnJvci5zeW50YXhFcnJvcihzcmMsIDAsIDEsIFwiZW1wdHkgc2NyaXB0XCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IFtwdXJwb3NlLCBuYW1lLCBzdGF0ZW1lbnRzLCBtYWluSWR4XSA9IGJ1aWxkU2NyaXB0KHRzLCBTY3JpcHRQdXJwb3NlLk1vZHVsZSk7XG5cblx0XHRzcmMudGhyb3dFcnJvcnMoKTtcblxuXHRcdGlmIChuYW1lICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1vZHVsZShuYW1lLCBzdGF0ZW1lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTsgLy8gc2hvdWxkJ3ZlIGJlZW4gY2F1Z2h0IGJ5IGNhbGxpbmcgc3JjLnRocm93RXJyb3JzKCkgYWJvdmVcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1dvcmR9XG5cdCAqL1xuXHRnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jbmFtZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7U3RhdGVtZW50W119XG5cdCAqL1xuXHRnZXQgc3RhdGVtZW50cygpIHtcblx0XHRyZXR1cm4gdGhpcy4jc3RhdGVtZW50cy5zbGljZSgpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3N0YXRlbWVudHMubWFwKHMgPT4gcy50b1N0cmluZygpKS5qb2luKFwiXFxuXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TW9kdWxlU2NvcGV9IHNjb3BlIFxuXHQgKi9cblx0ZXZhbFR5cGVzKHNjb3BlKSB7XG5cdFx0Zm9yIChsZXQgcyBvZiB0aGlzLnN0YXRlbWVudHMpIHtcblx0XHRcdHMuZXZhbChzY29wZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFucyB0aGUgcHJvZ3JhbSBieSByZW1vdmluZyBldmVyeXRoaW5nIHRoYXQgaXMgdW5lY2Vzc2FyeSBmb3IgdGhlIHNtYXJ0IGNvbnRyYWN0IChlYXNpZXIgdG8gYXVkaXQpXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRjbGVhblNvdXJjZSgpIHtcblx0XHRsZXQgcmF3ID0gdGhpcy5uYW1lLnNpdGUuc3JjLnJhdztcblx0XHRsZXQgbiA9IHJhdy5sZW5ndGg7XG5cblx0XHRsZXQgbWFzayA9IG5ldyBVaW50OEFycmF5KG4pO1xuXG5cdFx0bWFzay5maWxsKDEpOyAvLyBoaWRlIHRoZSB1bnVzZWQgcGFydHMgYnkgc2V0dGluZyB0byAwXG5cblx0XHRmb3IgKGxldCBzIG9mIHRoaXMuI3N0YXRlbWVudHMpIHtcblx0XHRcdHMuaGlkZVVudXNlZChtYXNrKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGxldCBjaGFycyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdGxldCBjID0gcmF3LmNoYXJBdChpKTtcblxuXHRcdFx0aWYgKGMgPT0gJ1xcbicgfHwgYyA9PSAnICcpIHtcblx0XHRcdFx0Y2hhcnMucHVzaChjKTtcblx0XHRcdH0gZWxzZSBpZiAobWFza1tpXSA9PSAxKSB7XG5cdFx0XHRcdGNoYXJzLnB1c2goYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGFycy5wdXNoKCcgJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGxpbmVzID0gY2hhcnMuam9pbihcIlwiKS5zcGxpdChcIlxcblwiKS5tYXAobCA9PiB7XG5cdFx0XHRpZiAobC50cmltKCkubGVuZ3RoID09IDApIHtcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJlbW92ZSBtb3JlIHRoYW4gb25lIGNvbnNlY3V0aXZlIGVtcHR5IGxpbmVcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmdbXX1cblx0XHQgKi9cblx0XHRsZXQgcGFydHMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghKGkgPiAwICYmIGxpbmVzW2ktMV0ubGVuZ3RoID09IDAgJiYgbGluZXNbaV0ubGVuZ3RoID09IDApKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2gobGluZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbW9kdWxlIGNhbiBkZXBlbmQgb24gb3RoZXIgbW9kdWxlc1xuXHQgKiBUT0RPOiBkZXRlY3QgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cdCAqIEBwYXJhbSB7TW9kdWxlW119IG1vZHVsZXMgXG5cdCAqIEBwYXJhbSB7TW9kdWxlW119IHN0YWNrXG5cdCAqIEByZXR1cm5zIHtNb2R1bGVbXX1cblx0ICovXG5cdGZpbHRlckRlcGVuZGVuY2llcyhtb2R1bGVzLCBzdGFjayA9IFtdKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge01vZHVsZVtdfVxuXHRcdCAqL1xuXHRcdGxldCBkZXBzID0gW107XG5cblx0XHQvKiogQHR5cGUge01vZHVsZVtdfSAqL1xuXHRcdGxldCBuZXdTdGFjayA9IFt0aGlzXTtcblx0XHRuZXdTdGFjayA9IG5ld1N0YWNrLmNvbmNhdChzdGFjayk7XG5cblx0XHRmb3IgKGxldCBzIG9mIHRoaXMuI3N0YXRlbWVudHMpIHtcblx0XHRcdGlmIChzIGluc3RhbmNlb2YgSW1wb3J0U3RhdGVtZW50KSB7XG5cdFx0XHRcdGxldCBtbiA9IHMubW9kdWxlTmFtZS52YWx1ZTtcblxuXHRcdFx0XHRpZiAobW4gPT0gdGhpcy5uYW1lLnZhbHVlKSB7XG5cdFx0XHRcdFx0dGhyb3cgcy5zeW50YXhFcnJvcihcImNhbid0IGltcG9ydCBzZWxmXCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YWNrLnNvbWUoZCA9PiBkLm5hbWUudmFsdWUgPT0gbW4pKSB7XG5cdFx0XHRcdFx0dGhyb3cgcy5zeW50YXhFcnJvcihcImNpcmN1bGFyIGltcG9ydCBkZXRlY3RlZFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIGFscmVhZHkgaW4gZGVwcywgdGhlbiBkb24ndCBhZGQgKGJlY2F1c2UgaXQgd2lsbCBoYXZlIGJlZW4gYWRkZWQgYmVmb3JlIGFsb25nIHdpdGggYWxsIGl0cyBkZXBlbmRlbmNpZXMpXG5cdFx0XHRcdGlmICghZGVwcy5zb21lKGQgPT4gZC5uYW1lLnZhbHVlID09IG1uKSkge1xuXHRcdFx0XHRcdGxldCBtID0gbW9kdWxlcy5maW5kKG0gPT4gbS5uYW1lLnZhbHVlID09IG1uKTtcblxuXHRcdFx0XHRcdGlmIChtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRocm93IHMucmVmZXJlbmNlRXJyb3IoYG1vZHVsZSAnJHttbn0nIG5vdCBmb3VuZGApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IGFkZCBkZXBzIHRoYXQgd2VyZW4ndCBhZGRlZCBiZWZvcmVcblx0XHRcdFx0XHRcdGxldCBuZXdEZXBzID0gbS5maWx0ZXJEZXBlbmRlbmNpZXMobW9kdWxlcywgbmV3U3RhY2spLmNvbmNhdChbbV0pLmZpbHRlcihkID0+ICFkZXBzLnNvbWUoZF8gPT4gZF8ubmFtZS52YWx1ZSA9PSBkLm5hbWUudmFsdWUpKTtcblxuXHRcdFx0XHRcdFx0ZGVwcyA9IGRlcHMuY29uY2F0KG5ld0RlcHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBzO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGVudHJ5cG9pbnQgbW9kdWxlXG4gKi9cbmNsYXNzIE1haW5Nb2R1bGUgZXh0ZW5kcyBNb2R1bGUge1xuXHQvKipcblx0ICogQHBhcmFtIHtXb3JkfSBuYW1lIFxuXHQgKiBAcGFyYW0ge1N0YXRlbWVudFtdfSBzdGF0ZW1lbnRzIFxuXHQgKi9cblx0Y29uc3RydWN0b3IobmFtZSwgc3RhdGVtZW50cykge1xuXHRcdHN1cGVyKG5hbWUsIHN0YXRlbWVudHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtGdW5jU3RhdGVtZW50fVxuXHQgKi9cblx0Z2V0IG1haW5GdW5jKCkge1xuXHRcdGZvciAobGV0IHMgb2YgdGhpcy5zdGF0ZW1lbnRzKSB7XG5cdFx0XHRpZiAocy5uYW1lLnZhbHVlID09IFwibWFpblwiKSB7XG5cdFx0XHRcdGlmICghKHMgaW5zdGFuY2VvZiBGdW5jU3RhdGVtZW50KSkge1x0XG5cdFx0XHRcdFx0dGhyb3cgcy50eXBlRXJyb3IoXCInbWFpbicgaXNuJ3QgYSBmdW5jdGlvbiBzdGF0ZW1lbnRcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCInbWFpbicgbm90IGZvdW5kIChpcyBhIG1vZHVsZSBiZWluZyB1c2VkIGFzIGFuIGVudHJ5cG9pbnQ/KVwiKTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgSGVsaW9zRGF0YUNsYXNzPEhlbGlvc0RhdGE+Pn0gVXNlclR5cGVzXG4gKi9cblxuLyoqXG4gKiBIZWxpb3Mgcm9vdCBvYmplY3RcbiAqL1xuIGV4cG9ydCBjbGFzcyBQcm9ncmFtIHtcblx0I3B1cnBvc2U7XG5cdCNtb2R1bGVzO1xuXG5cdC8qKiBAdHlwZSB7VXNlclR5cGVzfSAqL1xuXHQjdHlwZXM7XG5cblx0LyoqXG5cdCAqIENhY2hlIG9mIGNvbnN0IHZhbHVlc1xuXHQgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEhlbGlvc0RhdGE+fVxuXHQgKi9cblx0I3BhcmFtZXRlcnM7XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHB1cnBvc2Vcblx0ICogQHBhcmFtIHtNb2R1bGVbXX0gbW9kdWxlc1xuXHQgKi9cblx0Y29uc3RydWN0b3IocHVycG9zZSwgbW9kdWxlcykge1xuXHRcdHRoaXMuI3B1cnBvc2UgPSBwdXJwb3NlO1xuXHRcdHRoaXMuI21vZHVsZXMgPSBtb2R1bGVzO1xuXHRcdHRoaXMuI3R5cGVzID0ge307XG5cdFx0dGhpcy4jcGFyYW1ldGVycyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByYXdTcmMgXG5cdCAqIEByZXR1cm5zIHtbcHVycG9zZSwgTW9kdWxlW11dfVxuXHQgKi9cblx0c3RhdGljIHBhcnNlTWFpbihyYXdTcmMpIHtcblx0XHRjb25zdCBzcmMgPSBuZXcgU291cmNlKHJhd1NyYywgMCk7XG5cblx0XHRjb25zdCB0cyA9IHRva2VuaXplKHNyYyk7XG5cblx0XHRzcmMudGhyb3dFcnJvcnMoKTtcblxuXHRcdGlmICh0cyA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic2hvdWxkJ3ZlIGJlZW4gdGhyb3duIGFib3ZlXCIpO1xuXHRcdH1cblxuXHRcdGlmICh0cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgVXNlckVycm9yLnN5bnRheEVycm9yKHNyYywgMCwgMSwgXCJlbXB0eSBzY3JpcHRcIik7XG5cdFx0fVxuXG5cdFx0Y29uc3QgW3B1cnBvc2UsIG5hbWUsIHN0YXRlbWVudHMsIG1haW5JZHhdID0gYnVpbGRTY3JpcHQodHMpO1xuXG5cdFx0c3JjLnRocm93RXJyb3JzKCk7XG5cblx0XHRpZiAocHVycG9zZSAhPT0gbnVsbCAmJiBuYW1lICE9PSBudWxsKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtNb2R1bGVbXX1cblx0XHRcdCAqL1xuXHRcdFx0Y29uc3QgbW9kdWxlcyA9IFtuZXcgTWFpbk1vZHVsZShuYW1lLCBzdGF0ZW1lbnRzLnNsaWNlKDAsIG1haW5JZHgrMSkpXTtcblxuXHRcdFx0aWYgKG1haW5JZHggPCBzdGF0ZW1lbnRzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0bW9kdWxlcy5wdXNoKG5ldyBNb2R1bGUobmFtZSwgc3RhdGVtZW50cy5zbGljZShtYWluSWR4KzEpKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBbcHVycG9zZSwgbW9kdWxlc107XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7IC8vIHNob3VsZCd2ZSBiZWVuIGNhdWdodCBieSBjYWxsaW5nIHNyYy50aHJvd0Vycm9ycygpIGFib3ZlXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWFpbk5hbWUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IG1vZHVsZVNyY3Ncblx0ICogQHJldHVybnMge01vZHVsZVtdfVxuXHQgKi9cblx0c3RhdGljIHBhcnNlSW1wb3J0cyhtYWluTmFtZSwgbW9kdWxlU3JjcyA9IFtdKSB7XG5cdFx0bGV0IGltcG9ydHMgPSBtb2R1bGVTcmNzLm1hcCgoc3JjLCBpKSA9PiBNb2R1bGUubmV3KHNyYywgaSsxKSk7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7U2V0PHN0cmluZz59XG5cdFx0ICovXG5cdFx0bGV0IG5hbWVzID0gbmV3IFNldCgpO1xuXG5cdFx0bmFtZXMuYWRkKG1haW5OYW1lKTtcblxuXHRcdGZvciAobGV0IG0gb2YgaW1wb3J0cykge1xuXHRcdFx0aWYgKG5hbWVzLmhhcyhtLm5hbWUudmFsdWUpKSB7XG5cdFx0XHRcdHRocm93IG0ubmFtZS5zeW50YXhFcnJvcihgbm9uLXVuaXF1ZSBtb2R1bGUgbmFtZSAnJHttLm5hbWUudmFsdWV9J2ApO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lcy5hZGQobS5uYW1lLnZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW1wb3J0cztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzICBhIG5ldyBwcm9ncmFtLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWFpblNyYyBcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gbW9kdWxlU3JjcyAtIG9wdGlvbmFsIHNvdXJjZXMgb2YgbW9kdWxlcywgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGltcG9ydHNcblx0ICogQHJldHVybnMge1Byb2dyYW19XG5cdCAqL1xuXHRzdGF0aWMgbmV3KG1haW5TcmMsIG1vZHVsZVNyY3MgPSBbXSkge1xuXHRcdGxldCBbcHVycG9zZSwgbW9kdWxlc10gPSBQcm9ncmFtLnBhcnNlTWFpbihtYWluU3JjKTtcblxuXHRcdGxldCBzaXRlID0gbW9kdWxlc1swXS5uYW1lLnNpdGU7XG5cblx0XHRsZXQgaW1wb3J0cyA9IFByb2dyYW0ucGFyc2VJbXBvcnRzKG1vZHVsZXNbMF0ubmFtZS52YWx1ZSwgbW9kdWxlU3Jjcyk7XG5cdFx0XG5cdFx0bGV0IG1haW5JbXBvcnRzID0gbW9kdWxlc1swXS5maWx0ZXJEZXBlbmRlbmNpZXMoaW1wb3J0cyk7XG5cblx0XHQvKiogQHR5cGUge01vZHVsZVtdfSAqL1xuXHRcdGxldCBwb3N0SW1wb3J0cyA9IFtdO1xuXG5cdFx0aWYgKG1vZHVsZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0cG9zdEltcG9ydHMgPSBtb2R1bGVzW21vZHVsZXMubGVuZ3RoIC0gMV0uZmlsdGVyRGVwZW5kZW5jaWVzKGltcG9ydHMpLmZpbHRlcihtID0+ICFtYWluSW1wb3J0cy5zb21lKGQgPT4gZC5uYW1lLnZhbHVlID09IG0ubmFtZS52YWx1ZSkpO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSB0aGUgZmluYWwgb3JkZXIgb2YgYWxsIHRoZSBtb2R1bGVzICh0aGlzIGlzIHRoZSBvcmRlciBpbiB3aGljaCBzdGF0ZW1lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIElSKVxuXHRcdG1vZHVsZXMgPSBtYWluSW1wb3J0cy5jb25jYXQoW21vZHVsZXNbMF1dKS5jb25jYXQocG9zdEltcG9ydHMpLmNvbmNhdChtb2R1bGVzLnNsaWNlKDEpKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1Byb2dyYW19XG5cdFx0ICovXG5cdFx0bGV0IHByb2dyYW07XG5cblx0XHRzd2l0Y2ggKHB1cnBvc2UpIHtcblx0XHRcdGNhc2UgU2NyaXB0UHVycG9zZS5UZXN0aW5nOlxuXHRcdFx0XHRwcm9ncmFtID0gbmV3IFRlc3RpbmdQcm9ncmFtKG1vZHVsZXMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU2NyaXB0UHVycG9zZS5TcGVuZGluZzpcblx0XHRcdFx0cHJvZ3JhbSA9IG5ldyBTcGVuZGluZ1Byb2dyYW0obW9kdWxlcyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTY3JpcHRQdXJwb3NlLk1pbnRpbmc6XG5cdFx0XHRcdHByb2dyYW0gPSBuZXcgTWludGluZ1Byb2dyYW0obW9kdWxlcyk7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIFNjcmlwdFB1cnBvc2UuU3Rha2luZzpcblx0XHRcdFx0cHJvZ3JhbSA9IG5ldyBTdGFraW5nUHJvZ3JhbShtb2R1bGVzKTtcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgU2NyaXB0UHVycG9zZS5Nb2R1bGU6XG5cdFx0XHRcdHRocm93IHNpdGUuc3ludGF4RXJyb3IoXCJjYW4ndCB1c2UgbW9kdWxlIGZvciBtYWluXCIpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkIHNjcmlwdCBwdXJwb3NlXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRvcFNjb3BlID0gcHJvZ3JhbS5ldmFsVHlwZXMoKTtcblxuXHRcdHByb2dyYW0uZmlsbFR5cGVzKHRvcFNjb3BlKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAdHlwZSB7TW9kdWxlW119IFxuXHQgKi9cblx0Z2V0IG1haW5JbXBvcnRlZE1vZHVsZXMoKSB7XG5cdFx0LyoqIEB0eXBlIHtNb2R1bGVbXX0gKi9cblx0XHRsZXQgbXMgPSBbXTtcblxuXHRcdGZvciAobGV0IG0gb2YgdGhpcy4jbW9kdWxlcykge1xuXHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBNYWluTW9kdWxlKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bXMucHVzaChtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbXM7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge01haW5Nb2R1bGV9XG5cdCAqL1xuXHRnZXQgbWFpbk1vZHVsZSgpIHtcblx0XHRmb3IgKGxldCBtIG9mIHRoaXMuI21vZHVsZXMpIHtcblx0XHRcdGlmIChtIGluc3RhbmNlb2YgTWFpbk1vZHVsZSkge1xuXHRcdFx0XHRyZXR1cm4gbTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNYWluTW9kdWxlIG5vdCBmb3VuZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7P01vZHVsZX1cblx0ICovXG5cdGdldCBwb3N0TW9kdWxlKCkge1xuXHRcdGxldCBtID0gdGhpcy4jbW9kdWxlc1t0aGlzLiNtb2R1bGVzLmxlbmd0aCAtIDFdO1xuXG5cdFx0aWYgKG0gaW5zdGFuY2VvZiBNYWluTW9kdWxlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5tYWluTW9kdWxlLm5hbWUudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge0Z1bmNTdGF0ZW1lbnR9XG5cdCAqL1xuXHRnZXQgbWFpbkZ1bmMoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFpbk1vZHVsZS5tYWluRnVuYztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IG1haW5QYXRoKCkge1xuXHRcdHJldHVybiB0aGlzLm1haW5GdW5jLnBhdGg7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1N0YXRlbWVudFtdfVxuXHQgKi9cblx0Z2V0IG1haW5TdGF0ZW1lbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLm1haW5Nb2R1bGUuc3RhdGVtZW50cztcblx0fVxuXG5cdC8qKlxuXHQgKiBOZWVkZWQgdG8gbGlzdCB0aGUgcGFyYW1UeXBlcywgYW5kIHRvIGNhbGwgY2hhbmdlUGFyYW1cblx0ICogQHR5cGUge1N0YXRlbWVudFtdfVxuXHQgKi9cblx0Z2V0IG1haW5BbmRQb3N0U3RhdGVtZW50cygpIHtcblx0XHRsZXQgc3RhdGVtZW50cyA9IHRoaXMubWFpbk1vZHVsZS5zdGF0ZW1lbnRzO1xuXG5cdFx0aWYgKHRoaXMucG9zdE1vZHVsZSAhPSBudWxsKSB7XG5cdFx0XHRzdGF0ZW1lbnRzID0gc3RhdGVtZW50cy5jb25jYXQodGhpcy5wb3N0TW9kdWxlLnN0YXRlbWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdGF0ZW1lbnRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtbU3RhdGVtZW50LCBib29sZWFuXVtdfSAtIGJvb2xlYW4gdmFsdWUgbWFya3MgaWYgc3RhdGVtZW50IGlzIGltcG9ydCBvciBub3Rcblx0ICovXG5cdGdldCBhbGxTdGF0ZW1lbnRzKCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtbU3RhdGVtZW50LCBib29sZWFuXVtdfVxuXHRcdCAqL1xuXHRcdGxldCBzdGF0ZW1lbnRzID0gW107XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBtID0gdGhpcy4jbW9kdWxlc1tpXTtcblxuXHRcdFx0bGV0IGlzSW1wb3J0ID0gIShtIGluc3RhbmNlb2YgTWFpbk1vZHVsZSB8fCAoaSA9PSB0aGlzLiNtb2R1bGVzLmxlbmd0aCAtIDEpKTtcblxuXHRcdFx0c3RhdGVtZW50cyA9IHN0YXRlbWVudHMuY29uY2F0KG0uc3RhdGVtZW50cy5tYXAocyA9PiBbcywgaXNJbXBvcnRdKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YXRlbWVudHM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLiNtb2R1bGVzLm1hcChtID0+IG0udG9TdHJpbmcoKSkuam9pbihcIlxcblwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7W3N0cmluZ1tdLCBzdHJpbmddfVxuXHQgKi9cblx0Y2xlYW5Tb3VyY2UoKSB7XG5cdFx0cmV0dXJuIFt0aGlzLm1haW5JbXBvcnRlZE1vZHVsZXMubWFwKG0gPT4gbS5jbGVhblNvdXJjZSgpKSwgdGhpcy5tYWluTW9kdWxlLmNsZWFuU291cmNlKCldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7R2xvYmFsU2NvcGV9IGdsb2JhbFNjb3BlXG5cdCAqIEByZXR1cm5zIHtUb3BTY29wZX1cblx0ICovXG5cdGV2YWxUeXBlc0ludGVybmFsKGdsb2JhbFNjb3BlKSB7XG5cdFx0Y29uc3QgdG9wU2NvcGUgPSBuZXcgVG9wU2NvcGUoZ2xvYmFsU2NvcGUpO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSBtb2R1bGVzXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG0gPSB0aGlzLiNtb2R1bGVzW2ldO1xuXG5cdFx0XHQvLyByZXVzZSBtYWluIE1vZHVsZVNjb3BlIGZvciBwb3N0IG1vZHVsZVxuXHRcdFx0Y29uc3QgbW9kdWxlU2NvcGUgPSAobSA9PT0gIHRoaXMucG9zdE1vZHVsZSkgPyB0b3BTY29wZS5nZXRNb2R1bGVTY29wZSh0aGlzLm1haW5Nb2R1bGUubmFtZSkgOiBuZXcgTW9kdWxlU2NvcGUodG9wU2NvcGUpO1xuXG5cdFx0XHRtLmV2YWxUeXBlcyhtb2R1bGVTY29wZSk7XG5cblx0XHRcdGlmIChtIGluc3RhbmNlb2YgTWFpbk1vZHVsZSkge1xuXHRcdFx0XHRnbG9iYWxTY29wZS5hbGxvd01hY3JvcygpO1xuXHRcdFx0XHR0b3BTY29wZS5zZXRTdHJpY3QoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobSAhPT0gdGhpcy5wb3N0TW9kdWxlKSB7XG5cdFx0XHRcdHRvcFNjb3BlLnNldChtLm5hbWUsIG1vZHVsZVNjb3BlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLm1haW5GdW5jLnVzZSgpO1xuXHRcdFxuXHRcdHJldHVybiB0b3BTY29wZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VG9wU2NvcGV9XG5cdCAqL1xuXHRldmFsVHlwZXMoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbmV0ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VzZXJUeXBlc31cblx0ICovXG5cdGdldCB0eXBlcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jdHlwZXM7XG5cdH1cblxuXHQvKipcblx0ICogRmlsbCAjdHlwZXMgd2l0aCBjb252ZW5pZW50IGphdmFzY3JpcHQgZXF1aXZhbGVudHMgb2YgSW50LCBCeXRlQXJyYXkgZXRjLlxuXHQgKiBAcGFyYW0ge1RvcFNjb3BlfSB0b3BTY29wZVxuXHQgKi9cblx0ZmlsbFR5cGVzKHRvcFNjb3BlKSB7XG5cdFx0Y29uc3QgbWFpbk1vZHVsZVNjb3BlID0gdG9wU2NvcGUuZ2V0TW9kdWxlU2NvcGUodGhpcy5tYWluTW9kdWxlLm5hbWUpO1xuXG5cdFx0bWFpbk1vZHVsZVNjb3BlLmxvb3BUeXBlcygobmFtZSwgdHlwZSkgPT4ge1xuXHRcdFx0aWYgKHR5cGUgaW5zdGFuY2VvZiBTdHJ1Y3RTdGF0ZW1lbnRUeXBlIHx8IHR5cGUgaW5zdGFuY2VvZiBFbnVtU3RhdGVtZW50VHlwZSkge1xuXHRcdFx0XHRpZiAobmFtZSBpbiB0aGlzLiN0eXBlcykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBkdXBsaWNhdGUgdHlwZSBuYW1lICR7bmFtZX0gaW4gbWFpbiBwcm9ncmFtIHNjb3BlYCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLiN0eXBlc1tuYW1lXSA9IHR5cGUudXNlclR5cGU7O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgVHlwZT59XG5cdCAqL1xuXHRnZXQgcGFyYW1UeXBlcygpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIFR5cGU+fVxuXHRcdCAqL1xuXHRcdGxldCByZXMgPSB7fTtcblxuXHRcdGZvciAobGV0IHMgb2YgdGhpcy5tYWluQW5kUG9zdFN0YXRlbWVudHMpIHtcblx0XHRcdGlmIChzIGluc3RhbmNlb2YgQ29uc3RTdGF0ZW1lbnQpIHtcblx0XHRcdFx0cmVzW3MubmFtZS52YWx1ZV0gPSBzLnR5cGU7XG5cdFx0XHR9IGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBJbXBvcnRTdGF0ZW1lbnQgJiYgcy5vcmlnU3RhdGVtZW50IGluc3RhbmNlb2YgQ29uc3RTdGF0ZW1lbnQpIHtcblx0XHRcdFx0cmVzW3MubmFtZS52YWx1ZV0gPSBzLm9yaWdTdGF0ZW1lbnQudHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgbGl0ZXJhbCB2YWx1ZSBvZiBhIGNvbnN0IHN0YXRlbWVudHMgIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBVcGxjVmFsdWV9IHZhbHVlIFxuXHQgKiBAcmV0dXJucyB7UHJvZ3JhbX0gLSByZXR1cm5zICd0aGlzJyBzbyB0aGF0IGNoYW5nZVBhcmFtIGNhbGxzIGNhbiBiZSBjaGFpbmVkXG5cdCAqL1xuXHRjaGFuZ2VQYXJhbShuYW1lLCB2YWx1ZSkge1xuXHRcdGRlcHJlY2F0aW9uV2FybmluZyhcInByb2dyYW0uY2hhbmdlUGFyYW1cIiwgXCIwLjE0LjBcIiwgXCJ1c2UgcHJvZ3JhbS5wYXJhbWV0ZXJzIGluc3RlYWRcIiwgXCJodHRwczovL3d3dy5oeXBlcmlvbi1idC5vcmcvaGVsaW9zLWJvb2svYXBpL3JlZmVyZW5jZS9wcm9ncmFtLmh0bWwjcGFyYW1ldGVycy0xXCIpO1xuXG5cdFx0Zm9yIChsZXQgcyBvZiB0aGlzLm1haW5BbmRQb3N0U3RhdGVtZW50cykge1xuXHRcdFx0aWYgKHMgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudCAmJiBzLm5hbWUudmFsdWUgPT0gbmFtZSkge1xuXHRcdFx0XHRzLmNoYW5nZVZhbHVlKHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBJbXBvcnRTdGF0ZW1lbnQgJiYgcy5uYW1lLnZhbHVlID09IG5hbWUgJiYgcy5vcmlnU3RhdGVtZW50IGluc3RhbmNlb2YgQ29uc3RTdGF0ZW1lbnQpIHtcblx0XHRcdFx0cy5vcmlnU3RhdGVtZW50LmNoYW5nZVZhbHVlKHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgdGhpcy5tYWluRnVuYy5yZWZlcmVuY2VFcnJvcihgcGFyYW0gJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgbGl0ZXJhbCB2YWx1ZSBvZiBhIGNvbnN0IHN0YXRlbWVudHMgIFxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YVxuXHQgKi9cblx0Y2hhbmdlUGFyYW1TYWZlKG5hbWUsIGRhdGEpIHtcblx0XHRmb3IgKGxldCBzIG9mIHRoaXMubWFpbkFuZFBvc3RTdGF0ZW1lbnRzKSB7XG5cdFx0XHRpZiAocyBpbnN0YW5jZW9mIENvbnN0U3RhdGVtZW50ICYmIHMubmFtZS52YWx1ZSA9PSBuYW1lKSB7XG5cdFx0XHRcdHMuY2hhbmdlVmFsdWVTYWZlKGRhdGEpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAocyBpbnN0YW5jZW9mIEltcG9ydFN0YXRlbWVudCAmJiBzLm5hbWUudmFsdWUgPT0gbmFtZSAmJiBzLm9yaWdTdGF0ZW1lbnQgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudCkge1xuXHRcdFx0XHRzLm9yaWdTdGF0ZW1lbnQuY2hhbmdlVmFsdWVTYWZlKGRhdGEpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyB0aGlzLm1haW5GdW5jLnJlZmVyZW5jZUVycm9yKGBwYXJhbSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG5cdH1cblxuXHQvKipcblx0ICogRG9lc24ndCB1c2Ugd3JhcEVudHJ5UG9pbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEByZXR1cm5zIHtVcGxjVmFsdWV9XG5cdCAqL1xuXHRldmFsUGFyYW0obmFtZSkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtNYXA8c3RyaW5nLCBJUj59XG5cdFx0ICovXG5cdFx0bGV0IG1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdC8qKiBAdHlwZSB7P0NvbnN0U3RhdGVtZW50fSAqL1xuXHRcdGxldCBjb25zdFN0YXRlbWVudCA9IG51bGw7XG5cblx0XHRmb3IgKGxldCBzIG9mIHRoaXMubWFpbkFuZFBvc3RTdGF0ZW1lbnRzKSB7XG5cdFx0XHRpZiAocyBpbnN0YW5jZW9mIEltcG9ydFN0YXRlbWVudCAmJiBzLm5hbWUudmFsdWUgPT0gbmFtZSAmJiBzLm9yaWdTdGF0ZW1lbnQgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudCkge1xuXHRcdFx0XHRjb25zdFN0YXRlbWVudCA9IHMub3JpZ1N0YXRlbWVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgW3MsIGlzSW1wb3J0XSBvZiB0aGlzLmFsbFN0YXRlbWVudHMpIHtcblx0XHRcdHMudG9JUihtYXApO1xuXHRcdFx0aWYgKHMgaW5zdGFuY2VvZiBDb25zdFN0YXRlbWVudCAmJiAoKHMubmFtZS52YWx1ZSA9PSBuYW1lICYmICFpc0ltcG9ydCkgfHwgcyA9PT0gY29uc3RTdGF0ZW1lbnQpKSB7XG5cdFx0XHRcdGNvbnN0U3RhdGVtZW50ID0gcztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbnN0U3RhdGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHBhcmFtICcke25hbWV9JyBub3QgZm91bmRgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHBhdGggPSBjb25zdFN0YXRlbWVudC5wYXRoO1xuXG5cdFx0XHRsZXQgaXIgPSBhc3NlcnREZWZpbmVkKG1hcC5nZXQocGF0aCkpO1xuXG5cdFx0XHRtYXAuZGVsZXRlKHBhdGgpO1xuXG5cdFx0XHRpciA9IHdyYXBXaXRoUmF3RnVuY3Rpb25zKElSLndyYXBXaXRoRGVmaW5pdGlvbnMoaXIsIG1hcCkpO1xuXG5cdFx0XHRsZXQgaXJQcm9ncmFtID0gSVJQcm9ncmFtLm5ldyhpciwgdGhpcy4jcHVycG9zZSwgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRcdHJldHVybiBuZXcgVXBsY0RhdGFWYWx1ZShpclByb2dyYW0uc2l0ZSwgaXJQcm9ncmFtLmRhdGEpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEFsdGVybmF0aXZlIHdheSB0byBnZXQgdGhlIHBhcmFtZXRlcnMgYXMgSGVsaW9zRGF0YSBpbnN0YW5jZXNcblx0ICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBIZWxpb3NEYXRhPn1cblx0ICovXG5cdGdldCBwYXJhbWV0ZXJzKCkge1xuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly8gbm90IGV4cGVuc2l2ZSwgc28gZG9lc24ndCBuZWVkIHRvIGJlIGV2YWx1YXRlZCBvbi1kZW1hbmRcblx0XHRjb25zdCB0eXBlcyA9IHRoaXMucGFyYW1UeXBlcztcblxuXHRcdGNvbnN0IGhhbmRsZXIgPSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybiBmcm9tIHRoaXMuI3BhcmFtZXRlcnMgaWYgYXZhaWxhYmxlLCBvciBjYWxjdWxhdGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEhlbGlvc0RhdGE+fSB0YXJnZXQgXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHRcdFx0ICogQHJldHVybnMgXG5cdFx0XHQgKi9cblx0XHRcdGdldCh0YXJnZXQsIG5hbWUpIHtcblx0XHRcdFx0aWYgKG5hbWUgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRhcmdldFtuYW1lXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXNzZXJ0RGVmaW5lZCh0eXBlc1tuYW1lXSwgYGludmFsaWQgcGFyYW0gbmFtZSAnJHtuYW1lfSdgKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCB1cGxjVmFsdWUgPSB0aGF0LmV2YWxQYXJhbShuYW1lKTtcblxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gKHVwbGNWYWx1ZSBpbnN0YW5jZW9mIFVwbGNCb29sKSA/IG5ldyBCb29sKHVwbGNWYWx1ZS5ib29sKSA6IHR5cGUudXNlclR5cGUuZnJvbVVwbGNEYXRhKHVwbGNWYWx1ZS5kYXRhKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0Ly8gVE9ETzogcmV0dXJuIFByb3h5IGluc3RlYWQ/XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRyZXR1cm4gbmV3IFByb3h5KHRoaXMuI3BhcmFtZXRlcnMsIGhhbmRsZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEhlbGlvc0RhdGEgfCBhbnk+fSB2YWx1ZXNcblx0ICovXG5cdHNldCBwYXJhbWV0ZXJzKHZhbHVlcykge1xuXHRcdGNvbnN0IHR5cGVzID0gdGhpcy5wYXJhbVR5cGVzO1xuXG5cdFx0Zm9yIChsZXQgbmFtZSBpbiB2YWx1ZXMpIHtcblx0XHRcdGNvbnN0IHJhd1ZhbHVlID0gdmFsdWVzW25hbWVdO1xuXG5cdFx0XHRjb25zdCBVc2VyVHlwZSA9IGFzc2VydERlZmluZWQodHlwZXNbbmFtZV0sIGBpbnZhbGlkIHBhcmFtIG5hbWUgJyR7bmFtZX0nYCkudXNlclR5cGU7XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gcmF3VmFsdWUgaW5zdGFuY2VvZiBVc2VyVHlwZSA/IHJhd1ZhbHVlIDogbmV3IFVzZXJUeXBlKHJhd1ZhbHVlKTtcblxuXHRcdFx0dGhpcy4jcGFyYW1ldGVyc1tuYW1lXSA9IHZhbHVlO1xuXG5cdFx0XHR0aGlzLmNoYW5nZVBhcmFtU2FmZShuYW1lLCB2YWx1ZS5fdG9VcGxjRGF0YSgpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtJUn0gaXJcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1ldGVyc1xuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR3cmFwRW50cnlQb2ludChpciwgcGFyYW1ldGVycykge1xuXHRcdC8vIGZpbmQgdGhlIGNvbnN0U3RhdGVtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHBhcmFtZXRlcnNcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7KENvbnN0U3RhdGVtZW50IHwgbnVsbClbXX1cblx0XHQgKi9cblx0XHRjb25zdCBwYXJhbWV0ZXJTdGF0ZW1lbnRzID0gbmV3IEFycmF5KHBhcmFtZXRlcnMubGVuZ3RoKS5maWxsKG51bGwpO1xuXG5cdFx0aWYgKHBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yIChsZXQgc3RhdGVtZW50IG9mIHRoaXMubWFpblN0YXRlbWVudHMpIHtcblx0XHRcdFx0aWYgKHN0YXRlbWVudCBpbnN0YW5jZW9mIENvbnN0U3RhdGVtZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgaSA9IHBhcmFtZXRlcnMuZmluZEluZGV4KHAgPT4gc3RhdGVtZW50Lm5hbWUudmFsdWUgPT0gcCk7XG5cblx0XHRcdFx0XHRpZiAoaSAhPSAtMSkge1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVyU3RhdGVtZW50c1tpXSA9IHN0YXRlbWVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGVtZW50IGluc3RhbmNlb2YgSW1wb3J0U3RhdGVtZW50ICYmIHN0YXRlbWVudC5vcmlnU3RhdGVtZW50IGluc3RhbmNlb2YgQ29uc3RTdGF0ZW1lbnQpIHtcblx0XHRcdFx0XHRjb25zdCBpID0gcGFyYW1ldGVycy5maW5kSW5kZXgocCA9PiBzdGF0ZW1lbnQubmFtZS52YWx1ZSA9PSBwKTtcblxuXHRcdFx0XHRcdGlmIChpICE9IC0xKSB7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJTdGF0ZW1lbnRzW2ldID0gc3RhdGVtZW50Lm9yaWdTdGF0ZW1lbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHBhcmFtZXRlcnMuZm9yRWFjaCgocCwgaSkgPT4ge1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyU3RhdGVtZW50c1tpXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwYXJhbWV0ZXIgJHtwfSBub3QgZm91bmQgKGhpbnQ6IG11c3QgY29tZSBiZWZvcmUgbWFpbilgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVx0XHRcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtNYXA8c3RyaW5nLCBJUj59XG5cdFx0ICovXG5cdFx0Y29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0Zm9yIChsZXQgW3N0YXRlbWVudCwgX10gb2YgdGhpcy5hbGxTdGF0ZW1lbnRzKSB7XG5cdFx0XHRpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwICYmIHN0YXRlbWVudCBpbnN0YW5jZW9mIENvbnN0U3RhdGVtZW50KSB7XG5cdFx0XHRcdGNvbnN0IGkgPSBwYXJhbWV0ZXJTdGF0ZW1lbnRzLmZpbmRJbmRleChjcyA9PiBjcyA9PT0gc3RhdGVtZW50KTtcblxuXHRcdFx0XHRpZiAoaSAhPSAtMSkge1xuXHRcdFx0XHRcdGxldCBpciA9IG5ldyBJUihgX19QQVJBTV8ke2l9YCk7XG5cblx0XHRcdFx0XHRpZiAoc3RhdGVtZW50LnR5cGUgaW5zdGFuY2VvZiBCb29sVHlwZSkge1xuXHRcdFx0XHRcdFx0aXIgPSBuZXcgSVIoW1xuXHRcdFx0XHRcdFx0XHRuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX191bkJvb2xEYXRhKFwiKSxcblx0XHRcdFx0XHRcdFx0aXIsXG5cdFx0XHRcdFx0XHRcdG5ldyBJUihcIilcIilcblx0XHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1hcC5zZXQoc3RhdGVtZW50LnBhdGgsIGlyKTsgXG5cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZW1lbnQudG9JUihtYXApO1xuXG5cdFx0XHRpZiAoc3RhdGVtZW50Lm5hbWUudmFsdWUgPT0gXCJtYWluXCIpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuIFxuXHRcdC8vIGJ1aWx0aW4gZnVuY3Rpb25zIGFyZSBhZGRlZCB3aGVuIHRoZSBJUiBwcm9ncmFtIGlzIGJ1aWx0XG5cdFx0Ly8gYWxzbyByZXBsYWNlIGFsbCB0YWJzIHdpdGggZm91ciBzcGFjZXNcblx0XHRyZXR1cm4gd3JhcFdpdGhSYXdGdW5jdGlvbnMoSVIud3JhcFdpdGhEZWZpbml0aW9ucyhpciwgbWFwKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gIHBhcmFtZXRlcnNcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihwYXJhbWV0ZXJzID0gW10pIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRwcmV0dHlJUihzaW1wbGlmeSA9IGZhbHNlKSB7XG5cdFx0Y29uc3QgaXIgPSB0aGlzLnRvSVIoW10pO1xuXG5cdFx0Y29uc3QgaXJQcm9ncmFtID0gSVJQcm9ncmFtLm5ldyhpciwgdGhpcy4jcHVycG9zZSwgc2ltcGxpZnkpO1xuXG5cdFx0cmV0dXJuIG5ldyBTb3VyY2UoaXJQcm9ncmFtLnRvU3RyaW5nKCkpLnByZXR0eSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltcGxpZnkgXG5cdCAqIEByZXR1cm5zIHtVcGxjUHJvZ3JhbX1cblx0ICovXG5cdGNvbXBpbGUoc2ltcGxpZnkgPSBmYWxzZSkge1xuXHRcdGNvbnN0IGlyID0gdGhpcy50b0lSKFtdKTtcblxuXHRcdGNvbnN0IGlyUHJvZ3JhbSA9IElSUHJvZ3JhbS5uZXcoaXIsIHRoaXMuI3B1cnBvc2UsIHNpbXBsaWZ5KTtcblx0XHRcblx0XHQvL2NvbnNvbGUubG9nKG5ldyBTb3VyY2UoaXJQcm9ncmFtLnRvU3RyaW5nKCkpLnByZXR0eSgpKTtcblx0XHRcblx0XHRyZXR1cm4gaXJQcm9ncmFtLnRvVXBsYygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbXBpbGUgYSBzcGVjaWFsIFVwbGNcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXBsaWZ5XG5cdCAqIEByZXR1cm5zIHtVcGxjUHJvZ3JhbX1cblx0ICovXG5cdGNvbXBpbGVQYXJhbWV0cmljKHBhcmFtZXRlcnMsIHNpbXBsaWZ5ID0gZmFsc2UpIHtcblx0XHRhc3NlcnQocGFyYW1ldGVycy5sZW5ndGggPiAwLCBcImV4cGVjdGVkIGF0IGxlYXN0IDEgcGFyYW1ldGVyIChoaW50OiB1c2UgcHJvZ3JhbS5jb21waWxlKCkgaW5zdGVhZClcIik7XG5cblx0XHRjb25zdCBpciA9IHRoaXMudG9JUihwYXJhbWV0ZXJzKTtcblxuXHRcdGNvbnN0IGlyUHJvZ3JhbSA9IElSUGFyYW1ldHJpY1Byb2dyYW0ubmV3KGlyLCB0aGlzLiNwdXJwb3NlLCBwYXJhbWV0ZXJzLCBzaW1wbGlmeSk7XG5cblx0XHQvLyBUT0RPOiBVcGxjUGFyYW1ldHJpY1Byb2dyYW1cblx0XHRyZXR1cm4gaXJQcm9ncmFtLnRvVXBsYygpO1xuXHR9XG59XG5cbmNsYXNzIFJlZGVlbWVyUHJvZ3JhbSBleHRlbmRzIFByb2dyYW0ge1xuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHB1cnBvc2Vcblx0ICogQHBhcmFtIHtNb2R1bGVbXX0gbW9kdWxlcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKHB1cnBvc2UsIG1vZHVsZXMpIHtcblx0XHRzdXBlcihwdXJwb3NlLCBtb2R1bGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge0dsb2JhbFNjb3BlfSBzY29wZVxuXHQgKiBAcmV0dXJucyB7VG9wU2NvcGV9XG5cdCAqL1xuXHRldmFsVHlwZXNJbnRlcm5hbChzY29wZSkge1xuXHRcdGNvbnN0IHRvcFNjb3BlID0gc3VwZXIuZXZhbFR5cGVzSW50ZXJuYWwoc2NvcGUpO1xuXG5cdFx0Ly8gY2hlY2sgdGhlICdtYWluJyBmdW5jdGlvblxuXG5cdFx0bGV0IG1haW4gPSB0aGlzLm1haW5GdW5jO1xuXHRcdGxldCBhcmdUeXBlTmFtZXMgPSBtYWluLmFyZ1R5cGVOYW1lcztcblx0XHRsZXQgcmV0VHlwZXMgPSBtYWluLnJldFR5cGVzO1xuXHRcdGxldCBoYXZlUmVkZWVtZXIgPSBmYWxzZTtcblx0XHRsZXQgaGF2ZVNjcmlwdENvbnRleHQgPSBmYWxzZTtcblx0XHRsZXQgaGF2ZVVuZGVyc2NvcmVzID0gYXJnVHlwZU5hbWVzLnNvbWUobmFtZSA9PiBuYW1lID09XCJcIik7XG5cblx0XHRpZiAoYXJnVHlwZU5hbWVzLmxlbmd0aCA+IDIpIHtcblx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBtYWluXCIpO1xuXHRcdH0gZWxzZSBpZiAoaGF2ZVVuZGVyc2NvcmVzKSB7XG5cdFx0XHQvLyBlbXB0eSB0eXBlIG5hbWUgY29tZXMgZnJvbSBhbiB1bmRlcnNjb3JlXG5cdFx0XHRhc3NlcnQoYXJnVHlwZU5hbWVzLmxlbmd0aCA9PSAyLCBcImV4cGVjdGVkIDIgYXJndW1lbnRzXCIpO1xuXHRcdH0gZWxzZSBpZiAoYXJnVHlwZU5hbWVzLmxlbmd0aCAhPSAyKSB7XG5cdFx0XHRkZXByZWNhdGlvbldhcm5pbmcoXCJtYWluIHdpdGggdmFyaWFibGUgYXJndW1lbnRzXCIsIFwiMC4xNC4wXCIsIFwidXNlIHVuZGVyc2NvcmVzIGluc3RlYWRcIiwgXCJodHRwczovL3d3dy5oeXBlcmlvbi1idC5vcmcvaGVsaW9zLWJvb2svbGFuZy9zY3JpcHQtc3RydWN0dXJlLmh0bWwjbWFpbi1mdW5jdGlvbi00XCIpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJnVHlwZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB0ID0gYXJnVHlwZU5hbWVzW2ldO1xuXG5cdFx0XHRpZiAodCA9PSBcIlwiKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gXCJSZWRlZW1lclwiKSB7XG5cdFx0XHRcdGlmIChoYXZlVW5kZXJzY29yZXMgJiYgaSAhPSAwKSB7XG5cdFx0XHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoYHVuZXhwZWN0ZWQgUmVkZWVtZXIgdHlwZSBmb3IgYXJnICR7aX0gb2YgbWFpbmApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhhdmVSZWRlZW1lcikge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGBkdXBsaWNhdGUgJ1JlZGVlbWVyJyBhcmd1bWVudGApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGhhdmVTY3JpcHRDb250ZXh0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoYCdSZWRlZW1lcicgbXVzdCBjb21lIGJlZm9yZSAnU2NyaXB0Q29udGV4dCdgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoYXZlUmVkZWVtZXIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gXCJTY3JpcHRDb250ZXh0XCIpIHtcblx0XHRcdFx0aWYgKGhhdmVVbmRlcnNjb3JlcyAmJiBpICE9IDEpIHtcblx0XHRcdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihgdW5leHBlY3RlZCBTY3JpcHRDb250ZXh0IHR5cGUgZm9yIGFyZyAke2l9IG9mIG1haW5gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYXZlU2NyaXB0Q29udGV4dCkge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGBkdXBsaWNhdGUgJ1NjcmlwdENvbnRleHQnIGFyZ3VtZW50YCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGF2ZVNjcmlwdENvbnRleHQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihgaWxsZWdhbCBhcmd1bWVudCB0eXBlLCBtdXN0IGJlICdSZWRlZW1lcicgb3IgJ1NjcmlwdENvbnRleHQnLCBnb3QgJyR7dH0nYCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJldFR5cGVzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoYGlsbGVnYWwgbnVtYmVyIG9mIHJldHVybiB2YWx1ZXMgZm9yIG1haW4sIGV4cGVjdGVkIDEsIGdvdCAke3JldFR5cGVzLmxlbmd0aH1gKTtcblx0XHR9IGVsc2UgaWYgKCEocmV0VHlwZXNbMF0gaW5zdGFuY2VvZiBCb29sVHlwZSkpIHtcblx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGBpbGxlZ2FsIHJldHVybiB0eXBlIGZvciBtYWluLCBleHBlY3RlZCAnQm9vbCcsIGdvdCAnJHtyZXRUeXBlc1swXS50b1N0cmluZygpfSdgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdG9wU2NvcGU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1ldGVyc1xuXHQgKiBAcmV0dXJucyB7SVJ9IFxuXHQgKi9cblx0dG9JUihwYXJhbWV0ZXJzID0gW10pIHtcblx0XHQvKiogQHR5cGUge0lSW119ICovXG5cdFx0Y29uc3Qgb3V0ZXJBcmdzID0gW107XG5cblx0XHQvKiogQHR5cGUge0lSW119ICovXG5cdFx0Y29uc3QgaW5uZXJBcmdzID0gW107XG5cblx0XHRmb3IgKGxldCB0IG9mIHRoaXMubWFpbkZ1bmMuYXJnVHlwZU5hbWVzKSB7XG5cdFx0XHRpZiAodCA9PSBcIlJlZGVlbWVyXCIpIHtcblx0XHRcdFx0aW5uZXJBcmdzLnB1c2gobmV3IElSKFwicmVkZWVtZXJcIikpO1xuXHRcdFx0XHRvdXRlckFyZ3MucHVzaChuZXcgSVIoXCJyZWRlZW1lclwiKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gXCJTY3JpcHRDb250ZXh0XCIpIHtcblx0XHRcdFx0aW5uZXJBcmdzLnB1c2gobmV3IElSKFwiY3R4XCIpKTtcblx0XHRcdFx0aWYgKG91dGVyQXJncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcIl9cIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcImN0eFwiKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gXCJcIikge1xuXHRcdFx0XHRpbm5lckFyZ3MucHVzaChuZXcgSVIoXCIwXCIpKTsgLy8gdXNlIGEgbGl0ZXJhbCB0byBtYWtlIGxpZmUgZWFzaWVyIGZvciB0aGUgb3B0aW1pemVyXG5cdFx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcIl9cIikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZShvdXRlckFyZ3MubGVuZ3RoIDwgMikge1xuXHRcdFx0b3V0ZXJBcmdzLnB1c2gobmV3IElSKFwiX1wiKSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXIgPSBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKGAke1RBQn0vKmVudHJ5IHBvaW50Ki9cXG4ke1RBQn0oYCksXG5cdFx0XHRuZXcgSVIob3V0ZXJBcmdzKS5qb2luKFwiLCBcIiksXG5cdFx0XHRuZXcgSVIoYCkgLT4ge1xcbiR7VEFCfSR7VEFCfWApLFxuXHRcdFx0bmV3IElSKGBfX2NvcmVfX2lmVGhlbkVsc2UoXFxuJHtUQUJ9JHtUQUJ9JHtUQUJ9JHt0aGlzLm1haW5QYXRofShgKSxcblx0XHRcdG5ldyBJUihpbm5lckFyZ3MpLmpvaW4oXCIsIFwiKSxcblx0XHRcdG5ldyBJUihgKSxcXG4ke1RBQn0ke1RBQn0ke1RBQn0oKSAtPiB7KCl9LFxcbiR7VEFCfSR7VEFCfSR7VEFCfSgpIC0+IHtlcnJvcihcInRyYW5zYWN0aW9uIHJlamVjdGVkXCIpfVxcbiR7VEFCfSR7VEFCfSkoKWApLFxuXHRcdFx0bmV3IElSKGBcXG4ke1RBQn19YCksXG5cdFx0XSk7XG5cblx0XHRyZXR1cm4gdGhpcy53cmFwRW50cnlQb2ludChpciwgcGFyYW1ldGVycyk7XG5cdH1cbn1cblxuY2xhc3MgRGF0dW1SZWRlZW1lclByb2dyYW0gZXh0ZW5kcyBQcm9ncmFtIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwdXJwb3NlXG5cdCAqIEBwYXJhbSB7TW9kdWxlW119IG1vZHVsZXNcblx0ICovXG5cdGNvbnN0cnVjdG9yKHB1cnBvc2UsIG1vZHVsZXMpIHtcblx0XHRzdXBlcihwdXJwb3NlLCBtb2R1bGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcGFyYW0ge0dsb2JhbFNjb3BlfSBzY29wZSBcblx0ICogQHJldHVybnMge1RvcFNjb3BlfVxuXHQgKi9cblx0ZXZhbFR5cGVzSW50ZXJuYWwoc2NvcGUpIHtcblx0XHRjb25zdCB0b3BTY29wZSA9IHN1cGVyLmV2YWxUeXBlc0ludGVybmFsKHNjb3BlKTtcblxuXHRcdC8vIGNoZWNrIHRoZSAnbWFpbicgZnVuY3Rpb25cblxuXHRcdGNvbnN0IG1haW4gPSB0aGlzLm1haW5GdW5jO1xuXHRcdGNvbnN0IGFyZ1R5cGVOYW1lcyA9IG1haW4uYXJnVHlwZU5hbWVzO1xuXHRcdGNvbnN0IHJldFR5cGVzID0gbWFpbi5yZXRUeXBlcztcblx0XHRjb25zdCBoYXZlVW5kZXJzY29yZXMgPSBhcmdUeXBlTmFtZXMuc29tZShuYW1lID0+IG5hbWUgPT0gXCJcIik7XG5cdFx0bGV0IGhhdmVEYXR1bSA9IGZhbHNlO1xuXHRcdGxldCBoYXZlUmVkZWVtZXIgPSBmYWxzZTtcblx0XHRsZXQgaGF2ZVNjcmlwdENvbnRleHQgPSBmYWxzZTtcblxuXHRcdGlmIChhcmdUeXBlTmFtZXMubGVuZ3RoID4gMykge1xuXHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHMgZm9yIG1haW5cIik7XG5cdFx0fSBlbHNlIGlmIChoYXZlVW5kZXJzY29yZXMpIHtcblx0XHRcdGFzc2VydChhcmdUeXBlTmFtZXMubGVuZ3RoID09IDMsIFwiZXhwZWN0ZWQgMyBhcmdzXCIpO1xuXHRcdH0gZWxzZSBpZiAoYXJnVHlwZU5hbWVzLmxlbmd0aCAhPSAzKSB7XG5cdFx0XHRkZXByZWNhdGlvbldhcm5pbmcoXCJtYWluIHdpdGggdmFyaWFibGUgYXJndW1lbnRzXCIsIFwiMC4xNC4wXCIsIFwidXNlIHVuZGVyc2NvcmVzIGluc3RlYWRcIiwgXCJodHRwczovL3d3dy5oeXBlcmlvbi1idC5vcmcvaGVsaW9zLWJvb2svbGFuZy9zY3JpcHQtc3RydWN0dXJlLmh0bWwjbWFpbi1mdW5jdGlvbi00XCIpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJnVHlwZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB0ID0gYXJnVHlwZU5hbWVzW2ldO1xuXG5cdFx0XHRpZiAodCA9PSBcIlwiKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmICh0ID09IFwiRGF0dW1cIikge1xuXHRcdFx0XHRpZiAoaGF2ZVVuZGVyc2NvcmVzICYmIGkgIT0gMCkge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGB1bmV4cGVjdGVkIERhdHVtIHR5cGUgZm9yIGFyZyAke2l9IG9mIG1haW5gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYXZlRGF0dW0pIHtcblx0XHRcdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihcImR1cGxpY2F0ZSAnRGF0dW0nIGFyZ3VtZW50XCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGhhdmVSZWRlZW1lcikge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKFwiJ0RhdHVtJyBtdXN0IGNvbWUgYmVmb3JlICdSZWRlZW1lcidcIik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaGF2ZVNjcmlwdENvbnRleHQpIHtcblx0XHRcdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihcIidEYXR1bScgbXVzdCBjb21lIGJlZm9yZSAnU2NyaXB0Q29udGV4dCdcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGF2ZURhdHVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0ID09IFwiUmVkZWVtZXJcIikge1xuXHRcdFx0XHRpZiAoaGF2ZVVuZGVyc2NvcmVzICYmIGkgIT0gMSkge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGB1bmV4cGVjdGVkIFJlZGVlbWVyIHR5cGUgZm9yIGFyZyAke2l9IG9mIG1haW5gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYXZlUmVkZWVtZXIpIHtcblx0XHRcdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihcImR1cGxpY2F0ZSAnUmVkZWVtZXInIGFyZ3VtZW50XCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGhhdmVTY3JpcHRDb250ZXh0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoXCInUmVkZWVtZXInIG11c3QgY29tZSBiZWZvcmUgJ1NjcmlwdENvbnRleHQnXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhhdmVSZWRlZW1lciA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodCA9PSBcIlNjcmlwdENvbnRleHRcIikge1xuXHRcdFx0XHRpZiAoaGF2ZVVuZGVyc2NvcmVzICYmIGkgIT0gMikge1xuXHRcdFx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGB1bmV4cGVjdGVkIFNjcmlwdENvbnRleHQgdHlwZSBmb3IgYXJnICR7aX0gb2YgbWFpbmApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhhdmVTY3JpcHRDb250ZXh0KSB7XG5cdFx0XHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoXCJkdXBsaWNhdGUgJ1NjcmlwdENvbnRleHQnIGFyZ3VtZW50XCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhhdmVTY3JpcHRDb250ZXh0ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbWFpbi50eXBlRXJyb3IoYGlsbGVnYWwgYXJndW1lbnQgdHlwZSwgbXVzdCBiZSAnRGF0dW0nLCAnUmVkZWVtZXInIG9yICdTY3JpcHRDb250ZXh0JywgZ290ICcke3R9J2ApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXRUeXBlcy5sZW5ndGggIT09IDEpIHtcblx0XHRcdHRocm93IG1haW4udHlwZUVycm9yKGBpbGxlZ2FsIG51bWJlciBvZiByZXR1cm4gdmFsdWVzIGZvciBtYWluLCBleHBlY3RlZCAxLCBnb3QgJHtyZXRUeXBlcy5sZW5ndGh9YCk7XG5cdFx0fSBlbHNlIGlmICghKHJldFR5cGVzWzBdIGluc3RhbmNlb2YgQm9vbFR5cGUpKSB7XG5cdFx0XHR0aHJvdyBtYWluLnR5cGVFcnJvcihgaWxsZWdhbCByZXR1cm4gdHlwZSBmb3IgbWFpbiwgZXhwZWN0ZWQgJ0Jvb2wnLCBnb3QgJyR7cmV0VHlwZXNbMF0udG9TdHJpbmcoKX0nYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvcFNjb3BlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtZXRlcnNcblx0ICogQHJldHVybnMge0lSfVxuXHQgKi9cblx0dG9JUihwYXJhbWV0ZXJzID0gW10pIHtcblx0XHQvKiogQHR5cGUge0lSW119ICovXG5cdFx0Y29uc3Qgb3V0ZXJBcmdzID0gW107XG5cblx0XHQvKiogQHR5cGUge0lSW119ICovXG5cdFx0Y29uc3QgaW5uZXJBcmdzID0gW107XG5cblx0XHRmb3IgKGxldCB0IG9mIHRoaXMubWFpbkZ1bmMuYXJnVHlwZU5hbWVzKSB7XG5cdFx0XHRpZiAodCA9PSBcIkRhdHVtXCIpIHtcblx0XHRcdFx0aW5uZXJBcmdzLnB1c2gobmV3IElSKFwiZGF0dW1cIikpO1xuXHRcdFx0XHRvdXRlckFyZ3MucHVzaChuZXcgSVIoXCJkYXR1bVwiKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gXCJSZWRlZW1lclwiKSB7XG5cdFx0XHRcdGlubmVyQXJncy5wdXNoKG5ldyBJUihcInJlZGVlbWVyXCIpKTtcblx0XHRcdFx0aWYgKG91dGVyQXJncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcIl9cIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcInJlZGVlbWVyXCIpKTtcblx0XHRcdH0gZWxzZSBpZiAodCA9PSBcIlNjcmlwdENvbnRleHRcIikge1xuXHRcdFx0XHRpbm5lckFyZ3MucHVzaChuZXcgSVIoXCJjdHhcIikpO1xuXHRcdFx0XHR3aGlsZSAob3V0ZXJBcmdzLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0XHRvdXRlckFyZ3MucHVzaChuZXcgSVIoXCJfXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvdXRlckFyZ3MucHVzaChuZXcgSVIoXCJjdHhcIikpO1xuXHRcdFx0fSBlbHNlIGlmICh0ID09IFwiXCIpIHtcblx0XHRcdFx0aW5uZXJBcmdzLnB1c2gobmV3IElSKFwiMFwiKSk7IC8vIHVzZSBhIGxpdGVyYWwgdG8gbWFrZSBsaWZlIGVhc2llciBmb3IgdGhlIG9wdGltaXplclxuXHRcdFx0XHRvdXRlckFyZ3MucHVzaChuZXcgSVIoXCJfXCIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUob3V0ZXJBcmdzLmxlbmd0aCA8IDMpIHtcblx0XHRcdG91dGVyQXJncy5wdXNoKG5ldyBJUihcIl9cIikpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlyID0gbmV3IElSKFtcblx0XHRcdG5ldyBJUihgJHtUQUJ9LyplbnRyeSBwb2ludCovXFxuJHtUQUJ9KGApLFxuXHRcdFx0bmV3IElSKG91dGVyQXJncykuam9pbihcIiwgXCIpLFxuXHRcdFx0bmV3IElSKGApIC0+IHtcXG4ke1RBQn0ke1RBQn1gKSxcblx0XHRcdG5ldyBJUihgX19jb3JlX19pZlRoZW5FbHNlKFxcbiR7VEFCfSR7VEFCfSR7VEFCfSR7dGhpcy5tYWluUGF0aH0oYCksXG5cdFx0XHRuZXcgSVIoaW5uZXJBcmdzKS5qb2luKFwiLCBcIiksXG5cdFx0XHRuZXcgSVIoYCksXFxuJHtUQUJ9JHtUQUJ9JHtUQUJ9KCkgLT4geygpfSxcXG4ke1RBQn0ke1RBQn0ke1RBQn0oKSAtPiB7ZXJyb3IoXCJ0cmFuc2FjdGlvbiByZWplY3RlZFwiKX1cXG4ke1RBQn0ke1RBQn0pKClgKSxcblx0XHRcdG5ldyBJUihgXFxuJHtUQUJ9fWApLFxuXHRcdF0pO1xuXG5cdFx0cmV0dXJuIHRoaXMud3JhcEVudHJ5UG9pbnQoaXIsIHBhcmFtZXRlcnMpO1xuXHR9XG59XG5cbmNsYXNzIFRlc3RpbmdQcm9ncmFtIGV4dGVuZHMgUHJvZ3JhbSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge01vZHVsZVtdfSBtb2R1bGVzIFxuXHQgKi9cblx0Y29uc3RydWN0b3IobW9kdWxlcykge1xuXHRcdHN1cGVyKFNjcmlwdFB1cnBvc2UuVGVzdGluZywgbW9kdWxlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiBgdGVzdGluZyAke3RoaXMubmFtZX1cXG4ke3N1cGVyLnRvU3RyaW5nKCl9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFja2FnZVxuXHQgKiBAcmV0dXJucyB7VG9wU2NvcGV9XG5cdCAqL1xuXHRldmFsVHlwZXMoKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSBHbG9iYWxTY29wZS5uZXcoU2NyaXB0UHVycG9zZS5UZXN0aW5nKTtcblxuXHRcdGNvbnN0IHRvcFNjb3BlID0gdGhpcy5ldmFsVHlwZXNJbnRlcm5hbChzY29wZSk7XG5cblx0XHQvLyBtYWluIGNhbiBoYXZlIGFueSBhcmcgdHlwZXMsIGFuZCBhbnkgcmV0dXJuIHR5cGUgXG5cblx0XHRpZiAodGhpcy5tYWluRnVuYy5yZXRUeXBlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aHJvdyB0aGlzLm1haW5GdW5jLnR5cGVFcnJvcihcInByb2dyYW0gZW50cnktcG9pbnQgY2FuIG9ubHkgcmV0dXJuIG9uZSB2YWx1ZVwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdG9wU2NvcGU7XG5cdH1cblxuXHQvKipcblx0ICogQHBhY2thZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1ldGVyc1xuXHQgKiBAcmV0dXJucyB7SVJ9XG5cdCAqL1xuXHR0b0lSKHBhcmFtZXRlcnMgPSBbXSkge1xuXHRcdGNvbnN0IGlubmVyQXJncyA9IHRoaXMubWFpbkZ1bmMuYXJnVHlwZXMubWFwKCh0LCBpKSA9PiB7XG5cdFx0XHRpZiAodCBpbnN0YW5jZW9mIEJvb2xUeXBlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSVIoYF9faGVsaW9zX19jb21tb25fX3VuQm9vbERhdGEoYXJnJHtpfSlgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBuZXcgSVIoYGFyZyR7aX1gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGxldCBpciA9IG5ldyBJUihbXG5cdFx0XHRuZXcgSVIoYCR7dGhpcy5tYWluUGF0aH0oYCksXG5cdFx0XHRuZXcgSVIoaW5uZXJBcmdzKS5qb2luKFwiLCBcIiksXG5cdFx0XHRuZXcgSVIoXCIpXCIpLFxuXHRcdF0pO1xuXG5cdFx0aWYgKHRoaXMubWFpbkZ1bmMucmV0VHlwZXNbMF0gaW5zdGFuY2VvZiBCb29sVHlwZSkge1xuXHRcdFx0aXIgPSBuZXcgSVIoW1xuXHRcdFx0XHRuZXcgSVIoXCJfX2hlbGlvc19fY29tbW9uX19ib29sRGF0YShcIiksXG5cdFx0XHRcdGlyLFxuXHRcdFx0XHRuZXcgSVIoXCIpXCIpXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHRjb25zdCBvdXRlckFyZ3MgPSB0aGlzLm1haW5GdW5jLmFyZ1R5cGVzLm1hcCgoXywgaSkgPT4gbmV3IElSKGBhcmcke2l9YCkpO1xuXG5cdFx0aXIgPSBuZXcgSVIoW1xuXHRcdFx0bmV3IElSKGAke1RBQn0vKmVudHJ5IHBvaW50Ki9cXG4ke1RBQn0oYCksXG5cdFx0XHRuZXcgSVIob3V0ZXJBcmdzKS5qb2luKFwiLCBcIiksXG5cdFx0XHRuZXcgSVIoYCkgLT4ge1xcbiR7VEFCfSR7VEFCfWApLFxuXHRcdFx0aXIsXG5cdFx0XHRuZXcgSVIoYFxcbiR7VEFCfX1gKSxcblx0XHRdKTtcblxuXHRcdHJldHVybiB0aGlzLndyYXBFbnRyeVBvaW50KGlyLCBwYXJhbWV0ZXJzKTtcblx0fVxufVxuXG5jbGFzcyBTcGVuZGluZ1Byb2dyYW0gZXh0ZW5kcyBEYXR1bVJlZGVlbWVyUHJvZ3JhbSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge01vZHVsZVtdfSBtb2R1bGVzXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihtb2R1bGVzKSB7XG5cdFx0c3VwZXIoU2NyaXB0UHVycG9zZS5TcGVuZGluZywgbW9kdWxlcyk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gYHNwZW5kaW5nICR7dGhpcy5uYW1lfVxcbiR7c3VwZXIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtUb3BTY29wZX1cblx0ICovXG5cdGV2YWxUeXBlcygpIHtcblx0XHRjb25zdCBzY29wZSA9IEdsb2JhbFNjb3BlLm5ldyhTY3JpcHRQdXJwb3NlLlNwZW5kaW5nKTtcblxuXHRcdHJldHVybiB0aGlzLmV2YWxUeXBlc0ludGVybmFsKHNjb3BlKTtcdFxuXHR9XG59XG5cbmNsYXNzIE1pbnRpbmdQcm9ncmFtIGV4dGVuZHMgUmVkZWVtZXJQcm9ncmFtIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7TW9kdWxlW119IG1vZHVsZXMgXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihtb2R1bGVzKSB7XG5cdFx0c3VwZXIoU2NyaXB0UHVycG9zZS5NaW50aW5nLCBtb2R1bGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBtaW50aW5nICR7dGhpcy5uYW1lfVxcbiR7c3VwZXIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtUb3BTY29wZX1cblx0ICovXG5cdGV2YWxUeXBlcygpIHtcblx0XHRjb25zdCBzY29wZSA9IEdsb2JhbFNjb3BlLm5ldyhTY3JpcHRQdXJwb3NlLk1pbnRpbmcpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXZhbFR5cGVzSW50ZXJuYWwoc2NvcGUpO1x0XG5cdH1cbn1cblxuY2xhc3MgU3Rha2luZ1Byb2dyYW0gZXh0ZW5kcyBSZWRlZW1lclByb2dyYW0ge1xuXHQvKipcblx0ICogQHBhcmFtIHtNb2R1bGVbXX0gbW9kdWxlcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKG1vZHVsZXMpIHtcblx0XHRzdXBlcihTY3JpcHRQdXJwb3NlLlN0YWtpbmcsIG1vZHVsZXMpO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIGBzdGFraW5nICR7dGhpcy5uYW1lfVxcbiR7c3VwZXIudG9TdHJpbmcoKX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYWNrYWdlXG5cdCAqIEByZXR1cm5zIHtUb3BTY29wZX1cblx0ICovXG5cdGV2YWxUeXBlcygpIHtcblx0XHRjb25zdCBzY29wZSA9IEdsb2JhbFNjb3BlLm5ldyhTY3JpcHRQdXJwb3NlLlN0YWtpbmcpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXZhbFR5cGVzSW50ZXJuYWwoc2NvcGUpO1x0XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAyNTogVHggdHlwZXNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBUeCBleHRlbmRzIENib3JEYXRhIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUeEJvZHl9XG5cdCAqL1xuXHQjYm9keTtcblxuXHQvKipcblx0ICogQHR5cGUge1R4V2l0bmVzc2VzfVxuXHQgKi9cblx0I3dpdG5lc3NlcztcblxuXHQvKipcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqL1xuXHQjdmFsaWQ7XG5cblx0LyoqIFxuXHQgKiBAdHlwZSB7P1R4TWV0YWRhdGF9IFxuXHQgKi9cblx0I21ldGFkYXRhO1xuXG5cdC8vIHRoZSBmb2xsb3dpbmcgZmllbGQocykgYXJlbid0IHVzZWQgYnkgdGhlIHNlcmlhbGl6YXRpb24gKG9ubHkgZm9yIGJ1aWxkaW5nKVxuXHQvKipcblx0ICogVXBvbiBmaW5hbGl6YXRpb24gdGhlIHNsb3QgaXMgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIHRoZSBib2R5XG5cdCAqIEB0eXBlIHs/RGF0ZX0gXG5cdCAqL1xuXHQjdmFsaWRUbztcblxuXHQvKipcblx0ICogVXBvbiBmaW5hbGl6YXRpb24gdGhlIHNsb3QgaXMgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIHRoZSBib2R5IFxuXHQgKiAgQHR5cGUgez9EYXRlfSBcblx0ICovXG5cdCN2YWxpZEZyb207XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNib2R5ID0gbmV3IFR4Qm9keSgpO1xuXHRcdHRoaXMuI3dpdG5lc3NlcyA9IG5ldyBUeFdpdG5lc3NlcygpO1xuXHRcdHRoaXMuI3ZhbGlkID0gZmFsc2U7IC8vIGJ1aWxkaW5nIGlzIG9ubHkgcG9zc2libGUgaWYgdmFsaWQ9PWZhbHNlXG5cdFx0dGhpcy4jbWV0YWRhdGEgPSBudWxsO1xuXHRcdHRoaXMuI3ZhbGlkVG8gPSBudWxsO1xuXHRcdHRoaXMuI3ZhbGlkRnJvbSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R4Qm9keX1cblx0ICovXG5cdGdldCBib2R5KCkge1xuXHRcdHJldHVybiB0aGlzLiNib2R5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJbXX1cblx0ICovXG5cdGdldCBib2R5SGFzaCgpIHtcblx0XHRyZXR1cm4gQ3J5cHRvLmJsYWtlMmIodGhpcy4jYm9keS50b0Nib3IoKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R4V2l0bmVzc2VzfVxuXHQgKi9cblx0Z2V0IHdpdG5lc3NlcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jd2l0bmVzc2VzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgZW11bGF0b3IgdG8gY2hlY2sgaWYgdHggaXMgdmFsaWQuXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBzbG90XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNWYWxpZChzbG90KSB7XG5cdFx0aWYgKCF0aGlzLiN2YWxpZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jYm9keS5pc1ZhbGlkKHNsb3QpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVUdXBsZShbXG5cdFx0XHR0aGlzLiNib2R5LnRvQ2JvcigpLFxuXHRcdFx0dGhpcy4jd2l0bmVzc2VzLnRvQ2JvcigpLFxuXHRcdFx0Q2JvckRhdGEuZW5jb2RlQm9vbCh0aGlzLiN2YWxpZCksXG5cdFx0XHR0aGlzLiNtZXRhZGF0YSA9PT0gbnVsbCA/IENib3JEYXRhLmVuY29kZU51bGwoKSA6IHRoaXMuI21ldGFkYXRhLnRvQ2JvcigpLFxuXHRcdF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHRieXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG5cblx0XHRsZXQgdHggPSBuZXcgVHgoKTtcblxuXHRcdGxldCBuID0gQ2JvckRhdGEuZGVjb2RlVHVwbGUoYnl0ZXMsIChpLCBmaWVsZEJ5dGVzKSA9PiB7XG5cdFx0XHRzd2l0Y2goaSkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0dHguI2JvZHkgPSBUeEJvZHkuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHR0eC4jd2l0bmVzc2VzID0gVHhXaXRuZXNzZXMuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHR0eC4jdmFsaWQgPSBDYm9yRGF0YS5kZWNvZGVCb29sKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0aWYgKENib3JEYXRhLmlzTnVsbChmaWVsZEJ5dGVzKSkge1xuXHRcdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlTnVsbChmaWVsZEJ5dGVzKTtcblxuXHRcdFx0XHRcdFx0dHguI21ldGFkYXRhID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHguI21ldGFkYXRhID0gVHhNZXRhZGF0YS5mcm9tQ2JvcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYmFkIHR1cGxlIHNpemVcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQobiA9PSA0KTtcblx0XHRhc3NlcnQoYnl0ZXMubGVuZ3RoID09IDApO1xuXG5cdFx0cmV0dXJuIHR4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRkdW1wKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRib2R5OiB0aGlzLiNib2R5LmR1bXAoKSxcblx0XHRcdHdpdG5lc3NlczogdGhpcy4jd2l0bmVzc2VzLmR1bXAoKSxcblx0XHRcdHZhbGlkOiB0aGlzLiN2YWxpZCxcblx0XHRcdG1ldGFkYXRhOiB0aGlzLiNtZXRhZGF0YSAhPT0gbnVsbCA/IHRoaXMuI21ldGFkYXRhLmR1bXAoKSA6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RGF0ZX0gdFxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHR2YWxpZEZyb20odCkge1xuXHRcdGFzc2VydCghdGhpcy4jdmFsaWQpO1xuXG5cdFx0dGhpcy4jdmFsaWRGcm9tID0gdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RGF0ZX0gdFxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHR2YWxpZFRvKHQpIHtcblx0XHRhc3NlcnQoIXRoaXMuI3ZhbGlkKTtcblxuXHRcdHRoaXMuI3ZhbGlkVG8gPSB0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGVycm9yIGlmIGFzc2V0cyBvZiBnaXZlbiBtcGggYXJlIGFscmVhZHkgYmVpbmcgbWludGVkIGluIHRoaXMgdHJhbnNhY3Rpb25cblx0ICogQHBhcmFtIHtNaW50aW5nUG9saWN5SGFzaH0gbXBoIFxuXHQgKiBAcGFyYW0ge1tudW1iZXJbXSB8IHN0cmluZywgYmlnaW50XVtdfSB0b2tlbnMgLSBsaXN0IG9mIHBhaXJzIG9mIFt0b2tlbk5hbWUsIHF1YW50aXR5XSwgdG9rZW5OYW1lIGNhbiBiZSBsaXN0IG9mIGJ5dGVzIG9yIGhleC1zdHJpbmdcblx0ICogQHBhcmFtIHtVcGxjRGF0YVZhbHVlIHwgVXBsY0RhdGF9IHJlZGVlbWVyXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdG1pbnRUb2tlbnMobXBoLCB0b2tlbnMsIHJlZGVlbWVyKSB7XG5cdFx0YXNzZXJ0KCF0aGlzLiN2YWxpZCk7XG5cblx0XHR0aGlzLiNib2R5LmFkZE1pbnQobXBoLCB0b2tlbnMubWFwKChbbmFtZSwgYW1vdW50XSkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiBbaGV4VG9CeXRlcyhuYW1lKSwgYW1vdW50XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBbbmFtZSwgYW1vdW50XTtcblx0XHRcdH1cblx0XHR9KSk7XG5cblx0XHR0aGlzLiN3aXRuZXNzZXMuYWRkTWludGluZ1JlZGVlbWVyKG1waCwgVXBsY0RhdGFWYWx1ZS51bndyYXAocmVkZWVtZXIpKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VVR4T30gaW5wdXRcblx0ICogQHBhcmFtIHs/KFVwbGNEYXRhVmFsdWUgfCBVcGxjRGF0YSl9IHJlZGVlbWVyXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdGFkZElucHV0KGlucHV0LCByZWRlZW1lciA9IG51bGwpIHtcblx0XHRhc3NlcnQoIXRoaXMuI3ZhbGlkKTtcblxuXHRcdGlmIChpbnB1dC5vcmlnT3V0cHV0ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUeElucHV0Lm9yaWdPdXRwdXQgbXVzdCBiZSBzZXQgd2hlbiBidWlsZGluZyB0cmFuc2FjdGlvblwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm9pZCB0aGlzLiNib2R5LmFkZElucHV0KGlucHV0LmFzVHhJbnB1dCk7XG5cblx0XHRcdGlmIChyZWRlZW1lciAhPT0gbnVsbCkge1xuXHRcdFx0XHRhc3NlcnQoaW5wdXQub3JpZ091dHB1dC5hZGRyZXNzLnZhbGlkYXRvckhhc2ggIT09IG51bGwsIFwiaW5wdXQgaXNuJ3QgbG9ja2VkIGJ5IGEgc2NyaXB0XCIpO1xuXG5cdFx0XHRcdHRoaXMuI3dpdG5lc3Nlcy5hZGRTcGVuZGluZ1JlZGVlbWVyKGlucHV0LmFzVHhJbnB1dCwgVXBsY0RhdGFWYWx1ZS51bndyYXAocmVkZWVtZXIpKTtcblxuXHRcdFx0XHRpZiAoaW5wdXQub3JpZ091dHB1dC5kYXR1bSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG5vbi1udWxsIGRhdHVtXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBkYXR1bSA9IGlucHV0Lm9yaWdPdXRwdXQuZGF0dW07XG5cblx0XHRcdFx0XHRpZiAoZGF0dW0gaW5zdGFuY2VvZiBIYXNoZWREYXR1bSkge1xuXHRcdFx0XHRcdFx0bGV0IGRhdHVtRGF0YSA9IGRhdHVtLmRhdGE7XG5cdFx0XHRcdFx0XHRpZiAoZGF0dW1EYXRhID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG5vbi1udWxsIGRhdHVtIGRhdGFcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLiN3aXRuZXNzZXMuYWRkRGF0dW1EYXRhKGRhdHVtRGF0YSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhc3NlcnQoaW5wdXQub3JpZ091dHB1dC5hZGRyZXNzLnB1YktleUhhc2ggIT09IG51bGwsIFwiaW5wdXQgaXMgbG9ja2VkIGJ5IGEgc2NyaXB0LCBidXQgcmVkZWVtZXIgaXNuJ3Qgc3BlY2lmaWVkXCIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VVR4T1tdfSBpbnB1dHNcblx0ICogQHBhcmFtIHs/KFVwbGNEYXRhVmFsdWUgfCBVcGxjRGF0YSl9IHJlZGVlbWVyXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdGFkZElucHV0cyhpbnB1dHMsIHJlZGVlbWVyID0gbnVsbCkge1xuXHRcdGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuXHRcdFx0dGhpcy5hZGRJbnB1dChpbnB1dCwgcmVkZWVtZXIpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhSZWZJbnB1dH0gaW5wdXRcblx0ICogQHBhcmFtIHs/VXBsY1Byb2dyYW19IHJlZlNjcmlwdFxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRhZGRSZWZJbnB1dChpbnB1dCwgcmVmU2NyaXB0ID0gbnVsbCkge1xuXHRcdGFzc2VydCghdGhpcy4jdmFsaWQpO1xuXG5cdFx0dGhpcy4jYm9keS5hZGRSZWZJbnB1dChpbnB1dCk7XG5cblx0XHRpZiAocmVmU2NyaXB0ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLiN3aXRuZXNzZXMuYXR0YWNoU2NyaXB0KHJlZlNjcmlwdCwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUeFJlZklucHV0W119IGlucHV0c1xuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRhZGRSZWZJbnB1dHMoaW5wdXRzKSB7XG5cdFx0Zm9yIChsZXQgaW5wdXQgb2YgaW5wdXRzKSB7XG5cdFx0XHR0aGlzLmFkZFJlZklucHV0KGlucHV0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4T3V0cHV0fSBvdXRwdXQgXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdGFkZE91dHB1dChvdXRwdXQpIHtcblx0XHRhc3NlcnQoIXRoaXMuI3ZhbGlkKTtcblx0XHRcblx0XHQvLyBtaW4gbG92ZWxhY2UgaXMgY2hlY2tlZCBkdXJpbmcgYnVpbGQsIGJlY2F1c2UgXG5cdFx0dGhpcy4jYm9keS5hZGRPdXRwdXQob3V0cHV0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhPdXRwdXRbXX0gb3V0cHV0cyBcblx0ICogQHJldHVybnMge1R4fVxuXHQgKi9cblx0YWRkT3V0cHV0cyhvdXRwdXRzKSB7XG5cdFx0Zm9yIChsZXQgb3V0cHV0IG9mIG91dHB1dHMpIHtcblx0XHRcdHRoaXMuYWRkT3V0cHV0KG91dHB1dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtQdWJLZXlIYXNofSBoYXNoXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdGFkZFNpZ25lcihoYXNoKSB7XG5cdFx0YXNzZXJ0KCF0aGlzLiN2YWxpZCk7XG5cblx0XHR0aGlzLiNib2R5LmFkZFNpZ25lcihoYXNoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVudXNlZCBzY3JpcHRzIGFyZSBkZXRlY3RlZCBkdXJpbmcgZmluYWxpemUoKSwgaW4gd2hpY2ggY2FzZSBhbiBlcnJvciBpcyB0aHJvd25cblx0ICogVGhyb3dzIGVycm9yIGlmIHNjcmlwdCB3YXMgYWxyZWFkeSBhZGRlZCBiZWZvcmVcblx0ICogQHBhcmFtIHtVcGxjUHJvZ3JhbX0gcHJvZ3JhbVxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRhdHRhY2hTY3JpcHQocHJvZ3JhbSkge1xuXHRcdGFzc2VydCghdGhpcy4jdmFsaWQpO1xuXG5cdFx0dGhpcy4jd2l0bmVzc2VzLmF0dGFjaFNjcmlwdChwcm9ncmFtKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzdWFsbHkgYWRkaW5nIG9ubHkgb25lIGNvbGxhdGVyYWwgaW5wdXQgaXMgZW5vdWdoXG5cdCAqIE11c3QgYmUgbGVzcyB0aGFuIHRoZSBsaW1pdCBpbiBuZXR3b3JrUGFyYW1zIChlZy4gMyksIG9yIGVsc2UgYW4gZXJyb3IgaXMgdGhyb3duIGR1cmluZyBmaW5hbGl6YXRpb25cblx0ICogQHBhcmFtIHtVVHhPfSBpbnB1dCBcblx0ICogQHJldHVybnMge1R4fVxuXHQgKi9cblx0YWRkQ29sbGF0ZXJhbChpbnB1dCkge1xuXHRcdGFzc2VydCghdGhpcy4jdmFsaWQpO1xuXG5cdFx0dGhpcy4jYm9keS5hZGRDb2xsYXRlcmFsKGlucHV0LmFzVHhJbnB1dCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHR4IGZlZSAoaW5jbHVkaW5nIHNjcmlwdCBleGVjdXRpb24pXG5cdCAqIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0ZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcykge1xuXHRcdGxldCBbYSwgYl0gPSBuZXR3b3JrUGFyYW1zLnR4RmVlUGFyYW1zO1xuXG5cdFx0aWYgKCF0aGlzLiN2YWxpZCkge1xuXHRcdFx0Ly8gYWRkIGR1bW15IHNpZ25hdHVyZXNcblx0XHRcdGxldCBuVW5pcXVlUHViS2V5SGFzaGVzID0gdGhpcy4jYm9keS5jb3VudFVuaXF1ZVNpZ25lcnMoKTtcblx0XHRcdFxuXHRcdFx0dGhpcy4jd2l0bmVzc2VzLmFkZER1bW15U2lnbmF0dXJlcyhuVW5pcXVlUHViS2V5SGFzaGVzKTtcblx0XHR9XG5cblx0XHRsZXQgc2l6ZSA9IHRoaXMudG9DYm9yKCkubGVuZ3RoO1xuXG5cdFx0aWYgKCF0aGlzLiN2YWxpZCkge1xuXHRcdFx0Ly8gY2xlYW4gdXAgdGhlIGR1bW15IHNpZ25hdHVyZXNcblx0XHRcdHRoaXMuI3dpdG5lc3Nlcy5yZW1vdmVEdW1teVNpZ25hdHVyZXMoKTtcblx0XHR9XG5cblx0XHRsZXQgc2l6ZUZlZSA9IEJpZ0ludChhKSArIEJpZ0ludChzaXplKSpCaWdJbnQoYik7XG5cblx0XHRsZXQgZXhGZWUgPSB0aGlzLiN3aXRuZXNzZXMuZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcyk7XG5cblx0XHRyZXR1cm4gc2l6ZUZlZSArIGV4RmVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIHVudGlsIGZlZSBpcyBleGFjdFxuXHQgKiBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICogQHBhcmFtIHtiaWdpbnR9IGZlZVxuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0c2V0RmVlKG5ldHdvcmtQYXJhbXMsIGZlZSkge1xuXHRcdGxldCBvbGRGZWUgPSB0aGlzLiNib2R5LmZlZTtcblxuXHRcdHdoaWxlIChvbGRGZWUgIT0gZmVlKSB7XG5cdFx0XHR0aGlzLiNib2R5LnNldEZlZShmZWUpO1xuXG5cdFx0XHRvbGRGZWUgPSBmZWU7XG5cblx0XHRcdGZlZSA9IHRoaXMuZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZlZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgdGhhdCBhbGwgbmVjZXNzYXJ5IHNjcmlwdHMgYXJlIGluY2x1ZGVkLCBhbmQgdGhhdCBhbGwgaW5jbHVkZWQgc2NyaXB0cyBhcmUgdXNlZFxuXHQgKiBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuXHQgKi9cblx0Y2hlY2tTY3JpcHRzKCkge1xuXHRcdGxldCBzY3JpcHRzID0gdGhpcy4jd2l0bmVzc2VzLnNjcmlwdHM7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7U2V0PHN0cmluZz59XG5cdFx0ICovXG5cdFx0Y29uc3QgY3VycmVudFNjcmlwdHMgPSBuZXcgU2V0KCk7XG5cdFx0c2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG5cdFx0XHRjdXJyZW50U2NyaXB0cy5hZGQoYnl0ZXNUb0hleChzY3JpcHQuaGFzaCgpKSlcblx0XHR9KVxuXG5cdFx0LyoqIFxuXHRcdCAqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBcblx0XHQgKi9cblx0XHRsZXQgd2FudGVkU2NyaXB0cyA9IG5ldyBNYXAoKTtcblxuXHRcdHRoaXMuI2JvZHkuY29sbGVjdFNjcmlwdEhhc2hlcyh3YW50ZWRTY3JpcHRzKTtcblxuXHRcdGlmICh3YW50ZWRTY3JpcHRzLnNpemUgPCBzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgc2NyaXB0cyBpbmNsdWRlZFwiKTtcblx0XHR9IGVsc2UgaWYgKHdhbnRlZFNjcmlwdHMuc2l6ZSA+IHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR3YW50ZWRTY3JpcHRzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcblx0XHRcdFx0aWYgKCFjdXJyZW50U2NyaXB0cy5oYXMoa2V5KSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgc2NyaXB0IGZvciBpbnB1dCAke3ZhbHVlfWApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgc2NyaXB0IGZvciBtaW50aW5nIHBvbGljeSAkey12YWx1ZS0xfWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y3VycmVudFNjcmlwdHMuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRpZiAoIXdhbnRlZFNjcmlwdHMuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc29sZS5sb2cod2FudGVkU2NyaXB0cywgY3VycmVudFNjcmlwdHMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVudXNlZCBzY3JpcHRcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcGFyYW0ge0FkZHJlc3N9IGNoYW5nZUFkZHJlc3Ncblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyBleGVjdXRlUmVkZWVtZXJzKG5ldHdvcmtQYXJhbXMsIGNoYW5nZUFkZHJlc3MpIHtcblx0XHRhd2FpdCB0aGlzLiN3aXRuZXNzZXMuZXhlY3V0ZVJlZGVlbWVycyhuZXR3b3JrUGFyYW1zLCB0aGlzLiNib2R5LCBjaGFuZ2VBZGRyZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXMgXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuXHQgKi9cblx0YXN5bmMgY2hlY2tFeGVjdXRpb25CdWRnZXRzKG5ldHdvcmtQYXJhbXMpIHtcblx0XHRhd2FpdCB0aGlzLiN3aXRuZXNzZXMuY2hlY2tFeGVjdXRpb25CdWRnZXRzKG5ldHdvcmtQYXJhbXMsIHRoaXMuI2JvZHkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QWRkcmVzc30gY2hhbmdlQWRkcmVzcyBcblx0ICovXG5cdGJhbGFuY2VBc3NldHMoY2hhbmdlQWRkcmVzcykge1xuXHRcdGNvbnN0IGlucHV0QXNzZXRzID0gdGhpcy4jYm9keS5zdW1JbnB1dEFuZE1pbnRlZEFzc2V0cygpO1xuXG5cdFx0Y29uc3Qgb3V0cHV0QXNzZXRzID0gdGhpcy4jYm9keS5zdW1PdXRwdXRBc3NldHMoKTtcblxuXHRcdGlmIChpbnB1dEFzc2V0cy5lcShvdXRwdXRBc3NldHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIGlmIChvdXRwdXRBc3NldHMuZ2UoaW5wdXRBc3NldHMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgZW5vdWdoIGlucHV0IGFzc2V0c1wiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZGlmZiA9IGlucHV0QXNzZXRzLnN1YihvdXRwdXRBc3NldHMpO1xuXG5cdFx0XHRjb25zdCBjaGFuZ2VPdXRwdXQgPSBuZXcgVHhPdXRwdXQoY2hhbmdlQWRkcmVzcywgbmV3IFZhbHVlKDBuLCBkaWZmKSk7XG5cblx0XHRcdHRoaXMuI2JvZHkuYWRkT3V0cHV0KGNoYW5nZU91dHB1dCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgYmFzZSBmZWUgd2hpY2ggd2lsbCBiZSBtdWx0aXBsaWVkIGJ5IHRoZSByZXF1aXJlZCBtaW4gY29sbGF0ZXJhbCBwZXJjZW50YWdlIFxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXMgXG5cdCAqIEBwYXJhbSB7QWRkcmVzc30gY2hhbmdlQWRkcmVzcyBcblx0ICogQHBhcmFtIHtVVHhPW119IHNwYXJlVXR4b3MgXG5cdCAqL1xuXHRlc3RpbWF0ZUNvbGxhdGVyYWxCYXNlRmVlKG5ldHdvcmtQYXJhbXMsIGNoYW5nZUFkZHJlc3MsIHNwYXJlVXR4b3MpIHtcblx0XHRhc3NlcnQoY29uZmlnLk5fRFVNTVlfSU5QVVRTID09IDEgfHwgY29uZmlnLk5fRFVNTVlfSU5QVVRTID09IDIsIFwiZXhwZWN0ZWQgTl9EVU1NWV9JTlBVVHMgPT0gMSBvciBOX0RVTU1ZX0lOUFVUUyA9PSAyXCIpO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSBjb2xsYXRlcmFsIHJldHVybiBvdXRwdXQgKG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhZGRlZCBpZiB0aGVyZSBpc24ndCBlbm91Z2ggbG92ZWxhY2UpXG5cdFx0Y29uc3QgZHVtbXlPdXRwdXQgPSBuZXcgVHhPdXRwdXQoY2hhbmdlQWRkcmVzcywgbmV3IFZhbHVlKDBuKSk7XG5cdFx0ZHVtbXlPdXRwdXQuY29ycmVjdExvdmVsYWNlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0Ly8gc29tZSBkdW1teSBVVHhPcyBvbiB0byBiZSBhYmxlIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgdGhlIGNvbGxhdGVyYWwgKGFzc3VtaW5nIGl0IHVzZXMgZnVsbCBib2R5IGZlZSlcblx0XHRjb25zdCBkdW1teUNvbGxhdGVyYWwgPSBzcGFyZVV0eG9zLm1hcChzcGFyZSA9PiBzcGFyZS5hc1R4SW5wdXQpLmNvbmNhdCh0aGlzLiNib2R5LmlucHV0cykuc2xpY2UoMCwgMyk7XG5cdFx0ZHVtbXlDb2xsYXRlcmFsLmZvckVhY2goaW5wdXQgPT4ge1xuXHRcdFx0dGhpcy4jYm9keS5jb2xsYXRlcmFsLnB1c2goaW5wdXQpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgZHVtbXlJbnB1dHMgPSBkdW1teUNvbGxhdGVyYWwuc2xpY2UoMCwgY29uZmlnLk5fRFVNTVlfSU5QVVRTKTtcblxuXHRcdHRoaXMuI2JvZHkuc2V0Q29sbGF0ZXJhbFJldHVybihkdW1teU91dHB1dCk7XG5cdFx0ZHVtbXlJbnB1dHMuZm9yRWFjaChkdW1teUlucHV0ID0+IHRoaXMuI2JvZHkuYWRkSW5wdXQoZHVtbXlJbnB1dCwgZmFsc2UpKTtcblx0XHR0aGlzLiNib2R5LmFkZE91dHB1dChkdW1teU91dHB1dCk7XG5cblx0XHRjb25zdCBiYXNlRmVlID0gdGhpcy5lc3RpbWF0ZUZlZShuZXR3b3JrUGFyYW1zKTtcblxuXHRcdC8vIHJlbW92ZSB0aGUgZHVtbXkgaW5wdXRzIGFuZCBvdXRwdXRzXG5cdFx0d2hpbGUodGhpcy4jYm9keS5jb2xsYXRlcmFsLmxlbmd0aCkge1xuXHRcdFx0dGhpcy4jYm9keS5jb2xsYXRlcmFsLnBvcCgpO1xuXHRcdH1cblx0XHR0aGlzLiNib2R5LnNldENvbGxhdGVyYWxSZXR1cm4obnVsbCk7XG5cdFx0ZHVtbXlJbnB1dHMuZm9yRWFjaChkdW1teUlucHV0ID0+IHRoaXMuI2JvZHkucmVtb3ZlSW5wdXQoZHVtbXlJbnB1dCkpO1xuXHRcdHRoaXMuI2JvZHkucmVtb3ZlT3V0cHV0KGR1bW15T3V0cHV0KTtcblxuXHRcdHJldHVybiBiYXNlRmVlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zXG5cdCAqIEBwYXJhbSB7QWRkcmVzc30gY2hhbmdlQWRkcmVzc1xuXHQgKiBAcGFyYW0ge1VUeE9bXX0gc3BhcmVVdHhvc1xuXHQgKi9cblx0YmFsYW5jZUNvbGxhdGVyYWwobmV0d29ya1BhcmFtcywgY2hhbmdlQWRkcmVzcywgc3BhcmVVdHhvcykge1xuXHRcdC8vIGRvbid0IGRvIHRoaXMgc3RlcCBpZiBjb2xsYXRlcmFsIHdhcyBhbHJlYWR5IGFkZGVkIGV4cGxpY2l0bHlcblx0XHRpZiAodGhpcy4jYm9keS5jb2xsYXRlcmFsLmxlbmd0aCA+IDAgfHwgIXRoaXMuaXNTbWFydCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgYmFzZUZlZSA9IHRoaXMuZXN0aW1hdGVDb2xsYXRlcmFsQmFzZUZlZShuZXR3b3JrUGFyYW1zLCBjaGFuZ2VBZGRyZXNzLCBzcGFyZVV0eG9zKTtcblxuXHRcdGNvbnN0IG1pbkNvbGxhdGVyYWwgPSAoKGJhc2VGZWUqQmlnSW50KG5ldHdvcmtQYXJhbXMubWluQ29sbGF0ZXJhbFBjdCkpICsgMTAwbikvMTAwbjsgLy8gaW50ZWdlciBkaXZpc2lvbiB0aGF0IHJvdW5kcyB1cFxuXG5cdFx0bGV0IGNvbGxhdGVyYWwgPSAwbjtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7VHhJbnB1dFtdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IGNvbGxhdGVyYWxJbnB1dHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7VHhJbnB1dFtdfSBpbnB1dHMgXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYWRkQ29sbGF0ZXJhbElucHV0cyhpbnB1dHMpIHtcblx0XHRcdC8vIGZpcnN0IHRyeSB1c2luZyB0aGUgVVR4T3MgdGhhdCBhbHJlYWR5IGZvcm0gdGhlIGlucHV0c1xuXHRcdFx0Y29uc3QgY2xlYW5JbnB1dHMgPSBpbnB1dHMuZmlsdGVyKHV0eG8gPT4gdXR4by52YWx1ZS5hc3NldHMuaXNaZXJvKCkpLnNvcnQoKGEsIGIpID0+IE51bWJlcihhLnZhbHVlLmxvdmVsYWNlIC0gYi52YWx1ZS5sb3ZlbGFjZSkpO1xuXG5cdFx0XHRmb3IgKGxldCBpbnB1dCBvZiBjbGVhbklucHV0cykge1xuXHRcdFx0XHRpZiAoY29sbGF0ZXJhbCA+IG1pbkNvbGxhdGVyYWwpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdoaWxlIChjb2xsYXRlcmFsSW5wdXRzLmxlbmd0aCA+PSBuZXR3b3JrUGFyYW1zLm1heENvbGxhdGVyYWxJbnB1dHMpIHtcblx0XHRcdFx0XHRjb2xsYXRlcmFsSW5wdXRzLnNoaWZ0KCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGNvbGxhdGVyYWxJbnB1dHMucHVzaChpbnB1dCk7XG5cdFx0XHRcdGNvbGxhdGVyYWwgKz0gaW5wdXQudmFsdWUubG92ZWxhY2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGFkZENvbGxhdGVyYWxJbnB1dHModGhpcy4jYm9keS5pbnB1dHMuc2xpY2UoKSk7XG5cblx0XHRhZGRDb2xsYXRlcmFsSW5wdXRzKHNwYXJlVXR4b3MubWFwKHV0eG8gPT4gdXR4by5hc1R4SW5wdXQpKTtcblxuXHRcdC8vIGNyZWF0ZSB0aGUgY29sbGF0ZXJhbCByZXR1cm4gb3V0cHV0IGlmIHRoZXJlIGlzIGVub3VnaCBsb3ZlbGFjZVxuXHRcdGNvbnN0IGNoYW5nZU91dHB1dCA9IG5ldyBUeE91dHB1dChjaGFuZ2VBZGRyZXNzLCBuZXcgVmFsdWUoMG4pKTtcblx0XHRjaGFuZ2VPdXRwdXQuY29ycmVjdExvdmVsYWNlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0aWYgKGNvbGxhdGVyYWwgPCBtaW5Db2xsYXRlcmFsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gZmluZCBlbm91Z2ggY29sbGF0ZXJhbCBpbnB1dFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGNvbGxhdGVyYWwgPiBtaW5Db2xsYXRlcmFsICsgY2hhbmdlT3V0cHV0LnZhbHVlLmxvdmVsYWNlKSB7XG5cdFx0XHRcdGNoYW5nZU91dHB1dC5zZXRWYWx1ZShuZXcgVmFsdWUoMG4pKTtcblxuXHRcdFx0XHRjaGFuZ2VPdXRwdXQuY29ycmVjdExvdmVsYWNlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0XHRcdGlmIChjb2xsYXRlcmFsID4gbWluQ29sbGF0ZXJhbCArIGNoYW5nZU91dHB1dC52YWx1ZS5sb3ZlbGFjZSkge1xuXHRcdFx0XHRcdGNoYW5nZU91dHB1dC5zZXRWYWx1ZShuZXcgVmFsdWUoY29sbGF0ZXJhbCAtIG1pbkNvbGxhdGVyYWwpKTtcblx0XHRcdFx0XHR0aGlzLiNib2R5LnNldENvbGxhdGVyYWxSZXR1cm4oY2hhbmdlT3V0cHV0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgbm90IHNldHRpbmcgY29sbGF0ZXJhbCByZXR1cm46IGNvbGxhdGVyYWwgaW5wdXQgdG9vIGxvdyAoJHtjb2xsYXRlcmFsfSlgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxhdGVyYWxJbnB1dHMuZm9yRWFjaCh1dHhvID0+IHtcblx0XHRcdHRoaXMuI2JvZHkuYWRkQ29sbGF0ZXJhbCh1dHhvKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIGZlZSBhbmQgYmFsYW5jZXMgdHJhbnNhY3Rpb24gYnkgc2VuZGluZyBhbiBvdXRwdXQgYmFjayB0byBjaGFuZ2VBZGRyZXNzXG5cdCAqIEZpcnN0IGFzc3VtZXMgdGhhdCBjaGFuZ2Ugb3V0cHV0IGlzbid0IG5lZWRlZCwgYW5kIGlmIHRoYXQgYXNzdW1wdGlvbiBkb2Vzbid0IHJlc3VsdCBpbiBhIGJhbGFuY2VkIHRyYW5zYWN0aW9uIHRoZSBjaGFuZ2Ugb3V0cHV0IGlzIGNyZWF0ZWQuXG5cdCAqIEl0ZXJhdGl2ZWx5IGluY3JlbWVudHMgdGhlIGZlZSBiZWNhdXNlIHRoZSBmZWUgaW5jcmVhc2UgdGhlIHR4IHNpemUgd2hpY2ggaW4gdHVybiBpbmNyZWFzZXMgdGhlIGZlZSAoYWx3YXlzIGNvbnZlcmdlcyB3aXRoaW4gdHdvIHN0ZXBzIHRob3VnaCkuXG5cdCAqIFRocm93cyBlcnJvciBpZiB0cmFuc2FjdGlvbiBjYW4ndCBiZSBiYWxhbmNlZC5cblx0ICogU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcGFyYW0ge0FkZHJlc3N9IGNoYW5nZUFkZHJlc3Ncblx0ICogQHBhcmFtIHtVVHhPW119IHNwYXJlVXR4b3MgLSB1c2VkIHdoZW4gdGhlcmUgYXJlIHlldCBlbm91Z2ggaW5wdXRzIHRvIGNvdmVyIGV2ZXJ5dGhpbmcgKGVnLiBkdWUgdG8gbWluIG91dHB1dCBsb3ZlbGFjZSByZXF1aXJlbWVudHMsIG9yIGZlZXMpXG5cdCAqL1xuXHRiYWxhbmNlTG92ZWxhY2UobmV0d29ya1BhcmFtcywgY2hhbmdlQWRkcmVzcywgc3BhcmVVdHhvcykge1xuXHRcdC8vIGRvbid0IGluY2x1ZGUgdGhlIGNoYW5nZU91dHB1dCBpbiB0aGlzIHZhbHVlXG5cdFx0bGV0IG5vbkNoYW5nZU91dHB1dFZhbHVlID0gdGhpcy4jYm9keS5zdW1PdXRwdXRWYWx1ZSgpO1xuXG5cdFx0Ly8gYXNzdW1lIGEgY2hhbmdlIG91dHB1dCBpcyBhbHdheXMgbmVlZGVkXG5cdFx0Y29uc3QgY2hhbmdlT3V0cHV0ID0gbmV3IFR4T3V0cHV0KGNoYW5nZUFkZHJlc3MsIG5ldyBWYWx1ZSgwbikpO1xuXG5cdFx0Y2hhbmdlT3V0cHV0LmNvcnJlY3RMb3ZlbGFjZShuZXR3b3JrUGFyYW1zKTtcblxuXHRcdHRoaXMuI2JvZHkuYWRkT3V0cHV0KGNoYW5nZU91dHB1dCk7XG5cdFx0XG5cdFx0Y29uc3QgbWluTG92ZWxhY2UgPSBjaGFuZ2VPdXRwdXQudmFsdWUubG92ZWxhY2U7XG5cblx0XHRsZXQgZmVlID0gdGhpcy5zZXRGZWUobmV0d29ya1BhcmFtcywgdGhpcy5lc3RpbWF0ZUZlZShuZXR3b3JrUGFyYW1zKSk7XG5cdFx0XG5cdFx0bGV0IGlucHV0VmFsdWUgPSB0aGlzLiNib2R5LnN1bUlucHV0QW5kTWludGVkVmFsdWUoKTtcblxuXHRcdGxldCBmZWVWYWx1ZSA9IG5ldyBWYWx1ZShmZWUpO1xuXG5cdFx0bm9uQ2hhbmdlT3V0cHV0VmFsdWUgPSBmZWVWYWx1ZS5hZGQobm9uQ2hhbmdlT3V0cHV0VmFsdWUpO1xuXG5cdFx0c3BhcmVVdHhvcyA9IHNwYXJlVXR4b3MuZmlsdGVyKHV0eG8gPT4gdXR4by52YWx1ZS5hc3NldHMuaXNaZXJvKCkpO1xuXHRcdFxuXHRcdC8vIHVzZSBzb21lIHNwYXJlVXR4b3MgaWYgdGhlIGlucHV0VmFsdWUgZG9lc24ndCBjb3ZlciB0aGUgb3V0cHV0cyBhbmQgZmVlc1xuXG5cdFx0d2hpbGUgKCFpbnB1dFZhbHVlLmdlKG5vbkNoYW5nZU91dHB1dFZhbHVlLmFkZChjaGFuZ2VPdXRwdXQudmFsdWUpKSkge1xuXHRcdFx0bGV0IHNwYXJlID0gc3BhcmVVdHhvcy5wb3AoKTtcblxuXHRcdFx0aWYgKHNwYXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gZG9lc24ndCBoYXZlIGVub3VnaCBpbnB1dHMgdG8gY292ZXIgdGhlIG91dHB1dHMgKyBmZWVzICsgbWluTG92ZWxhY2VcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLiNib2R5LmFkZElucHV0KHNwYXJlLmFzVHhJbnB1dCk7XG5cblx0XHRcdFx0aW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUuYWRkKHNwYXJlLnZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1c2UgdG8gdGhlIGV4YWN0IGRpZmYsIHdoaWNoIGlzID49IG1pbkxvdmVsYWNlXG5cdFx0bGV0IGRpZmYgPSBpbnB1dFZhbHVlLnN1Yihub25DaGFuZ2VPdXRwdXRWYWx1ZSk7XG5cblx0XHRhc3NlcnQoZGlmZi5hc3NldHMuaXNaZXJvKCksIFwidW5leHBlY3RlZCB1bmJhbGFuY2VkIGFzc2V0c1wiKTtcblx0XHRhc3NlcnQoZGlmZi5sb3ZlbGFjZSA+PSBtaW5Mb3ZlbGFjZSk7XG5cblx0XHRjaGFuZ2VPdXRwdXQuc2V0VmFsdWUoZGlmZik7XG5cblx0XHQvLyB3ZSBjYW4gbXV0YXRlIHRoZSBsb3ZlbGFjZSB2YWx1ZSBvZiAnY2hhbmdlT3V0cHV0JyB1bnRpbCB3ZSBoYXZlIGEgYmFsYW5jZWQgdHJhbnNhY3Rpb24gd2l0aCBwcmVjaXNlbHkgdGhlIHJpZ2h0IGZlZVxuXG5cdFx0bGV0IG9sZEZlZSA9IGZlZTtcblx0XHRmZWUgPSB0aGlzLmVzdGltYXRlRmVlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0d2hpbGUgKGZlZSAhPSBvbGRGZWUpIHtcblx0XHRcdHRoaXMuI2JvZHkuc2V0RmVlKGZlZSk7XG5cblx0XHRcdGxldCBkaWZmRmVlID0gZmVlIC0gb2xkRmVlO1xuXG5cdFx0XHQvLyB1c2Ugc29tZSBtb3JlIHNwYXJlVXR4b3Ncblx0XHRcdHdoaWxlIChkaWZmRmVlICA+IChjaGFuZ2VPdXRwdXQudmFsdWUubG92ZWxhY2UgLSBtaW5Mb3ZlbGFjZSkpIHtcblx0XHRcdFx0bGV0IHNwYXJlID0gc3BhcmVVdHhvcy5wb3AoKTtcblxuXHRcdFx0XHRpZiAoc3BhcmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCBlbm91Z2ggY2xlYW4gaW5wdXRzIHRvIGNvdmVyIGZlZXNcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4jYm9keS5hZGRJbnB1dChzcGFyZS5hc1R4SW5wdXQpO1xuXG5cdFx0XHRcdFx0aW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUuYWRkKHNwYXJlLnZhbHVlKTtcblxuXHRcdFx0XHRcdGRpZmYgPSBkaWZmLmFkZChzcGFyZS52YWx1ZSk7XG5cblx0XHRcdFx0XHRjaGFuZ2VPdXRwdXQuc2V0VmFsdWUoZGlmZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2hhbmdlT3V0cHV0LnZhbHVlLnNldExvdmVsYWNlKGNoYW5nZU91dHB1dC52YWx1ZS5sb3ZlbGFjZSAtIGRpZmZGZWUpO1xuXG5cdFx0XHQvLyBjaGFuZ2VPdXRwdXQudmFsdWUubG92ZWxhY2Ugc2hvdWxkIHN0aWxsIGJlID49IG1pbkxvdmVsYWNlIGF0IHRoaXMgcG9pbnRcblxuXHRcdFx0b2xkRmVlID0gZmVlO1xuXG5cdFx0XHRmZWUgPSB0aGlzLmVzdGltYXRlRmVlKG5ldHdvcmtQYXJhbXMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseVxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICovXG5cdHN5bmNTY3JpcHREYXRhSGFzaChuZXR3b3JrUGFyYW1zKSB7XG5cdFx0Y29uc3QgaGFzaCA9IHRoaXMuI3dpdG5lc3Nlcy5jYWxjU2NyaXB0RGF0YUhhc2gobmV0d29ya1BhcmFtcyk7XG5cblx0XHR0aGlzLiNib2R5LnNldFNjcmlwdERhdGFIYXNoKGhhc2gpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNTbWFydCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jd2l0bmVzc2VzLnNjcmlwdHMubGVuZ3RoID4gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIGNvbGxhdGVyYWxcblx0ICogQWxzbyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNjcmlwdCBkb2Vzbid0IHJlcXVpcmUgY29sbGF0ZXJhbCwgYnV0IGNvbGxhdGVyYWwgd2FzIGFjdHVhbGx5IGluY2x1ZGVkXG5cdCAqIFNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5XG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtcyBcblx0ICovXG5cdGNoZWNrQ29sbGF0ZXJhbChuZXR3b3JrUGFyYW1zKSB7XG5cdFx0aWYgKHRoaXMuaXNTbWFydCgpKSB7XG5cdFx0XHRsZXQgbWluQ29sbGF0ZXJhbFBjdCA9IG5ldHdvcmtQYXJhbXMubWluQ29sbGF0ZXJhbFBjdDtcblxuXHRcdFx0Ly8gb25seSB1c2UgdGhlIGV4QnVkZ2V0IFxuXG5cdFx0XHRjb25zdCBmZWUgPSB0aGlzLiNib2R5LmZlZTtcblxuXHRcdFx0dGhpcy4jYm9keS5jaGVja0NvbGxhdGVyYWwobmV0d29ya1BhcmFtcywgQmlnSW50KE1hdGguY2VpbChtaW5Db2xsYXRlcmFsUGN0Kk51bWJlcihmZWUpLzEwMC4wKSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiNib2R5LmNoZWNrQ29sbGF0ZXJhbChuZXR3b3JrUGFyYW1zLCBudWxsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGVycm9yIGlmIHR4IGlzIHRvbyBiaWdcblx0ICogU2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHlcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKi9cblx0Y2hlY2tTaXplKG5ldHdvcmtQYXJhbXMpIHtcblx0XHRsZXQgc2l6ZSA9IHRoaXMudG9DYm9yKCkubGVuZ3RoO1xuXG5cdFx0aWYgKHNpemUgPiBuZXR3b3JrUGFyYW1zLm1heFR4U2l6ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidHggdG9vIGJpZ1wiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRmluYWwgY2hlY2sgdGhhdCBmZWUgaXMgYmlnIGVub3VnaFxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXMgXG5cdCAqL1xuXHRjaGVja0ZlZShuZXR3b3JrUGFyYW1zKSB7XG5cdFx0YXNzZXJ0KHRoaXMuZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcykgPD0gdGhpcy4jYm9keS5mZWUsIFwiZmVlIHRvbyBzbWFsbFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3N1bWVzIHRyYW5zYWN0aW9uIGhhc24ndCB5ZXQgYmVlbiBzaWduZWQgYnkgYW55b25lIChpLmUuIHdpdG5lc3Nlcy5zaWduYXR1cmVzIGlzIGVtcHR5KVxuXHQgKiBNdXRhdGVzICd0aGlzJ1xuXHQgKiBOb3RlOiB0aGlzIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIHNvIHRoYXQgYSBkZWJ1Z2dlciBjYW4gb3B0aW9uYWxseSBiZSBhdHRhY2hlZCBpbiB0aGUgZnV0dXJlXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKiBAcGFyYW0ge0FkZHJlc3N9ICAgICAgIGNoYW5nZUFkZHJlc3Ncblx0ICogQHBhcmFtIHtVVHhPW119ICAgICAgICBzcGFyZVV0eG9zIC0gbWlnaHQgYmUgdXNlZCBkdXJpbmcgYmFsYW5jaW5nIGlmIHRoZXJlIGN1cnJlbnRseSBhcmVuJ3QgZW5vdWdoIGlucHV0c1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxUeD59XG5cdCAqL1xuXHRhc3luYyBmaW5hbGl6ZShuZXR3b3JrUGFyYW1zLCBjaGFuZ2VBZGRyZXNzLCBzcGFyZVV0eG9zID0gW10pIHtcblx0XHRhc3NlcnQoIXRoaXMuI3ZhbGlkKTtcblxuXHRcdGlmICh0aGlzLiNtZXRhZGF0YSAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBNZXRhZGF0YSBoYXNoIGFuZCBhZGQgdG8gdGhlIFR4Qm9keVxuXHRcdFx0dGhpcy4jYm9keS5zZXRNZXRhZGF0YUhhc2goXG5cdFx0XHRcdG5ldyBIYXNoKENyeXB0by5ibGFrZTJiKHRoaXMuI21ldGFkYXRhLnRvQ2JvcigpKSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3ZhbGlkVG8gIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI2JvZHkudmFsaWRUbyhcblx0XHRcdFx0bmV0d29ya1BhcmFtcy50aW1lVG9TbG90KEJpZ0ludCh0aGlzLiN2YWxpZFRvLmdldFRpbWUoKSkpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiN2YWxpZEZyb20gIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI2JvZHkudmFsaWRGcm9tKG5ldHdvcmtQYXJhbXMudGltZVRvU2xvdChCaWdJbnQodGhpcy4jdmFsaWRGcm9tLmdldFRpbWUoKSkpKTtcblx0XHR9XG5cblx0XHQvLyBpbnB1dHMsIG1pbnRlZCBhc3NldHMsIGFuZCB3aXRoZHJhd2FscyBtdXN0IGFsbCBiZSBpbiBhIHBhcnRpY3VsYXIgb3JkZXJcblx0XHR0aGlzLiNib2R5LnNvcnQoKTtcblxuXHRcdC8vIGFmdGVyIGlucHV0cyBldGMuIGhhdmUgYmVlbiBzb3J0ZWQgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgcmVkZWVtZXJzIHJlZmVycmluZyB0byB0aG9zZSBpbnB1dHNcblx0XHR0aGlzLiN3aXRuZXNzZXMudXBkYXRlUmVkZWVtZXJJbmRpY2VzKHRoaXMuI2JvZHkpO1xuXG5cdFx0dGhpcy5jaGVja1NjcmlwdHMoKTtcblxuXHRcdC8vIGJhbGFuY2UgdGhlIG5vbi1hZGEgYXNzZXRzXG5cdFx0dGhpcy5iYWxhbmNlQXNzZXRzKGNoYW5nZUFkZHJlc3MpXG5cblx0XHQvLyBtYWtlIHN1cmUgdGhhdCBlYWNoIG91dHB1dCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IG1pbmltdW0gYW1vdW50IG9mIGxvdmVsYWNlXHRcblx0XHR0aGlzLiNib2R5LmNvcnJlY3RPdXRwdXRzKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0Ly8gdGhlIHNjcmlwdHMgZXhlY3V0ZWQgYXQgdGhpcyBwb2ludCB3aWxsIG5vdCBzZWUgdGhlIGNvcnJlY3QgdHhIYXNoIG5vciB0aGUgY29ycmVjdCBmZWVcblx0XHRhd2FpdCB0aGlzLmV4ZWN1dGVSZWRlZW1lcnMobmV0d29ya1BhcmFtcywgY2hhbmdlQWRkcmVzcyk7XG5cblx0XHQvLyBiYWxhbmNlIGNvbGxhdGVyYWwgKGlmIGNvbGxhdGVyYWwgd2Fzbid0IGFscmVhZHkgc2V0IG1hbnVhbGx5KVxuXHRcdHRoaXMuYmFsYW5jZUNvbGxhdGVyYWwobmV0d29ya1BhcmFtcywgY2hhbmdlQWRkcmVzcywgc3BhcmVVdHhvcy5zbGljZSgpKTtcblxuXHRcdC8vIGJhbGFuY2UgdGhlIGxvdmVsYWNlXG5cdFx0dGhpcy5iYWxhbmNlTG92ZWxhY2UobmV0d29ya1BhcmFtcywgY2hhbmdlQWRkcmVzcywgc3BhcmVVdHhvcy5zbGljZSgpKTtcblxuXHRcdC8vIHJ1biB1cGRhdGVSZWRlZW1lckluZGljZXMgYWdhaW4gYmVjYXVzZSBuZXcgaW5wdXRzIG1heSBoYXZlIGJlZW4gYWRkZWQgYW5kIHNvcnRlZFxuXHRcdHRoaXMuI3dpdG5lc3Nlcy51cGRhdGVSZWRlZW1lckluZGljZXModGhpcy4jYm9keSk7XG5cblx0XHQvLyB3ZSBjYW4gb25seSBzeW5jIHNjcmlwdERhdGFIYXNoIGFmdGVyIHRoZSByZWRlZW1lciBleGVjdXRpb24gY29zdHMgaGF2ZSBiZWVuIGVzdGltYXRlZCwgYW5kIGZpbmFsIHJlZGVlbWVyIGluZGljZXMgaGF2ZSBiZWVuIGRldGVybWluZWRcblx0XHR0aGlzLnN5bmNTY3JpcHREYXRhSGFzaChuZXR3b3JrUGFyYW1zKTtcblxuXHRcdC8vIGEgYnVuY2ggb2YgY2hlY2tzXG5cdFx0dGhpcy4jYm9keS5jaGVja091dHB1dHMobmV0d29ya1BhcmFtcyk7XG5cblx0XHR0aGlzLmNoZWNrQ29sbGF0ZXJhbChuZXR3b3JrUGFyYW1zKTtcblxuXHRcdGF3YWl0IHRoaXMuY2hlY2tFeGVjdXRpb25CdWRnZXRzKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0dGhpcy4jd2l0bmVzc2VzLmNoZWNrRXhlY3V0aW9uQnVkZ2V0TGltaXRzKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0dGhpcy5jaGVja1NpemUobmV0d29ya1BhcmFtcyk7XG5cblx0XHR0aGlzLmNoZWNrRmVlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0dGhpcy4jdmFsaWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIHZlcmlmeT09dHJ1ZSBhbmQgc2lnbmF0dXJlIGlzIGludmFsaWQgXG5cdCAqIEFkZGluZyBtYW55IHNpZ25hdHVyZXMgbWlnaHQgYmUgYSBiaXQgc2xvd1xuXHQgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlIFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZlcmlmeVxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRhZGRTaWduYXR1cmUoc2lnbmF0dXJlLCB2ZXJpZnkgPSB0cnVlKSB7XG5cdFx0YXNzZXJ0KHRoaXMuI3ZhbGlkKTtcblxuXHRcdGlmICh2ZXJpZnkpIHtcblx0XHRcdHNpZ25hdHVyZS52ZXJpZnkodGhpcy5ib2R5SGFzaCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4jd2l0bmVzc2VzLmFkZFNpZ25hdHVyZShzaWduYXR1cmUpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIHZlcmlmeT09dHJ1ZSBhbmQgYW55IG9mIHRoZSBzaWduYXR1cmVzIGlzIGludmFsaWRcblx0ICogQWRkaW5nIG1hbnkgc2lnbmF0dXJlcyBtaWdodCBiZSBhIGJpdCBzbG93XG5cdCAqIEBwYXJhbSB7U2lnbmF0dXJlW119IHNpZ25hdHVyZXMgXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdmVyaWZ5IFxuXHQgKiBAcmV0dXJucyB7VHh9XG5cdCAqL1xuXHRhZGRTaWduYXR1cmVzKHNpZ25hdHVyZXMsIHZlcmlmeSA9IHRydWUpIHtcblx0XHRmb3IgKGxldCBzIG9mIHNpZ25hdHVyZXMpIHtcblx0XHRcdHRoaXMuYWRkU2lnbmF0dXJlKHMsIHZlcmlmeSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRhZ1xuXHQgKiBAcGFyYW0ge01ldGFkYXRhfSBkYXRhXG5cdCAqIEByZXR1cm5zIHtUeH1cblx0ICovXG5cdGFkZE1ldGFkYXRhKHRhZywgZGF0YSkge1xuXHRcdGlmICh0aGlzLiNtZXRhZGF0YSA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jbWV0YWRhdGEgPSBuZXcgVHhNZXRhZGF0YSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuI21ldGFkYXRhLmFkZCh0YWcsIGRhdGEpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1R4SWR9XG5cdCAqL1xuXHRpZCgpIHtcblx0XHRhc3NlcnQodGhpcy4jdmFsaWQsIFwiY2FuJ3QgZ2V0IFR4SWQgb2YgdW5maW5hbGl6ZWQgVHhcIik7XG5cdFx0cmV0dXJuIG5ldyBUeElkKHRoaXMuYm9keUhhc2gpO1xuXHR9XG59XG5cbi8qKlxuICogaW5wdXRzLCBtaW50ZWQgYXNzZXRzLCBhbmQgd2l0aGRyYXdhbHMgbmVlZCB0byBiZSBzb3J0ZWQgaW4gb3JkZXIgdG8gZm9ybSBhIHZhbGlkIHRyYW5zYWN0aW9uXG4gKi9cbmNsYXNzIFR4Qm9keSBleHRlbmRzIENib3JEYXRhIHtcblx0LyoqXG5cdCAqIElucHV0cyBtdXN0IGJlIHNvcnRlZCBiZWZvcmUgc3VibWl0dGluZyAoZmlyc3QgYnkgVHhJZCwgdGhlbiBieSB1dHhvSW5kZXgpXG5cdCAqIFNwZW5kaW5nIHJlZGVlbWVycyBtdXN0IHBvaW50IHRvIHRoZSBzb3J0ZWQgaW5wdXRzXG5cdCAqIEB0eXBlIHtUeElucHV0W119IFxuXHQgKi9cblx0I2lucHV0cztcblxuXHQvKiogQHR5cGUge1R4T3V0cHV0W119ICovXG5cdCNvdXRwdXRzO1xuXG5cdC8qKiBAdHlwZSB7YmlnaW50fSBpbiBsb3ZlbGFjZSAqL1xuXHQjZmVlO1xuXG5cdC8qKiBAdHlwZSB7P2JpZ2ludH0gKi9cblx0I2xhc3RWYWxpZFNsb3Q7XG5cblx0LyoqIEB0eXBlIHtEQ2VydFtdfSAqL1xuXHQjY2VydHM7XG5cblx0LyoqXG5cdCAqIFdpdGhkcmF3YWxzIG11c3QgYmUgc29ydGVkIGJ5IGFkZHJlc3Ncblx0ICogU3Rha2UgcmV3YXJkaW5nIHJlZGVlbWVycyBtdXN0IHBvaW50IHRvIHRoZSBzb3J0ZWQgd2l0aGRyYXdhbHNcblx0ICogQHR5cGUge01hcDxBZGRyZXNzLCBiaWdpbnQ+fSBcblx0ICovXG5cdCN3aXRoZHJhd2FscztcblxuXHQvKiogQHR5cGUgez9iaWdpbnR9ICovXG5cdCNmaXJzdFZhbGlkU2xvdDtcblxuXHQvKipcblx0ICogSW50ZXJuYWxseSB0aGUgYXNzZXRzIG11c3QgYmUgc29ydGVkIGJ5IG1pbnRpbmdwb2xpY3loYXNoXG5cdCAqIE1pbnRpbmcgcmVkZWVtZXJzIG11c3QgcG9pbnQgdG8gdGhlIHNvcnRlZCBtaW50ZWQgYXNzZXRzXG5cdCAqIEB0eXBlIHtBc3NldHN9IFxuXHQgKi9cblx0I21pbnRlZDtcblxuXHQvKiogQHR5cGUgez9IYXNofSAqL1xuXHQjc2NyaXB0RGF0YUhhc2g7XG5cblx0LyoqIEB0eXBlIHtUeElucHV0W119ICovXG5cdCNjb2xsYXRlcmFsO1xuXG5cdC8qKiBAdHlwZSB7UHViS2V5SGFzaFtdfSAqL1xuXHQjc2lnbmVycztcblxuXHQvKiogQHR5cGUgez9UeE91dHB1dH0gKi9cblx0I2NvbGxhdGVyYWxSZXR1cm47XG5cblx0LyoqIEB0eXBlIHtiaWdpbnR9ICovXG5cdCN0b3RhbENvbGxhdGVyYWw7XG5cblx0LyoqIEB0eXBlIHtUeElucHV0W119ICovXG5cdCNyZWZJbnB1dHM7XG5cblx0LyoqIEB0eXBlIHs/SGFzaH0gKi9cblx0I21ldGFkYXRhSGFzaDtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy4jaW5wdXRzID0gW107XG5cdFx0dGhpcy4jb3V0cHV0cyA9IFtdO1xuXHRcdHRoaXMuI2ZlZSA9IDBuO1xuXHRcdHRoaXMuI2xhc3RWYWxpZFNsb3QgPSBudWxsO1xuXHRcdHRoaXMuI2NlcnRzID0gW107XG5cdFx0dGhpcy4jd2l0aGRyYXdhbHMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy4jZmlyc3RWYWxpZFNsb3QgPSBudWxsO1xuXHRcdHRoaXMuI21pbnRlZCA9IG5ldyBBc3NldHMoKTsgLy8gc3RhcnRzIGFzIHplcm8gdmFsdWUgKGkuZS4gZW1wdHkgbWFwKVxuXHRcdHRoaXMuI3NjcmlwdERhdGFIYXNoID0gbmV3IEhhc2goKG5ldyBBcnJheSgzMikpLmZpbGwoMCkpOyAvLyBpbml0aWFsbHkgZHVtbXkgZm9yIG1vcmUgY29ycmVjdCBib2R5IHNpemUsIChyZSljYWxjdWxhdGVkIHVwb24gZmluYWxpemF0aW9uXG5cdFx0dGhpcy4jY29sbGF0ZXJhbCA9IFtdO1xuXHRcdHRoaXMuI3NpZ25lcnMgPSBbXTtcblx0XHR0aGlzLiNjb2xsYXRlcmFsUmV0dXJuID0gbnVsbDtcblx0XHR0aGlzLiN0b3RhbENvbGxhdGVyYWwgPSAwbjsgLy8gZG9lc24ndCBzZWVtIHRvIGJlIHVzZWQgYW55bW9yZVxuXHRcdHRoaXMuI3JlZklucHV0cyA9IFtdO1xuXHRcdHRoaXMuI21ldGFkYXRhSGFzaCA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R4SW5wdXRbXX1cblx0ICovXG5cdGdldCBpbnB1dHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2lucHV0cztcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhPdXRwdXRbXX1cblx0ICovXG5cdGdldCBvdXRwdXRzKCkge1xuXHRcdHJldHVybiB0aGlzLiNvdXRwdXRzO1xuXHR9XG5cblx0Z2V0IGZlZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jZmVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBmZWVcblx0ICovXG5cdHNldEZlZShmZWUpIHtcblx0XHR0aGlzLiNmZWUgPSBmZWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge0Fzc2V0c31cblx0ICovXG5cdGdldCBtaW50ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI21pbnRlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhJbnB1dFtdfVxuXHQgKi9cblx0Z2V0IGNvbGxhdGVyYWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2NvbGxhdGVyYWw7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXJbXT59XG5cdFx0ICovXG5cdFx0bGV0IG9iamVjdCA9IG5ldyBNYXAoKTtcblxuXHRcdG9iamVjdC5zZXQoMCwgQ2JvckRhdGEuZW5jb2RlRGVmTGlzdCh0aGlzLiNpbnB1dHMpKTtcblx0XHRvYmplY3Quc2V0KDEsIENib3JEYXRhLmVuY29kZURlZkxpc3QodGhpcy4jb3V0cHV0cykpO1xuXHRcdG9iamVjdC5zZXQoMiwgQ2JvckRhdGEuZW5jb2RlSW50ZWdlcih0aGlzLiNmZWUpKTtcblx0XHRcblx0XHRpZiAodGhpcy4jbGFzdFZhbGlkU2xvdCAhPT0gbnVsbCkge1xuXHRcdFx0b2JqZWN0LnNldCgzLCBDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKHRoaXMuI2xhc3RWYWxpZFNsb3QpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jY2VydHMubGVuZ3RoICE9IDApIHtcblx0XHRcdG9iamVjdC5zZXQoNCwgQ2JvckRhdGEuZW5jb2RlRGVmTGlzdCh0aGlzLiNjZXJ0cykpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiN3aXRoZHJhd2Fscy5zaXplICE9IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI21ldGFkYXRhSGFzaCAhPT0gbnVsbCkge1xuXHRcdFx0b2JqZWN0LnNldCg3LCB0aGlzLiNtZXRhZGF0YUhhc2gudG9DYm9yKCkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNmaXJzdFZhbGlkU2xvdCAhPT0gbnVsbCkge1xuXHRcdFx0b2JqZWN0LnNldCg4LCBDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKHRoaXMuI2ZpcnN0VmFsaWRTbG90KSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLiNtaW50ZWQuaXNaZXJvKCkpIHtcblx0XHRcdG9iamVjdC5zZXQoOSwgdGhpcy4jbWludGVkLnRvQ2JvcigpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jc2NyaXB0RGF0YUhhc2ggIT09IG51bGwpIHtcblx0XHRcdG9iamVjdC5zZXQoMTEsIHRoaXMuI3NjcmlwdERhdGFIYXNoLnRvQ2JvcigpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jY29sbGF0ZXJhbC5sZW5ndGggIT0gMCkge1xuXHRcdFx0b2JqZWN0LnNldCgxMywgQ2JvckRhdGEuZW5jb2RlRGVmTGlzdCh0aGlzLiNjb2xsYXRlcmFsKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3NpZ25lcnMubGVuZ3RoICE9IDApIHtcblx0XHRcdG9iamVjdC5zZXQoMTQsIENib3JEYXRhLmVuY29kZURlZkxpc3QodGhpcy4jc2lnbmVycykpO1xuXHRcdH1cblxuXHRcdC8vIHdoYXQgaXMgTmV0d29ya0lkIHVzZWQgZm9yP1xuXHRcdC8vb2JqZWN0LnNldCgxNSwgQ2JvckRhdGEuZW5jb2RlSW50ZWdlcigybikpO1xuXG5cdFx0aWYgKHRoaXMuI2NvbGxhdGVyYWxSZXR1cm4gIT09IG51bGwpIHtcblx0XHRcdG9iamVjdC5zZXQoMTYsIHRoaXMuI2NvbGxhdGVyYWxSZXR1cm4udG9DYm9yKCkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiN0b3RhbENvbGxhdGVyYWwgPiAwbikge1xuXHRcdFx0b2JqZWN0LnNldCgxNywgQ2JvckRhdGEuZW5jb2RlSW50ZWdlcih0aGlzLiN0b3RhbENvbGxhdGVyYWwpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jcmVmSW5wdXRzLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRvYmplY3Quc2V0KDE4LCBDYm9yRGF0YS5lbmNvZGVEZWZMaXN0KHRoaXMuI3JlZklucHV0cykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVPYmplY3Qob2JqZWN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7VHhCb2R5fVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0bGV0IHR4Qm9keSA9IG5ldyBUeEJvZHkoKTtcblxuXHRcdGxldCBkb25lID0gQ2JvckRhdGEuZGVjb2RlT2JqZWN0KGJ5dGVzLCAoaSwgZmllbGRCeXRlcykgPT4ge1xuXHRcdFx0c3dpdGNoKGkpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUxpc3QoZmllbGRCeXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0XHRcdFx0dHhCb2R5LiNpbnB1dHMucHVzaChUeElucHV0LmZyb21DYm9yKGl0ZW1CeXRlcykpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChmaWVsZEJ5dGVzLCAoXywgaXRlbUJ5dGVzKSA9PiB7XG5cdFx0XHRcdFx0XHR0eEJvZHkuI291dHB1dHMucHVzaChUeE91dHB1dC5mcm9tQ2JvcihpdGVtQnl0ZXMpKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0dHhCb2R5LiNmZWUgPSBDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0dHhCb2R5LiNsYXN0VmFsaWRTbG90ID0gQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUxpc3QoZmllbGRCeXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0XHRcdFx0dHhCb2R5LiNjZXJ0cy5wdXNoKERDZXJ0LmZyb21DYm9yKGl0ZW1CeXRlcykpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDU6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0XHRcdFx0Y2FzZSA2OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdFx0XHRcdGNhc2UgNzpcblx0XHRcdFx0XHR0eEJvZHkuI21ldGFkYXRhSGFzaCA9IEhhc2guZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHR0eEJvZHkuI2ZpcnN0VmFsaWRTbG90ID0gQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA5OlxuXHRcdFx0XHRcdHR4Qm9keS4jbWludGVkID0gQXNzZXRzLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDEwOlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBmaWVsZFwiKTtcblx0XHRcdFx0Y2FzZSAxMTpcblx0XHRcdFx0XHR0eEJvZHkuI3NjcmlwdERhdGFIYXNoID0gSGFzaC5mcm9tQ2JvcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxMjpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmhhbmRsZWQgZmllbGRcIik7XG5cdFx0XHRcdGNhc2UgMTM6XG5cdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChmaWVsZEJ5dGVzLCAoXywgaXRlbUJ5dGVzKSA9PiB7XG5cdFx0XHRcdFx0XHR0eEJvZHkuI2NvbGxhdGVyYWwucHVzaChUeElucHV0LmZyb21DYm9yKGl0ZW1CeXRlcykpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE0OlxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUxpc3QoZmllbGRCeXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0XHRcdFx0dHhCb2R5LiNzaWduZXJzLnB1c2goUHViS2V5SGFzaC5mcm9tQ2JvcihpdGVtQnl0ZXMpKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxNTpcblx0XHRcdFx0XHRhc3NlcnQoQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihmaWVsZEJ5dGVzKSA9PSAybik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0dHhCb2R5LiNjb2xsYXRlcmFsUmV0dXJuID0gVHhPdXRwdXQuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTc6XG5cdFx0XHRcdFx0dHhCb2R5LiN0b3RhbENvbGxhdGVyYWwgPSBDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE4OlxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUxpc3QoZmllbGRCeXRlcywgaXRlbUJ5dGVzID0+IHtcblx0XHRcdFx0XHRcdHR4Qm9keS4jcmVmSW5wdXRzLnB1c2goVHhJbnB1dC5mcm9tQ2JvcihmaWVsZEJ5dGVzKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGZpZWxkXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGRvbmUuaGFzKDApICYmIGRvbmUuaGFzKDEpICYmIGRvbmUuaGFzKDIpKTtcblxuXHRcdHJldHVybiB0eEJvZHk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlucHV0czogdGhpcy4jaW5wdXRzLm1hcChpbnB1dCA9PiBpbnB1dC5kdW1wKCkpLFxuXHRcdFx0b3V0cHV0czogdGhpcy4jb3V0cHV0cy5tYXAob3V0cHV0ID0+IG91dHB1dC5kdW1wKCkpLFxuXHRcdFx0ZmVlOiB0aGlzLiNmZWUudG9TdHJpbmcoKSxcblx0XHRcdGxhc3RWYWxpZFNsb3Q6IHRoaXMuI2xhc3RWYWxpZFNsb3QgPT09IG51bGwgPyBudWxsIDogdGhpcy4jbGFzdFZhbGlkU2xvdC50b1N0cmluZygpLFxuXHRcdFx0Zmlyc3RWYWxpZFNsb3Q6IHRoaXMuI2ZpcnN0VmFsaWRTbG90ID09PSBudWxsID8gbnVsbCA6IHRoaXMuI2ZpcnN0VmFsaWRTbG90LnRvU3RyaW5nKCksXG5cdFx0XHRtaW50ZWQ6IHRoaXMuI21pbnRlZC5pc1plcm8oKSA/IG51bGwgOiB0aGlzLiNtaW50ZWQuZHVtcCgpLFxuXHRcdFx0bWV0YWRhdGFIYXNoOiB0aGlzLiNtZXRhZGF0YUhhc2ggPT09IG51bGwgPyBudWxsIDogdGhpcy4jbWV0YWRhdGFIYXNoLmR1bXAoKSxcblx0XHRcdHNjcmlwdERhdGFIYXNoOiB0aGlzLiNzY3JpcHREYXRhSGFzaCA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLiNzY3JpcHREYXRhSGFzaC5kdW1wKCksXG5cdFx0XHRjb2xsYXRlcmFsOiB0aGlzLiNjb2xsYXRlcmFsLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMuI2NvbGxhdGVyYWwubWFwKGMgPT4gYy5kdW1wKCkpLFxuXHRcdFx0c2lnbmVyczogdGhpcy4jc2lnbmVycy5sZW5ndGggPT0gMCA/IG51bGwgOiB0aGlzLiNzaWduZXJzLm1hcChycyA9PiBycy5kdW1wKCkpLFxuXHRcdFx0Y29sbGF0ZXJhbFJldHVybjogdGhpcy4jY29sbGF0ZXJhbFJldHVybiA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLiNjb2xsYXRlcmFsUmV0dXJuLmR1bXAoKSxcblx0XHRcdC8vdG90YWxDb2xsYXRlcmFsOiB0aGlzLiN0b3RhbENvbGxhdGVyYWwudG9TdHJpbmcoKSwgLy8gZG9lc24ndCBzZWVtIHRvIGJlIHVzZWQgYW55bW9yZVxuXHRcdFx0cmVmSW5wdXRzOiB0aGlzLiNyZWZJbnB1dHMubWFwKHJpID0+IHJpLmR1bXAoKSksXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3Igbm93IHNpbXBseSByZXR1cm5zIG1pbnVzIGluZmluaXR5IHRvIHBsdXMgaW5maW5pdHkgKFdpUClcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0dG9WYWxpZFRpbWVSYW5nZURhdGEobmV0d29ya1BhcmFtcykge1xuXHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgwLCBbXG5cdFx0XHRuZXcgQ29uc3RyRGF0YSgwLCBbIC8vIExvd2VyQm91bmRcblx0XHRcdFx0dGhpcy4jZmlyc3RWYWxpZFNsb3QgPT09IG51bGwgPyBuZXcgQ29uc3RyRGF0YSgwLCBbXSkgOiBuZXcgQ29uc3RyRGF0YSgxLCBbbmV3IEludERhdGEobmV0d29ya1BhcmFtcy5zbG90VG9UaW1lKHRoaXMuI2ZpcnN0VmFsaWRTbG90KSldKSwgLy8gTmVnSW5mXG5cdFx0XHRcdG5ldyBDb25zdHJEYXRhKDEsIFtdKSwgLy8gdHJ1ZVxuXHRcdFx0XSksXG5cdFx0XHRuZXcgQ29uc3RyRGF0YSgwLCBbIC8vIFVwcGVyQm91bmRcblx0XHRcdFx0dGhpcy4jbGFzdFZhbGlkU2xvdCA9PT0gbnVsbCA/IG5ldyBDb25zdHJEYXRhKDIsIFtdKSA6IG5ldyBDb25zdHJEYXRhKDEsIFtuZXcgSW50RGF0YShuZXR3b3JrUGFyYW1zLnNsb3RUb1RpbWUodGhpcy4jbGFzdFZhbGlkU2xvdCkpXSksIC8vIFBvc0luZlxuXHRcdFx0XHRuZXcgQ29uc3RyRGF0YSgxLCBbXSksIC8vIHRydWVcblx0XHRcdF0pLFxuXHRcdF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKiBAcGFyYW0ge1JlZGVlbWVyW119IHJlZGVlbWVyc1xuXHQgKiBAcGFyYW0ge0xpc3REYXRhfSBkYXR1bXMgXG5cdCAqIEBwYXJhbSB7VHhJZH0gdHhJZFxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvVHhEYXRhKG5ldHdvcmtQYXJhbXMsIHJlZGVlbWVycywgZGF0dW1zLCB0eElkKSB7XG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcblx0XHRcdG5ldyBMaXN0RGF0YSh0aGlzLiNpbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LnRvRGF0YSgpKSksXG5cdFx0XHRuZXcgTGlzdERhdGEodGhpcy4jcmVmSW5wdXRzLm1hcChpbnB1dCA9PiBpbnB1dC50b0RhdGEoKSkpLFxuXHRcdFx0bmV3IExpc3REYXRhKHRoaXMuI291dHB1dHMubWFwKG91dHB1dCA9PiBvdXRwdXQudG9EYXRhKCkpKSxcblx0XHRcdChuZXcgVmFsdWUodGhpcy4jZmVlKSkuX3RvVXBsY0RhdGEoKSxcblx0XHRcdC8vIE5PVEU6IGFsbCBvdGhlciBWYWx1ZSBpbnN0YW5jZXMgaW4gU2NyaXB0Q29udGV4dCBjb250YWluIHNvbWUgbG92ZWxhY2UsIGJ1dCAjbWludGVkIGNhbiBuZXZlciBjb250YWluIGFueSBsb3ZlbGFjZSwgeWV0IGNhcmRhbm8tbm9kZSBhbHdheXMgcHJlcGVuZHMgMCBsb3ZlbGFjZSB0byB0aGUgI21pbnRlZCBNYXBEYXRhXG5cdFx0XHQobmV3IFZhbHVlKDBuLCB0aGlzLiNtaW50ZWQpKS5fdG9VcGxjRGF0YSh0cnVlKSwgXG5cdFx0XHRuZXcgTGlzdERhdGEodGhpcy4jY2VydHMubWFwKGNlcnQgPT4gY2VydC50b0RhdGEoKSkpLFxuXHRcdFx0bmV3IE1hcERhdGEoQXJyYXkuZnJvbSh0aGlzLiN3aXRoZHJhd2Fscy5lbnRyaWVzKCkpLm1hcCh3ID0+IFt3WzBdLnRvU3Rha2luZ0RhdGEoKSwgbmV3IEludERhdGEod1sxXSldKSksXG5cdFx0XHR0aGlzLnRvVmFsaWRUaW1lUmFuZ2VEYXRhKG5ldHdvcmtQYXJhbXMpLFxuXHRcdFx0bmV3IExpc3REYXRhKHRoaXMuI3NpZ25lcnMubWFwKHJzID0+IG5ldyBCeXRlQXJyYXlEYXRhKHJzLmJ5dGVzKSkpLFxuXHRcdFx0bmV3IE1hcERhdGEocmVkZWVtZXJzLm1hcChyID0+IFtyLnRvU2NyaXB0UHVycG9zZURhdGEodGhpcyksIHIuZGF0YV0pKSxcblx0XHRcdG5ldyBNYXBEYXRhKGRhdHVtcy5saXN0Lm1hcChkID0+IFtcblx0XHRcdFx0bmV3IEJ5dGVBcnJheURhdGEoQ3J5cHRvLmJsYWtlMmIoZC50b0Nib3IoKSkpLCBcblx0XHRcdFx0ZFxuXHRcdFx0XSkpLFxuXHRcdFx0bmV3IENvbnN0ckRhdGEoMCwgW25ldyBCeXRlQXJyYXlEYXRhKHR4SWQuYnl0ZXMpXSlcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXMgXG5cdCAqIEBwYXJhbSB7UmVkZWVtZXJbXX0gcmVkZWVtZXJzXG5cdCAqIEBwYXJhbSB7TGlzdERhdGF9IGRhdHVtc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gcmVkZWVtZXJJZHhcblx0ICogQHJldHVybnMge1VwbGNEYXRhfVxuXHQgKi9cblx0dG9TY3JpcHRDb250ZXh0RGF0YShuZXR3b3JrUGFyYW1zLCByZWRlZW1lcnMsIGRhdHVtcywgcmVkZWVtZXJJZHgpIHtcdFx0XG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcblx0XHRcdC8vIHR4ICh3ZSBjYW4ndCBrbm93IHRoZSB0eElkIHJpZ2h0IG5vdywgYmVjYXVzZSB3ZSBkb24ndCBrbm93IHRoZSBleGVjdXRpb24gY29zdHMgeWV0LCBidXQgYSBkdW1teSB0eElkIHNob3VsZCBiZSBmaW5lKVxuXHRcdFx0dGhpcy50b1R4RGF0YShuZXR3b3JrUGFyYW1zLCByZWRlZW1lcnMsIGRhdHVtcywgVHhJZC5kdW1teSgpKSxcblx0XHRcdHJlZGVlbWVyc1tyZWRlZW1lcklkeF0udG9TY3JpcHRQdXJwb3NlRGF0YSh0aGlzKSxcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VmFsdWV9XG5cdCAqL1xuXHRzdW1JbnB1dFZhbHVlKCkge1xuXHRcdGxldCBzdW0gPSBuZXcgVmFsdWUoKTtcblxuXHRcdGZvciAobGV0IGlucHV0IG9mIHRoaXMuI2lucHV0cykge1xuXHRcdFx0aWYgKGlucHV0Lm9yaWdPdXRwdXQgIT09IG51bGwpIHtcblx0XHRcdFx0c3VtID0gc3VtLmFkZChpbnB1dC5vcmlnT3V0cHV0LnZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBlcnJvciBpZiBhbnkgcGFydCBvZiB0aGUgc3VtIGlzIG5lZ2F0aXZlIChpLmUuIG1vcmUgaXMgYnVybmVkIHRoYW4gaW5wdXQpXG5cdCAqIEByZXR1cm5zIHtWYWx1ZX1cblx0ICovXG5cdHN1bUlucHV0QW5kTWludGVkVmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3VtSW5wdXRWYWx1ZSgpLmFkZChuZXcgVmFsdWUoMG4sIHRoaXMuI21pbnRlZCkpLmFzc2VydEFsbFBvc2l0aXZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0Fzc2V0c31cblx0ICovXG5cdHN1bUlucHV0QW5kTWludGVkQXNzZXRzKCkge1xuXHRcdHJldHVybiB0aGlzLnN1bUlucHV0QW5kTWludGVkVmFsdWUoKS5hc3NldHM7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1ZhbHVlfVxuXHQgKi9cblx0c3VtT3V0cHV0VmFsdWUoKSB7XG5cdFx0bGV0IHN1bSA9IG5ldyBWYWx1ZSgpO1xuXG5cdFx0Zm9yIChsZXQgb3V0cHV0IG9mIHRoaXMuI291dHB1dHMpIHtcblx0XHRcdHN1bSA9IHN1bS5hZGQob3V0cHV0LnZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtBc3NldHN9XG5cdCAqL1xuXHRzdW1PdXRwdXRBc3NldHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3VtT3V0cHV0VmFsdWUoKS5hc3NldHM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtiaWdpbnR9IHNsb3Rcblx0ICovXG5cdHZhbGlkRnJvbShzbG90KSB7XG5cdFx0dGhpcy4jZmlyc3RWYWxpZFNsb3QgPSBzbG90O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YmlnaW50fSBzbG90XG5cdCAqL1xuXHR2YWxpZFRvKHNsb3QpIHtcblx0XHR0aGlzLiNsYXN0VmFsaWRTbG90ID0gc2xvdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgdGhpcy4jbWludGVkIGFscmVhZHkgY29udGFpbnMgbXBoXG5cdCAqIEBwYXJhbSB7TWludGluZ1BvbGljeUhhc2h9IG1waCAtIG1pbnRpbmcgcG9saWN5IGhhc2hcblx0ICogQHBhcmFtIHtbbnVtYmVyW10sIGJpZ2ludF1bXX0gdG9rZW5zXG5cdCAqL1xuXHRhZGRNaW50KG1waCwgdG9rZW5zKSB7XG5cdFx0dGhpcy4jbWludGVkLmFkZFRva2VucyhtcGgsIHRva2Vucyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUeElucHV0fSBpbnB1dCBcblx0ICogQHBhcmFtIHtib29sZWFufSBjaGVja1VuaXF1ZW5lc3Ncblx0ICovXG5cdGFkZElucHV0KGlucHV0LCBjaGVja1VuaXF1ZW5lc3MgPSB0cnVlKSB7XG5cdFx0aWYgKGlucHV0Lm9yaWdPdXRwdXQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR4SW5wdXQub3JpZ091dHB1dCBtdXN0IGJlIHNldCB3aGVuIGJ1aWxkaW5nIHRyYW5zYWN0aW9uXCIpO1xuXHRcdH1cblxuXHRcdGlucHV0Lm9yaWdPdXRwdXQudmFsdWUuYXNzZXJ0QWxsUG9zaXRpdmUoKTtcblxuXHRcdGlmIChjaGVja1VuaXF1ZW5lc3MpIHtcblx0XHRcdGFzc2VydCh0aGlzLiNpbnB1dHMuZXZlcnkocHJldklucHV0ID0+IHtcblx0XHRcdFx0cmV0dXJuICAhcHJldklucHV0LnR4SWQuZXEoaW5wdXQudHhJZCkgfHwgcHJldklucHV0LnV0eG9JZHggIT0gaW5wdXQudXR4b0lkeFxuXHRcdFx0fSksIFwiaW5wdXQgYWxyZWFkeSBhZGRlZCBiZWZvcmVcIik7XG5cdFx0fVxuXG5cdFx0Ly8gcHVzaCwgdGhlbiBzb3J0IGltbWVkaWF0ZWx5XG5cdFx0dGhpcy4jaW5wdXRzLnB1c2goaW5wdXQpO1xuXHRcdHRoaXMuI2lucHV0cy5zb3J0KFR4SW5wdXQuY29tcCk7XG5cdH1cblxuXHQvKipcblx0ICogVXNlZCB0byByZW1vdmUgZHVtbXkgaW5wdXRzXG5cdCAqIER1bW15IGlucHV0cyBhcmUgbmVlZGVkIHRvIGJlIGFibGUgdG8gY29ycmVjdGx5IGVzdGltYXRlIGZlZXNcblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIGlucHV0IGRvZXNuJ3QgZXhpc3QgaW4gbGlzdCBvZiBpbnB1dHNcblx0ICogSW50ZXJuYWwgdXNlIG9ubHkhXG5cdCAqIEBwYXJhbSB7VHhJbnB1dH0gaW5wdXRcblx0ICovXG5cdHJlbW92ZUlucHV0KGlucHV0KSB7XG5cdFx0bGV0IGlkeCA9IC0xO1xuXG5cdFx0Ly8gc2VhcmNoIGZyb20gZW5kLCBzbyByZW1vdmFsIGlzIGV4YWN0IGludmVyc2Ugb2YgYWRkaXRpb25cblx0XHRmb3IgKGxldCBpID0gdGhpcy4jaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAodGhpcy4jaW5wdXRzW2ldID09IGlucHV0KSB7XG5cdFx0XHRcdGlkeCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IG4gPSB0aGlzLiNpbnB1dHMubGVuZ3RoO1xuXG5cdFx0YXNzZXJ0KGlkeCAhPSAtMSwgXCJpbnB1dCBub3QgZm91bmRcIik7XG5cblx0XHR0aGlzLiNpbnB1dHMgPSB0aGlzLiNpbnB1dHMuZmlsdGVyKChfLCBpKSA9PiBpICE9IGlkeCk7XG5cblx0XHRhc3NlcnQodGhpcy4jaW5wdXRzLmxlbmd0aCA9PSBuIC0gMSwgXCJpbnB1dCBub3QgcmVtb3ZlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4SW5wdXR9IGlucHV0IFxuXHQgKi9cblx0YWRkUmVmSW5wdXQoaW5wdXQpIHtcblx0XHR0aGlzLiNyZWZJbnB1dHMucHVzaChpbnB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUeE91dHB1dH0gb3V0cHV0XG5cdCAqL1xuXHRhZGRPdXRwdXQob3V0cHV0KSB7XG5cdFx0b3V0cHV0LnZhbHVlLmFzc2VydEFsbFBvc2l0aXZlKCk7XG5cblx0XHR0aGlzLiNvdXRwdXRzLnB1c2gob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHJlbW92ZSBkdW1teSBvdXRwdXRzXG5cdCAqIER1bW15IG91dHB1dHMgYXJlIG5lZWRlZCB0byBiZSBhYmxlIHRvIGNvcnJlY3RseSBlc3RpbWF0ZSBmZWVzXG5cdCAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgb3V0cHV0IGRvZXNuJ3QgZXhpc3QgaW4gbGlzdCBvZiBvdXRwdXRzXG5cdCAqIEludGVybmFsIHVzZSBvbmx5IVxuXHQgKiBAcGFyYW0ge1R4T3V0cHV0fSBvdXRwdXQgXG5cdCAqL1xuXHRyZW1vdmVPdXRwdXQob3V0cHV0KSB7XG5cdFx0bGV0IGlkeCA9IC0xO1xuXG5cdFx0Ly8gc2VhcmNoIGZyb20gZW5kLCBzbyByZW1vdmFsIGlzIGV4YWN0IGludmVyc2Ugb2YgYWRkaXRpb25cblx0XHRmb3IgKGxldCBpID0gdGhpcy4jb3V0cHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKHRoaXMuI291dHB1dHNbaV0gPT0gb3V0cHV0KSB7XG5cdFx0XHRcdGlkeCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IG4gPSB0aGlzLiNvdXRwdXRzLmxlbmd0aDtcblxuXHRcdGFzc2VydChpZHggIT0gLTEsIFwib3V0cHV0IG5vdCBmb3VuZFwiKTtcblxuXHRcdHRoaXMuI291dHB1dHMgPSB0aGlzLiNvdXRwdXRzLmZpbHRlcigoXywgaSkgPT4gaSAhPSBpZHgpO1xuXG5cdFx0YXNzZXJ0KHRoaXMuI291dHB1dHMubGVuZ3RoID09IG4gLSAxLCBcIm91dHB1dCBub3QgcmVtb3ZlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1B1YktleUhhc2h9IGhhc2ggXG5cdCAqL1xuXHRhZGRTaWduZXIoaGFzaCkge1xuXHRcdHRoaXMuI3NpZ25lcnMucHVzaChoYXNoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4SW5wdXR9IGlucHV0IFxuXHQgKi9cblx0YWRkQ29sbGF0ZXJhbChpbnB1dCkge1xuXHRcdHRoaXMuI2NvbGxhdGVyYWwucHVzaChpbnB1dCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0hhc2ggfCBudWxsfSBzY3JpcHREYXRhSGFzaFxuXHQgKi9cblx0c2V0U2NyaXB0RGF0YUhhc2goc2NyaXB0RGF0YUhhc2gpIHtcblx0XHR0aGlzLiNzY3JpcHREYXRhSGFzaCA9IHNjcmlwdERhdGFIYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7SGFzaH0gbWV0YWRhdGFIYXNoXG5cdCAqL1xuXHRzZXRNZXRhZGF0YUhhc2gobWV0YWRhdGFIYXNoKSB7XG5cdFx0dGhpcy4jbWV0YWRhdGFIYXNoID0gbWV0YWRhdGFIYXNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhPdXRwdXQgfCBudWxsfSBvdXRwdXQgXG5cdCAqL1xuXHRzZXRDb2xsYXRlcmFsUmV0dXJuKG91dHB1dCkge1xuXHRcdHRoaXMuI2NvbGxhdGVyYWxSZXR1cm4gPSBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGR1bW15IHNpZ25hdHVyZXMgbmVlZGVkIHRvIGdldCBwcmVjaXNlbHkgdGhlIHJpZ2h0IHR4IHNpemVcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdGNvdW50VW5pcXVlU2lnbmVycygpIHtcblx0XHQvKiogQHR5cGUge1NldDxQdWJLZXlIYXNoPn0gKi9cblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xuXG5cdFx0Y29uc3QgaW5wdXRzID0gdGhpcy4jaW5wdXRzLmNvbmNhdCh0aGlzLiNjb2xsYXRlcmFsKTtcblxuXHRcdGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuXHRcdFx0bGV0IG9yaWdPdXRwdXQgPSBpbnB1dC5vcmlnT3V0cHV0O1xuXG5cdFx0XHRpZiAob3JpZ091dHB1dCAhPT0gbnVsbCkge1xuXHRcdFx0XHRsZXQgcHViS2V5SGFzaCA9IG9yaWdPdXRwdXQuYWRkcmVzcy5wdWJLZXlIYXNoO1xuXG5cdFx0XHRcdGlmIChwdWJLZXlIYXNoICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0c2V0LmFkZChwdWJLZXlIYXNoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IHJzIG9mIHRoaXMuI3NpZ25lcnMpIHtcblx0XHRcdHNldC5hZGQocnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZXQuc2l6ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTY3JpcHQgaGFzaGVzIGFyZSBmb3VuZCBpbiBhZGRyZXNzZXMgb2YgVHhJbnB1dHMgYW5kIGhhc2hlcyBvZiB0aGUgbWludGVkIE11bHRpQXNzZXRcblx0ICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBzZXQgLSBoYXNoZXMgaW4gaGV4IGZvcm1hdFxuXHQgKi9cblx0Y29sbGVjdFNjcmlwdEhhc2hlcyhzZXQpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI2lucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5wdXQgPSB0aGlzLiNpbnB1dHNbaV07XG5cblx0XHRcdGlmIChpbnB1dC5vcmlnT3V0cHV0ICE9PSBudWxsKSB7XG5cdFx0XHRcdGxldCBzY3JpcHRIYXNoID0gaW5wdXQub3JpZ091dHB1dC5hZGRyZXNzLnZhbGlkYXRvckhhc2g7XG5cblx0XHRcdFx0aWYgKHNjcmlwdEhhc2ggIT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCBoYXNoID0gYnl0ZXNUb0hleChzY3JpcHRIYXNoLmJ5dGVzKTtcblxuXHRcdFx0XHRcdGlmICghc2V0LmhhcyhoYXNoKSkgeyBcblx0XHRcdFx0XHRcdHNldC5zZXQoaGFzaCwgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IG1waHMgPSB0aGlzLiNtaW50ZWQubWludGluZ1BvbGljaWVzO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtcGhzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBtcGggPSBtcGhzW2ldO1xuXG5cdFx0XHRjb25zdCBoYXNoID0gYnl0ZXNUb0hleChtcGguYnl0ZXMpO1xuXG5cdFx0XHRpZiAoIXNldC5oYXMoaGFzaCkpIHtcblx0XHRcdFx0c2V0LnNldChoYXNoLCAtaS0xKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgc3VyZSBlYWNoIG91dHB1dCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IG1pbiBsb3ZlbGFjZVxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICovXG5cdGNvcnJlY3RPdXRwdXRzKG5ldHdvcmtQYXJhbXMpIHtcblx0XHRmb3IgKGxldCBvdXRwdXQgb2YgdGhpcy4jb3V0cHV0cykge1xuXHRcdFx0b3V0cHV0LmNvcnJlY3RMb3ZlbGFjZShuZXR3b3JrUGFyYW1zKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIHRoYXQgZWFjaCBvdXRwdXQgY29udGFpbnMgZW5vdWdoIGxvdmVsYWNlXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKi9cblx0Y2hlY2tPdXRwdXRzKG5ldHdvcmtQYXJhbXMpIHtcblx0XHRmb3IgKGxldCBvdXRwdXQgb2YgdGhpcy4jb3V0cHV0cykge1xuXHRcdFx0bGV0IG1pbkxvdmVsYWNlID0gb3V0cHV0LmNhbGNNaW5Mb3ZlbGFjZShuZXR3b3JrUGFyYW1zKTtcblxuXHRcdFx0YXNzZXJ0KG1pbkxvdmVsYWNlIDw9IG91dHB1dC52YWx1ZS5sb3ZlbGFjZSwgYG5vdCBlbm91Z2ggbG92ZWxhY2UgaW4gb3V0cHV0IChleHBlY3RlZCBhdCBsZWFzdCAke21pbkxvdmVsYWNlLnRvU3RyaW5nKCl9LCBnb3QgJHtvdXRwdXQudmFsdWUubG92ZWxhY2V9KWApO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtc1xuXHQgKiBAcGFyYW0gez9iaWdpbnR9IG1pbkNvbGxhdGVyYWwgXG5cdCAqL1xuXHRjaGVja0NvbGxhdGVyYWwobmV0d29ya1BhcmFtcywgbWluQ29sbGF0ZXJhbCkge1xuXHRcdGFzc2VydCh0aGlzLiNjb2xsYXRlcmFsLmxlbmd0aCA8PSBuZXR3b3JrUGFyYW1zLm1heENvbGxhdGVyYWxJbnB1dHMpO1xuXG5cdFx0aWYgKG1pbkNvbGxhdGVyYWwgPT09IG51bGwpIHtcblx0XHRcdGFzc2VydCh0aGlzLiNjb2xsYXRlcmFsLmxlbmd0aCA9PSAwLCBcInVubmVjZXNzYXJ5IGNvbGxhdGVyYWwgaW5jbHVkZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBzdW0gPSBuZXcgVmFsdWUoKTtcblxuXHRcdFx0Zm9yIChsZXQgY29sIG9mIHRoaXMuI2NvbGxhdGVyYWwpIHtcblx0XHRcdFx0aWYgKGNvbC5vcmlnT3V0cHV0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgY29sbGF0ZXJhbCBUeElucHV0Lm9yaWdPdXRwdXQgdG8gYmUgc2V0XCIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFjb2wub3JpZ091dHB1dC52YWx1ZS5hc3NldHMuaXNaZXJvKCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjb2xsYXRlcmFsIGNhbiBvbmx5IGNvbnRhaW4gbG92ZWxhY2VcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3VtID0gc3VtLmFkZChjb2wub3JpZ091dHB1dC52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuI2NvbGxhdGVyYWxSZXR1cm4gIT0gbnVsbCkge1xuXHRcdFx0XHRzdW0gPSBzdW0uc3ViKHRoaXMuI2NvbGxhdGVyYWxSZXR1cm4udmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3NlcnQoc3VtLmxvdmVsYWNlID49IG1pbkNvbGxhdGVyYWwsIFwibm90IGVub3VnaCBjb2xsYXRlcmFsXCIpO1xuXG5cdFx0XHRpZiAoc3VtLmxvdmVsYWNlID4gbWluQ29sbGF0ZXJhbCo1bil7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3YXkgdG9vIG11Y2ggY29sbGF0ZXJhbFwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWFrZXMgc29yZSBpbnB1dHMsIHdpdGhkcmF3YWxzLCBhbmQgbWludGVkIGFzc2V0cyBhcmUgaW4gY29ycmVjdCBvcmRlclxuXHQgKiBNdXRhdGVzXG5cdCAqL1xuXHRzb3J0KCkge1xuXHRcdC8vIGlucHV0cyBzaG91bGQndmUgYmVlbiBhZGRlZCBpbiBzb3J0ZWQgbWFubmVyLCBzbyB0aGlzIGlzIGp1c3QgYSBjaGVja1xuXHRcdHRoaXMuI2lucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IHByZXYgPSB0aGlzLiNpbnB1dHNbaS0xXTtcblxuXHRcdFx0XHQvLyBjYW4gYmUgbGVzcyB0aGFuIC0xIGlmIHV0eG9JZHMgYXJlbid0IGNvbnNlY3V0aXZlXG5cdFx0XHRcdGFzc2VydChUeElucHV0LmNvbXAocHJldiwgaW5wdXQpIDw9IC0xLCBcImlucHV0cyBub3Qgc29ydGVkXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gVE9ETzogYWxzbyBhZGQgd2l0aGRyYXdhbHMgaW4gc29ydGVkIG1hbm5lclxuXHRcdHRoaXMuI3dpdGhkcmF3YWxzID0gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuI3dpdGhkcmF3YWxzLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0cmV0dXJuIEFkZHJlc3MuY29tcFN0YWtpbmdIYXNoZXMoYVswXSwgYlswXSk7XG5cdFx0fSkpO1xuXG5cdFx0Ly8gbWludGVkIGFzc2V0cyBzaG91bGQndmUgYmVlbiBhZGRlZCBpbiBzb3J0ZWQgbWFubmVyLCBzbyB0aGlzIGlzIGp1c3QgYSBjaGVja1xuXHRcdHRoaXMuI21pbnRlZC5hc3NlcnRTb3J0ZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VkIGJ5IChpbmRpcmVjdGx5KSBieSBlbXVsYXRvciB0byBjaGVjayBpZiBzbG90IHJhbmdlIGlzIHZhbGlkLlxuXHQgKiBAcGFyYW0ge2JpZ2ludH0gc2xvdFxuXHQgKi9cblx0aXNWYWxpZChzbG90KSB7XG5cdFx0aWYgKHRoaXMuI2xhc3RWYWxpZFNsb3QgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHNsb3QgPiB0aGlzLiNsYXN0VmFsaWRTbG90KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy4jZmlyc3RWYWxpZFNsb3QgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHNsb3QgPCB0aGlzLiNmaXJzdFZhbGlkU2xvdCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFR4V2l0bmVzc2VzIGV4dGVuZHMgQ2JvckRhdGEge1xuXHQvKiogQHR5cGUge1NpZ25hdHVyZVtdfSAqL1xuXHQjc2lnbmF0dXJlcztcblxuXHQvKiogQHR5cGUge0xpc3REYXRhfSAqL1xuXHQjZGF0dW1zO1xuXG5cdC8qKiBAdHlwZSB7UmVkZWVtZXJbXX0gKi9cblx0I3JlZGVlbWVycztcblxuXHQvKiogQHR5cGUge1VwbGNQcm9ncmFtW119ICovXG5cdCNzY3JpcHRzO1xuXG5cdC8qKiBAdHlwZSB7VXBsY1Byb2dyYW1bXX0gKi9cblx0I3JlZlNjcmlwdHM7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNzaWduYXR1cmVzID0gW107XG5cdFx0dGhpcy4jZGF0dW1zID0gbmV3IExpc3REYXRhKFtdKTtcblx0XHR0aGlzLiNyZWRlZW1lcnMgPSBbXTtcblx0XHR0aGlzLiNzY3JpcHRzID0gW107XG5cdFx0dGhpcy4jcmVmU2NyaXB0cyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTaWduYXR1cmVbXX1cblx0ICovXG5cdGdldCBzaWduYXR1cmVzKCkge1xuXHRcdHJldHVybiB0aGlzLiNzaWduYXR1cmVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHRoZSBzY3JpcHRzLCBpbmNsdWRpbmcgdGhlIHJlZmVyZW5jZSBzY3JpcHRzXG5cdCAqIEB0eXBlIHtVcGxjUHJvZ3JhbVtdfVxuXHQgKi9cblx0Z2V0IHNjcmlwdHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3NjcmlwdHMuc2xpY2UoKS5jb25jYXQodGhpcy4jcmVmU2NyaXB0cy5zbGljZSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcltdPn1cblx0XHQgKi9cblx0XHRsZXQgb2JqZWN0ID0gbmV3IE1hcCgpO1xuXG5cdFx0aWYgKHRoaXMuI3NpZ25hdHVyZXMubGVuZ3RoICE9IDApIHtcblx0XHRcdG9iamVjdC5zZXQoMCwgQ2JvckRhdGEuZW5jb2RlRGVmTGlzdCh0aGlzLiNzaWduYXR1cmVzKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2RhdHVtcy5saXN0Lmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRvYmplY3Quc2V0KDQsIHRoaXMuI2RhdHVtcy50b0Nib3IoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3JlZGVlbWVycy5sZW5ndGggIT0gMCkge1xuXHRcdFx0b2JqZWN0LnNldCg1LCBDYm9yRGF0YS5lbmNvZGVEZWZMaXN0KHRoaXMuI3JlZGVlbWVycykpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNzY3JpcHRzLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtudW1iZXJbXVtdfVxuXHRcdFx0ICovXG5cdFx0XHRsZXQgc2NyaXB0Qnl0ZXMgPSB0aGlzLiNzY3JpcHRzLm1hcChzID0+IHMudG9DYm9yKCkpO1xuXG5cdFx0XHRvYmplY3Quc2V0KDYsIENib3JEYXRhLmVuY29kZURlZkxpc3Qoc2NyaXB0Qnl0ZXMpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlT2JqZWN0KG9iamVjdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtUeFdpdG5lc3Nlc31cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdGxldCB0eFdpdG5lc3NlcyA9IG5ldyBUeFdpdG5lc3NlcygpO1xuXG5cdFx0Q2JvckRhdGEuZGVjb2RlT2JqZWN0KGJ5dGVzLCAoaSwgZmllbGRCeXRlcykgPT4ge1xuXHRcdFx0c3dpdGNoKGkpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdENib3JEYXRhLmRlY29kZUxpc3QoZmllbGRCeXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0XHRcdFx0dHhXaXRuZXNzZXMuI3NpZ25hdHVyZXMucHVzaChTaWduYXR1cmUuZnJvbUNib3IoaXRlbUJ5dGVzKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkIGZpZWxkXCIpO1xuXHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0dHhXaXRuZXNzZXMuI2RhdHVtcyA9IExpc3REYXRhLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDU6XG5cdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChmaWVsZEJ5dGVzLCAoXywgaXRlbUJ5dGVzKSA9PiB7XG5cdFx0XHRcdFx0XHR0eFdpdG5lc3Nlcy4jcmVkZWVtZXJzLnB1c2goUmVkZWVtZXIuZnJvbUNib3IoaXRlbUJ5dGVzKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNjpcblx0XHRcdFx0XHRDYm9yRGF0YS5kZWNvZGVMaXN0KGZpZWxkQnl0ZXMsIChfLCBpdGVtQnl0ZXMpID0+IHtcblx0XHRcdFx0XHRcdHR4V2l0bmVzc2VzLiNzY3JpcHRzLnB1c2goVXBsY1Byb2dyYW0uZnJvbUNib3IoaXRlbUJ5dGVzKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGZpZWxkXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHR4V2l0bmVzc2VzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBlcnJvciBpZiBzaWduYXR1cmVzIGFyZSBpbmNvcnJlY3Rcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYm9keUJ5dGVzIFxuXHQgKi9cblx0dmVyaWZ5U2lnbmF0dXJlcyhib2R5Qnl0ZXMpIHtcblx0XHRmb3IgKGxldCBzaWduYXR1cmUgb2YgdGhpcy4jc2lnbmF0dXJlcykge1xuXHRcdFx0c2lnbmF0dXJlLnZlcmlmeShDcnlwdG8uYmxha2UyYihib2R5Qnl0ZXMpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNpZ25hdHVyZXM6IHRoaXMuI3NpZ25hdHVyZXMubWFwKHBrdyA9PiBwa3cuZHVtcCgpKSxcblx0XHRcdGRhdHVtczogdGhpcy4jZGF0dW1zLmxpc3QubWFwKGRhdHVtID0+IGRhdHVtLnRvU3RyaW5nKCkpLFxuXHRcdFx0cmVkZWVtZXJzOiB0aGlzLiNyZWRlZW1lcnMubWFwKHJlZGVlbWVyID0+IHJlZGVlbWVyLmR1bXAoKSksXG5cdFx0XHRzY3JpcHRzOiB0aGlzLiNzY3JpcHRzLm1hcChzY3JpcHQgPT4gYnl0ZXNUb0hleChzY3JpcHQudG9DYm9yKCkpKSxcblx0XHRcdHJlZlNjcmlwdHM6IHRoaXMuI3JlZlNjcmlwdHMubWFwKHNjcmlwdCA9PiBieXRlc1RvSGV4KHNjcmlwdC50b0Nib3IoKSkpLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zXG5cdCAqIEByZXR1cm5zIHtiaWdpbnR9XG5cdCAqL1xuXHRlc3RpbWF0ZUZlZShuZXR3b3JrUGFyYW1zKSB7XG5cdFx0bGV0IHN1bSA9IDBuO1xuXG5cdFx0Zm9yIChsZXQgcmVkZWVtZXIgb2YgdGhpcy4jcmVkZWVtZXJzKSB7XG5cdFx0XHRzdW0gKz0gcmVkZWVtZXIuZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NpZ25hdHVyZX0gc2lnbmF0dXJlIFxuXHQgKi9cblx0YWRkU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuXHRcdHRoaXMuI3NpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuXG5cdCAqL1xuXHRhZGREdW1teVNpZ25hdHVyZXMobikge1xuXHRcdGZvciAobGV0IGkgPSAwIDsgaSA8IG47IGkrKykge1xuXHRcdFx0dGhpcy4jc2lnbmF0dXJlcy5wdXNoKFNpZ25hdHVyZS5kdW1teSgpKTtcblx0XHR9XG5cdH1cblxuXHRyZW1vdmVEdW1teVNpZ25hdHVyZXMoKSB7XG5cdFx0dGhpcy4jc2lnbmF0dXJlcyA9IHRoaXMuI3NpZ25hdHVyZXMuZmlsdGVyKHBrdyA9PiAhcGt3LmlzRHVtbXkoKSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5kZXggaXMgY2FsY3VsYXRlZCBsYXRlclxuXHQgKiBAcGFyYW0ge1R4SW5wdXR9IGlucHV0XG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IHJlZGVlbWVyRGF0YSBcblx0ICovXG5cdGFkZFNwZW5kaW5nUmVkZWVtZXIoaW5wdXQsIHJlZGVlbWVyRGF0YSkge1xuXHRcdHRoaXMuI3JlZGVlbWVycy5wdXNoKG5ldyBTcGVuZGluZ1JlZGVlbWVyKGlucHV0LCAtMSwgcmVkZWVtZXJEYXRhKSk7IC8vIGFjdHVhbCBpbnB1dCBpbmRleCBpcyBkZXRlcm1pbmVkIGxhdGVyXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNaW50aW5nUG9saWN5SGFzaH0gbXBoXG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IHJlZGVlbWVyRGF0YVxuXHQgKi9cblx0YWRkTWludGluZ1JlZGVlbWVyKG1waCwgcmVkZWVtZXJEYXRhKSB7XG5cdFx0dGhpcy4jcmVkZWVtZXJzLnB1c2gobmV3IE1pbnRpbmdSZWRlZW1lcihtcGgsIC0xLCByZWRlZW1lckRhdGEpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuXHQgKi9cblx0YWRkRGF0dW1EYXRhKGRhdGEpIHtcblx0XHQvLyBjaGVjayB0aGF0IGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gaW5jbHVkZWRcblx0XHRmb3IgKGxldCBwcmV2IG9mIHRoaXMuI2RhdHVtcy5saXN0KSB7XG5cdFx0XHRpZiAoZXEocHJldi50b0Nib3IoKSwgZGF0YS50b0Nib3IoKSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBsc3QgPSB0aGlzLiNkYXR1bXMubGlzdDtcblx0XHRsc3QucHVzaChkYXRhKTtcblxuXHRcdHRoaXMuI2RhdHVtcyA9IG5ldyBMaXN0RGF0YShsc3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBlcnJvciBpZiBzY3JpcHQgd2FzIGFscmVhZHkgYWRkZWQgYmVmb3JlXG5cdCAqIEBwYXJhbSB7VXBsY1Byb2dyYW19IHByb2dyYW0gXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWZcblx0ICovXG5cdGF0dGFjaFNjcmlwdChwcm9ncmFtLCBpc1JlZiA9IGZhbHNlKSB7XG5cdFx0bGV0IGggPSBwcm9ncmFtLmhhc2goKTtcblxuXHRcdGFzc2VydCh0aGlzLiNzY3JpcHRzLmV2ZXJ5KHMgPT4gIWVxKHMuaGFzaCgpLCBoKSkpO1xuXHRcdGFzc2VydCh0aGlzLiNyZWZTY3JpcHRzLmV2ZXJ5KHMgPT4gIWVxKHMuaGFzaCgpLCBoKSkpO1xuXG5cdFx0aWYgKGlzUmVmKSB7XG5cdFx0XHR0aGlzLiNyZWZTY3JpcHRzLnB1c2gocHJvZ3JhbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuI3NjcmlwdHMucHVzaChwcm9ncmFtKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIGVpdGhlciBhIHJlZ3VsYXIgc2NyaXB0IG9yIGEgcmVmZXJlbmNlIHNjcmlwdFxuXHQgKiBAcGFyYW0ge0hhc2h9IHNjcmlwdEhhc2ggLSBjYW4gYmUgVmFsaWRhdG9ySGFzaCBvciBNaW50aW5nUG9saWN5SGFzaFxuXHQgKiBAcmV0dXJucyB7VXBsY1Byb2dyYW19XG5cdCAqL1xuXHRnZXRTY3JpcHQoc2NyaXB0SGFzaCkge1xuXHRcdHJldHVybiBhc3NlcnREZWZpbmVkKHRoaXMuc2NyaXB0cy5maW5kKHMgPT4gZXEocy5oYXNoKCksIHNjcmlwdEhhc2guYnl0ZXMpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUeEJvZHl9IGJvZHlcblx0ICovXG5cdHVwZGF0ZVJlZGVlbWVySW5kaWNlcyhib2R5KSB7XG5cdFx0Zm9yIChsZXQgcmVkZWVtZXIgb2YgdGhpcy4jcmVkZWVtZXJzKSB7XG5cdFx0XHRyZWRlZW1lci51cGRhdGVJbmRleChib2R5KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcmV0dXJucyB7SGFzaCB8IG51bGx9IC0gcmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyByZWRlZW1lcnNcblx0ICovXG5cdGNhbGNTY3JpcHREYXRhSGFzaChuZXR3b3JrUGFyYW1zKSB7XG5cdFx0aWYgKHRoaXMuI3JlZGVlbWVycy5sZW5ndGggPiAwKSB7XG5cdFx0XHRsZXQgYnl0ZXMgPSBDYm9yRGF0YS5lbmNvZGVEZWZMaXN0KHRoaXMuI3JlZGVlbWVycyk7XG5cblx0XHRcdGlmICh0aGlzLiNkYXR1bXMubGlzdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGJ5dGVzID0gYnl0ZXMuY29uY2F0KHRoaXMuI2RhdHVtcy50b0Nib3IoKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxhbmd1YWdlIHZpZXcgZW5jb2RpbmdzP1xuXHRcdFx0bGV0IHNvcnRlZENvc3RQYXJhbXMgPSBuZXR3b3JrUGFyYW1zLnNvcnRlZENvc3RQYXJhbXM7XG5cblx0XHRcdGJ5dGVzID0gYnl0ZXMuY29uY2F0KENib3JEYXRhLmVuY29kZU1hcChbW1xuXHRcdFx0XHRDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKDFuKSwgXG5cdFx0XHRcdENib3JEYXRhLmVuY29kZURlZkxpc3Qoc29ydGVkQ29zdFBhcmFtcy5tYXAoY3AgPT4gQ2JvckRhdGEuZW5jb2RlSW50ZWdlcihCaWdJbnQoY3ApKSkpLFxuXHRcdFx0XV0pKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBIYXNoKENyeXB0by5ibGFrZTJiKGJ5dGVzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcGFyYW0ge1R4Qm9keX0gYm9keVxuXHQgKiBAcGFyYW0ge1JlZGVlbWVyfSByZWRlZW1lciBcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gc2NyaXB0Q29udGV4dFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxDb3N0Pn0gXG5cdCAqL1xuXHRhc3luYyBleGVjdXRlUmVkZWVtZXIobmV0d29ya1BhcmFtcywgYm9keSwgcmVkZWVtZXIsIHNjcmlwdENvbnRleHQpIHtcblx0XHRpZiAocmVkZWVtZXIgaW5zdGFuY2VvZiBTcGVuZGluZ1JlZGVlbWVyKSB7XG5cdFx0XHRjb25zdCBpZHggPSByZWRlZW1lci5pbnB1dEluZGV4O1xuXG5cdFx0XHRjb25zdCBvcmlnT3V0cHV0ID0gYm9keS5pbnB1dHNbaWR4XS5vcmlnT3V0cHV0O1xuXG5cdFx0XHRpZiAob3JpZ091dHB1dCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBvcmlnT3V0cHV0IHRvIGJlIG5vbi1udWxsXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZGF0dW1EYXRhID0gb3JpZ091dHB1dC5nZXREYXR1bURhdGEoKTtcblxuXHRcdFx0XHRjb25zdCB2YWxpZGF0b3JIYXNoID0gb3JpZ091dHB1dC5hZGRyZXNzLnZhbGlkYXRvckhhc2g7XG5cblx0XHRcdFx0aWYgKHZhbGlkYXRvckhhc2ggPT09IG51bGwgfHwgdmFsaWRhdG9ySGFzaCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgdmFsaWRhdG9ySGFzaCB0byBiZSBub24tbnVsbFwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBzY3JpcHQgPSB0aGlzLmdldFNjcmlwdCh2YWxpZGF0b3JIYXNoKTtcblxuXHRcdFx0XHRcdGNvbnN0IGFyZ3MgPSBbXG5cdFx0XHRcdFx0XHRuZXcgVXBsY0RhdGFWYWx1ZShTaXRlLmR1bW15KCksIGRhdHVtRGF0YSksIFxuXHRcdFx0XHRcdFx0bmV3IFVwbGNEYXRhVmFsdWUoU2l0ZS5kdW1teSgpLCByZWRlZW1lci5kYXRhKSwgXG5cdFx0XHRcdFx0XHRuZXcgVXBsY0RhdGFWYWx1ZShTaXRlLmR1bW15KCksIHNjcmlwdENvbnRleHQpLFxuXHRcdFx0XHRcdF07XG5cblx0XHRcdFx0XHRjb25zdCBwcm9maWxlID0gYXdhaXQgc2NyaXB0LnByb2ZpbGUoYXJncywgbmV0d29ya1BhcmFtcyk7XG5cblx0XHRcdFx0XHRwcm9maWxlLm1lc3NhZ2VzLmZvckVhY2gobSA9PiBjb25zb2xlLmxvZyhtKSk7XG5cblx0XHRcdFx0XHRpZiAocHJvZmlsZS5yZXN1bHQgaW5zdGFuY2VvZiBVc2VyRXJyb3IpIHtcdFxuXHRcdFx0XHRcdFx0dGhyb3cgcHJvZmlsZS5yZXN1bHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiB7bWVtOiBwcm9maWxlLm1lbSwgY3B1OiBwcm9maWxlLmNwdX07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChyZWRlZW1lciBpbnN0YW5jZW9mIE1pbnRpbmdSZWRlZW1lcikge1xuXHRcdFx0Y29uc3QgbXBoID0gYm9keS5taW50ZWQubWludGluZ1BvbGljaWVzW3JlZGVlbWVyLm1waEluZGV4XTtcblxuXHRcdFx0Y29uc3Qgc2NyaXB0ID0gdGhpcy5nZXRTY3JpcHQobXBoKTtcblxuXHRcdFx0Y29uc3QgYXJncyA9IFtcblx0XHRcdFx0bmV3IFVwbGNEYXRhVmFsdWUoU2l0ZS5kdW1teSgpLCByZWRlZW1lci5kYXRhKSxcblx0XHRcdFx0bmV3IFVwbGNEYXRhVmFsdWUoU2l0ZS5kdW1teSgpLCBzY3JpcHRDb250ZXh0KSxcblx0XHRcdF07XG5cblx0XHRcdGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBzY3JpcHQucHJvZmlsZShhcmdzLCBuZXR3b3JrUGFyYW1zKTtcblxuXHRcdFx0cHJvZmlsZS5tZXNzYWdlcy5mb3JFYWNoKG0gPT4gY29uc29sZS5sb2cobSkpO1xuXG5cdFx0XHRpZiAocHJvZmlsZS5yZXN1bHQgaW5zdGFuY2VvZiBVc2VyRXJyb3IpIHtcdFxuXHRcdFx0XHR0aHJvdyBwcm9maWxlLnJlc3VsdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB7bWVtOiBwcm9maWxlLm1lbSwgY3B1OiBwcm9maWxlLmNwdX07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCByZWRlZW1lciB0eXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyB0aGUgcmVkZWVtZXJzIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgbmVjZXNzYXJ5IGV4IHVuaXRzXG5cdCAqIEBwYXJhbSB7TmV0d29ya1BhcmFtc30gbmV0d29ya1BhcmFtcyBcblx0ICogQHBhcmFtIHtUeEJvZHl9IGJvZHkgLSBuZWVkZWQgaW4gb3JkZXIgdG8gY3JlYXRlIGNvcnJlY3QgU2NyaXB0Q29udGV4dHNcblx0ICogQHBhcmFtIHtBZGRyZXNzfSBjaGFuZ2VBZGRyZXNzIC0gbmVlZGVkIGZvciBkdW1teSBpbnB1dCBhbmQgZHVtbXkgb3V0cHV0XG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuXHQgKi9cblx0YXN5bmMgZXhlY3V0ZVJlZGVlbWVycyhuZXR3b3JrUGFyYW1zLCBib2R5LCBjaGFuZ2VBZGRyZXNzKSB7XG5cdFx0YXNzZXJ0KGNvbmZpZy5OX0RVTU1ZX0lOUFVUUyA9PSAxIHx8IGNvbmZpZy5OX0RVTU1ZX0lOUFVUUyA9PSAyLCBcImV4cGVjdGVkIE5fRFVNTVlfSU5QVVRTPT0xIG9yIE5fRFVNTVlfSU5QVVRTPT0yXCIpO1xuXHRcdGNvbnN0IHR3b0R1bW15SW5wdXRzID0gY29uZmlnLk5fRFVNTVlfSU5QVVRTID09IDI7XG5cblx0XHRjb25zdCBmZWUgPSBuZXR3b3JrUGFyYW1zLm1heFR4RmVlO1xuXG5cdFx0Ly8gQWRkaXRpb25hbCAyIGR1bW15IGlucHV0cyBhbmQgMSBkdW1teSBvdXRwdXQgdG8gY29tcGVuc2F0ZSBmb3IgYmFsYW5jaW5nIGlucHV0cyBhbmQgb3V0cHV0cyB0aGF0IG1pZ2h0IGJlIGFkZGVkIGxhdGVyXG5cdFx0Ly8gVGhlIHJlYXNvbiBmb3IgbmVlZGluZyAyIGR1bW15IGlucHV0cyBpcyB0aGF0IG9uZSBuZWVkcyB0byBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBib2R5LmlucHV0cyBsaXN0IChUeElkIDAwMDAuLi4pLCBhbmQgdGhlIG90aGVyIG5lZWRzIFR4SWQgZmZmZmZmIChhdCB0aGUgZW5kIG9mIHRoZSBsaXN0KVxuXHRcdC8vIFR4SWQgZmZmZmZmIG92ZXJlc3RpbWF0ZXMgdGhlIGNvc3Qgb2YgcHJpbnRpbmcgdGhlIFR4SWRzLCBhbmQgdGhlIGR1bW15IFR4SWQgMDAwMDAgb3ZlcmVzdGltYXRlcyBpdGVyYXRpbmcgb3ZlciBib2R5LmlucHV0c1xuXHRcdC8vIFdlIGNhbid0IGp1c3QgcHJlcGVuZCBhIGR1bW15IGlucHV0IHdpdGggVHhJZCBmZmZmZmYsIGJlY2F1c2Ugc29tZSBzY3JpcHRzIG1pZ2h0IGJlIHJlbHlpbmcgb24gdGhlIG9yZGVyIG9mIHRoZSBpbnB1dHMgKGVnLiBjb3VudGluZyB2b3RlcyBpbiBEQU9zKVxuXG5cdFx0Ly8gMTAwMCBBREEgc2hvdWxkIGJlIGVub3VnaCBhcyBhIGR1bW15IGlucHV0L291dHB1dFxuXHRcdGNvbnN0IGR1bW15SW5wdXQxID0gbmV3IFR4SW5wdXQoXG5cdFx0XHRUeElkLmR1bW15KDApLFxuXHRcdFx0MG4sXG5cdFx0XHRuZXcgVHhPdXRwdXQoXG5cdFx0XHRcdGNoYW5nZUFkZHJlc3MsXG5cdFx0XHRcdG5ldyBWYWx1ZShmZWUgKyAxMDAwXzAwMF8wMDBuKVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0XG5cdFx0Y29uc3QgZHVtbXlJbnB1dDIgPSBuZXcgVHhJbnB1dChcblx0XHRcdFR4SWQuZHVtbXkoMjU1KSxcblx0XHRcdDk5OW4sXG5cdFx0XHRuZXcgVHhPdXRwdXQoXG5cdFx0XHRcdGNoYW5nZUFkZHJlc3MsXG5cdFx0XHRcdG5ldyBWYWx1ZSgxMDAwXzAwMF8wMDBuKVxuXHRcdFx0KVxuXHRcdCk7XG5cblx0XHRjb25zdCBkdW1teU91dHB1dCA9IG5ldyBUeE91dHB1dChcblx0XHRcdGNoYW5nZUFkZHJlc3MsXG5cdFx0XHRuZXcgVmFsdWUodHdvRHVtbXlJbnB1dHMgPyAyMDAwXzAwMF8wMDBuIDogMTAwMF8wMDBfMDAwbilcblx0XHQpO1xuXG5cdFx0Ym9keS5zZXRGZWUoZmVlKTtcblx0XHRib2R5LmFkZElucHV0KGR1bW15SW5wdXQxLCBmYWxzZSk7XG5cdFx0aWYgKHR3b0R1bW15SW5wdXRzKSB7XG5cdFx0XHRib2R5LmFkZElucHV0KGR1bW15SW5wdXQyLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGJvZHkuYWRkT3V0cHV0KGR1bW15T3V0cHV0KTtcblxuXHRcdHRoaXMudXBkYXRlUmVkZWVtZXJJbmRpY2VzKGJvZHkpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNyZWRlZW1lcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJlZGVlbWVyID0gdGhpcy4jcmVkZWVtZXJzW2ldO1xuXG5cdFx0XHRjb25zdCBzY3JpcHRDb250ZXh0ID0gYm9keS50b1NjcmlwdENvbnRleHREYXRhKG5ldHdvcmtQYXJhbXMsIHRoaXMuI3JlZGVlbWVycywgdGhpcy4jZGF0dW1zLCBpKTtcblxuXHRcdFx0Y29uc3QgY29zdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlZGVlbWVyKG5ldHdvcmtQYXJhbXMsIGJvZHksIHJlZGVlbWVyLCBzY3JpcHRDb250ZXh0KTtcblxuXHRcdFx0cmVkZWVtZXIuc2V0Q29zdChjb3N0KTtcblx0XHR9XG5cblx0XHRib2R5LnJlbW92ZUlucHV0KGR1bW15SW5wdXQxKTtcblx0XHRpZiAodHdvRHVtbXlJbnB1dHMpIHtcblx0XHRcdGJvZHkucmVtb3ZlSW5wdXQoZHVtbXlJbnB1dDIpO1xuXHRcdH1cblx0XHRib2R5LnJlbW92ZU91dHB1dChkdW1teU91dHB1dCk7XG5cblx0XHR0aGlzLnVwZGF0ZVJlZGVlbWVySW5kaWNlcyhib2R5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXJ1bnMgYWxsIHRoZSByZWRlZW1lcnMgdG8gbWFrZSBzdXJlIHRoZSBleCBidWRnZXRzIGFyZSBzdGlsbCBjb3JyZWN0IChjYW4gY2hhbmdlIGR1ZSB0byBvdXRwdXRzIGFkZGVkIGR1cmluZyByZWJhbGFuY2luZylcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcGFyYW0ge1R4Qm9keX0gYm9keSBcblx0ICovXG5cdGFzeW5jIGNoZWNrRXhlY3V0aW9uQnVkZ2V0cyhuZXR3b3JrUGFyYW1zLCBib2R5KSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNyZWRlZW1lcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJlZGVlbWVyID0gdGhpcy4jcmVkZWVtZXJzW2ldO1xuXG5cdFx0XHRjb25zdCBzY3JpcHRDb250ZXh0ID0gYm9keS50b1NjcmlwdENvbnRleHREYXRhKG5ldHdvcmtQYXJhbXMsIHRoaXMuI3JlZGVlbWVycywgdGhpcy4jZGF0dW1zLCBpKTtcblxuXHRcdFx0Y29uc3QgY29zdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlZGVlbWVyKG5ldHdvcmtQYXJhbXMsIGJvZHksIHJlZGVlbWVyLCBzY3JpcHRDb250ZXh0KTtcblxuXHRcdFx0aWYgKHJlZGVlbWVyLm1lbUNvc3QgPCBjb3N0Lm1lbSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBmaW5hbGl6YXRpb24gZXJyb3IsIHJlZGVlbWVyIG1lbSBidWRnZXQgdG9vIGxvd1wiKTtcblx0XHRcdH0gZWxzZSBpZiAocmVkZWVtZXIuY3B1Q29zdCA8IGNvc3QuY3B1KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGZpbmFsaXphdGlvbiBlcnJvciwgcmVkZWVtZXIgY3B1IGJ1ZGdldCB0b28gbG93XCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaHJvd3MgZXJyb3IgaWYgZXhlY3V0aW9uIGJ1ZGdldCBpcyBleGNlZWRlZFxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICovXG5cdGNoZWNrRXhlY3V0aW9uQnVkZ2V0TGltaXRzKG5ldHdvcmtQYXJhbXMpIHtcblx0XHRsZXQgdG90YWxNZW0gPSAwbjtcblx0XHRsZXQgdG90YWxDcHUgPSAwbjtcblxuXHRcdGZvciAobGV0IHJlZGVlbWVyIG9mIHRoaXMuI3JlZGVlbWVycykge1xuXHRcdFx0dG90YWxNZW0gKz0gcmVkZWVtZXIubWVtQ29zdDtcblx0XHRcdHRvdGFsQ3B1ICs9IHJlZGVlbWVyLmNwdUNvc3Q7XG5cdFx0fVxuXG5cdFx0bGV0IFttYXhNZW0sIG1heENwdV0gPSBuZXR3b3JrUGFyYW1zLm1heFR4RXhlY3V0aW9uQnVkZ2V0O1xuXG5cdFx0aWYgKHRvdGFsTWVtID49IEJpZ0ludChtYXhNZW0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleGVjdXRpb24gYnVkZ2V0IGV4Y2VlZGVkIGZvciBtZW1cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRvdGFsQ3B1ID49IEJpZ0ludChtYXhDcHUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleGVjdXRpb24gYnVkZ2V0IGV4Y2VlZGVkIGZvciBjcHVcIik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhY2thZ2VcbiAqL1xuY2xhc3MgVHhJbnB1dCBleHRlbmRzIENib3JEYXRhIHtcblx0LyoqIEB0eXBlIHtUeElkfSAqL1xuXHQjdHhJZDtcblxuXHQvKiogQHR5cGUge2JpZ2ludH0gKi9cblx0I3V0eG9JZHg7XG5cblx0LyoqIEB0eXBlIHs/VHhPdXRwdXR9ICovXG5cdCNvcmlnT3V0cHV0O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4SWR9IHR4SWQgXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB1dHhvSWR4IFxuXHQgKiBAcGFyYW0gez9UeE91dHB1dH0gb3JpZ091dHB1dCAtIHVzZWQgZHVyaW5nIGJ1aWxkaW5nLCBub3QgcGFydCBvZiBzZXJpYWxpemF0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0eElkLCB1dHhvSWR4LCBvcmlnT3V0cHV0ID0gbnVsbCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jdHhJZCA9IHR4SWQ7XG5cdFx0dGhpcy4jdXR4b0lkeCA9IHV0eG9JZHg7XG5cdFx0dGhpcy4jb3JpZ091dHB1dCA9IG9yaWdPdXRwdXQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhJZH1cblx0ICovXG5cdGdldCB0eElkKCkge1xuXHRcdHJldHVybiB0aGlzLiN0eElkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtiaWdpbnR9XG5cdCAqL1xuXHRnZXQgdXR4b0lkeCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jdXR4b0lkeDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhPdXRwdXR9XG5cdCAqL1xuXHRnZXQgb3JpZ091dHB1dCgpIHtcblx0XHRpZiAodGhpcy4jb3JpZ091dHB1dCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwib3JpZ091dHB1dCBub3Qgc2V0XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jb3JpZ091dHB1dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnRjdXRcblx0ICogQHR5cGUge1ZhbHVlfVxuXHQgKi9cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLm9yaWdPdXRwdXQudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnRjdXRcblx0ICogQHR5cGUge0FkZHJlc3N9XG5cdCAqL1xuXHRnZXQgYWRkcmVzcygpIHtcblx0XHRyZXR1cm4gdGhpcy5vcmlnT3V0cHV0LmFkZHJlc3M7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge0NvbnN0ckRhdGF9XG5cdCAqL1xuXHR0b091dHB1dElkRGF0YSgpIHtcblx0XHRyZXR1cm4gbmV3IENvbnN0ckRhdGEoMCwgW1xuXHRcdFx0bmV3IENvbnN0ckRhdGEoMCwgW25ldyBCeXRlQXJyYXlEYXRhKHRoaXMuI3R4SWQuYnl0ZXMpXSksXG5cdFx0XHRuZXcgSW50RGF0YSh0aGlzLiN1dHhvSWR4KSxcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvRGF0YSgpIHtcblx0XHRpZiAodGhpcy4jb3JpZ091dHB1dCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgdG8gYmUgbm9uLW51bGxcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgwLCBbXG5cdFx0XHRcdHRoaXMudG9PdXRwdXRJZERhdGEoKSxcblx0XHRcdFx0dGhpcy4jb3JpZ091dHB1dC50b0RhdGEoKSxcblx0XHRcdF0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZVR1cGxlKFtcblx0XHRcdHRoaXMuI3R4SWQudG9DYm9yKCksXG5cdFx0XHRDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKHRoaXMuI3V0eG9JZHgpLFxuXHRcdF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7VHhJbnB1dH1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdC8qKiBAdHlwZSB7P1R4SWR9ICovXG5cdFx0bGV0IHR4SWQgPSBudWxsO1xuXG5cdFx0LyoqIEB0eXBlIHs/YmlnaW50fSAqL1xuXHRcdGxldCB1dHhvSWR4ID0gbnVsbDtcblxuXHRcdENib3JEYXRhLmRlY29kZVR1cGxlKGJ5dGVzLCAoaSwgZmllbGRCeXRlcykgPT4ge1xuXHRcdFx0c3dpdGNoKGkpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdHR4SWQgPSBUeElkLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dXR4b0lkeCA9IENib3JEYXRhLmRlY29kZUludGVnZXIoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGZpZWxkXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHR4SWQgPT09IG51bGwgfHwgdXR4b0lkeCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBUeElucHV0KHR4SWQsIHV0eG9JZHgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUeCBpbnB1dHMgbXVzdCBiZSBvcmRlcmVkLiBcblx0ICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBkaXJlY3RseSBieSBhIGpzIGFycmF5IHNvcnRcblx0ICogQHBhcmFtIHtUeElucHV0fSBhXG5cdCAqIEBwYXJhbSB7VHhJbnB1dH0gYlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c3RhdGljIGNvbXAoYSwgYikge1xuXHRcdGxldCByZXMgPSBCeXRlQXJyYXlEYXRhLmNvbXAoYS4jdHhJZC5ieXRlcywgYi4jdHhJZC5ieXRlcyk7XG5cblx0XHRpZiAocmVzID09IDApIHtcblx0XHRcdHJldHVybiBOdW1iZXIoYS4jdXR4b0lkeCAtIGIuI3V0eG9JZHgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0fSBcblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR4SWQ6IHRoaXMuI3R4SWQuZHVtcCgpLFxuXHRcdFx0dXR4b0lkeDogdGhpcy4jdXR4b0lkeC50b1N0cmluZygpLFxuXHRcdFx0b3JpZ091dHB1dDogdGhpcy4jb3JpZ091dHB1dCAhPT0gbnVsbCA/IHRoaXMuI29yaWdPdXRwdXQuZHVtcCgpIDogbnVsbCxcblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogVVR4TyB3cmFwcyBUeElucHV0XG4gKi9cbmV4cG9ydCBjbGFzcyBVVHhPIHtcblx0I2lucHV0O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4SWR9IHR4SWQgXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB1dHhvSWR4IFxuXHQgKiBAcGFyYW0ge1R4T3V0cHV0fSBvcmlnT3V0cHV0XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0eElkLCB1dHhvSWR4LCBvcmlnT3V0cHV0KSB7XG5cdFx0dGhpcy4jaW5wdXQgPSBuZXcgVHhJbnB1dCh0eElkLCB1dHhvSWR4LCBvcmlnT3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhJZH1cblx0ICovXG5cdGdldCB0eElkKCkge1xuXHRcdHJldHVybiB0aGlzLiNpbnB1dC50eElkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtiaWdpbnR9XG5cdCAqL1xuXHRnZXQgdXR4b0lkeCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jaW5wdXQudXR4b0lkeDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7VHhJbnB1dH1cblx0ICovXG5cdGdldCBhc1R4SW5wdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2lucHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtWYWx1ZX1cblx0ICovXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jaW5wdXQudmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1R4T3V0cHV0fVxuXHQgKi9cblx0Z2V0IG9yaWdPdXRwdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2lucHV0Lm9yaWdPdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogRGVzZXJpYWxpemVzIFVUeE8gZm9ybWF0IHVzZWQgYnkgd2FsbGV0IGNvbm5lY3RvclxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlc1xuXHQgKiBAcmV0dXJucyB7VVR4T31cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdC8qKiBAdHlwZSB7P1R4SW5wdXR9ICovXG5cdFx0bGV0IG1heWJlVHhJbnB1dCA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUgez9UeE91dHB1dH0gKi9cblx0XHRsZXQgb3JpZ091dHB1dCA9IG51bGw7XG5cblx0XHRDYm9yRGF0YS5kZWNvZGVUdXBsZShieXRlcywgKGksIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdHN3aXRjaChpKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRtYXliZVR4SW5wdXQgPSBUeElucHV0LmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0b3JpZ091dHB1dCA9IFR4T3V0cHV0LmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBmaWVsZFwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChtYXliZVR4SW5wdXQgIT09IG51bGwgJiYgb3JpZ091dHB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtUeElucHV0fSAqL1xuICAgICAgICAgICAgY29uc3QgdHhJbnB1dCA9IG1heWJlVHhJbnB1dDtcbiAgICAgICAgICAgIFxuXHRcdFx0cmV0dXJuIG5ldyBVVHhPKHR4SW5wdXQudHhJZCwgdHhJbnB1dC51dHhvSWR4LCBvcmlnT3V0cHV0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVUdXBsZShbXG5cdFx0XHR0aGlzLiNpbnB1dC50b0Nib3IoKSxcblx0XHRcdHRoaXMuI2lucHV0Lm9yaWdPdXRwdXQudG9DYm9yKClcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VUeE9bXX0gdXR4b3Ncblx0ICogQHJldHVybnMge1ZhbHVlfVxuXHQgKi9cblx0c3RhdGljIHN1bVZhbHVlKHV0eG9zKSB7XG5cdFx0bGV0IHN1bSA9IG5ldyBWYWx1ZSgpO1xuXG5cdFx0Zm9yIChsZXQgdXR4byBvZiB1dHhvcykge1xuXHRcdFx0c3VtID0gc3VtLmFkZCh1dHhvLnZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3VtO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBUeFJlZklucHV0IGV4dGVuZHMgVHhJbnB1dCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4SWR9IHR4SWQgXG5cdCAqIEBwYXJhbSB7YmlnaW50fSB1dHhvSWRcblx0ICogQHBhcmFtIHtUeE91dHB1dH0gb3JpZ091dHB1dFxuXHQgKi9cblx0Y29uc3RydWN0b3IodHhJZCwgdXR4b0lkLCBvcmlnT3V0cHV0KSB7XG5cdFx0c3VwZXIodHhJZCwgdXR4b0lkLCBvcmlnT3V0cHV0KTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgVHhPdXRwdXQgZXh0ZW5kcyBDYm9yRGF0YSB7XG5cdC8qKiBAdHlwZSB7QWRkcmVzc30gKi9cblx0I2FkZHJlc3M7XG5cblx0LyoqIEB0eXBlIHtWYWx1ZX0gKi9cblx0I3ZhbHVlO1xuXG5cdC8qKiBAdHlwZSB7P0RhdHVtfSAqL1xuXHQjZGF0dW07XG5cblx0LyoqIEB0eXBlIHs/VXBsY1Byb2dyYW19ICovXG5cdCNyZWZTY3JpcHQ7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzcyBcblx0ICogQHBhcmFtIHtWYWx1ZX0gdmFsdWUgXG5cdCAqIEBwYXJhbSB7P0RhdHVtfSBkYXR1bSBcblx0ICogQHBhcmFtIHs/VXBsY1Byb2dyYW19IHJlZlNjcmlwdCBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGFkZHJlc3MsIHZhbHVlLCBkYXR1bSA9IG51bGwsIHJlZlNjcmlwdCA9IG51bGwpIHtcblx0XHRhc3NlcnQoZGF0dW0gPT09IG51bGwgfHwgZGF0dW0gaW5zdGFuY2VvZiBEYXR1bSk7IC8vIGNoZWNrIHRoaXMgZXhwbGljaXRlbHkgYmVjYXVzZSBjYWxsZXIgbWlnaHQgYmUgdXNpbmcgdGhpcyBjb25zdHJ1Y3RvciB3aXRob3V0IHByb3BlciB0eXBlLWNoZWNraW5nXG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLiNhZGRyZXNzID0gYWRkcmVzcztcblx0XHR0aGlzLiN2YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuI2RhdHVtID0gZGF0dW07XG5cdFx0dGhpcy4jcmVmU2NyaXB0ID0gcmVmU2NyaXB0O1xuXHR9XG5cblx0Z2V0IGFkZHJlc3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2FkZHJlc3M7XG5cdH1cblxuXHQvKipcblx0ICogTXV0YXRpb24gaXMgaGFuZHkgd2hlbiBjb3JyZWN0aW4gdGhlIHF1YW50aXR5IG9mIGxvdmVsYWNlIGluIGEgdXR4b1xuXHQgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJcblx0ICovXG5cdHNldEFkZHJlc3MoYWRkcikge1xuXHRcdHRoaXMuI2FkZHJlc3MgPSBhZGRyO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLiN2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNdXRhdGlvbiBpcyBoYW5keSB3aGVuIGNvcnJlY3RpbmcgdGhlIHF1YW50aXR5IG9mIGxvdmVsYWNlIGluIGEgdXR4b1xuXHQgKiBAcGFyYW0ge1ZhbHVlfSB2YWxcblx0ICovXG5cdHNldFZhbHVlKHZhbCkge1xuXHRcdHRoaXMuI3ZhbHVlID0gdmFsO1xuXHR9XG5cblx0Z2V0IGRhdHVtKCkge1xuXHRcdHJldHVybiB0aGlzLiNkYXR1bTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNdXRhdGlvbiBpcyBoYW5keSB3aGVuIGNvcnJlY3RpbiB0aGUgcXVhbnRpdHkgb2YgbG92ZWxhY2UgaW4gYSB1dHhvIFxuXHQgKiBAcGFyYW0ge0RhdHVtfSBkYXR1bSBcblx0ICovXG5cdHNldERhdHVtKGRhdHVtKSB7XG5cdFx0dGhpcy4jZGF0dW0gPSBkYXR1bTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7VXBsY0RhdGF9XG5cdCAqL1xuXHRnZXREYXR1bURhdGEoKSB7XG5cdFx0aWYgKHRoaXMuI2RhdHVtID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJubyBkYXR1bSBkYXRhIGF2YWlsYWJsZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGRhdGEgPSB0aGlzLiNkYXR1bS5kYXRhO1xuXHRcdFx0aWYgKGRhdGEgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm8gZGF0dW0gZGF0YSBhdmFpbGFibGVcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdGlmICgodGhpcy4jZGF0dW0gPT09IG51bGwgfHwgdGhpcy4jZGF0dW0gaW5zdGFuY2VvZiBIYXNoZWREYXR1bSkgJiYgdGhpcy4jcmVmU2NyaXB0ID09PSBudWxsICYmICFjb25maWcuU1RSSUNUX0JBQkJBR0UpIHtcblx0XHRcdC8vIHRoaXMgaXMgbmVlZGVkIHRvIG1hdGNoIGV0ZXJubCB3YWxsZXQgKGRlKXNlcmlhbGl6YXRpb24gKGFubm95aW5nbHkgZXRlcm5sIGRlc2VyaWFsaXplcyB0aGUgdHggYW5kIHRoZW4gc2lnbnMgaXRzIG93biBzZXJpYWxpemF0aW9uKVxuXHRcdFx0Ly8gaG9wZWZ1bGx5IGNhcmRhbm8tY2xpIHNpZ25zIHdoYXRldmVyIHNlcmlhbGl6YXRpb24gd2UgY2hvb3NlIChzbyB3ZSB1c2UgdGhlIGV0ZXJubCB2YXJpYW50IGluIG9yZGVyIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBib3RoKVxuXG5cdFx0XHRsZXQgZmllbGRzID0gW1xuXHRcdFx0XHR0aGlzLiNhZGRyZXNzLnRvQ2JvcigpLFxuXHRcdFx0XHR0aGlzLiN2YWx1ZS50b0Nib3IoKVxuXHRcdFx0XTtcblxuXHRcdFx0aWYgKHRoaXMuI2RhdHVtICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmICh0aGlzLiNkYXR1bSBpbnN0YW5jZW9mIEhhc2hlZERhdHVtKSB7XG5cdFx0XHRcdFx0ZmllbGRzLnB1c2godGhpcy4jZGF0dW0uaGFzaC50b0Nib3IoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlVHVwbGUoZmllbGRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXJbXT59ICovXG5cdFx0XHRsZXQgb2JqZWN0ID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRvYmplY3Quc2V0KDAsIHRoaXMuI2FkZHJlc3MudG9DYm9yKCkpO1xuXHRcdFx0b2JqZWN0LnNldCgxLCB0aGlzLiN2YWx1ZS50b0Nib3IoKSk7XG5cblx0XHRcdGlmICh0aGlzLiNkYXR1bSAhPT0gbnVsbCkge1xuXHRcdFx0XHRvYmplY3Quc2V0KDIsIHRoaXMuI2RhdHVtLnRvQ2JvcigpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuI3JlZlNjcmlwdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRvYmplY3Quc2V0KDMsIENib3JEYXRhLmVuY29kZVRhZygyNG4pLmNvbmNhdChDYm9yRGF0YS5lbmNvZGVCeXRlcyhcblx0XHRcdFx0XHRDYm9yRGF0YS5lbmNvZGVUdXBsZShbXG5cdFx0XHRcdFx0XHRDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKEJpZ0ludCh0aGlzLiNyZWZTY3JpcHQudmVyc2lvblRhZygpKSksXG5cdFx0XHRcdFx0XHR0aGlzLiNyZWZTY3JpcHQudG9DYm9yKClcblx0XHRcdFx0XHRdKVxuXHRcdFx0XHQpKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVPYmplY3Qob2JqZWN0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtUeE91dHB1dH1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdC8qKiBAdHlwZSB7P0FkZHJlc3N9ICovXG5cdFx0bGV0IGFkZHJlc3MgPSBudWxsO1xuXG5cdFx0LyoqIEB0eXBlIHs/VmFsdWV9ICovXG5cdFx0bGV0IHZhbHVlID0gbnVsbDtcblxuXHRcdC8qKiBAdHlwZSB7P0RhdHVtfSAqL1xuXHRcdGxldCBvdXRwdXREYXR1bSA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUgez9VcGxjUHJvZ3JhbX0gKi9cblx0XHRsZXQgcmVmU2NyaXB0ID0gbnVsbDtcblxuXHRcdGlmIChDYm9yRGF0YS5pc09iamVjdChieXRlcykpIHtcblx0XHRcdENib3JEYXRhLmRlY29kZU9iamVjdChieXRlcywgKGksIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdFx0c3dpdGNoKGkpIHsgXG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0YWRkcmVzcyA9IEFkZHJlc3MuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IFZhbHVlLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0b3V0cHV0RGF0dW0gPSBEYXR1bS5mcm9tQ2JvcihmaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdGFzc2VydChDYm9yRGF0YS5kZWNvZGVUYWcoZmllbGRCeXRlcykgPT0gMjRuKTtcblxuXHRcdFx0XHRcdFx0bGV0IHR1cGxlQnl0ZXMgPSBDYm9yRGF0YS5kZWNvZGVCeXRlcyhmaWVsZEJ5dGVzKTtcblxuXHRcdFx0XHRcdFx0Q2JvckRhdGEuZGVjb2RlVHVwbGUodHVwbGVCeXRlcywgKHR1cGxlSWR4LCBpbm5lclR1cGxlQnl0ZXMpID0+IHtcblx0XHRcdFx0XHRcdFx0YXNzZXJ0KHJlZlNjcmlwdCA9PT0gbnVsbCk7XG5cblx0XHRcdFx0XHRcdFx0c3dpdGNoKHR1cGxlSWR4KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibmF0aXZlIHJlZlNjcmlwdCB1bmhhbmRsZWRcIik7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwicGx1dHVTY3JpcHRWMSBhcyByZWZTY3JpcHQgdW5oYW5kbGVkXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdHJlZlNjcmlwdCA9IFVwbGNQcm9ncmFtLmZyb21DYm9yKGlubmVyVHVwbGVCeXRlcyk7XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBzY3JpcHQgdHlwZSBmb3IgcmVmU2NyaXB0XCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBmaWVsZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChDYm9yRGF0YS5pc1R1cGxlKGJ5dGVzKSkge1xuXHRcdFx0Ly8gdGhpcyBpcyB0aGUgcHJlLXZhc2lsIGZvcm1hdCwgd2hpY2ggaXMgc3RpbGwgc29tZXRpbWVzIHJldHVybmVkIGJ5IHdhbGxldCBjb25uZWN0b3IgZnVuY3Rpb25zXG5cdFx0XHRDYm9yRGF0YS5kZWNvZGVUdXBsZShieXRlcywgKGksIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdFx0c3dpdGNoKGkpIHsgXG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0YWRkcmVzcyA9IEFkZHJlc3MuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IFZhbHVlLmZyb21DYm9yKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0b3V0cHV0RGF0dW0gPSBuZXcgSGFzaGVkRGF0dW0oRGF0dW1IYXNoLmZyb21DYm9yKGZpZWxkQnl0ZXMpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgZmllbGRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBvYmplY3Qgb3IgdHVwbGUgZm9yIFR4T3V0cHV0XCIpO1xuXHRcdH1cblxuXHRcdGlmIChhZGRyZXNzID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR4T3V0cHV0KGFkZHJlc3MsIHZhbHVlLCBvdXRwdXREYXR1bSwgcmVmU2NyaXB0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZHJlc3M6IHRoaXMuI2FkZHJlc3MuZHVtcCgpLFxuXHRcdFx0dmFsdWU6IHRoaXMuI3ZhbHVlLmR1bXAoKSxcblx0XHRcdGRhdHVtOiB0aGlzLiNkYXR1bSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLiNkYXR1bS5kdW1wKCksXG5cdFx0XHRyZWZTY3JpcHQ6IHRoaXMuI3JlZlNjcmlwdCA9PT0gbnVsbCA/IG51bGwgOiBieXRlc1RvSGV4KHRoaXMuI3JlZlNjcmlwdC50b0Nib3IoKSksXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvRGF0YSgpIHtcblx0XHRsZXQgZGF0dW0gPSBuZXcgQ29uc3RyRGF0YSgwLCBbXSk7IC8vIG5vbmVcblx0XHRpZiAodGhpcy4jZGF0dW0gIT09IG51bGwpIHtcblx0XHRcdGRhdHVtID0gdGhpcy4jZGF0dW0udG9EYXRhKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcblx0XHRcdHRoaXMuI2FkZHJlc3MuX3RvVXBsY0RhdGEoKSxcblx0XHRcdHRoaXMuI3ZhbHVlLl90b1VwbGNEYXRhKCksXG5cdFx0XHRkYXR1bSxcblx0XHRcdG5ldyBDb25zdHJEYXRhKDEsIFtdKSwgLy8gVE9ETzogaG93IHRvIGluY2x1ZGUgdGhlIHJlZiBzY3JpcHRcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFYWNoIFVUeE8gbXVzdCBjb250YWluIHNvbWUgbWluaW11bSBxdWFudGl0eSBvZiBsb3ZlbGFjZSB0byBhdm9pZCB0aGF0IHRoZSBibG9ja2NoYWluIGlzIHVzZWQgZm9yIGRhdGEgc3RvcmFnZVxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXNcblx0ICogQHJldHVybnMge2JpZ2ludH1cblx0ICovXG5cdGNhbGNNaW5Mb3ZlbGFjZShuZXR3b3JrUGFyYW1zKSB7XG5cdFx0bGV0IGxvdmVsYWNlUGVyQnl0ZSA9IG5ldHdvcmtQYXJhbXMubG92ZWxhY2VQZXJVVFhPQnl0ZTtcblxuXHRcdGxldCBjb3JyZWN0ZWRTaXplID0gdGhpcy50b0Nib3IoKS5sZW5ndGggKyAxNjA7IC8vIDE2MCBhY2NvdW50cyBmb3Igc29tZSBkYXRhYmFzZSBvdmVyaGVhZD9cblxuXHRcdHJldHVybiBCaWdJbnQoY29ycmVjdGVkU2l6ZSkqQmlnSW50KGxvdmVsYWNlUGVyQnl0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogTXV0YXRlcy4gTWFrZXMgc3VyZSB0aGUgb3V0cHV0IGNvbnRhaW5zIGF0IGxlYXN0IHRoZSBtaW5pbXVtIHF1YW50aXR5IG9mIGxvdmVsYWNlLlxuXHQgKiBPdGhlciBwYXJ0cyBvZiB0aGUgb3V0cHV0IGNhbiBvcHRpb25hbGx5IGFsc28gYmUgbXV0YXRlZFxuXHQgKiBAcGFyYW0ge05ldHdvcmtQYXJhbXN9IG5ldHdvcmtQYXJhbXMgXG5cdCAqIEBwYXJhbSB7Pygob3V0cHV0OiBUeE91dHB1dCkgPT4gdm9pZCl9IHVwZGF0ZXJcblx0ICovXG5cdGNvcnJlY3RMb3ZlbGFjZShuZXR3b3JrUGFyYW1zLCB1cGRhdGVyID0gbnVsbCkge1xuXHRcdGxldCBtaW5Mb3ZlbGFjZSA9IHRoaXMuY2FsY01pbkxvdmVsYWNlKG5ldHdvcmtQYXJhbXMpO1xuXG5cdFx0d2hpbGUgKHRoaXMuI3ZhbHVlLmxvdmVsYWNlIDwgbWluTG92ZWxhY2UpIHtcblx0XHRcdHRoaXMuI3ZhbHVlLnNldExvdmVsYWNlKG1pbkxvdmVsYWNlKTtcblxuXHRcdFx0aWYgKHVwZGF0ZXIgIT0gbnVsbCkge1xuXHRcdFx0XHR1cGRhdGVyKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtaW5Mb3ZlbGFjZSA9IHRoaXMuY2FsY01pbkxvdmVsYWNlKG5ldHdvcmtQYXJhbXMpO1xuXHRcdH1cblx0fVxufVxuXG4vLyBUT0RPOiBlbnVtIG1lbWJlcnNcbmNsYXNzIERDZXJ0IGV4dGVuZHMgQ2JvckRhdGEge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGJ5dGVzIFxuXHQgKiBAcmV0dXJucyB7RENlcnR9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUNib3IoYnl0ZXMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0dG9EYXRhKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cbn1cblxuLyoqXG4gKiBDb252ZW5pZW5jZSBhZGRyZXNzIHRoYXQgaXMgdXNlZCB0byBxdWVyeSBhbGwgYXNzZXRzIGNvbnRyb2xsZWQgYnkgYSBnaXZlbiBTdGFrZUhhc2ggKGNhbiBiZSBzY3JpcHRIYXNoIG9yIHJlZ3VsYXIgc3Rha2VIYXNoKVxuICovXG5leHBvcnQgY2xhc3MgU3Rha2VBZGRyZXNzIHtcblx0I2J5dGVzO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICovXG5cdGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG5cdFx0YXNzZXJ0KGJ5dGVzLmxlbmd0aCA9PSAyOSk7XG5cblx0XHR0aGlzLiNieXRlcyA9IGJ5dGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJbXX1cblx0ICovXG5cdGdldCBieXRlcygpIHtcblx0XHRyZXR1cm4gdGhpcy4jYnl0ZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTdGFrZUFkZHJlc3N9IHNhXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c3RhdGljIGlzRm9yVGVzdG5ldChzYSkge1xuXHRcdHJldHVybiBBZGRyZXNzLmlzRm9yVGVzdG5ldChuZXcgQWRkcmVzcyhzYS5ieXRlcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgcmVndWxhciBBZGRyZXNzIGludG8gU3Rha2VBZGRyZXNzLlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIEFkZHJlc3MgZG9lc24ndCBoYXZlIGEgc3Rha2luZyBwYXJ0LlxuXHQgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHIgXG5cdCAqIEByZXR1cm5zIHtTdGFrZUFkZHJlc3N9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbUFkZHJlc3MoYWRkcikge1xuXHRcdGNvbnN0IHNoID0gYWRkci5zdGFraW5nSGFzaDtcblxuXHRcdGlmIChzaCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBzdGFraW5nIHBhcnRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBTdGFrZUFkZHJlc3MuZnJvbUhhc2goQWRkcmVzcy5pc0ZvclRlc3RuZXQoYWRkciksIHNoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVCeXRlcyh0aGlzLiNieXRlcyk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXNcblx0ICogQHJldHVybnMge1N0YWtlQWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdHJldHVybiBuZXcgU3Rha2VBZGRyZXNzKENib3JEYXRhLmRlY29kZUJ5dGVzKGJ5dGVzKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvQmVjaDMyKCkge1xuXHRcdHJldHVybiBDcnlwdG8uZW5jb2RlQmVjaDMyKFxuXHRcdFx0U3Rha2VBZGRyZXNzLmlzRm9yVGVzdG5ldCh0aGlzKSA/IFwic3Rha2VfdGVzdFwiIDogXCJzdGFrZVwiLFxuXHRcdFx0dGhpcy5ieXRlc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJucyB7U3Rha2VBZGRyZXNzfVxuXHQgKi9cblx0c3RhdGljIGZyb21CZWNoMzIoc3RyKSB7XG5cdFx0bGV0IFtwcmVmaXgsIGJ5dGVzXSA9IENyeXB0by5kZWNvZGVCZWNoMzIoc3RyKTtcblxuXHRcdGxldCByZXN1bHQgPSBuZXcgU3Rha2VBZGRyZXNzKGJ5dGVzKTtcblxuXHRcdGFzc2VydChwcmVmaXggPT0gKFN0YWtlQWRkcmVzcy5pc0ZvclRlc3RuZXQocmVzdWx0KSA/IFwic3Rha2VfdGVzdFwiIDogXCJzdGFrZVwiKSwgXCJpbnZhbGlkIFN0YWtlQWRkcmVzcyBwcmVmaXhcIik7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJhdyBTdGFrZUFkZHJlc3MgYnl0ZXMgYXMgYSBoZXggZW5jb2RlZCBzdHJpbmdcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHRvSGV4KCkge1xuXHRcdHJldHVybiBieXRlc1RvSGV4KHRoaXMuI2J5dGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2Vzbid0IGNoZWNrIHZhbGlkaXR5XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBoZXhcblx0ICogQHJldHVybnMge1N0YWtlQWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tSGV4KGhleCkge1xuXHRcdHJldHVybiBuZXcgU3Rha2VBZGRyZXNzKGhleFRvQnl0ZXMoaGV4KSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcmVzcyB3aXRoIG9ubHkgc3Rha2luZyBwYXJ0IChyZWd1bGFyIFN0YWtlS2V5SGFzaClcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1Rlc3RuZXRcblx0ICogQHBhcmFtIHtTdGFrZUtleUhhc2h9IGhhc2hcblx0ICogQHJldHVybnMge1N0YWtlQWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tU3Rha2VLZXlIYXNoKGlzVGVzdG5ldCwgaGFzaCkge1xuXHRcdHJldHVybiBuZXcgU3Rha2VBZGRyZXNzKFxuXHRcdFx0W2lzVGVzdG5ldCA/IDB4ZTAgOiAweGUxXS5jb25jYXQoaGFzaC5ieXRlcylcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHJlc3Mgd2l0aCBvbmx5IHN0YWtpbmcgcGFydCAoc2NyaXB0IFN0YWtpbmdWYWxpZGF0b3JIYXNoKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGVzdG5ldFxuXHQgKiBAcGFyYW0ge1N0YWtpbmdWYWxpZGF0b3JIYXNofSBoYXNoXG5cdCAqIEByZXR1cm5zIHtTdGFrZUFkZHJlc3N9XG5cdCAqL1xuXHRzdGF0aWMgZnJvbVN0YWtpbmdWYWxpZGF0b3JIYXNoKGlzVGVzdG5ldCwgaGFzaCkge1xuXHRcdHJldHVybiBuZXcgU3Rha2VBZGRyZXNzKFxuXHRcdFx0W2lzVGVzdG5ldCA/IDB4ZjAgOiAweGYxXS5jb25jYXQoaGFzaC5ieXRlcylcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUZXN0bmV0XG5cdCAqIEBwYXJhbSB7U3Rha2VLZXlIYXNoIHwgU3Rha2luZ1ZhbGlkYXRvckhhc2h9IGhhc2hcblx0ICogQHJldHVybnMge1N0YWtlQWRkcmVzc31cblx0ICovXG5cdHN0YXRpYyBmcm9tSGFzaChpc1Rlc3RuZXQsIGhhc2gpIHtcblx0XHRpZiAoaGFzaCBpbnN0YW5jZW9mIFN0YWtlS2V5SGFzaCkge1xuXHRcdFx0cmV0dXJuIFN0YWtlQWRkcmVzcy5mcm9tU3Rha2VLZXlIYXNoKGlzVGVzdG5ldCwgaGFzaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBTdGFrZUFkZHJlc3MuZnJvbVN0YWtpbmdWYWxpZGF0b3JIYXNoKGlzVGVzdG5ldCwgaGFzaCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtTdGFrZUtleUhhc2ggfCBTdGFraW5nVmFsaWRhdG9ySGFzaH1cblx0ICovXG5cdGdldCBzdGFraW5nSGFzaCgpIHtcblx0XHRjb25zdCB0eXBlID0gdGhpcy5ieXRlc1swXTtcblxuXHRcdGlmICh0eXBlID09IDB4ZTAgfHwgdHlwZSA9PSAweGUxKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0YWtlS2V5SGFzaCh0aGlzLmJ5dGVzLnNsaWNlKDEpKTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gMHhmMCB8fCB0eXBlID09IDB4ZjEpIHtcblx0XHRcdHJldHVybiBuZXcgU3Rha2luZ1ZhbGlkYXRvckhhc2godGhpcy5ieXRlcy5zbGljZSgxKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImJhZCBTdGFrZUFkZHJlc3MgaGVhZGVyXCIpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIGV4dGVuZHMgQ2JvckRhdGEge1xuXHQvKiogQHR5cGUge251bWJlcltdfSAqL1xuXHQjcHViS2V5O1xuXG5cdC8qKiBAdHlwZSB7bnVtYmVyW119ICovXG5cdCNzaWduYXR1cmU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHB1YktleSBcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gc2lnbmF0dXJlIFxuXHQgKi9cblx0Y29uc3RydWN0b3IocHViS2V5LCBzaWduYXR1cmUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuI3B1YktleSA9IHB1YktleTtcblx0XHR0aGlzLiNzaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge1NpZ25hdHVyZX1cblx0ICovXG5cdHN0YXRpYyBkdW1teSgpIHtcblx0XHRyZXR1cm4gbmV3IFNpZ25hdHVyZSgobmV3IEFycmF5KDMyKSkuZmlsbCgwKSwgKG5ldyBBcnJheSg2NCkpLmZpbGwoMCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNEdW1teSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jcHViS2V5LmV2ZXJ5KGIgPT4gYiA9PSAwKSAmJiB0aGlzLiNzaWduYXR1cmUuZXZlcnkoYiA9PiBiID09IDApO1xuXHR9XG5cblx0dG9DYm9yKCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVUdXBsZShbXG5cdFx0XHRDYm9yRGF0YS5lbmNvZGVCeXRlcyh0aGlzLiNwdWJLZXkpLFxuXHRcdFx0Q2JvckRhdGEuZW5jb2RlQnl0ZXModGhpcy4jc2lnbmF0dXJlKSxcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge1NpZ25hdHVyZX1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdC8qKiBAdHlwZSB7P251bWJlcltdfSAqL1xuXHRcdGxldCBwdWJLZXkgPSBudWxsO1xuXG5cdFx0LyoqIEB0eXBlIHs/bnVtYmVyW119ICovXG5cdFx0bGV0IHNpZ25hdHVyZSA9IG51bGw7XG5cblx0XHRsZXQgbiA9IENib3JEYXRhLmRlY29kZVR1cGxlKGJ5dGVzLCAoaSwgZmllbGRCeXRlcykgPT4ge1xuXHRcdFx0c3dpdGNoKGkpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdHB1YktleSA9IENib3JEYXRhLmRlY29kZUJ5dGVzKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0c2lnbmF0dXJlID0gQ2JvckRhdGEuZGVjb2RlQnl0ZXMoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5yZWNvZ25pemVkIGZpZWxkXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KG4gPT0gMik7XG5cblx0XHRpZiAocHViS2V5ID09PSBudWxsIHx8IHNpZ25hdHVyZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBTaWduYXR1cmUocHViS2V5LCBzaWduYXR1cmUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cHViS2V5OiBieXRlc1RvSGV4KHRoaXMuI3B1YktleSksXG5cdFx0XHRwdWJLZXlIYXNoOiBieXRlc1RvSGV4KENyeXB0by5ibGFrZTJiKHRoaXMuI3B1YktleSwgMjgpKSxcblx0XHRcdHNpZ25hdHVyZTogYnl0ZXNUb0hleCh0aGlzLiNzaWduYXR1cmUpLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogVGhyb3dzIGVycm9yIGlmIGluY29ycmVjdFxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBtc2dcblx0ICovXG5cdHZlcmlmeShtc2cpIHtcblx0XHRpZiAodGhpcy4jc2lnbmF0dXJlID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzaWduYXR1cmUgY2FuJ3QgYmUgbnVsbFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuI3B1YktleSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJwdWJLZXkgY2FuJ3QgYmUgbnVsbFwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghQ3J5cHRvLkVkMjU1MTkudmVyaWZ5KHRoaXMuI3NpZ25hdHVyZSwgbXNnLCB0aGlzLiNwdWJLZXkpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IHNpZ25hdHVyZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5jbGFzcyBSZWRlZW1lciBleHRlbmRzIENib3JEYXRhIHtcblx0LyoqIEB0eXBlIHtVcGxjRGF0YX0gKi9cblx0I2RhdGE7XG5cblx0LyoqIEB0eXBlIHtDb3N0fSAqL1xuXHQjZXhVbml0cztcblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YSBcblx0ICogQHBhcmFtIHtDb3N0fSBleFVuaXRzIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoZGF0YSwgZXhVbml0cyA9IHttZW06IDBuLCBjcHU6IDBufSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy4jZXhVbml0cyA9IGV4VW5pdHM7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1VwbGNEYXRhfVxuXHQgKi9cblx0Z2V0IGRhdGEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2RhdGE7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge2JpZ2ludH1cblx0ICovXG5cdGdldCBtZW1Db3N0KCkge1xuXHRcdHJldHVybiB0aGlzLiNleFVuaXRzLm1lbTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7YmlnaW50fVxuXHQgKi9cblx0Z2V0IGNwdUNvc3QoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI2V4VW5pdHMuY3B1O1xuXHR9XG5cblx0LyoqXG5cdCAqIHR5cGU6XG5cdCAqICAgMCAtPiBzcGVuZGluZ1xuXHQgKiAgIDEgLT4gbWludGluZyBcblx0ICogICAyIC0+IGNlcnRpZnlpbmdcblx0ICogICAzIC0+IHJld2FyZGluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdHlwZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3JJbnRlcm5hbCh0eXBlLCBpbmRleCkge1xuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVUdXBsZShbXG5cdFx0XHRDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKEJpZ0ludCh0eXBlKSksXG5cdFx0XHRDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKEJpZ0ludChpbmRleCkpLFxuXHRcdFx0dGhpcy4jZGF0YS50b0Nib3IoKSxcblx0XHRcdENib3JEYXRhLmVuY29kZVR1cGxlKFtcblx0XHRcdFx0Q2JvckRhdGEuZW5jb2RlSW50ZWdlcih0aGlzLiNleFVuaXRzLm1lbSksXG5cdFx0XHRcdENib3JEYXRhLmVuY29kZUludGVnZXIodGhpcy4jZXhVbml0cy5jcHUpLFxuXHRcdFx0XSksXG5cdFx0XSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gYnl0ZXMgXG5cdCAqIEByZXR1cm5zIHtSZWRlZW1lcn1cblx0ICovXG5cdHN0YXRpYyBmcm9tQ2JvcihieXRlcykge1xuXHRcdC8qKiBAdHlwZSB7P251bWJlcn0gKi9cblx0XHRsZXQgdHlwZSA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUgez9udW1iZXJ9ICovXG5cdFx0bGV0IGluZGV4ID0gbnVsbDtcblxuXHRcdC8qKiBAdHlwZSB7P1VwbGNEYXRhfSAqL1xuXHRcdGxldCBkYXRhID0gbnVsbDtcblxuXHRcdC8qKiBAdHlwZSB7P0Nvc3R9ICovXG5cdFx0bGV0IGNvc3QgPSBudWxsO1xuXG5cdFx0bGV0IG4gPSBDYm9yRGF0YS5kZWNvZGVUdXBsZShieXRlcywgKGksIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdHN3aXRjaChpKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHR0eXBlID0gTnVtYmVyKENib3JEYXRhLmRlY29kZUludGVnZXIoZmllbGRCeXRlcykpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0aW5kZXggPSBOdW1iZXIoQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihmaWVsZEJ5dGVzKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRkYXRhID0gVXBsY0RhdGEuZnJvbUNib3IoZmllbGRCeXRlcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMzogXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHs/YmlnaW50fSAqL1xuXHRcdFx0XHRcdGxldCBtZW0gPSBudWxsO1xuXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHs/YmlnaW50fSAqL1xuXHRcdFx0XHRcdGxldCBjcHUgPSBudWxsO1xuXG5cdFx0XHRcdFx0bGV0IG0gPSBDYm9yRGF0YS5kZWNvZGVUdXBsZShmaWVsZEJ5dGVzLCAoaiwgc3ViRmllbGRCeXRlcykgPT4ge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChqKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRcdFx0XHRtZW0gPSBDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKHN1YkZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdFx0Y3B1ID0gQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihzdWJGaWVsZEJ5dGVzKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlY29nbml6ZWQgZmllbGRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRhc3NlcnQobSA9PSAyKTtcblxuXHRcdFx0XHRcdGlmIChtZW0gPT09IG51bGwgfHwgY3B1ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb3N0ID0ge21lbTogbWVtLCBjcHU6IGNwdX07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBmaWVsZFwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChuID09IDQpO1xuXG5cdFx0aWYgKHR5cGUgPT09IG51bGwgfHwgaW5kZXggPT09IG51bGwgfHwgZGF0YSA9PT0gbnVsbCB8fCBjb3N0ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN3aXRjaCh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFNwZW5kaW5nUmVkZWVtZXIobnVsbCwgaW5kZXgsIGRhdGEsIGNvc3QpO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNaW50aW5nUmVkZWVtZXIobnVsbCwgaW5kZXgsIGRhdGEsIGNvc3QpO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCByZWRlZW1lciB0eXBlIChUb2RvKVwiKTtcdFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcEludGVybmFsKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiB0aGlzLiNkYXRhLnRvU3RyaW5nKCksXG5cdFx0XHRleFVuaXRzOiB7XG5cdFx0XHRcdG1lbTogdGhpcy4jZXhVbml0cy5tZW0udG9TdHJpbmcoKSxcblx0XHRcdFx0Y3B1OiB0aGlzLiNleFVuaXRzLmNwdS50b1N0cmluZygpLFxuXHRcdFx0fSxcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R4Qm9keX0gYm9keSBcblx0ICogQHJldHVybnMge0NvbnN0ckRhdGF9XG5cdCAqL1xuXHR0b1NjcmlwdFB1cnBvc2VEYXRhKGJvZHkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhCb2R5fSBib2R5IFxuXHQgKi9cblx0dXBkYXRlSW5kZXgoYm9keSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtDb3N0fSBjb3N0IFxuXHQgKi9cblx0c2V0Q29zdChjb3N0KSB7XG5cdFx0dGhpcy4jZXhVbml0cyA9IGNvc3Q7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtOZXR3b3JrUGFyYW1zfSBuZXR3b3JrUGFyYW1zIFxuXHQgKiBAcmV0dXJucyB7YmlnaW50fVxuXHQgKi9cblx0ZXN0aW1hdGVGZWUobmV0d29ya1BhcmFtcykge1xuXHRcdC8vIHRoaXMuI2V4VW5pdHMubWVtIGFuZCB0aGlzLiNleFVuaXRzIGNhbiBiZSAwIGlmIHdlIGFyZSBlc3RpbWF0aW5nIHRoZSBmZWUgZm9yIGFuIGluaXRpYWwgYmFsYW5jZVxuXHRcdFxuXHRcdGxldCBbbWVtRmVlLCBjcHVGZWVdID0gbmV0d29ya1BhcmFtcy5leEZlZVBhcmFtcztcblxuXHRcdHJldHVybiBCaWdJbnQoTWF0aC5jZWlsKE51bWJlcih0aGlzLiNleFVuaXRzLm1lbSkqbWVtRmVlICsgTnVtYmVyKHRoaXMuI2V4VW5pdHMuY3B1KSpjcHVGZWUpKTtcblx0fVxufVxuXG5jbGFzcyBTcGVuZGluZ1JlZGVlbWVyIGV4dGVuZHMgUmVkZWVtZXIge1xuXHQjaW5wdXQ7XG5cdCNpbnB1dEluZGV4O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gez9UeElucHV0fSBpbnB1dFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5wdXRJbmRleFxuXHQgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuXHQgKiBAcGFyYW0ge0Nvc3R9IGV4VW5pdHMgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihpbnB1dCwgaW5wdXRJbmRleCwgZGF0YSwgZXhVbml0cyA9IHttZW06IDBuLCBjcHU6IDBufSkge1xuXHRcdHN1cGVyKGRhdGEsIGV4VW5pdHMpO1xuXG5cdFx0dGhpcy4jaW5wdXQgPSBpbnB1dFxuXHRcdHRoaXMuI2lucHV0SW5kZXggPSBpbnB1dEluZGV4O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRnZXQgaW5wdXRJbmRleCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jaW5wdXRJbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9DYm9ySW50ZXJuYWwoMCwgdGhpcy4jaW5wdXRJbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0bGV0IG9iaiA9IHN1cGVyLmR1bXBJbnRlcm5hbCgpO1xuXG5cdFx0b2JqW1widHlwZVwiXSA9IDA7XG5cdFx0b2JqW1widHlwZU5hbWVcIl0gPSBcInNwZW5kaW5nXCI7XG5cdFx0b2JqW1wiaW5wdXRJbmRleFwiXSA9IHRoaXMuI2lucHV0SW5kZXg7XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhCb2R5fSBib2R5IFxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvU2NyaXB0UHVycG9zZURhdGEoYm9keSkge1xuXHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgxLCBbXG5cdFx0XHRib2R5LmlucHV0c1t0aGlzLiNpbnB1dEluZGV4XS50b091dHB1dElkRGF0YSgpLFxuXHRcdF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhCb2R5fSBib2R5XG5cdCAqL1xuXHR1cGRhdGVJbmRleChib2R5KSB7XG5cdFx0aWYgKHRoaXMuI2lucHV0ID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImlucHV0IGNhbid0IGJlIG51bGxcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuI2lucHV0SW5kZXggPSBib2R5LmlucHV0cy5maW5kSW5kZXgoaSA9PiB7XG5cdFx0XHRcdHJldHVybiBpLnR4SWQuZXEoYXNzZXJ0RGVmaW5lZCh0aGlzLiNpbnB1dCkudHhJZCkgJiYgKGkudXR4b0lkeCA9PSBhc3NlcnREZWZpbmVkKHRoaXMuI2lucHV0KS51dHhvSWR4KVxuXHRcdFx0fSk7XG5cblx0XHRcdGFzc2VydCh0aGlzLiNpbnB1dEluZGV4ICE9IC0xKTtcblx0XHR9XG5cdH1cbn1cblxuY2xhc3MgTWludGluZ1JlZGVlbWVyIGV4dGVuZHMgUmVkZWVtZXIge1xuXHQjbXBoO1xuXHQjbXBoSW5kZXg7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7P01pbnRpbmdQb2xpY3lIYXNofSBtcGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1waEluZGV4XG5cdCAqIEBwYXJhbSB7VXBsY0RhdGF9IGRhdGFcblx0ICogQHBhcmFtIHtDb3N0fSBleFVuaXRzXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtcGgsIG1waEluZGV4LCBkYXRhLCBleFVuaXRzID0ge21lbTogMG4sIGNwdTogMG59KSB7XG5cdFx0c3VwZXIoZGF0YSwgZXhVbml0cyk7XG5cblx0XHR0aGlzLiNtcGggPSBtcGg7XG5cdFx0dGhpcy4jbXBoSW5kZXggPSBtcGhJbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0IG1waEluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLiNtcGhJbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9DYm9ySW50ZXJuYWwoMSwgdGhpcy4jbXBoSW5kZXgpO1xuXHR9XG5cblx0LyoqIFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRsZXQgb2JqID0gc3VwZXIuZHVtcEludGVybmFsKCk7XG5cblx0XHRvYmpbXCJ0eXBlXCJdID0gMTtcblx0XHRvYmpbXCJ0eXBlTmFtZVwiXSA9IFwibWludGluZ1wiO1xuXHRcdG9ialtcIm1waEluZGV4XCJdID0gdGhpcy4jbXBoSW5kZXg7XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VHhCb2R5fSBib2R5IFxuXHQgKiBAcmV0dXJucyB7Q29uc3RyRGF0YX1cblx0ICovXG5cdHRvU2NyaXB0UHVycG9zZURhdGEoYm9keSkge1xuXHRcdGxldCBtcGggPSBib2R5Lm1pbnRlZC5taW50aW5nUG9saWNpZXNbdGhpcy4jbXBoSW5kZXhdO1xuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIFtcblx0XHRcdG5ldyBCeXRlQXJyYXlEYXRhKG1waC5ieXRlcyksXG5cdFx0XSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUeEJvZHl9IGJvZHkgXG5cdCAqL1xuXHR1cGRhdGVJbmRleChib2R5KSB7XG5cdFx0aWYgKHRoaXMuI21waCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgaGF2ZSBudWxsIG1waCBhdCB0aGlzIHBvaW50XCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiNtcGhJbmRleCA9IGJvZHkubWludGVkLm1pbnRpbmdQb2xpY2llcy5maW5kSW5kZXgobXBoID0+IG1waC5lcShhc3NlcnREZWZpbmVkKHRoaXMuI21waCkpKTtcblxuXHRcdFx0YXNzZXJ0KHRoaXMuI21waEluZGV4ICE9IC0xKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBJbnNpZGUgaGVsaW9zIHRoaXMgdHlwZSBpcyBuYW1lZCBPdXRwdXREYXR1bSBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIHRoZSB1c2VyIGRlZmluZWQgRGF0dW0sXG4gKiBidXQgb3V0c2lkZSBoZWxpb3Mgc2NyaXB0cyB0aGVyZSBpc24ndCBtdWNoIHNlbnNlIHRvIGtlZXAgdXNpbmcgdGhlIG5hbWUgJ091dHB1dERhdHVtJyBpbnN0ZWFkIG9mIERhdHVtXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXR1bSBleHRlbmRzIENib3JEYXRhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcblx0ICogQHJldHVybnMge0RhdHVtfVxuXHQgKi9cblx0c3RhdGljIGZyb21DYm9yKGJ5dGVzKSB7XG5cdFx0LyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuXHRcdGxldCB0eXBlID0gbnVsbDtcblxuXHRcdC8qKiBAdHlwZSB7P0RhdHVtfSAqL1xuXHRcdGxldCByZXMgPSBudWxsO1xuXG5cdFx0bGV0IG4gPSBDYm9yRGF0YS5kZWNvZGVUdXBsZShieXRlcywgKGksIGZpZWxkQnl0ZXMpID0+IHtcblx0XHRcdHN3aXRjaChpKSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHR0eXBlID0gTnVtYmVyKENib3JEYXRhLmRlY29kZUludGVnZXIoZmllbGRCeXRlcykpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT0gMCkge1xuXHRcdFx0XHRcdFx0cmVzID0gbmV3IEhhc2hlZERhdHVtKERhdHVtSGFzaC5mcm9tQ2JvcihmaWVsZEJ5dGVzKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09IDEpIHtcblx0XHRcdFx0XHRcdGFzc2VydChDYm9yRGF0YS5kZWNvZGVUYWcoZmllbGRCeXRlcykgPT0gMjRuKTtcblxuXHRcdFx0XHRcdFx0bGV0IGRhdGFCeXRlcyA9IENib3JEYXRhLmRlY29kZUJ5dGVzKGZpZWxkQnl0ZXMpO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGEgPSBVcGxjRGF0YS5mcm9tQ2JvcihkYXRhQnl0ZXMpO1xuXG5cdFx0XHRcdFx0XHRyZXMgPSBuZXcgSW5saW5lRGF0dW0oZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVucmVjb2duaXplZCBmaWVsZCBsYWJlbFwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChuID09IDIpO1xuXG5cdFx0aWYgKHR5cGUgPT09IG51bGwgfHwgcmVzID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNEYXRhVmFsdWUgfCBVcGxjRGF0YSB8IEhlbGlvc0RhdGF9IGRhdGFcblx0ICogQHJldHVybnMge0hhc2hlZERhdHVtfVxuXHQgKi9cblx0c3RhdGljIGhhc2hlZChkYXRhKSB7XG5cdFx0aWYgKGRhdGEgaW5zdGFuY2VvZiBIZWxpb3NEYXRhKSB7XG5cdFx0XHRyZXR1cm4gSGFzaGVkRGF0dW0uZnJvbURhdGEoZGF0YS5fdG9VcGxjRGF0YSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIEhhc2hlZERhdHVtLmZyb21EYXRhKFVwbGNEYXRhVmFsdWUudW53cmFwKGRhdGEpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YVZhbHVlIHwgVXBsY0RhdGEgfCBIZWxpb3NEYXRhfSBkYXRhXG5cdCAqIEByZXR1cm5zIHtJbmxpbmVEYXR1bX1cblx0ICovXG5cdHN0YXRpYyBpbmxpbmUoZGF0YSkge1xuXHRcdGlmIChkYXRhIGluc3RhbmNlb2YgSGVsaW9zRGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBJbmxpbmVEYXR1bShkYXRhLl90b1VwbGNEYXRhKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IElubGluZURhdHVtKFVwbGNEYXRhVmFsdWUudW53cmFwKGRhdGEpKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0lubGluZSgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNIYXNoZWQoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7RGF0dW1IYXNofVxuXHQgKi9cblx0Z2V0IGhhc2goKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7P1VwbGNEYXRhfVxuXHQgKi9cblx0Z2V0IGRhdGEoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZFwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgeWV0IGltcGxlbWVudGVkXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0dG9EYXRhKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnNpZGUgaGVsaW9zIHRoaXMgdHlwZSBpcyBuYW1lZCBPdXRwdXREYXR1bTo6SGFzaCBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIHRoZSB1c2VyIGRlZmluZWQgRGF0dW0sXG4gKiBidXQgb3V0c2lkZSBoZWxpb3Mgc2NyaXB0cyB0aGVyZSBpc24ndCBtdWNoIHNlbnNlIHRvIGtlZXAgdXNpbmcgdGhlIG5hbWUgJ091dHB1dERhdHVtJyBpbnN0ZWFkIG9mIERhdHVtXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoZWREYXR1bSBleHRlbmRzIERhdHVtIHtcblx0LyoqIEB0eXBlIHtEYXR1bUhhc2h9ICovXG5cdCNoYXNoO1xuXG5cdC8qKiBAdHlwZSB7P1VwbGNEYXRhfSAqL1xuXHQjb3JpZ0RhdGE7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RGF0dW1IYXNofSBoYXNoIFxuXHQgKiBAcGFyYW0gez9VcGxjRGF0YX0gb3JpZ0RhdGFcblx0ICovXG5cdGNvbnN0cnVjdG9yKGhhc2gsIG9yaWdEYXRhID0gbnVsbCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jaGFzaCA9IGhhc2g7XG5cdFx0dGhpcy4jb3JpZ0RhdGEgPSBvcmlnRGF0YTtcblxuXHRcdGlmICh0aGlzLiNvcmlnRGF0YSAhPT0gbnVsbCkge1xuXHRcdFx0YXNzZXJ0KGVxKHRoaXMuI2hhc2guYnl0ZXMsIENyeXB0by5ibGFrZTJiKHRoaXMuI29yaWdEYXRhLnRvQ2JvcigpKSkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSW5saW5lKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSGFzaGVkKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtEYXR1bUhhc2h9XG5cdCAqL1xuXHRnZXQgaGFzaCgpIHtcblx0XHRyZXR1cm4gdGhpcy4jaGFzaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7P1VwbGNEYXRhfVxuXHQgKi9cblx0Z2V0IGRhdGEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI29yaWdEYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgc2NyaXB0IGNvbnRleHQgZW11bGF0aW9uXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0dG9EYXRhKCkge1xuXHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgxLCBbbmV3IEJ5dGVBcnJheURhdGEodGhpcy4jaGFzaC5ieXRlcyldKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHR0b0Nib3IoKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZVR1cGxlKFtcblx0XHRcdENib3JEYXRhLmVuY29kZUludGVnZXIoMG4pLFxuXHRcdFx0dGhpcy4jaGFzaC50b0Nib3IoKSxcblx0XHRdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwbGNEYXRhfSBkYXRhIFxuXHQgKiBAcmV0dXJucyB7SGFzaGVkRGF0dW19XG5cdCAqL1xuXHRzdGF0aWMgZnJvbURhdGEoZGF0YSkge1xuXHRcdHJldHVybiBuZXcgSGFzaGVkRGF0dW0obmV3IEhhc2goQ3J5cHRvLmJsYWtlMmIoZGF0YS50b0Nib3IoKSkpLCBkYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0ZHVtcCgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGFzaDogdGhpcy4jaGFzaC5kdW1wKCksXG5cdFx0XHRjYm9yOiB0aGlzLiNvcmlnRGF0YSA9PT0gbnVsbCA/IG51bGwgOiBieXRlc1RvSGV4KHRoaXMuI29yaWdEYXRhLnRvQ2JvcigpKSxcblx0XHRcdHNjaGVtYTogdGhpcy4jb3JpZ0RhdGEgPT09IG51bGwgPyBudWxsIDogSlNPTi5wYXJzZSh0aGlzLiNvcmlnRGF0YS50b1NjaGVtYUpzb24oKSlcblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogSW5zaWRlIGhlbGlvcyB0aGlzIHR5cGUgaXMgbmFtZWQgT3V0cHV0RGF0dW06OklubGluZSBpbiBvcmRlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIHRoZSB1c2VyIGRlZmluZWQgRGF0dW0sXG4gKiBidXQgb3V0c2lkZSBoZWxpb3Mgc2NyaXB0cyB0aGVyZSBpc24ndCBtdWNoIHNlbnNlIHRvIGtlZXAgdXNpbmcgdGhlIG5hbWUgJ091dHB1dERhdHVtJyBpbnN0ZWFkIG9mIERhdHVtXG4gKi9cbmNsYXNzIElubGluZURhdHVtIGV4dGVuZHMgRGF0dW0ge1xuXHQvKiogQHR5cGUge1VwbGNEYXRhfSAqL1xuXHQjZGF0YTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGxjRGF0YX0gZGF0YVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZGF0YSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy4jZGF0YSA9IGRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0lubGluZSgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSGFzaGVkKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7RGF0dW1IYXNofVxuXHQgKi9cblx0Z2V0IGhhc2goKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXR1bUhhc2goQ3J5cHRvLmJsYWtlMmIodGhpcy4jZGF0YS50b0Nib3IoKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtVcGxjRGF0YX1cblx0ICovXG5cdGdldCBkYXRhKCkge1xuXHRcdHJldHVybiB0aGlzLiNkYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgc2NyaXB0IGNvbnRleHQgZW11bGF0aW9uXG5cdCAqIEByZXR1cm5zIHtDb25zdHJEYXRhfVxuXHQgKi9cblx0dG9EYXRhKCkge1xuXHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgyLCBbdGhpcy4jZGF0YV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHRvQ2JvcigpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlVHVwbGUoW1xuXHRcdFx0Q2JvckRhdGEuZW5jb2RlSW50ZWdlcigxbiksXG5cdFx0XHRDYm9yRGF0YS5lbmNvZGVUYWcoMjRuKS5jb25jYXQoQ2JvckRhdGEuZW5jb2RlQnl0ZXModGhpcy4jZGF0YS50b0Nib3IoKSkpXG5cdFx0XSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICovXG5cdGR1bXAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlubGluZUNib3I6IGJ5dGVzVG9IZXgodGhpcy4jZGF0YS50b0Nib3IoKSksXG5cdFx0XHRpbmxpbmVTY2hlbWE6IEpTT04ucGFyc2UodGhpcy4jZGF0YS50b1NjaGVtYUpzb24oKSlcblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGlubmVyICdhbnknIGlzIGFsc28gTWV0YWRhdGEsIGJ1dCBqc2RvYyBkb2Vzbid0IGFsbG93IGRlY2xhcmluZyByZWN1cnNpdmUgdHlwZXNcbiAqIE1ldGFkYXRhIGlzIGVzc2VudGlhbGx5IGEgSlNPTiBzY2hlbWEgb2JqZWN0XG4gKiBAdHlwZWRlZiB7e21hcDogW2FueSwgYW55XVtdfSB8IGFueVtdIHwgc3RyaW5nIHwgbnVtYmVyfSBNZXRhZGF0YVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtNZXRhZGF0YX0gbWV0YWRhdGEgXG4gKiBAcmV0dXJucyB7bnVtYmVyW119XG4gKi9cbmZ1bmN0aW9uIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG5cdGlmICh0eXBlb2YgbWV0YWRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZVV0ZjgobWV0YWRhdGEsIHRydWUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtZXRhZGF0YSA9PT0gJ251bWJlcicpIHtcblx0XHRhc3NlcnQobWV0YWRhdGEgJSAxLjAgPT0gMC4wKTtcblxuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVJbnRlZ2VyKEJpZ0ludChtZXRhZGF0YSkpO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWV0YWRhdGEpKSB7XG5cdFx0cmV0dXJuIENib3JEYXRhLmVuY29kZURlZkxpc3QobWV0YWRhdGEubWFwKGl0ZW0gPT4gZW5jb2RlTWV0YWRhdGEoaXRlbSkpKTtcblx0fSBlbHNlIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIE9iamVjdCAmJiBcIm1hcFwiIGluIG1ldGFkYXRhICYmIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPT0gMSkge1xuXHRcdGxldCBwYWlycyA9IG1ldGFkYXRhW1wibWFwXCJdO1xuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocGFpcnMpKSB7XG5cdFx0XHRyZXR1cm4gQ2JvckRhdGEuZW5jb2RlTWFwKHBhaXJzLm1hcChwYWlyID0+IHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocGFpcikgJiYgcGFpci5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRlbmNvZGVNZXRhZGF0YShwYWlyWzBdKSxcblx0XHRcdFx0XHRcdGVuY29kZU1ldGFkYXRhKHBhaXJbMV0pXG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1ldGFkYXRhIHNjaGVtYVwiKTtcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH0pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtZXRhZGF0YSBzY2hlbWFcIik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbWV0YWRhdGEgc2NoZW1hXCIpO1xuXHR9XG59XG5cbi8qKlxuICogU2hpZnRzIGJ5dGVzIHRvIG5leHQgQ2JvciBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcltdfSBieXRlcyBcbiAqIEByZXR1cm5zIHtNZXRhZGF0YX1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlTWV0YWRhdGEoYnl0ZXMpIHtcblx0aWYgKENib3JEYXRhLmlzVXRmOChieXRlcykpIHtcblx0XHRyZXR1cm4gQ2JvckRhdGEuZGVjb2RlVXRmOChieXRlcyk7XG5cdH0gZWxzZSBpZiAoQ2JvckRhdGEuaXNMaXN0KGJ5dGVzKSkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtNZXRhZGF0YVtdfVxuXHRcdCAqL1xuXHRcdGxldCBpdGVtcyA9IFtdO1xuXG5cdFx0Q2JvckRhdGEuZGVjb2RlTGlzdChieXRlcywgKF8sIGl0ZW1CeXRlcykgPT4ge1xuXHRcdFx0aXRlbXMucHVzaChkZWNvZGVNZXRhZGF0YShpdGVtQnl0ZXMpKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBpdGVtcztcblx0fSBlbHNlIGlmIChDYm9yRGF0YS5pc01hcChieXRlcykpIHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7W01ldGFkYXRhLCBNZXRhZGF0YV1bXX1cblx0XHQgKi9cblx0XHRsZXQgcGFpcnMgPSBbXTtcblxuXHRcdENib3JEYXRhLmRlY29kZU1hcChieXRlcywgKF8sIHBhaXJCeXRlcykgPT4ge1xuXHRcdFx0cGFpcnMucHVzaChbXG5cdFx0XHRcdGRlY29kZU1ldGFkYXRhKHBhaXJCeXRlcyksXG5cdFx0XHRcdGRlY29kZU1ldGFkYXRhKHBhaXJCeXRlcylcblx0XHRcdF0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtcIm1hcFwiOiBwYWlyc307XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIE51bWJlcihDYm9yRGF0YS5kZWNvZGVJbnRlZ2VyKGJ5dGVzKSk7XG5cdH1cbn1cblxuY2xhc3MgVHhNZXRhZGF0YSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIE1ldGFkYXRhPn0gXG5cdCAqL1xuXHQjbWV0YWRhdGE7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy4jbWV0YWRhdGEgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGFnXG5cdCAqIEBwYXJhbSB7TWV0YWRhdGF9IGRhdGFcblx0ICovXG5cdGFkZCh0YWcsIGRhdGEpIHtcblx0XHR0aGlzLiNtZXRhZGF0YVt0YWddID0gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7bnVtYmVyW119XG5cdCAqL1xuXHRnZXQga2V5cygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy4jbWV0YWRhdGEpLm1hcChrZXkgPT4gcGFyc2VJbnQoa2V5KSkuc29ydCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRkdW1wKCkge1xuXHRcdGxldCBvYmogPSB7fTtcblxuXHRcdGZvciAobGV0IGtleSBvZiB0aGlzLmtleXMpIHtcblx0XHRcdG9ialtrZXldID10aGlzLiNtZXRhZGF0YVtrZXldO1xuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0dG9DYm9yKCkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtbbnVtYmVyW10sIG51bWJlcltdXVtdfVxuXHRcdCAqL1xuXHRcdGNvbnN0IHBhaXJzID0gdGhpcy5rZXlzLm1hcChrZXkgPT4gW1xuXHRcdFx0Q2JvckRhdGEuZW5jb2RlSW50ZWdlcihCaWdJbnQoa2V5KSksXG5cdFx0XHRlbmNvZGVNZXRhZGF0YSh0aGlzLiNtZXRhZGF0YVtrZXldKVxuXHRcdF0pO1xuXHRcdFxuXHRcdHJldHVybiBDYm9yRGF0YS5lbmNvZGVNYXAocGFpcnMpO1xuXHR9XG5cblx0LyoqXG5cdCogRGVjb2RlcyBhIFR4TWV0YWRhdGEgaW5zdGFuY2UgZnJvbSBDYm9yXG5cdCogQHBhcmFtIHtudW1iZXJbXX0gZGF0YVxuXHQqIEByZXR1cm5zIHtUeE1ldGFkYXRhfVxuXHQqL1xuXHRzdGF0aWMgZnJvbUNib3IoZGF0YSkge1xuXHRcdGNvbnN0IHR4TWV0YWRhdGEgPSBuZXcgVHhNZXRhZGF0YSgpO1xuXG5cdFx0Q2JvckRhdGEuZGVjb2RlTWFwKGRhdGEsIChfLCBwYWlyQnl0ZXMpID0+IHtcblx0XHRcdHR4TWV0YWRhdGEuYWRkKFxuXHRcdFx0XHROdW1iZXIoQ2JvckRhdGEuZGVjb2RlSW50ZWdlcihwYWlyQnl0ZXMpKSwgXG5cdFx0XHRcdGRlY29kZU1ldGFkYXRhKHBhaXJCeXRlcylcblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHhNZXRhZGF0YTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDI2OiBIaWdobGlnaHRpbmcgZnVuY3Rpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENhdGVnb3JpZXMgZm9yIHN5bnRheCBoaWdobGlnaHRpbmdcbiAqL1xuY29uc3QgU3ludGF4Q2F0ZWdvcnkgPSB7XG5cdE5vcm1hbDogICAgIDAsXG5cdENvbW1lbnQ6ICAgIDEsXG5cdExpdGVyYWw6ICAgIDIsXG5cdFN5bWJvbDogICAgIDMsXG5cdFR5cGU6ICAgICAgIDQsXG5cdEtleXdvcmQ6ICAgIDUsXG5cdEVycm9yOiAgICAgIDYsXG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc3ludGF4IGhpZ2hsaWdodGluZyBieSByZXR1cm5pbmcgYSBsaXN0IG9mIGNoYXIgY2F0ZWdvcmllcy5cbiAqIE5vdCBwYXJ0IG9mIFRva2VpemVyIGJlY2F1c2UgaXQgbmVlZHMgdG8gYmUgdmVyeSBmYXN0IGFuZCBjYW4ndCB0aHJvdyBlcnJvcnMuXG4gKiBEb2Vzbid0IGRlcGVuZCBvbiBhbnkgb3RoZXIgZnVuY3Rpb25zIHNvIGl0IGNhbiBlYXNpbHkgYmUgcG9ydGVkIHRvIG90aGVyIGxhbmd1YWdlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGlnaGxpZ2h0KHNyYykge1xuXHRsZXQgbiA9IHNyYy5sZW5ndGg7XG5cblx0Y29uc3QgU3ludGF4U3RhdGUgPSB7XG5cdFx0Tm9ybWFsOiAgICAgICAgMCxcblx0XHRTTENvbW1lbnQ6ICAgICAxLFxuXHRcdE1MQ29tbWVudDogICAgIDIsXG5cdFx0U3RyaW5nOiAgICAgICAgMyxcblx0XHROdW1iZXJTdGFydDogICA0LFxuXHRcdEhleE51bWJlcjogICAgIDUsXG5cdFx0QmluYXJ5TnVtYmVyOiAgNixcblx0XHRPY3RhbE51bWJlcjogICA3LFxuXHRcdERlY2ltYWxOdW1iZXI6IDgsXG5cdFx0Qnl0ZUFycmF5OiAgICAgOSxcblx0fTtcblxuXHQvLyBhcnJheSBvZiBjYXRlZ29yaWVzXG5cdGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobik7XG5cblx0bGV0IGogPSAwOyAvLyBwb3NpdGlvbiBpbiBkYXRhXG5cdGxldCBzdGF0ZSA9IFN5bnRheFN0YXRlLk5vcm1hbDtcblxuXHQvKiogQHR5cGUge1N5bWJvbFRva2VuW119ICovXG5cdGxldCBncm91cFN0YWNrID0gW107XG5cdFxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdGxldCBjID0gc3JjW2ldO1xuXHRcdGxldCBpc0xhc3QgPSBpID09IG4gLSAxO1xuXG5cdFx0c3dpdGNoIChzdGF0ZSkge1xuXHRcdFx0Y2FzZSBTeW50YXhTdGF0ZS5Ob3JtYWw6XG5cdFx0XHRcdGlmIChjID09IFwiL1wiKSB7XG5cdFx0XHRcdFx0Ly8gbWF5YmUgY29tbWVudFxuXHRcdFx0XHRcdGlmICghaXNMYXN0ICYmIHNyY1tpKzFdID09IFwiL1wiKSB7XG5cdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5Db21tZW50O1xuXHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuQ29tbWVudDtcblx0XHRcblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuU0xDb21tZW50O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWlzTGFzdCAmJiBzcmNbaSsxXSA9PSBcIipcIikge1xuXHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuQ29tbWVudDtcblx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LkNvbW1lbnQ7XG5cblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuTUxDb21tZW50O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGMgPT0gXCJbXCIgfHwgYyA9PSBcIl1cIiB8fCBjID09IFwie1wiIHx8IGMgPT0gXCJ9XCIgfHwgYyA9PSBcIihcIiB8fCBjID09IFwiKVwiKSB7XG5cdFx0XHRcdFx0bGV0IHMgPSBuZXcgU3ltYm9sVG9rZW4obmV3IFNpdGUobmV3IFNvdXJjZShzcmMpLCBpKSwgYyk7XG5cblx0XHRcdFx0XHRpZiAoR3JvdXAuaXNPcGVuU3ltYm9sKHMpKSB7XG5cdFx0XHRcdFx0XHRncm91cFN0YWNrLnB1c2gocyk7XG5cdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5Ob3JtYWw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBwcmV2R3JvdXAgPSBncm91cFN0YWNrLnBvcCgpO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJldkdyb3VwID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuRXJyb3I7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT0gR3JvdXAubWF0Y2hTeW1ib2wocHJldkdyb3VwKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5Ob3JtYWw7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkYXRhW3ByZXZHcm91cC5zaXRlLnN0YXJ0UG9zXSA9IFN5bnRheENhdGVnb3J5LkVycm9yO1xuXHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5FcnJvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PSBcIiVcIiB8fCBjID09IFwiIVwiIHx8IGMgPT0gXCImXCIgfHwgYyA9PSBcIipcIiB8fCBjID09IFwiK1wiIHx8IGMgPT0gXCItXCIgfHwgYyA9PSBcIjxcIiB8fCBjID09IFwiPVwiIHx8IGMgPT0gXCI+XCIgfHwgYyA9PSBcInxcIikge1xuXHRcdFx0XHRcdC8vIHN5bWJvbFxuXHRcdFx0XHRcdHN3aXRjaCAoYykge1xuXHRcdFx0XHRcdFx0Y2FzZSBcIiZcIjpcblx0XHRcdFx0XHRcdFx0aWYgKCFpc0xhc3QgJiYgc3JjW2krMV0gPT0gXCImXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5Ob3JtYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwifFwiOlxuXHRcdFx0XHRcdFx0XHRpZiAoIWlzTGFzdCAmJiBzcmNbaSsxXSA9PSBcInxcIikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5Lk5vcm1hbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdGlmICghaXNMYXN0ICYmIHNyY1tpKzFdID09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIj1cIjpcblx0XHRcdFx0XHRcdFx0aWYgKCFpc0xhc3QgJiYgKHNyY1tpKzFdID09IFwiPVwiIHx8IHNyY1tpKzFdID09IFwiPlwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCI+XCI6XG5cdFx0XHRcdFx0XHRcdGlmICghaXNMYXN0ICYmIHNyY1tpKzFdID09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIjxcIjpcblx0XHRcdFx0XHRcdFx0aWYgKCFpc0xhc3QgJiYgc3JjW2krMV0gPT0gXCI9XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuU3ltYm9sO1xuXHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiLVwiOlxuXHRcdFx0XHRcdFx0XHRpZiAoIWlzTGFzdCAmJiBzcmNbaSsxXSA9PSBcIj5cIikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5TeW1ib2w7XG5cdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LlN5bWJvbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PSBcIlxcXCJcIikge1xuXHRcdFx0XHRcdC8vIGxpdGVyYWwgc3RyaW5nXG5cdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblx0XHRcdFx0XHRzdGF0ZSA9IFN5bnRheFN0YXRlLlN0cmluZztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09IFwiMFwiKSB7XG5cdFx0XHRcdFx0Ly8gbGl0ZXJhbCBudW1iZXJcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuTnVtYmVyU3RhcnQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA+PSBcIjFcIiAmJiBjIDw9IFwiOVwiKSB7XG5cdFx0XHRcdFx0Ly8gbGl0ZXJhbCBkZWNpbWFsIG51bWJlclxuXHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LkxpdGVyYWw7XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5EZWNpbWFsTnVtYmVyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGMgPT0gXCIjXCIpIHtcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuQnl0ZUFycmF5O1xuXHRcdFx0XHR9IGVsc2UgaWYgKChjID49IFwiYVwiICYmIGMgPD0gXCJ6XCIpIHx8IChjID49IFwiQVwiICYmIGMgPD0gXCJaXCIpIHx8IGMgPT0gXCJfXCIpIHtcblx0XHRcdFx0XHQvLyBtYXliZSBrZXl3b3JkLCBidWlsdGluIHR5cGUsIG9yIGJvb2xlYW5cblx0XHRcdFx0XHRsZXQgaTAgPSBpO1xuXHRcdFx0XHRcdGxldCBjaGFycyA9IFtjXTtcblx0XHRcdFx0XHQvLyBtb3ZlIGkgdG8gdGhlIGxhc3Qgd29yZCBjaGFyXG5cdFx0XHRcdFx0d2hpbGUgKGkgKyAxIDwgbikge1xuXHRcdFx0XHRcdFx0bGV0IGQgPSBzcmNbaSsxXTtcblxuXHRcdFx0XHRcdFx0aWYgKChkID49IFwiYVwiICYmIGQgPD0gXCJ6XCIpIHx8IChkID49IFwiQVwiICYmIGQgPD0gXCJaXCIpIHx8IGQgPT0gXCJfXCIgfHwgKGQgPj0gXCIwXCIgJiYgZCA8PSBcIjlcIikpIHtcblx0XHRcdFx0XHRcdFx0Y2hhcnMucHVzaChkKTtcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IHdvcmQgPSBjaGFycy5qb2luKFwiXCIpO1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdFx0XHRcdGxldCB0eXBlO1xuXHRcdFx0XHRcdHN3aXRjaCAod29yZCkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcInRydWVcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJmYWxzZVwiOlxuXHRcdFx0XHRcdFx0XHR0eXBlID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiQm9vbFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkludFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIkJ5dGVBcnJheVwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIlN0cmluZ1wiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIk9wdGlvblwiOlxuXHRcdFx0XHRcdFx0XHR0eXBlID0gU3ludGF4Q2F0ZWdvcnkuVHlwZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiaWZcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJlbHNlXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwic3dpdGNoXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiZnVuY1wiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcImNvbnN0XCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwic3RydWN0XCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiZW51bVwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcImltcG9ydFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcInByaW50XCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJzZWxmXCI6XG5cdFx0XHRcdFx0XHRcdHR5cGUgPSBTeW50YXhDYXRlZ29yeS5LZXl3b3JkO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ0ZXN0aW5nXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwic3BlbmRpbmdcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJzdGFraW5nXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwibWludGluZ1wiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcIm1vZHVsZVwiOlxuXHRcdFx0XHRcdFx0XHRpZiAoaTAgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGUgPSBTeW50YXhDYXRlZ29yeS5LZXl3b3JkO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGUgPSBTeW50YXhDYXRlZ29yeS5Ob3JtYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR0eXBlID0gU3ludGF4Q2F0ZWdvcnkuTm9ybWFsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGlpID0gaTA7IGlpIDwgaTAgKyBjaGFycy5sZW5ndGg7IGlpKyspIHtcblx0XHRcdFx0XHRcdGRhdGFbaisrXSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5Lk5vcm1hbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU3ludGF4U3RhdGUuU0xDb21tZW50OlxuXHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5Db21tZW50O1xuXHRcdFx0XHRpZiAoYyA9PSBcIlxcblwiKSB7XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5Ob3JtYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFN5bnRheFN0YXRlLk1MQ29tbWVudDpcblx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuQ29tbWVudDtcblxuXHRcdFx0XHRpZiAoYyA9PSBcIipcIiAmJiAhaXNMYXN0ICYmIHNyY1tpKzFdID09IFwiL1wiKSB7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LkNvbW1lbnQ7XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5Ob3JtYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFN5bnRheFN0YXRlLlN0cmluZzpcblx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblxuXHRcdFx0XHRpZiAoYyA9PSBcIlxcXCJcIikge1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuTm9ybWFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTeW50YXhTdGF0ZS5OdW1iZXJTdGFydDpcblx0XHRcdFx0aWYgKGMgPT0gXCJ4XCIpIHtcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuSGV4TnVtYmVyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGMgPT0gXCJvXCIpIHtcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuT2N0YWxOdW1iZXI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA9PSBcImJcIikge1xuXHRcdFx0XHRcdGRhdGFbaisrXSA9IFN5bnRheENhdGVnb3J5LkxpdGVyYWw7XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5CaW5hcnlOdW1iZXI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYyA+PSBcIjBcIiAmJiBjIDw9IFwiOVwiKSB7XG5cdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblx0XHRcdFx0XHRzdGF0ZSA9IFN5bnRheFN0YXRlLkRlY2ltYWxOdW1iZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHRcdHN0YXRlID0gU3ludGF4U3RhdGUuTm9ybWFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTeW50YXhTdGF0ZS5EZWNpbWFsTnVtYmVyOlxuXHRcdFx0XHRpZiAoYyA+PSBcIjBcIiAmJiBjIDw9IFwiOVwiKSB7XG5cdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5Ob3JtYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFN5bnRheFN0YXRlLkhleE51bWJlcjpcblx0XHRcdGNhc2UgU3ludGF4U3RhdGUuQnl0ZUFycmF5OlxuXHRcdFx0XHRpZiAoKGMgPj0gXCJhXCIgJiYgYyA8PSBcImZcIikgfHwgKGMgPj0gXCIwXCIgJiYgYyA8PSBcIjlcIikpIHtcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGktLTtcblx0XHRcdFx0XHRzdGF0ZSA9IFN5bnRheFN0YXRlLk5vcm1hbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU3ludGF4U3RhdGUuT2N0YWxOdW1iZXI6XG5cdFx0XHRcdGlmIChjID49IFwiMFwiICYmIGMgPD0gXCI3XCIpIHtcblx0XHRcdFx0XHRkYXRhW2orK10gPSBTeW50YXhDYXRlZ29yeS5MaXRlcmFsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGktLTtcblx0XHRcdFx0XHRzdGF0ZSA9IFN5bnRheFN0YXRlLk5vcm1hbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU3ludGF4U3RhdGUuQmluYXJ5TnVtYmVyOlxuXHRcdFx0XHRpZiAoYyA9PSBcIjBcIiB8fCBjID09IFwiMVwiKSB7XG5cdFx0XHRcdFx0ZGF0YVtqKytdID0gU3ludGF4Q2F0ZWdvcnkuTGl0ZXJhbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0c3RhdGUgPSBTeW50YXhTdGF0ZS5Ob3JtYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmhhbmRsZWQgU3ludGF4U3RhdGVcIik7XG5cdFx0fVx0XHRcblx0fVxuXG5cdGZvciAobGV0IHMgb2YgZ3JvdXBTdGFjaykge1xuXHRcdGRhdGFbcy5zaXRlLnN0YXJ0UG9zXSA9IFN5bnRheENhdGVnb3J5LkVycm9yO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMjc6IEZ1enp5IHRlc3RpbmcgZnJhbWV3b3JrXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoKSA9PiBVcGxjRGF0YX0gVmFsdWVHZW5lcmF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnczogVXBsY1ZhbHVlW10sIHJlczogKFVwbGNWYWx1ZSB8IFVzZXJFcnJvcikpID0+IChib29sZWFuIHwgT2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+KX0gUHJvcGVydHlUZXN0XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGdlbmVyYXRvcnMgYW5kIHJ1bnMgc2NyaXB0IHRlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBGdXp6eVRlc3Qge1xuXHQvKipcblx0ICogQHR5cGUge051bWJlckdlbmVyYXRvcn0gLSBzZWVkIGdlbmVyYXRvclxuXHQgKi9cblx0I3JhbmQ7XG5cblx0I3J1bnNQZXJUZXN0O1xuXG5cdCNzaW1wbGlmeTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJ1bnNQZXJUZXN0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltcGxpZnkgLSBpZiB0cnVlIHRoZW4gYWxzbyB0ZXN0IHRoZSBzaW1wbGlmaWVkIHByb2dyYW1cblx0ICovXG5cdGNvbnN0cnVjdG9yKHNlZWQgPSAwLCBydW5zUGVyVGVzdCA9IDEwMCwgc2ltcGxpZnkgPSBmYWxzZSkge1xuXHRcdGNvbnNvbGUubG9nKFwic3RhcnRpbmcgZnV6enkgdGVzdGluZyAgd2l0aCBzZWVkXCIsIHNlZWQpO1xuXG5cdFx0dGhpcy4jcmFuZCA9IENyeXB0by5yYW5kKHNlZWQpO1xuXHRcdHRoaXMuI3J1bnNQZXJUZXN0ID0gcnVuc1BlclRlc3Q7XG5cdFx0dGhpcy4jc2ltcGxpZnkgPSBzaW1wbGlmeTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyR2VuZXJhdG9yfVxuXHQgKi9cblx0bmV3UmFuZCgpIHtcblx0XHRsZXQgc2VlZCA9IHRoaXMuI3JhbmQoKSoxMDAwMDAwO1xuXG5cdFx0cmV0dXJuIENyeXB0by5yYW5kKHNlZWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZXJuYXRvciBmb3Igd2hvbGUgbnVtYmVycyBiZXR3ZWVuIG1pbiBhbmQgbWF4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFxuXHQgKiBAcmV0dXJucyB7KCkgPT4gYmlnaW50fVxuXHQgKi9cblx0cmF3SW50KG1pbiA9IC0xMDAwMDAwMCwgbWF4ID0gMTAwMDAwMDApIHtcblx0XHRsZXQgcmFuZCA9IHRoaXMubmV3UmFuZCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJpZ0ludChNYXRoLmZsb29yKHJhbmQoKSoobWF4IC0gbWluKSkgKyBtaW4pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2VuZXJhdG9yIGZvciB3aG9sZSBudW1iZXJzIGJldHdlZW4gbWluIGFuZCBtYXgsIHdyYXBwZWQgd2l0aCBJbnREYXRhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFxuXHQgKiBAcmV0dXJucyB7VmFsdWVHZW5lcmF0b3J9XG5cdCAqL1xuXHRpbnQobWluID0gLTEwMDAwMDAwLCBtYXggPSAxMDAwMDAwMCkge1x0XHRcblx0XHRsZXQgcmFuZCA9IHRoaXMucmF3SW50KG1pbiwgbWF4KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgSW50RGF0YShyYW5kKCkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2VuZXJhdG9yIGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYW55IHV0Zi04IGNoYXJhY3RlclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGhcblx0ICogQHJldHVybnMge1ZhbHVlR2VuZXJhdG9yfVxuXHQgKi9cblx0c3RyaW5nKG1pbkxlbmd0aCA9IDAsIG1heExlbmd0aCA9IDY0KSB7XG5cdFx0bGV0IHJhbmQgPSB0aGlzLm5ld1JhbmQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGxldCBuID0gTWF0aC5yb3VuZChyYW5kKCkqKG1heExlbmd0aCAtIG1pbkxlbmd0aCkpICsgbWluTGVuZ3RoO1xuXHRcdFx0aWYgKG4gPCAwKSB7XG5cdFx0XHRcdG4gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY2hhcnMgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdGNoYXJzLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoTWF0aC5yb3VuZChyYW5kKCkqMTExMjA2NCkpKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIEJ5dGVBcnJheURhdGEuZnJvbVN0cmluZyhjaGFycy5qb2luKFwiXCIpKTtcblx0XHR9XG5cdH1cblxuXHQvKiogXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIHN0cmluZ3Mgd2l0aCBhc2NpaSBjaGFyYWN0ZXJzIGZyb20gMzIgKHNwYWNlKSB0byAxMjYgKHRpbGRlKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGhcblx0ICogQHJldHVybnMge1ZhbHVlR2VuZXJhdG9yfVxuXHQgKi9cblx0YXNjaWkobWluTGVuZ3RoID0gMCwgbWF4TGVuZ3RoID0gNjQpIHtcblx0XHRsZXQgcmFuZCA9IHRoaXMubmV3UmFuZCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IG4gPSBNYXRoLnJvdW5kKHJhbmQoKSoobWF4TGVuZ3RoIC0gbWluTGVuZ3RoKSkgKyBtaW5MZW5ndGg7XG5cdFx0XHRpZiAobiA8IDApIHtcblx0XHRcdFx0biA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBjaGFycyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0Y2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGgucm91bmQocmFuZCgpKjk0ICsgMzIpKSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBCeXRlQXJyYXlEYXRhLmZyb21TdHJpbmcoY2hhcnMuam9pbihcIlwiKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIGJ5dGVhcnJheXMgY29udGFpbmluZyBvbmx5IHZhbGlkIGFzY2lpIGNoYXJhY3RlcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbkxlbmd0aFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG5cdCAqIEByZXR1cm5zIHtWYWx1ZUdlbmVyYXRvcn1cblx0ICovXG5cdGFzY2lpQnl0ZXMobWluTGVuZ3RoID0gMCwgbWF4TGVuZ3RoID0gNjQpIHtcblx0XHRsZXQgcmFuZCA9IHRoaXMubmV3UmFuZCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IG4gPSBNYXRoLnJvdW5kKHJhbmQoKSoobWF4TGVuZ3RoIC0gbWluTGVuZ3RoKSkgKyBtaW5MZW5ndGg7XG5cdFx0XHRpZiAobiA8IDApIHtcblx0XHRcdFx0biA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBieXRlcyA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0Ynl0ZXMucHVzaChNYXRoLmZsb29yKHJhbmQoKSo5NCArIDMyKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgQnl0ZUFycmF5RGF0YShieXRlcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIGJ5dGVhcnJheXMgdGhlIGFyZSBhbHNvIHZhbGlkIHV0Zjggc3RyaW5nc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoIC0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcsIG5vdCBvZiB0aGUgYnl0ZWFycmF5IVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoIC0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcsIG5vdCBvZiB0aGUgYnl0ZWFycmF5IVxuXHQgKiBAcmV0dXJucyB7VmFsdWVHZW5lcmF0b3J9XG5cdCAqL1xuXHR1dGY4Qnl0ZXMobWluTGVuZ3RoID0gMCwgbWF4TGVuZ3RoID0gNjQpIHtcblx0XHRyZXR1cm4gdGhpcy5zdHJpbmcobWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIG51bWJlcltdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aFxuXHQgKiBAcmV0dXJucyB7KCkgPT4gbnVtYmVyW119XG5cdCAqL1xuXHRyYXdCeXRlcyhtaW5MZW5ndGggPSAwLCBtYXhMZW5ndGggPSA2NCkge1xuXHRcdGxldCByYW5kID0gdGhpcy5uZXdSYW5kKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgbiA9IE1hdGgucm91bmQocmFuZCgpKihtYXhMZW5ndGggLSBtaW5MZW5ndGgpKSArIG1pbkxlbmd0aDtcblx0XHRcdGlmIChuIDwgMCkge1xuXHRcdFx0XHRuID0gMDtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGJ5dGVzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRieXRlcy5wdXNoKE1hdGguZmxvb3IocmFuZCgpKjI1NikpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnl0ZXM7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIGJ5dGVhcnJheXMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aFxuXHQgKiBAcmV0dXJucyB7VmFsdWVHZW5lcmF0b3J9XG5cdCAqL1xuXHRieXRlcyhtaW5MZW5ndGggPSAwLCBtYXhMZW5ndGggPSA2NCkge1xuXHRcdGxldCByYW5kID0gdGhpcy5yYXdCeXRlcyhtaW5MZW5ndGgsIG1heExlbmd0aCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgYnl0ZXMgPSByYW5kKCk7XG5cblx0XHRcdHJldHVybiBuZXcgQnl0ZUFycmF5RGF0YShieXRlcyk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2VuZXJhdG9yIGZvciBib29sZWFucyxcblx0ICogQHJldHVybnMgeygpID0+IGJvb2xlYW59XG5cdCAqL1xuXHRyYXdCb29sKCkge1xuXHRcdGxldCByYW5kID0gdGhpcy5uZXdSYW5kKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgeCA9IHJhbmQoKTtcblxuXHRcdFx0cmV0dXJuIHggPj0gMC41O1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2VuZXJhdG9yIGZvciBib29sZWFucywgd3JhcHBlZCB3aXRoIENvbnN0ckRhdGFcblx0ICogQHJldHVybnMge1ZhbHVlR2VuZXJhdG9yfVxuXHQgKi9cblx0Ym9vbCgpIHtcblx0XHRsZXQgcmFuZCA9IHRoaXMucmF3Qm9vbCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKHJhbmQoKSA/IDEgOiAwLCBbXSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIG9wdGlvbnNcblx0ICogQHBhcmFtIHtWYWx1ZUdlbmVyYXRvcn0gc29tZUdlbmVyYXRvclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbm9uZVByb2JhYmlsaXR5XG5cdCAqIEByZXR1cm5zIHtWYWx1ZUdlbmVyYXRvcn1cblx0ICovXG5cdG9wdGlvbihzb21lR2VuZXJhdG9yLCBub25lUHJvYmFiaWxpdHkgPSAwLjUpIHtcblx0XHRsZXQgcmFuZCA9IHRoaXMubmV3UmFuZCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IHggPSByYW5kKCk7XG5cblx0XHRcdGlmICh4IDwgbm9uZVByb2JhYmlsaXR5KSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ29uc3RyRGF0YSgxLCBbXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbnN0ckRhdGEoMCwgW3NvbWVHZW5lcmF0b3IoKV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZ2VuZXJhdG9yIGZvciBsaXN0c1xuXHQgKiBAcGFyYW0ge1ZhbHVlR2VuZXJhdG9yfSBpdGVtR2VuZXJhdG9yXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aFxuXHQgKiBAcmV0dXJucyB7VmFsdWVHZW5lcmF0b3J9XG5cdCAqL1xuXHRsaXN0KGl0ZW1HZW5lcmF0b3IsIG1pbkxlbmd0aCA9IDAsIG1heExlbmd0aCA9IDEwKSB7XG5cdFx0bGV0IHJhbmQgPSB0aGlzLm5ld1JhbmQoKTtcblxuXHRcdGlmIChtaW5MZW5ndGggPCAwKSB7XG5cdFx0XHRtaW5MZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdGlmIChtYXhMZW5ndGggPCAwKSB7XG5cdFx0XHRtYXhMZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGxldCBuID0gTWF0aC5yb3VuZChyYW5kKCkqKG1heExlbmd0aCAtIG1pbkxlbmd0aCkpICsgbWluTGVuZ3RoO1xuXHRcdFx0aWYgKG4gPCAwKSB7XG5cdFx0XHRcdG4gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtVcGxjRGF0YVtdfVxuXHRcdFx0ICovXG5cdFx0XHRsZXQgaXRlbXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtR2VuZXJhdG9yKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IExpc3REYXRhKGl0ZW1zKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGdlbmVyYXRvciBmb3IgbWFwc1xuXHQgKiBAcGFyYW0ge1ZhbHVlR2VuZXJhdG9yfSBrZXlHZW5lcmF0b3Jcblx0ICogQHBhcmFtIHtWYWx1ZUdlbmVyYXRvcn0gdmFsdWVHZW5lcmF0b3Jcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbkxlbmd0aFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuZ3RoXG5cdCAqIEByZXR1cm5zIHtWYWx1ZUdlbmVyYXRvcn1cblx0ICovXG5cdG1hcChrZXlHZW5lcmF0b3IsIHZhbHVlR2VuZXJhdG9yLCBtaW5MZW5ndGggPSAwLCBtYXhMZW5ndGggPSAxMCkge1xuXHRcdGxldCByYW5kID0gdGhpcy5uZXdSYW5kKCk7XG5cblx0XHRpZiAobWluTGVuZ3RoIDwgMCkge1xuXHRcdFx0bWluTGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRpZiAobWF4TGVuZ3RoIDwgMCkge1xuXHRcdFx0bWF4TGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRsZXQgbiA9IE1hdGgucm91bmQocmFuZCgpKihtYXhMZW5ndGggLSBtaW5MZW5ndGgpKSArIG1pbkxlbmd0aDtcblxuXHRcdFx0aWYgKG4gPCAwKSB7XG5cdFx0XHRcdG4gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0eXBlIHtbVXBsY0RhdGEsIFVwbGNEYXRhXVtdfVxuXHRcdFx0ICovXG5cdFx0XHRsZXQgcGFpcnMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0cGFpcnMucHVzaChba2V5R2VuZXJhdG9yKCksIHZhbHVlR2VuZXJhdG9yKCldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBNYXBEYXRhKHBhaXJzKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBnZW5lcmF0b3IgZm9yIG9iamVjdHNcblx0ICogQHBhcmFtIHsuLi5WYWx1ZUdlbmVyYXRvcn0gaXRlbUdlbmVyYXRvcnNcblx0ICogQHJldHVybnMge1ZhbHVlR2VuZXJhdG9yfVxuXHQgKi9cblx0b2JqZWN0KC4uLml0ZW1HZW5lcmF0b3JzKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IGl0ZW1zID0gaXRlbUdlbmVyYXRvcnMubWFwKGcgPT4gZygpKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKDAsIGl0ZW1zKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGdlbmVyYXRvciBmb3IgdGFnZ2VkIGNvbnN0clxuXHQgKiBAcGFyYW0ge251bWJlciB8IE51bWJlckdlbmVyYXRvcn0gdGFnXG5cdCAqIEBwYXJhbSB7Li4uVmFsdWVHZW5lcmF0b3J9IGZpZWxkR2VuZXJhdG9yc1xuXHQgKiBAcmV0dXJucyB7VmFsdWVHZW5lcmF0b3J9XG5cdCAqL1xuXHRjb25zdHIodGFnLCAuLi5maWVsZEdlbmVyYXRvcnMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBmaWVsZHMgPSBmaWVsZEdlbmVyYXRvcnMubWFwKGcgPT4gZygpKTtcblxuXHRcdFx0Y29uc3QgZmluYWxUYWcgPSAodHlwZW9mIHRhZyA9PSBcIm51bWJlclwiKSA/IHRhZyA6IE1hdGgucm91bmQodGFnKCkqMTAwKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIG5ldyBDb25zdHJEYXRhKGZpbmFsVGFnLCBmaWVsZHMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSdW4gYSB0ZXN0XG5cdCAqIEBwYXJhbSB7VmFsdWVHZW5lcmF0b3JbXX0gYXJnR2Vuc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3JjXG5cdCAqIEBwYXJhbSB7UHJvcGVydHlUZXN0fSBwcm9wVGVzdFxuXHQgKiBAcGFyYW0ge251bWJlcn0gblJ1bnNcblx0ICogQHBhcmFtIHtib29sZWFufSBzaW1wbGlmeVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gLSB0aHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBwcm9wZXJ0eSB0ZXN0cyBmYWlsXG5cdCAqL1xuXHRhc3luYyB0ZXN0KGFyZ0dlbnMsIHNyYywgcHJvcFRlc3QsIG5SdW5zID0gdGhpcy4jcnVuc1BlclRlc3QsIHNpbXBsaWZ5ID0gZmFsc2UpIHtcblx0XHQvLyBjb21waWxhdGlvbiBlcnJvcnMgaGVyZSBhcmVuJ3QgY2F1Z2h0XG5cblx0XHRsZXQgcHVycG9zZU5hbWUgPSBleHRyYWN0U2NyaXB0UHVycG9zZUFuZE5hbWUoc3JjKTtcblxuXHRcdGlmIChwdXJwb3NlTmFtZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGdldCBzY3JpcHQgcHVycG9zZSBhbmQgbmFtZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IFtfLCB0ZXN0TmFtZV0gPSBwdXJwb3NlTmFtZTtcblxuXHRcdFx0bGV0IHByb2dyYW0gPSBQcm9ncmFtLm5ldyhzcmMpLmNvbXBpbGUoc2ltcGxpZnkpO1xuXG5cdFx0XHRmb3IgKGxldCBpdCA9IDA7IGl0IDwgblJ1bnM7IGl0KyspIHtcblx0XHRcdFx0bGV0IGFyZ3MgPSBhcmdHZW5zLm1hcChnZW4gPT4gbmV3IFVwbGNEYXRhVmFsdWUoU2l0ZS5kdW1teSgpLCBnZW4oKSkpO1xuXHRcdFx0XG5cdFx0XHRcdGxldCByZXN1bHQgPSBhd2FpdCBwcm9ncmFtLnJ1bihhcmdzKTtcblxuXHRcdFx0XHRsZXQgb2JqID0gcHJvcFRlc3QoYXJncywgcmVzdWx0KTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRcdGlmICghb2JqKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHByb3BlcnR5IHRlc3QgJyR7dGVzdE5hbWV9JyBmYWlsZWQgKGluZm86ICgke2FyZ3MubWFwKGEgPT4gYS50b1N0cmluZygpKS5qb2luKCcsICcpfSkgPT4gJHtyZXN1bHQudG9TdHJpbmcoKX0pYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBmYWlsdXJlc1xuXHRcdFx0XHRcdGZvciAobGV0IGtleSBpbiBvYmopIHtcblx0XHRcdFx0XHRcdGlmICghb2JqW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwcm9wZXJ0eSB0ZXN0ICcke3Rlc3ROYW1lfToke2tleX0nIGZhaWxlZCAoaW5mbzogKCR7YXJncy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oJywgJyl9KSA9PiAke3Jlc3VsdC50b1N0cmluZygpfSlgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5sb2coYHByb3BlcnR5IHRlc3RzIGZvciAnJHt0ZXN0TmFtZX0nIHN1Y2NlZWRlZCR7c2ltcGxpZnkgPyBcIiAoc2ltcGxpZmllZClcIjpcIlwifSAoJHtwcm9ncmFtLmNhbGNTaXplKCl9IGJ5dGVzKWApO1xuXHRcdH1cblxuXHRcdGlmICghc2ltcGxpZnkgJiYgdGhpcy4jc2ltcGxpZnkpIHtcblx0XHRcdGF3YWl0IHRoaXMudGVzdChhcmdHZW5zLCBzcmMsIHByb3BUZXN0LCBuUnVucywgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFZhbHVlR2VuZXJhdG9yPn0gcGFyYW1HZW5lcmF0b3JzXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtQXJnc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3JjXG5cdCAqIEBwYXJhbSB7UHJvcGVydHlUZXN0fSBwcm9wVGVzdFxuXHQgKiBAcGFyYW0ge251bWJlcn0gblJ1bnNcblx0ICogQHBhcmFtIHtib29sZWFufSBzaW1wbGlmeVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIHRlc3RQYXJhbXMocGFyYW1HZW5lcmF0b3JzLCBwYXJhbUFyZ3MsIHNyYywgcHJvcFRlc3QsIG5SdW5zID0gdGhpcy4jcnVuc1BlclRlc3QsIHNpbXBsaWZ5ID0gZmFsc2UpIHtcblx0XHRsZXQgcHJvZ3JhbSA9IFByb2dyYW0ubmV3KHNyYyk7XG5cblx0XHRsZXQgcHVycG9zZU5hbWUgPSBleHRyYWN0U2NyaXB0UHVycG9zZUFuZE5hbWUoc3JjKTtcblxuXHRcdGlmIChwdXJwb3NlTmFtZSA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGdldCBzY3JpcHQgcHVycG9zZSBhbmQgbmFtZVwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IFtfLCB0ZXN0TmFtZV0gPSBwdXJwb3NlTmFtZTtcblxuXHRcdFx0Zm9yIChsZXQgaXQgPSAwOyBpdCA8IG5SdW5zOyBpdCsrKSB7XG5cblx0XHRcdFx0Zm9yIChsZXQga2V5IGluIHBhcmFtR2VuZXJhdG9ycykge1xuXHRcdFx0XHRcdHByb2dyYW0uY2hhbmdlUGFyYW1TYWZlKGtleSwgcGFyYW1HZW5lcmF0b3JzW2tleV0oKSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBhcmdzID0gcGFyYW1BcmdzLm1hcChwYXJhbUFyZyA9PiBwcm9ncmFtLmV2YWxQYXJhbShwYXJhbUFyZykpO1xuXHRcdFx0XG5cdFx0XHRcdGxldCBjb3JlUHJvZ3JhbSA9IFByb2dyYW0ubmV3KHNyYykuY29tcGlsZShzaW1wbGlmeSk7XG5cblx0XHRcdFx0bGV0IHJlc3VsdCA9IGF3YWl0IGNvcmVQcm9ncmFtLnJ1bihhcmdzKTtcblxuXHRcdFx0XHRsZXQgb2JqID0gcHJvcFRlc3QoYXJncywgcmVzdWx0KTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRcdGlmICghb2JqKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHByb3BlcnR5IHRlc3QgJyR7dGVzdE5hbWV9JyBmYWlsZWQgKGluZm86ICgke2FyZ3MubWFwKGEgPT4gYS50b1N0cmluZygpKS5qb2luKCcsICcpfSkgPT4gJHtyZXN1bHQudG9TdHJpbmcoKX0pYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBmYWlsdXJlc1xuXHRcdFx0XHRcdGZvciAobGV0IGtleSBpbiBvYmopIHtcblx0XHRcdFx0XHRcdGlmICghb2JqW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBwcm9wZXJ0eSB0ZXN0ICcke3Rlc3ROYW1lfToke2tleX0nIGZhaWxlZCAoaW5mbzogKCR7YXJncy5tYXAoYSA9PiBhLnRvU3RyaW5nKCkpLmpvaW4oJywgJyl9KSA9PiAke3Jlc3VsdC50b1N0cmluZygpfSlgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5sb2coYHByb3BlcnR5IHRlc3RzIGZvciAnJHt0ZXN0TmFtZX0nIHN1Y2NlZWRlZCR7c2ltcGxpZnkgPyBcIiAoc2ltcGxpZmllZClcIjpcIlwifWApO1xuXHRcdH1cblxuXHRcdGlmICghc2ltcGxpZnkgJiYgdGhpcy4jc2ltcGxpZnkpIHtcblx0XHRcdGF3YWl0IHRoaXMudGVzdFBhcmFtcyhwYXJhbUdlbmVyYXRvcnMsIHBhcmFtQXJncywgc3JjLCBwcm9wVGVzdCwgblJ1bnMsIHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNlY3Rpb24gMjg6IENvaW5TZWxlY3Rpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBjb2luIHNlbGVjdGlvbiBhbGdvcml0aG1zXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2luU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VUeE9bXX0gdXR4b3MgXG4gICAgICogQHBhcmFtIHtWYWx1ZX0gYW1vdW50IFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGFyZ2VzdEZpcnN0XG4gICAgICogQHJldHVybnMge1tVVHhPW10sIFVUeE9bXV19IC0gW3BpY2tlZCwgbm90IHBpY2tlZCB0aGF0IGNhbiBiZSB1c2VkIGFzIHNwYXJlc11cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0RXh0cmVtdW1GaXJzdCh1dHhvcywgYW1vdW50LCBsYXJnZXN0Rmlyc3QpIHtcbiAgICAgICAgbGV0IHN1bSA9IG5ldyBWYWx1ZSgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VVR4T1tdfSAqL1xuICAgICAgICBsZXQgbm90U2VsZWN0ZWQgPSB1dHhvcy5zbGljZSgpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7VVR4T1tdfSAqL1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RzIHNtYWxsZXN0IHV0eG9zIHVudGlsICduZWVkZWQnIGlzIHJlYWNoZWRcbiAgICAgICAgICogQHBhcmFtIHtiaWdpbnR9IG5lZWRlZFF1YW50aXR5XG4gICAgICAgICAqIEBwYXJhbSB7KHV0eG86IFVUeE8pID0+IGJpZ2ludH0gZ2V0UXVhbnRpdHlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdChuZWVkZWRRdWFudGl0eSwgZ2V0UXVhbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHNvcnQgbm90WWV0UGlja2VkIGluIGFzY2VuZGluZyBvcmRlciB3aGVuIHBpY2tpbmcgc21hbGxlc3QgZmlyc3QsXG4gICAgICAgICAgICAvLyBhbmQgaW4gZGVzY2VuZGluZyBvcmRlciB3aGVuIHBpY2tpbmcgbGFyZ2VzdCBmaXJzdFxuICAgICAgICAgICAgLy8gc29ydCBVVHhPcyB0aGF0IGNvbnRhaW4gbW9yZSBhc3NldHMgbGFzdFxuICAgICAgICAgICAgbm90U2VsZWN0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHFhID0gZ2V0UXVhbnRpdHkoYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcWIgPSBnZXRRdWFudGl0eShiKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBsYXJnZXN0Rmlyc3QgPyAtMSA6IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAocWEgIT0gMG4gJiYgcWIgPT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ247XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxYSA9PSAwbiAmJiBxYiAhPSAwbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLXNpZ247XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxYSA9PSAwbiAmJiBxYiA9PSAwbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYSA9IGEudmFsdWUuYXNzZXRzLm5Ub2tlblR5cGVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYiA9IGIudmFsdWUuYXNzZXRzLm5Ub2tlblR5cGVzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYSA9PSBuYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihxYSAtIHFiKSpzaWduO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hIDwgbmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMG47XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUgKGNvdW50IDwgbmVlZGVkUXVhbnRpdHkgfHwgY291bnQgPT0gMG4pIHsgLy8gbXVzdCBzZWxlY3QgYXQgbGVhc3Qgb25lIHV0eG8gaWYgbmVlZGVkUXVhbnRpdHkgPT0gMG5cbiAgICAgICAgICAgICAgICBjb25zdCB1dHhvID0gbm90U2VsZWN0ZWQuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh1dHhvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGVub3VnaCB1dHhvcyB0byBjb3ZlciBhbW91bnRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXR5ID0gZ2V0UXVhbnRpdHkodXR4byk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHF0eSA+IDBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBxdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKHV0eG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtLmFkZCh1dHhvLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKHV0eG8pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vdFNlbGVjdGVkID0gbm90U2VsZWN0ZWQuY29uY2F0KHJlbWFpbmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IFVUeE9zIHdoaWxlIGxvb3BpbmcgdGhyb3VnaCAoTWludGluZ1BvbGljeUhhc2gsVG9rZW5OYW1lKSBlbnRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBtcGhzID0gYW1vdW50LmFzc2V0cy5taW50aW5nUG9saWNpZXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBtcGggb2YgbXBocykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5OYW1lcyA9IGFtb3VudC5hc3NldHMuZ2V0VG9rZW5OYW1lcyhtcGgpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuTmFtZSBvZiB0b2tlbk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVlZCA9IGFtb3VudC5hc3NldHMuZ2V0KG1waCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXZlID0gc3VtLmFzc2V0cy5nZXQobXBoLCB0b2tlbk5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPCBuZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBuZWVkIC0gaGF2ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QoZGlmZiwgKHV0eG8pID0+IHV0eG8udmFsdWUuYXNzZXRzLmdldChtcGgsIHRva2VuTmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyB1c2UgdGhlIHNhbWUgc3RyYXRlZ3kgZm9yIGxvdmVsYWNlXG4gICAgICAgIGNvbnN0IG5lZWQgPSBhbW91bnQubG92ZWxhY2U7XG4gICAgICAgIGNvbnN0IGhhdmUgPSBzdW0ubG92ZWxhY2U7XG5cbiAgICAgICAgaWYgKGhhdmUgPCBuZWVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gbmVlZCAtIGhhdmU7XG5cbiAgICAgICAgICAgIHNlbGVjdChkaWZmLCAodXR4bykgPT4gdXR4by52YWx1ZS5sb3ZlbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoc2VsZWN0ZWQubGVuZ3RoICsgbm90U2VsZWN0ZWQubGVuZ3RoID09IHV0eG9zLmxlbmd0aCwgXCJpbnRlcm5hbCBlcnJvcjogc2VsZWN0IGFsZ29yaXRobSBkb2Vzbid0IGNvbnNlcnZlIHV0eG9zXCIpO1xuXG4gICAgICAgIHJldHVybiBbc2VsZWN0ZWQsIG5vdFNlbGVjdGVkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VUeE9bXX0gdXR4b3MgXG4gICAgICogQHBhcmFtIHtWYWx1ZX0gYW1vdW50IFxuICAgICAqIEByZXR1cm5zIHtbVVR4T1tdLCBVVHhPW11dfSAtIFtzZWxlY3RlZCwgbm90IHNlbGVjdGVkXVxuICAgICAqL1xuICAgIHN0YXRpYyBzZWxlY3RTbWFsbGVzdEZpcnN0KHV0eG9zLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIENvaW5TZWxlY3Rpb24uc2VsZWN0RXh0cmVtdW1GaXJzdCh1dHhvcywgYW1vdW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVVHhPW119IHV0eG9zIFxuICAgICAqIEBwYXJhbSB7VmFsdWV9IGFtb3VudCBcbiAgICAgKiBAcmV0dXJucyB7W1VUeE9bXSwgVVR4T1tdXX0gLSBbc2VsZWN0ZWQsIG5vdCBzZWxlY3RlZF1cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0TGFyZ2VzdEZpcnN0KHV0eG9zLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIENvaW5TZWxlY3Rpb24uc2VsZWN0RXh0cmVtdW1GaXJzdCh1dHhvcywgYW1vdW50LCB0cnVlKTtcbiAgICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAyOTogV2FsbGV0c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgICBpc01haW5uZXQoKTogUHJvbWlzZTxib29sZWFuPixcbiAqICAgICB1c2VkQWRkcmVzc2VzOiBQcm9taXNlPEFkZHJlc3NbXT4sXG4gKiAgICAgdW51c2VkQWRkcmVzc2VzOiBQcm9taXNlPEFkZHJlc3NbXT4sXG4gKiAgICAgdXR4b3M6IFByb21pc2U8VVR4T1tdPixcbiAqICAgICBzaWduVHgodHg6IFR4KTogUHJvbWlzZTxTaWduYXR1cmVbXT4sXG4gKiAgICAgc3VibWl0VHgodHg6IFR4KTogUHJvbWlzZTxUeElkPlxuICogfX0gV2FsbGV0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICAgIGdldE5ldHdvcmtJZCgpOiBQcm9taXNlPG51bWJlcj4sXG4gKiAgICAgZ2V0VXNlZEFkZHJlc3NlcygpOiBQcm9taXNlPHN0cmluZ1tdPixcbiAqICAgICBnZXRVbnVzZWRBZGRyZXNzZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4sXG4gKiAgICAgZ2V0VXR4b3MoKTogUHJvbWlzZTxzdHJpbmdbXT4sXG4gKiAgICAgc2lnblR4KHR4SGV4OiBzdHJpbmcsIHBhcnRpYWxTaWduOiBib29sZWFuKTogUHJvbWlzZTxzdHJpbmc+LFxuICogICAgIHN1Ym1pdFR4KHR4SGV4OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz5cbiAqIH19IENpcDMwSGFuZGxlXG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7V2FsbGV0fVxuICovXG5leHBvcnQgY2xhc3MgQ2lwMzBXYWxsZXQge1xuICAgICNoYW5kbGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NpcDMwSGFuZGxlfSBoYW5kbGUgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFuZGxlKSB7XG4gICAgICAgIHRoaXMuI2hhbmRsZSA9IGhhbmRsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBhc3luYyBpc01haW5uZXQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jaGFuZGxlLmdldE5ldHdvcmtJZCgpKSA9PSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPEFkZHJlc3NbXT59XG4gICAgICovXG4gICAgZ2V0IHVzZWRBZGRyZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNoYW5kbGUuZ2V0VXNlZEFkZHJlc3NlcygpLnRoZW4oYWRkcmVzc2VzID0+IGFkZHJlc3Nlcy5tYXAoYSA9PiBuZXcgQWRkcmVzcyhhKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPEFkZHJlc3NbXT59XG4gICAgICovXG4gICAgZ2V0IHVudXNlZEFkZHJlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhbmRsZS5nZXRVbnVzZWRBZGRyZXNzZXMoKS50aGVuKGFkZHJlc3NlcyA9PiBhZGRyZXNzZXMubWFwKGEgPT4gbmV3IEFkZHJlc3MoYSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxVVHhPW10+fVxuICAgICAqL1xuICAgIGdldCB1dHhvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhbmRsZS5nZXRVdHhvcygpLnRoZW4odXR4b3MgPT4gdXR4b3MubWFwKHUgPT4gVVR4Ty5mcm9tQ2JvcihoZXhUb0J5dGVzKHUpKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHh9IHR4IFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyBzaWduVHgodHgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jaGFuZGxlLnNpZ25UeChieXRlc1RvSGV4KHR4LnRvQ2JvcigpKSwgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gVHhXaXRuZXNzZXMuZnJvbUNib3IoaGV4VG9CeXRlcyhyZXMpKS5zaWduYXR1cmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VHh9IHR4IFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFR4SWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHN1Ym1pdFR4KHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHRoaXMuI2hhbmRsZS5zdWJtaXRUeChieXRlc1RvSGV4KHR4LnRvQ2JvcigpKSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUeElkKHJlc3BvbnNlVGV4dCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2FsbGV0SGVscGVyIHtcbiAgICAjd2FsbGV0O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtXYWxsZXR9IHdhbGxldCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXQpIHtcbiAgICAgICAgdGhpcy4jd2FsbGV0ID0gd2FsbGV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPEFkZHJlc3NbXT59XG4gICAgICovXG4gICAgZ2V0IGFsbEFkZHJlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dhbGxldC51c2VkQWRkcmVzc2VzLnRoZW4odXNlZEFkZHJlc3MgPT4gdGhpcy4jd2FsbGV0LnVudXNlZEFkZHJlc3Nlcy50aGVuKHVudXNlZEFkZHJlc3NlcyA9PiB1c2VkQWRkcmVzcy5jb25jYXQodW51c2VkQWRkcmVzc2VzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZhbHVlPn1cbiAgICAgKi9cbiAgICBhc3luYyBjYWxjQmFsYW5jZSgpIHtcbiAgICAgICAgbGV0IHN1bSA9IG5ldyBWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IHV0eG9zID0gYXdhaXQgdGhpcy4jd2FsbGV0LnV0eG9zO1xuXG4gICAgICAgIGZvciAoY29uc3QgdXR4byBvZiB1dHhvcykge1xuICAgICAgICAgICAgc3VtID0gc3VtLmFkZCh1dHhvLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8QWRkcmVzcz59XG4gICAgICovXG4gICAgZ2V0IGJhc2VBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxBZGRyZXNzZXMudGhlbihhZGRyZXNzZXMgPT4gYXNzZXJ0RGVmaW5lZChhZGRyZXNzZXNbMF0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxBZGRyZXNzPn1cbiAgICAgKi9cbiAgICBnZXQgY2hhbmdlQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dhbGxldC51bnVzZWRBZGRyZXNzZXMudGhlbihhZGRyZXNzZXMgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiN3YWxsZXQudXNlZEFkZHJlc3Nlcy50aGVuKGFkZHJlc3NlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGFkZHJlc3NlcyBmb3VuZFwiKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3Nlc1thZGRyZXNzZXMubGVuZ3RoLTFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3Nlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgVVR4Tywgc28gdGhlIGNhbGxlciBjYW4gY2hlY2sgcHJlY2lzZWx5IHdoaWNoIG5ldHdvcmsgdGhlIHVzZXIgaXMgY29ubmVjdGVkIHRvIChlZy4gcHJldmlldyBvciBwcmVwcm9kKVxuICAgICAqIEB0eXBlIHtQcm9taXNlPD9VVHhPPn1cbiAgICAgKi9cbiAgICBnZXQgcmVmVXR4bygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dhbGxldC51dHhvcy50aGVuKHV0eG9zID0+IHtcbiAgICAgICAgICAgIGlmKHV0eG9zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnREZWZpbmVkKHV0eG9zWzBdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ZhbHVlfSBhbW91bnQgXG4gICAgICogQHBhcmFtIHsoYWxsVXR4b3M6IFVUeE9bXSwgYW5vdW50OiBWYWx1ZSkgPT4gW1VUeE9bXSwgVVR4T1tdXX0gYWxnb3JpdGhtXG4gICAgICogQHJldHVybnMge1Byb21pc2U8W1VUeE9bXSwgVVR4T1tdXT59IC0gW3BpY2tlZCwgbm90IHBpY2tlZCB0aGF0IGNhbiBiZSB1c2VkIGFzIHNwYXJlc11cbiAgICAgKi8gXG4gICAgYXN5bmMgcGlja1V0eG9zKGFtb3VudCwgYWxnb3JpdGhtID0gQ29pblNlbGVjdGlvbi5zZWxlY3RTbWFsbGVzdEZpcnN0KSB7XG4gICAgICAgIHJldHVybiBhbGdvcml0aG0oYXdhaXQgdGhpcy4jd2FsbGV0LnV0eG9zLCBhbW91bnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybmVkIGNvbGxhdGVyYWwgY2FuJ3QgY29udGFpbiBhbiBuYXRpdmUgYXNzZXRzIChwdXJlIGxvdmVsYWNlKVxuICAgICAqIFRPRE86IGNvbWJpbmUgVVR4T3MgaWYgYSBzaW5nbGUgVVR4TyBpc24ndCBlbm91Z2hcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gYW1vdW50IC0gMiBBZGEgc2hvdWxkIGNvdmVyIG1vc3QgdGhpbmdzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VVR4Tz59XG4gICAgICovXG4gICAgYXN5bmMgcGlja0NvbGxhdGVyYWwoYW1vdW50ID0gMjAwMDAwMG4pIHtcbiAgICAgICAgY29uc3QgcHVyZVV0eG9zID0gKGF3YWl0IHRoaXMuI3dhbGxldC51dHhvcykuZmlsdGVyKHV0eG8gPT4gdXR4by52YWx1ZS5hc3NldHMuaXNaZXJvKCkpO1xuXG4gICAgICAgIGlmIChwdXJlVXR4b3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHB1cmUgVVR4T3MgaW4gd2FsbGV0IChuZWVkZWQgZm9yIGNvbGxhdGVyYWwpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmlnRW5vdWdoID0gcHVyZVV0eG9zLmZpbHRlcih1dHhvID0+IHV0eG8udmFsdWUubG92ZWxhY2UgPj0gYW1vdW50KTtcblxuICAgICAgICBpZiAoYmlnRW5vdWdoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBVVHhPIGluIHdhbGxldCB0aGF0IGlzIGJpZyBlbm91Z2ggdG8gY292ZXIgY29sbGF0ZXJhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpZ0Vub3VnaC5zb3J0KChhLGIpID0+IE51bWJlcihhLnZhbHVlLmxvdmVsYWNlIC0gYi52YWx1ZS5sb3ZlbGFjZSkpO1xuXG4gICAgICAgIHJldHVybiBiaWdFbm91Z2hbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaXNPd25BZGRyZXNzKGFkZHIpIHtcbiAgICAgICAgY29uc3QgcGtoID0gYWRkci5wdWJLZXlIYXNoO1xuXG4gICAgICAgIGlmIChwa2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT3duUHViS2V5SGFzaChwa2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHViS2V5SGFzaH0gcGtoXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaXNPd25QdWJLZXlIYXNoKHBraCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmFsbEFkZHJlc3NlcztcblxuICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBhUGtoID0gYWRkci5wdWJLZXlIYXNoO1xuXG4gICAgICAgICAgICBpZiAoYVBraCAhPT0gbnVsbCAmJiBhUGtoLmVxKHBraCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2VjdGlvbiAzMDogTmV0d29ya1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgICAgZ2V0VXR4b3MoYWRkcmVzczogQWRkcmVzcyk6IFByb21pc2U8VVR4T1tdPixcbiAqICAgICBzdWJtaXRUeCh0eDogVHgpOiBQcm9taXNlPFR4SWQ+XG4gKiB9fSBOZXR3b3JrXG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7TmV0d29ya31cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrZnJvc3RWMCB7XG4gICAgI25ldHdvcmtOYW1lO1xuICAgICNwcm9qZWN0SWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya05hbWUgLSBcInByZXZpZXdcIiwgXCJwcmVwcm9kXCIgb3IgXCJtYWlubmV0XCJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29ya05hbWUsIHByb2plY3RJZCkge1xuICAgICAgICB0aGlzLiNuZXR3b3JrTmFtZSA9IG5ldHdvcmtOYW1lO1xuICAgICAgICB0aGlzLiNwcm9qZWN0SWQgPSBwcm9qZWN0SWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIG5ldHdvcmsgd2hpY2ggdGhlIHdhbGxldCBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICogQHBhcmFtIHtXYWxsZXR9IHdhbGxldCBcbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgcHJldmlldz86IHN0cmluZyxcbiAgICAgKiAgICAgcHJlcHJvZD86IHN0cmluZyxcbiAgICAgKiAgICAgbWFpbm5ldD86IHN0cmluZ1xuICAgICAqIH19IHByb2plY3RJZHMgXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QmxvY2tmcm9zdFYwPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZSh3YWxsZXQsIHByb2plY3RJZHMpIHtcbiAgICAgICAgaWYgKGF3YWl0IHdhbGxldC5pc01haW5uZXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja2Zyb3N0VjAoXCJtYWlubmV0XCIsIGFzc2VydERlZmluZWQocHJvamVjdElkc1tcIm1haW5uZXRcIl0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIod2FsbGV0KTtcblxuICAgICAgICAgICAgY29uc3QgcmVmVXR4byA9IGF3YWl0IGhlbHBlci5yZWZVdHhvO1xuXG4gICAgICAgICAgICBpZiAocmVmVXR4byA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHdhbGxldCwgY2FuJ3QgZGV0ZXJtaW5lIHdoaWNoIHRlc3RuZXQgeW91IGFyZSBjb25uZWN0aW5nIHRvXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVwcm9kUHJvamVjdElkID0gcHJvamVjdElkc1tcInByZXByb2RcIl07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlld1Byb2plY3RJZCA9IHByb2plY3RJZHNbXCJwcmV2aWV3XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXByb2RQcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVwcm9kTmV0d29yayA9IG5ldyBCbG9ja2Zyb3N0VjAoXCJwcmVwcm9kXCIsIHByZXByb2RQcm9qZWN0SWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwcmVwcm9kTmV0d29yay5oYXNVdHhvKHJlZlV0eG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlcHJvZE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChwcmV2aWV3UHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlld05ldHdvcmsgPSBuZXcgQmxvY2tmcm9zdFYwKFwicHJldmlld1wiLCBwcmV2aWV3UHJvamVjdElkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhd2FpdCBwcmV2aWV3TmV0d29yay5oYXNVdHhvKHJlZlV0eG8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHByZXZpZXcgbmV0d29yayAoaGludDogcHJvdmlkZSBwcm9qZWN0IGlkIGZvciBwcmVwcm9kXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpZXdOZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXByb2RQcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcHJvamVjdCBpZHMgZm9yIHRlc3RuZXRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcHJvamVjdCBpZCBmb3IgcHJldmlldyB0ZXN0bmV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG9iaiBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VWYWx1ZShvYmopIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBvYmopIHtcbiAgICAgICAgICAgIGxldCBxdHkgPSBCaWdJbnQoaXRlbS5xdWFudGl0eSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnVuaXQgPT0gXCJsb3ZlbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hZGQobmV3IFZhbHVlKHF0eSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9saWN5SUQgPSBpdGVtLnVuaXQuc3Vic3RyaW5nKDAsIDU2KTtcbiAgICAgICAgICAgICAgICBsZXQgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbUhleChwb2xpY3lJRCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBoZXhUb0J5dGVzKGl0ZW0udW5pdC5zdWJzdHJpbmcoNTYpKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYWRkKG5ldyBWYWx1ZSgwbiwgbmV3IEFzc2V0cyhbXG4gICAgICAgICAgICAgICAgICAgIFttcGgsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0b2tlbiwgcXR5XVxuICAgICAgICAgICAgICAgICAgICBdXVxuICAgICAgICAgICAgICAgIF0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBCbG9ja2Zyb3N0VjAucmVzb2x2ZSgpXG4gICAgICogQHBhcmFtIHtVVHhPfSB1dHhvXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaGFzVXR4byh1dHhvKSB7XG4gICAgICAgIGNvbnN0IHR4SWQgPSB1dHhvLnR4SWQ7XG5cbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vY2FyZGFuby0ke3RoaXMuI25ldHdvcmtOYW1lfS5ibG9ja2Zyb3N0LmlvL2FwaS92MC90eHMvJHt0eElkLmhleH0vdXR4b3NgO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJwcm9qZWN0X2lkXCI6IHRoaXMuI3Byb2plY3RJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvbGRlc3QgVVR4T3MgZmlyc3QsIG5ld2VzdCBsYXN0LlxuICAgICAqIFRPRE86IHBhZ2luYXRpb25cbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3MgXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VVR4T1tdPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVdHhvcyhhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGBodHRwczovL2NhcmRhbm8tJHt0aGlzLiNuZXR3b3JrTmFtZX0uYmxvY2tmcm9zdC5pby9hcGkvdjAvYWRkcmVzc2VzLyR7YWRkcmVzcy50b0JlY2gzMigpfS91dHhvcz9vcmRlcj1hc2NgO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJwcm9qZWN0X2lkXCI6IHRoaXMuI3Byb2plY3RJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIEB0eXBlIHthbnl9IFxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGFsbCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBpZiAoYWxsPy5zdGF0dXNfY29kZSA+PSAzMDApIHtcbiAgICAgICAgICAgIGFsbCA9IFtdOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGwubWFwKG9iaiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVUeE8oXG4gICAgICAgICAgICAgICAgVHhJZC5mcm9tSGV4KG9iai50eF9oYXNoKSxcbiAgICAgICAgICAgICAgICBCaWdJbnQob2JqLm91dHB1dF9pbmRleCksXG4gICAgICAgICAgICAgICAgbmV3IFR4T3V0cHV0KFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBCbG9ja2Zyb3N0VjAucGFyc2VWYWx1ZShvYmouYW1vdW50KSxcbiAgICAgICAgICAgICAgICAgICAgRGF0dW0uaW5saW5lKENvbnN0ckRhdGEuZnJvbUNib3IoaGV4VG9CeXRlcyhvYmouaW5saW5lX2RhdHVtKSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSAgXG5cbiAgICAvKiogXG4gICAgICogQHBhcmFtIHtUeH0gdHggXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHhJZD59XG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VHgodHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHR4LnRvQ2JvcigpKTtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vY2FyZGFuby0ke3RoaXMuI25ldHdvcmtOYW1lfS5ibG9ja2Zyb3N0LmlvL2FwaS92MC90eC9zdWJtaXRgO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vY2JvclwiLFxuICAgICAgICAgICAgICAgIFwicHJvamVjdF9pZFwiOiB0aGlzLiNwcm9qZWN0SWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBkYXRhXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9IDIwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR4SWQoSlNPTi5wYXJzZShyZXNwb25zZVRleHQpKTsgIFxuICAgICAgICB9XG4gICAgfSAgIFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZWN0aW9uIDMxOiBFbXVsYXRvclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogU2luZ2xlIGFkZHJlc3Mgd2FsbGV0IGVtdWxhdG9yLlxuICogQGltcGxlbWVudHMge1dhbGxldH1cbiAqL1xuZXhwb3J0IGNsYXNzIFdhbGxldEVtdWxhdG9yIHtcbiAgICAjbmV0d29yaztcbiAgICAjcHJpdmF0ZUtleTtcbiAgICAjcHVibGljS2V5O1xuXG4gICAgLyoqIFxuICAgICAqIEBwYXJhbSB7TmV0d29ya30gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7TnVtYmVyR2VuZXJhdG9yfSByYW5kb20gLSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBwcml2YXRlIGtleVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIHJhbmRvbSkge1xuICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IFdhbGxldEVtdWxhdG9yLmdlblByaXZhdGVLZXkocmFuZG9tKTtcbiAgICAgICAgdGhpcy4jcHVibGljS2V5ID0gQ3J5cHRvLkVkMjU1MTkuZGVyaXZlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpO1xuXG4gICAgICAgIC8vIFRPRE86IHN0YWtpbmcgY3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHByaXZhdGUga2V5IGZyb20gYSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciAobm90IGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSEpXG4gICAgICogQHBhcmFtIHtOdW1iZXJHZW5lcmF0b3J9IHJhbmRvbSBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gRWQyNTUxOSBwcml2YXRlIGtleSBpcyAzMiBieXRlcyBsb25nXG4gICAgICovXG4gICAgc3RhdGljIGdlblByaXZhdGVLZXkocmFuZG9tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAga2V5LnB1c2goTWF0aC5mbG9vcihyYW5kb20oKSoyNTYpJTI1Nik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQdWJLZXlIYXNofVxuICAgICAqL1xuICAgIGdldCBwdWJLZXlIYXNoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFB1YktleUhhc2goQ3J5cHRvLmJsYWtlMmIodGhpcy4jcHVibGljS2V5LCAyOCkpO1xuICAgIH1cblxuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHViS2V5SGFzaCh0aGlzLnB1YktleUhhc2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIGFzeW5jIGlzTWFpbm5ldCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc3VtZWQgd2FsbGV0IHdhcyBpbml0aWF0ZWQgd2l0aCBhdCBsZWFzdCAxIFVUeE8gYXQgdGhlIHB1YmtleWhhc2ggYWRkcmVzcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBZGRyZXNzW10+fVxuICAgICAqL1xuICAgIGdldCB1c2VkQWRkcmVzc2VzKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF8pID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoW3RoaXMuYWRkcmVzc10pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCB1bnVzZWRBZGRyZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgXykgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShbXSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHV0eG9zKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF8pID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy4jbmV0d29yay5nZXRVdHhvcyh0aGlzLmFkZHJlc3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltcGx5IGFzc3VtZWQgdGhlIHR4IG5lZWRzIHRvIGJ5IHNpZ25lZCBieSB0aGlzIHdhbGxldCB3aXRob3V0IGNoZWNraW5nLlxuICAgICAqIEBwYXJhbSB7VHh9IHR4XG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmF0dXJlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25UeCh0eCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFNpZ25hdHVyZShcbiAgICAgICAgICAgICAgICB0aGlzLiNwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgQ3J5cHRvLkVkMjU1MTkuc2lnbih0eC5ib2R5SGFzaCwgdGhpcy4jcHJpdmF0ZUtleSlcbiAgICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R4fSB0eCBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeElkPn1cbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRUeCh0eCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbmV0d29yay5zdWJtaXRUeCh0eCk7XG4gICAgfVxufVxuXG4vKipcbiAqIGNvbGxlY3RVdHhvcyByZW1vdmVzIHR4IGlucHV0cyBmcm9tIHRoZSBsaXN0LCBhbmQgYXBwZW5kcyB0eG91dHB1dHMgc2VudCB0byB0aGUgYWRkcmVzcyB0byB0aGUgZW5kLlxuICogQHR5cGVkZWYge3tcbiAqICAgICBpZCgpOiBUeElkLFxuICogICAgIGNvbnN1bWVzKHR4SWQ6IFR4SWQsIHV0eG9JZHg6IGJpZ2ludCk6IGJvb2xlYW4sXG4gKiAgICAgY29sbGVjdFV0eG9zKGFkZHJlc3M6IEFkZHJlc3MsIHV0eG9zOiBVVHhPW10pOiBVVHhPW11cbiAqIH19IEVtdWxhdG9yVHhcbiAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtFbXVsYXRvclR4fVxuICovXG5jbGFzcyBHZW5lc2lzVHgge1xuICAgICNpZDtcbiAgICAjYWRkcmVzcztcbiAgICAjbG92ZWxhY2U7XG4gICAgI2Fzc2V0cztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzcyBcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gbG92ZWxhY2VcbiAgICAgKiBAcGFyYW0ge0Fzc2V0c30gYXNzZXRzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlkLCBhZGRyZXNzLCBsb3ZlbGFjZSwgYXNzZXRzKSB7XG4gICAgICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgICAgIHRoaXMuI2FkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLiNsb3ZlbGFjZSA9IGxvdmVsYWNlO1xuICAgICAgICB0aGlzLiNhc3NldHMgPSBhc3NldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIGluY3JlbWVudGFsIHR4SWQgZm9yIGdlbmVzaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqIEl0J3MgdmVyeSB1bmxpa2VseSB0aGF0IHJlZ3VsYXIgdHJhbnNhY3Rpb25zIGhhdmUgdGhlIHNhbWUgaGFzaC5cbiAgICAgKiBAcmV0dXJuIHtUeElkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBiaWdJbnRUb0J5dGVzKEJpZ0ludCh0aGlzLiNpZCkpO1xuXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgYnl0ZXMgPSAobmV3IEFycmF5KDMyIC0gYnl0ZXMubGVuZ3RoKSkuZmlsbCgwKS5jb25jYXQoYnl0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUeElkKGJ5dGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R4SWR9IHR4SWQgXG4gICAgICogQHBhcmFtIHtiaWdpbnR9IHV0eG9JZHggXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgY29uc3VtZXModHhJZCwgdXR4b0lkeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBZGRyZXNzfSBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtVVHhPW119IHV0eG9zXG4gICAgICogQHJldHVybnMge1VUeE9bXX1cbiAgICAgKi9cbiAgICBjb2xsZWN0VXR4b3MoYWRkcmVzcywgdXR4b3MpIHtcbiAgICAgICAgaWYgKGVxKHRoaXMuI2FkZHJlc3MuYnl0ZXMsIGFkZHJlc3MuYnl0ZXMpKSB7XG4gICAgICAgICAgICB1dHhvcyA9IHV0eG9zLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIHV0eG9zLnB1c2gobmV3IFVUeE8oXG4gICAgICAgICAgICAgICAgdGhpcy5pZCgpLFxuICAgICAgICAgICAgICAgIDBuLFxuICAgICAgICAgICAgICAgIG5ldyBUeE91dHB1dChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZhbHVlKHRoaXMuI2xvdmVsYWNlLCB0aGlzLiNhc3NldHMpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB1dHhvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dHhvcztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7RW11bGF0b3JUeH1cbiAqL1xuY2xhc3MgUmVndWxhclR4IHtcbiAgICAjdHg7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R4fSB0eCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCkge1xuICAgICAgICB0aGlzLiN0eCA9IHR4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtUeElkfVxuICAgICAqL1xuICAgIGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHguaWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1R4SWR9IHR4SWRcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gdXR4b0lkeFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN1bWVzKHR4SWQsIHV0eG9JZHgpIHtcbiAgICAgICAgY29uc3QgdHhJbnB1dHMgPSB0aGlzLiN0eC5ib2R5LmlucHV0cztcblxuICAgICAgICByZXR1cm4gdHhJbnB1dHMuc29tZSh0eElucHV0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eElucHV0LnR4SWQuaGV4ID09IHR4SWQuaGV4ICYmIHR4SW5wdXQudXR4b0lkeCA9PSB1dHhvSWR4O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FkZHJlc3N9IGFkZHJlc3MgXG4gICAgICogQHBhcmFtIHtVVHhPW119IHV0eG9zIFxuICAgICAqIEByZXR1cm5zIHtVVHhPW119XG4gICAgICovXG4gICAgY29sbGVjdFV0eG9zKGFkZHJlc3MsIHV0eG9zKSB7XG4gICAgICAgIHV0eG9zID0gdXR4b3MuZmlsdGVyKHV0eG8gPT4gIXRoaXMuY29uc3VtZXModXR4by50eElkLCB1dHhvLnV0eG9JZHgpKTtcblxuICAgICAgICBjb25zdCB0eE91dHB1dHMgPSB0aGlzLiN0eC5ib2R5Lm91dHB1dHM7XG5cbiAgICAgICAgdHhPdXRwdXRzLmZvckVhY2goKHR4T3V0cHV0LCB1dHhvSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcSh0eE91dHB1dC5hZGRyZXNzLmJ5dGVzLCBhZGRyZXNzLmJ5dGVzKSkge1xuICAgICAgICAgICAgICAgIHV0eG9zLnB1c2gobmV3IFVUeE8oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWQoKSxcbiAgICAgICAgICAgICAgICAgICAgQmlnSW50KHV0eG9JZCksXG4gICAgICAgICAgICAgICAgICAgIHR4T3V0cHV0XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB1dHhvcztcbiAgICB9XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMge05ldHdvcmt9XG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JrRW11bGF0b3Ige1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtiaWdpbnR9XG4gICAgICovXG4gICAgI3Nsb3Q7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TnVtYmVyR2VuZXJhdG9yfVxuICAgICAqL1xuICAgICNyYW5kb207XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R2VuZXNpc1R4W119XG4gICAgICovXG4gICAgI2dlbmVzaXM7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RW11bGF0b3JUeFtdfVxuICAgICAqL1xuICAgICNtZW1wb29sO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VtdWxhdG9yVHhbXVtdfVxuICAgICAqL1xuICAgICNibG9ja3M7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VlZCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZWVkID0gMCkge1xuICAgICAgICB0aGlzLiNzbG90ID0gMG47XG4gICAgICAgIHRoaXMuI3JhbmRvbSA9IENyeXB0by5tdWxiZXJyeTMyKHNlZWQpO1xuICAgICAgICB0aGlzLiNnZW5lc2lzID0gW107XG4gICAgICAgIHRoaXMuI21lbXBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy4jYmxvY2tzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdhbGxldEVtdWxhdG9yIGFuZCBhZGRzIGEgYmxvY2sgd2l0aCBhIHNpbmdsZSBmYWtlIHVuYmFsYW5jZWQgVHhcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gbG92ZWxhY2VcbiAgICAgKiBAcGFyYW0ge0Fzc2V0c30gYXNzZXRzXG4gICAgICogQHJldHVybnMge1dhbGxldEVtdWxhdG9yfVxuICAgICAqL1xuICAgIGNyZWF0ZVdhbGxldChsb3ZlbGFjZSA9IDBuLCBhc3NldHMgPSBuZXcgQXNzZXRzKFtdKSkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0RW11bGF0b3IodGhpcywgdGhpcy4jcmFuZG9tKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZVV0eG8od2FsbGV0LCBsb3ZlbGFjZSwgYXNzZXRzKTtcblxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVHhPIHVzaW5nIGEgR2VuZXNpc1R4LlxuICAgICAqIEBwYXJhbSB7V2FsbGV0RW11bGF0b3J9IHdhbGxldCBcbiAgICAgKiBAcGFyYW0ge2JpZ2ludH0gbG92ZWxhY2UgXG4gICAgICogQHBhcmFtIHtBc3NldHN9IGFzc2V0cyBcbiAgICAgKi9cbiAgICBjcmVhdGVVdHhvKHdhbGxldCwgbG92ZWxhY2UsIGFzc2V0cyA9IG5ldyBBc3NldHMoW10pKSB7XG4gICAgICAgIGlmIChsb3ZlbGFjZSAhPSAwbiB8fCAhYXNzZXRzLmlzWmVybygpKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IG5ldyBHZW5lc2lzVHgoXG4gICAgICAgICAgICAgICAgdGhpcy4jZ2VuZXNpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgd2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbG92ZWxhY2UsXG4gICAgICAgICAgICAgICAgYXNzZXRzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLiNnZW5lc2lzLnB1c2godHgpO1xuICAgICAgICAgICAgdGhpcy4jbWVtcG9vbC5wdXNoKHR4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pbnQgYSBibG9jayB3aXRoIHRoZSBjdXJyZW50IG1lbXBvb2wsIGFuZCBhZHZhbmNlIHRoZSBzbG90LlxuICAgICAqIEBwYXJhbSB7YmlnaW50fSBuU2xvdHMgXG4gICAgICovXG4gICAgdGljayhuU2xvdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuI21lbXBvb2wubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tzLnB1c2godGhpcy4jbWVtcG9vbCk7XG5cbiAgICAgICAgICAgIHRoaXMuI21lbXBvb2wgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3Nsb3QgKz0gblNsb3RzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QWRkcmVzc30gYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVUeE9bXT59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXR4b3MoYWRkcmVzcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1VUeE9bXX1cbiAgICAgICAgICovXG4gICAgICAgIGxldCB1dHhvcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGJsb2NrIG9mIHRoaXMuI2Jsb2Nrcykge1xuICAgICAgICAgICAgZm9yIChsZXQgdHggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICB1dHhvcyA9IHR4LmNvbGxlY3RVdHhvcyhhZGRyZXNzLCB1dHhvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXR4b3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUeElkfSB0eElkIFxuICAgICAqIEBwYXJhbSB7YmlnaW50fSB1dHhvSWR4IFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ29uc3VtZWQodHhJZCwgdXR4b0lkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmxvY2tzLnNvbWUoYiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYi5zb21lKHR4ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHguY29uc3VtZXModHhJZCwgdXR4b0lkeClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pIHx8IHRoaXMuI21lbXBvb2wuc29tZSh0eCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHguY29uc3VtZXModHhJZCwgdXR4b0lkeCk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUeH0gdHggXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHhJZD59XG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VHgodHgpIHtcbiAgICAgICAgYXNzZXJ0KHR4LmlzVmFsaWQodGhpcy4jc2xvdCksIFwidHggaW52YWxpZCAobm90IGZpbmFsaXplZCBvciBzbG90IG91dCBvZiByYW5nZSlcIik7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgbm9uZSBvZiB0aGUgaW5wdXRzIGhhdmUgYmVlbiBjb25zdW1lZCBiZWZvcmVcbiAgICAgICAgYXNzZXJ0KHR4LmJvZHkuaW5wdXRzLmV2ZXJ5KGlucHV0ID0+ICF0aGlzLmlzQ29uc3VtZWQoaW5wdXQudHhJZCwgaW5wdXQudXR4b0lkeCkpLCBcImlucHV0IGFscmVhZHkgY29uc3VtZWQgYmVmb3JlXCIpO1xuXG4gICAgICAgIHRoaXMuI21lbXBvb2wucHVzaChuZXcgUmVndWxhclR4KHR4KSk7XG5cbiAgICAgICAgcmV0dXJuIHR4LmlkKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSB1c2VkIGZvciBzb21lIHRlc3RzIGluIC4vdGVzdC8sIGFuZCBhcmVuJ3RcbiAqIGludGVuZGVkIHRvIGJlIHVzZWQgYnkgcmVndWxhciB1c2VycyBvZiB0aGlzIGxpYnJhcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBleHBvcnRlZEZvclRlc3RpbmcgPSB7XG5cdGFzc2VydDogYXNzZXJ0LFxuXHRhc3NlcnRDbGFzczogYXNzZXJ0Q2xhc3MsXG5cdGJpZ0ludFRvQnl0ZXM6IGJpZ0ludFRvQnl0ZXMsXG5cdGJ5dGVzVG9CaWdJbnQ6IGJ5dGVzVG9CaWdJbnQsXG5cdHNldFJhd1VzYWdlTm90aWZpZXI6IHNldFJhd1VzYWdlTm90aWZpZXIsXG5cdHNldEJsYWtlMmJEaWdlc3RTaXplOiBzZXRCbGFrZTJiRGlnZXN0U2l6ZSxcblx0ZHVtcENvc3RNb2RlbHM6IGR1bXBDb3N0TW9kZWxzLFxuXHRTaXRlOiBTaXRlLFxuXHRTb3VyY2U6IFNvdXJjZSxcblx0Q3J5cHRvOiBDcnlwdG8sXG5cdE1hcERhdGE6IE1hcERhdGEsXG5cdFVwbGNEYXRhOiBVcGxjRGF0YSxcblx0Q2JvckRhdGE6IENib3JEYXRhLFxuXHRDb25zdHJEYXRhOiBDb25zdHJEYXRhLFxuXHRJbnREYXRhOiBJbnREYXRhLFxuXHRCeXRlQXJyYXlEYXRhOiBCeXRlQXJyYXlEYXRhLFxuXHRMaXN0RGF0YTogTGlzdERhdGEsXG5cdFVwbGNCb29sOiBVcGxjQm9vbCxcblx0VXBsY1ZhbHVlOiBVcGxjVmFsdWUsXG5cdFVwbGNEYXRhVmFsdWU6IFVwbGNEYXRhVmFsdWUsXG5cdFNjcmlwdFB1cnBvc2U6IFNjcmlwdFB1cnBvc2UsXG5cdFVwbGNUZXJtOiBVcGxjVGVybSxcblx0VXBsY1Byb2dyYW06IFVwbGNQcm9ncmFtLFxuXHRVcGxjTGFtYmRhOiBVcGxjTGFtYmRhLFxuXHRVcGxjQ2FsbDogVXBsY0NhbGwsXG5cdFVwbGNCdWlsdGluOiBVcGxjQnVpbHRpbixcblx0VXBsY1ZhcmlhYmxlOiBVcGxjVmFyaWFibGUsXG5cdFVwbGNDb25zdDogVXBsY0NvbnN0LFxuXHRVcGxjSW50OiBVcGxjSW50LFxuXHRJUlByb2dyYW06IElSUHJvZ3JhbSxcblx0VHg6IFR4LFxuXHRUeElucHV0OiBUeElucHV0LFxuXHRUeEJvZHk6IFR4Qm9keVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@hyperionbt/helios/helios.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fapp%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);